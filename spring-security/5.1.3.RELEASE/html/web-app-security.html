<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>10.&nbsp;Web Application Security</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Security Reference"><link rel="up" href="servlet-applications.html" title="Part&nbsp;II.&nbsp;Servlet Applications"><link rel="prev" href="test.html" title="9.&nbsp;Testing"><link rel="next" href="authorization.html" title="11.&nbsp;Authorization"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.&nbsp;Web Application Security</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="test.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Servlet Applications</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="authorization.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="web-app-security" href="#web-app-security"></a>10.&nbsp;Web Application Security</h2></div></div></div>

<p>Most Spring Security users will be using the framework in applications which make user of HTTP and the Servlet API.
In this part, we&#8217;ll take a look at how Spring Security provides authentication and access-control features for the web layer of an application.
We&#8217;ll look behind the facade of the namespace and see which classes and interfaces are actually assembled to provide web-layer security.
In some situations it is necessary to use traditional bean configuration to provide full control over the configuration, so we&#8217;ll also see how to configure these classes directly without the namespace.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-filter-chain" href="#security-filter-chain"></a>10.1&nbsp;The Security Filter Chain</h2></div></div></div>

<p>Spring Security&#8217;s web infrastructure is based entirely on standard servlet filters.
It doesn&#8217;t use servlets or any other servlet-based frameworks (such as Spring MVC) internally, so it has no strong links to any particular web technology.
It deals in <code class="literal">HttpServletRequest</code> s and <code class="literal">HttpServletResponse</code> s and doesn&#8217;t care whether the requests come from a browser, a web service client, an <code class="literal">HttpInvoker</code> or an AJAX application.</p>
<p>Spring Security maintains a filter chain internally where each of the filters has a particular responsibility and filters are added or removed from the configuration depending on which services are required.
The ordering of the filters is important as there are dependencies between them.
If you have been using <a class="link" href="ns-config.html" title="7.&nbsp;Security Namespace Configuration">namespace configuration</a>, then the filters are automatically configured for you and you don&#8217;t have to define any Spring beans explicitly but here may be times when you want full control over the security filter chain, either because you are using features which aren&#8217;t supported in the namespace, or you are using your own customized versions of classes.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delegating-filter-proxy" href="#delegating-filter-proxy"></a>10.1.1&nbsp;DelegatingFilterProxy</h3></div></div></div>

<p>When using servlet filters, you obviously need to declare them in your <code class="literal">web.xml</code>, or they will be ignored by the servlet container.
In Spring Security, the filter classes are also Spring beans defined in the application context and thus able to take advantage of Spring&#8217;s rich dependency-injection facilities and lifecycle interfaces.
Spring&#8217;s <code class="literal">DelegatingFilterProxy</code> provides the link between <code class="literal">web.xml</code> and the application context.</p>
<p>When using <code class="literal">DelegatingFilterProxy</code>, you will see something like this in the <code class="literal">web.xml</code> file:</p>
<pre class="programlisting"><span class="hl-tag">&lt;filter&gt;</span>
<span class="hl-tag">&lt;filter-name&gt;</span>myFilter<span class="hl-tag">&lt;/filter-name&gt;</span>
<span class="hl-tag">&lt;filter-class&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hl-tag">&lt;/filter-class&gt;</span>
<span class="hl-tag">&lt;/filter&gt;</span>

<span class="hl-tag">&lt;filter-mapping&gt;</span>
<span class="hl-tag">&lt;filter-name&gt;</span>myFilter<span class="hl-tag">&lt;/filter-name&gt;</span>
<span class="hl-tag">&lt;url-pattern&gt;</span>/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;/filter-mapping&gt;</span></pre>
<p>Notice that the filter is actually a <code class="literal">DelegatingFilterProxy</code>, and not the class that will actually implement the logic of the filter.
What <code class="literal">DelegatingFilterProxy</code> does is delegate the <code class="literal">Filter</code> 's methods through to a bean which is obtained from the Spring application context.
This enables the bean to benefit from the Spring web application context lifecycle support and configuration flexibility.
The bean must implement <code class="literal">javax.servlet.Filter</code> and it must have the same name as that in the <code class="literal">filter-name</code> element.
Read the Javadoc for <code class="literal">DelegatingFilterProxy</code> for more information</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="filter-chain-proxy" href="#filter-chain-proxy"></a>10.1.2&nbsp;FilterChainProxy</h3></div></div></div>

<p>Spring Security&#8217;s web infrastructure should only be used by delegating to an instance of <code class="literal">FilterChainProxy</code>.
The security filters should not be used by themselves.
In theory you could declare each Spring Security filter bean that you require in your application context file and add a corresponding <code class="literal">DelegatingFilterProxy</code> entry to <code class="literal">web.xml</code> for each filter, making sure that they are ordered correctly, but this would be cumbersome and would clutter up the <code class="literal">web.xml</code> file quickly if you have a lot of filters.
<code class="literal">FilterChainProxy</code> lets us add a single entry to <code class="literal">web.xml</code> and deal entirely with the application context file for managing our web security beans.
It is wired using a <code class="literal">DelegatingFilterProxy</code>, just like in the example above, but with the <code class="literal">filter-name</code> set to the bean name "filterChainProxy".
The filter chain is then declared in the application context with the same bean name.
Here&#8217;s an example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterChainProxy"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.FilterChainProxy"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;constructor-arg&gt;</span>
    <span class="hl-tag">&lt;list&gt;</span>
    <span class="hl-tag">&lt;sec:filter-chain</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/restful/**"</span> <span class="hl-attribute">filters</span>=<span class="hl-value">"
        securityContextPersistenceFilterWithASCFalse,
        basicAuthenticationFilter,
        exceptionTranslationFilter,
        filterSecurityInterceptor"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;sec:filter-chain</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">filters</span>=<span class="hl-value">"
        securityContextPersistenceFilterWithASCTrue,
        formLoginFilter,
        exceptionTranslationFilter,
        filterSecurityInterceptor"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/list&gt;</span>
<span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The namespace element <code class="literal">filter-chain</code> is used for convenience to set up the security filter chain(s) which are required within the application.
<a href="#ftn.d5e3604" class="footnote" name="d5e3604"><sup class="footnote">[6]</sup></a>.
It maps a particular URL pattern to a list of filters built up from the bean names specified in the <code class="literal">filters</code> element, and combines them in a bean of type <code class="literal">SecurityFilterChain</code>.
The <code class="literal">pattern</code> attribute takes an Ant Paths and the most specific URIs should appear first  <a href="#ftn.d5e3610" class="footnote" name="d5e3610"><sup class="footnote">[7]</sup></a>.
At runtime the <code class="literal">FilterChainProxy</code> will locate the first URI pattern that matches the current web request and the list of filter beans specified by the <code class="literal">filters</code> attribute will be applied to that request.
The filters will be invoked in the order they are defined, so you have complete control over the filter chain which is applied to a particular URL.</p>
<p>You may have noticed we have declared two <code class="literal">SecurityContextPersistenceFilter</code> s in the filter chain (<code class="literal">ASC</code> is short for <code class="literal">allowSessionCreation</code>, a property of <code class="literal">SecurityContextPersistenceFilter</code>).
As web services will never present a <code class="literal">jsessionid</code> on future requests, creating <code class="literal">HttpSession</code> s for such user agents would be wasteful.
If you had a high-volume application which required maximum scalability, we recommend you use the approach shown above.
For smaller applications, using a single <code class="literal">SecurityContextPersistenceFilter</code> (with its default <code class="literal">allowSessionCreation</code> as <code class="literal">true</code>) would likely be sufficient.</p>
<p>Note that <code class="literal">FilterChainProxy</code> does not invoke standard filter lifecycle methods on the filters it is configured with.
We recommend you use Spring&#8217;s application context lifecycle interfaces as an alternative, just as you would for any other Spring bean.</p>
<p>When we looked at how to set up web security using <a class="link" href="ns-config.html#ns-web-xml" title="7.2.1&nbsp;web.xml Configuration">namespace configuration</a>, we used a <code class="literal">DelegatingFilterProxy</code> with the name "springSecurityFilterChain".
You should now be able to see that this is the name of the <code class="literal">FilterChainProxy</code> which is created by the namespace.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="bypassing-the-filter-chain" href="#bypassing-the-filter-chain"></a>Bypassing the Filter Chain</h4></div></div></div>

<p>You can use the attribute <code class="literal">filters = "none"</code> as an alternative to supplying a filter bean list.
This will omit the request pattern from the security filter chain entirely.
Note that anything matching this path will then have no authentication or authorization services applied and will be freely accessible.
If you want to make use of the contents of the <code class="literal">SecurityContext</code> contents during a request, then it must have passed through the security filter chain.
Otherwise the <code class="literal">SecurityContextHolder</code> will not have been populated and the contents will be null.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="filter-ordering" href="#filter-ordering"></a>10.1.3&nbsp;Filter Ordering</h3></div></div></div>

<p>The order that filters are defined in the chain is very important.
Irrespective of which filters you are actually using, the order should be as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">ChannelProcessingFilter</code>, because it might need to redirect to a different protocol
</li><li class="listitem">
<code class="literal">SecurityContextPersistenceFilter</code>, so a <code class="literal">SecurityContext</code> can be set up in the <code class="literal">SecurityContextHolder</code> at the beginning of a web request, and any changes to the <code class="literal">SecurityContext</code> can be copied to the <code class="literal">HttpSession</code> when the web request ends (ready for use with the next web request)
</li><li class="listitem">
<code class="literal">ConcurrentSessionFilter</code>, because it uses the <code class="literal">SecurityContextHolder</code> functionality and needs to update the <code class="literal">SessionRegistry</code> to reflect ongoing requests from the principal
</li><li class="listitem">
Authentication processing mechanisms - <code class="literal">UsernamePasswordAuthenticationFilter</code>, <code class="literal">CasAuthenticationFilter</code>, <code class="literal">BasicAuthenticationFilter</code> etc - so that the <code class="literal">SecurityContextHolder</code> can be modified to contain a valid <code class="literal">Authentication</code> request token
</li><li class="listitem">
The <code class="literal">SecurityContextHolderAwareRequestFilter</code>, if you are using it to install a Spring Security aware <code class="literal">HttpServletRequestWrapper</code> into your servlet container
</li><li class="listitem">
The <code class="literal">JaasApiIntegrationFilter</code>, if a <code class="literal">JaasAuthenticationToken</code> is in the <code class="literal">SecurityContextHolder</code> this will process the <code class="literal">FilterChain</code> as the <code class="literal">Subject</code> in the <code class="literal">JaasAuthenticationToken</code>
</li><li class="listitem">
<code class="literal">RememberMeAuthenticationFilter</code>, so that if no earlier authentication processing mechanism updated the <code class="literal">SecurityContextHolder</code>, and the request presents a cookie that enables remember-me services to take place, a suitable remembered <code class="literal">Authentication</code> object will be put there
</li><li class="listitem">
<code class="literal">AnonymousAuthenticationFilter</code>, so that if no earlier authentication processing mechanism updated the <code class="literal">SecurityContextHolder</code>, an anonymous <code class="literal">Authentication</code> object will be put there
</li><li class="listitem">
<code class="literal">ExceptionTranslationFilter</code>, to catch any Spring Security exceptions so that either an HTTP error response can be returned or an appropriate <code class="literal">AuthenticationEntryPoint</code> can be launched
</li><li class="listitem">
<code class="literal">FilterSecurityInterceptor</code>, to protect web URIs and raise exceptions when access is denied
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="request-matching" href="#request-matching"></a>10.1.4&nbsp;Request Matching and HttpFirewall</h3></div></div></div>

<p>Spring Security has several areas where patterns you have defined are tested against incoming requests in order to decide how the request should be handled.
This occurs when the <code class="literal">FilterChainProxy</code> decides which filter chain a request should be passed through and also when the <code class="literal">FilterSecurityInterceptor</code> decides which security constraints apply to a request.
It&#8217;s important to understand what the mechanism is and what URL value is used when testing against the patterns that you define.</p>
<p>The Servlet Specification defines several properties for the <code class="literal">HttpServletRequest</code> which are accessible via getter methods, and which we might want to match against.
These are the <code class="literal">contextPath</code>, <code class="literal">servletPath</code>, <code class="literal">pathInfo</code> and <code class="literal">queryString</code>.
Spring Security is only interested in securing paths within the application, so the <code class="literal">contextPath</code> is ignored.
Unfortunately, the servlet spec does not define exactly what the values of <code class="literal">servletPath</code> and <code class="literal">pathInfo</code> will contain for a particular request URI.
For example, each path segment of a URL may contain parameters, as defined in <a class="ulink" href="http://www.ietf.org/rfc/rfc2396.txt" target="_top">RFC 2396</a>
<a href="#ftn.d5e3708" class="footnote" name="d5e3708"><sup class="footnote">[8]</sup></a>.
The Specification does not clearly state whether these should be included in the <code class="literal">servletPath</code> and <code class="literal">pathInfo</code> values and the behaviour varies between different servlet containers.
There is a danger that when an application is deployed in a container which does not strip path parameters from these values, an attacker could add them to the requested URL in order to cause a pattern match to succeed or fail unexpectedly.
<a href="#ftn.d5e3713" class="footnote" name="d5e3713"><sup class="footnote">[9]</sup></a>.
Other variations in the incoming URL are also possible.
For example, it could contain path-traversal sequences (like <code class="literal">/../</code>) or multiple forward slashes (<code class="literal">//</code>) which could also cause pattern-matches to fail.
Some containers normalize these out before performing the servlet mapping, but others don&#8217;t.
To protect against issues like these, <code class="literal">FilterChainProxy</code> uses an <code class="literal">HttpFirewall</code> strategy to check and wrap the request.
Un-normalized requests are automatically rejected by default, and path parameters and duplicate slashes are removed for matching purposes.
<a href="#ftn.d5e3720" class="footnote" name="d5e3720"><sup class="footnote">[10]</sup></a>.
It is therefore essential that a <code class="literal">FilterChainProxy</code> is used to manage the security filter chain.
Note that the <code class="literal">servletPath</code> and <code class="literal">pathInfo</code> values are decoded by the container, so your application should not have any valid paths which contain semi-colons, as these parts will be removed for matching purposes.</p>
<p>As mentioned above, the default strategy is to use Ant-style paths for matching and this is likely to be the best choice for most users.
The strategy is implemented in the class <code class="literal">AntPathRequestMatcher</code> which uses Spring&#8217;s <code class="literal">AntPathMatcher</code> to perform a case-insensitive match of the pattern against the concatenated <code class="literal">servletPath</code> and <code class="literal">pathInfo</code>, ignoring the <code class="literal">queryString</code>.</p>
<p>If for some reason, you need a more powerful matching strategy, you can use regular expressions.
The strategy implementation is then <code class="literal">RegexRequestMatcher</code>.
See the Javadoc for this class for more information.</p>
<p>In practice we recommend that you use method security at your service layer, to control access to your application, and do not rely entirely on the use of security constraints defined at the web-application level.
URLs change and it is difficult to take account of all the possible URLs that an application might support and how requests might be manipulated.
You should try and restrict yourself to using a few simple ant paths which are simple to understand.
Always try to use a "deny-by-default" approach where you have a catch-all wildcard ( /<span class="strong"><strong> or </strong></span>) defined last and denying access.</p>
<p>Security defined at the service layer is much more robust and harder to bypass, so you should always take advantage of Spring Security&#8217;s method security options.</p>
<p>The <code class="literal">HttpFirewall</code> also prevents <a class="ulink" href="https://www.owasp.org/index.php/HTTP_Response_Splitting" target="_top">HTTP Response Splitting</a> by rejecting new line characters in the HTTP Response headers.</p>
<p>By default the <code class="literal">StrictHttpFirewall</code> is used.
This implementation rejects requests that appear to be malicious.
If it is too strict for your needs, then you can customize what types of requests are rejected.
However, it is important that you do so knowing that this can open your application up to attacks.
For example, if you wish to leverage Spring MVC&#8217;s Matrix Variables, the following configuration could be used in XML:</p>
<pre class="programlisting"><span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpFirewall"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.firewall.StrictHttpFirewall"</span>
      <span class="hl-attribute">p:allowSemicolon</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;http-firewall</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpFirewall"</span><span class="hl-tag">/&gt;</span></pre>
<p>The same thing can be achieved with Java Configuration by exposing a <code class="literal">StrictHttpFirewall</code> bean.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = <span class="hl-keyword">new</span> StrictHttpFirewall();
    firewall.setAllowSemicolon(true);
    <span class="hl-keyword">return</span> firewall;
}</pre>
<p>The <code class="literal">StrictHttpFirewall</code> provides a whitelist of valid HTTP methods that are allowed to protect against <a class="ulink" href="https://www.owasp.org/index.php/Cross_Site_Tracing" target="_top">Cross Site Tracing (XST)</a> and <a class="ulink" href="https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)" target="_top">HTTP Verb Tampering</a>.
The default valid methods are "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", and "PUT".
If your application needs to modify the valid methods, you can configure a custom <code class="literal">StrictHttpFirewall</code> bean.
For example, the following will only allow HTTP "GET" and "POST" methods:</p>
<pre class="programlisting"><span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpFirewall"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.firewall.StrictHttpFirewall"</span>
      <span class="hl-attribute">p:allowedHttpMethods</span>=<span class="hl-value">"GET,HEAD"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;http-firewall</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpFirewall"</span><span class="hl-tag">/&gt;</span></pre>
<p>The same thing can be achieved with Java Configuration by exposing a <code class="literal">StrictHttpFirewall</code> bean.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = <span class="hl-keyword">new</span> StrictHttpFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList(<span class="hl-string">"GET"</span>, <span class="hl-string">"POST"</span>));
    <span class="hl-keyword">return</span> firewall;
}</pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>If you are using <code class="literal">new MockHttpServletRequest()</code> it currently creates an HTTP method as an empty String "".
This is an invalid HTTP method and will be rejected by Spring Security.
You can resolve this by replacing it with <code class="literal">new MockHttpServletRequest("GET", "")</code>.
See <a class="ulink" href="https://jira.spring.io/browse/SPR-16851" target="_top">SPR_16851</a> for an issue requesting to improve this.</p>
</td></tr></table></div>
<p>If you must allow any HTTP method (not recommended), you can use <code class="literal">StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)</code>.
This will disable validation of the HTTP method entirely.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="use-with-other-filter-based-frameworks" href="#use-with-other-filter-based-frameworks"></a>10.1.5&nbsp;Use with other Filter-Based Frameworks</h3></div></div></div>

<p>If you&#8217;re using some other framework that is also filter-based, then you need to make sure that the Spring Security filters come first.
This enables the <code class="literal">SecurityContextHolder</code> to be populated in time for use by the other filters.
Examples are the use of SiteMesh to decorate your web pages or a web framework like Wicket which uses a filter to handle its requests.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="filter-chains-with-ns" href="#filter-chains-with-ns"></a>10.1.6&nbsp;Advanced Namespace Configuration</h3></div></div></div>

<p>As we saw earlier in the namespace chapter, it&#8217;s possible to use multiple <code class="literal">http</code> elements to define different security configurations for different URL patterns.
Each element creates a filter chain within the internal <code class="literal">FilterChainProxy</code> and the URL pattern that should be mapped to it.
The elements will be added in the order they are declared, so the most specific patterns must again be declared first.
Here&#8217;s another example, for a similar situation to that above, where the application supports both a stateless RESTful API and also a normal web application which users log into using a form.</p>
<pre class="programlisting"><span class="hl-comment">&lt;!-- Stateless RESTful service using Basic authentication --&gt;</span>
<span class="hl-tag">&lt;http</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/restful/**"</span> <span class="hl-attribute">create-session</span>=<span class="hl-value">"stateless"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/**'</span> <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('REMOTE')"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;http-basic /&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span>

<span class="hl-comment">&lt;!-- Empty filter chain for the login page --&gt;</span>
<span class="hl-tag">&lt;http</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/login.htm*"</span> <span class="hl-attribute">security</span>=<span class="hl-value">"none"</span><span class="hl-tag">/&gt;</span>

<span class="hl-comment">&lt;!-- Additional filter chain for normal users, matching all other requests --&gt;</span>
<span class="hl-tag">&lt;http&gt;</span>
<span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/**'</span> <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('USER')"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;form-login</span> <span class="hl-attribute">login-page</span>=<span class="hl-value">'/login.htm'</span> <span class="hl-attribute">default-target-url</span>=<span class="hl-value">"/home.htm"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;logout /&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-web-filters" href="#core-web-filters"></a>10.2&nbsp;Core Security Filters</h2></div></div></div>

<p>There are some key filters which will always be used in a web application which uses Spring Security, so we&#8217;ll look at these and their supporting classes and interfaces first.
We won&#8217;t cover every feature, so be sure to look at the Javadoc for them if you want to get the complete picture.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="filter-security-interceptor" href="#filter-security-interceptor"></a>10.2.1&nbsp;FilterSecurityInterceptor</h3></div></div></div>

<p>We&#8217;ve already seen <code class="literal">FilterSecurityInterceptor</code> briefly when discussing <a class="link" href="overall-architecture.html#tech-intro-access-control" title="8.1.5&nbsp;Access-Control (Authorization) in Spring Security">access-control in general</a>, and we&#8217;ve already used it with the namespace where the <code class="literal">&lt;intercept-url&gt;</code> elements are combined to configure it internally.
Now we&#8217;ll see how to explicitly configure it for use with a <code class="literal">FilterChainProxy</code>, along with its companion filter <code class="literal">ExceptionTranslationFilter</code>.
A typical configuration example is shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterSecurityInterceptor"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.intercept.FilterSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDecisionManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadataSource"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:filter-security-metadata-source&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/secure/super/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_WE_DONT_HAVE"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/secure/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_SUPERVISOR,ROLE_TELLER"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/security:filter-security-metadata-source&gt;</span>
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p><code class="literal">FilterSecurityInterceptor</code> is responsible for handling the security of HTTP resources.
It requires a reference to an <code class="literal">AuthenticationManager</code> and an <code class="literal">AccessDecisionManager</code>.
It is also supplied with configuration attributes that apply to different HTTP URL requests.
Refer back to <a class="link" href="overall-architecture.html#tech-intro-config-attributes" title="What are Configuration Attributes?">the original discussion on these</a> in the technical introduction.</p>
<p>The <code class="literal">FilterSecurityInterceptor</code> can be configured with configuration attributes in two ways.
The first, which is shown above, is using the <code class="literal">&lt;filter-security-metadata-source&gt;</code> namespace element.
This is similar to the <code class="literal">&lt;http&gt;</code> element from the namespace chapter but the <code class="literal">&lt;intercept-url&gt;</code> child elements only use the <code class="literal">pattern</code> and <code class="literal">access</code> attributes.
Commas are used to delimit the different configuration attributes that apply to each HTTP URL.
The second option is to write your own <code class="literal">SecurityMetadataSource</code>, but this is beyond the scope of this document.
Irrespective of the approach used, the <code class="literal">SecurityMetadataSource</code> is responsible for returning a <code class="literal">List&lt;ConfigAttribute&gt;</code> containing all of the configuration attributes associated with a single secure HTTP URL.</p>
<p>It should be noted that the <code class="literal">FilterSecurityInterceptor.setSecurityMetadataSource()</code> method actually expects an instance of <code class="literal">FilterInvocationSecurityMetadataSource</code>.
This is a marker interface which subclasses <code class="literal">SecurityMetadataSource</code>.
It simply denotes the <code class="literal">SecurityMetadataSource</code> understands <code class="literal">FilterInvocation</code> s.
In the interests of simplicity we&#8217;ll continue to refer to the <code class="literal">FilterInvocationSecurityMetadataSource</code> as a <code class="literal">SecurityMetadataSource</code>, as the distinction is of little relevance to most users.</p>
<p>The <code class="literal">SecurityMetadataSource</code> created by the namespace syntax obtains the configuration attributes for a particular <code class="literal">FilterInvocation</code> by matching the request URL against the configured <code class="literal">pattern</code> attributes.
This behaves in the same way as it does for namespace configuration.
The default is to treat all expressions as Apache Ant paths and regular expressions are also supported for more complex cases.
The <code class="literal">request-matcher</code> attribute is used to specify the type of pattern being used.
It is not possible to mix expression syntaxes within the same definition.
As an example, the previous configuration using regular expressions instead of Ant paths would be written as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterInvocationInterceptor"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.intercept.FilterSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDecisionManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"runAsManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"runAsManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadataSource"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:filter-security-metadata-source</span> <span class="hl-attribute">request-matcher</span>=<span class="hl-value">"regex"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"\A/secure/super/.*\Z"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_WE_DONT_HAVE"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"\A/secure/.*\"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_SUPERVISOR,ROLE_TELLER"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/security:filter-security-metadata-source&gt;</span>
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Patterns are always evaluated in the order they are defined.
Thus it is important that more specific patterns are defined higher in the list than less specific patterns.
This is reflected in our example above, where the more specific <code class="literal">/secure/super/</code> pattern appears higher than the less specific <code class="literal">/secure/</code> pattern.
If they were reversed, the <code class="literal">/secure/</code> pattern would always match and the <code class="literal">/secure/super/</code> pattern would never be evaluated.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="exception-translation-filter" href="#exception-translation-filter"></a>10.2.2&nbsp;ExceptionTranslationFilter</h3></div></div></div>

<p>The <code class="literal">ExceptionTranslationFilter</code> sits above the <code class="literal">FilterSecurityInterceptor</code> in the security filter stack.
It doesn&#8217;t do any actual security enforcement itself, but handles exceptions thrown by the security interceptors and provides suitable and HTTP responses.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exceptionTranslationFilter"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.ExceptionTranslationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationEntryPoint"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationEntryPoint"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDeniedHandler"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDeniedHandler"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"authenticationEntryPoint"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"loginFormUrl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/login.jsp"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accessDeniedHandler"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.AccessDeniedHandlerImpl"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"errorPage"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/accessDenied.htm"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-entry-point" href="#auth-entry-point"></a>AuthenticationEntryPoint</h4></div></div></div>

<p>The <code class="literal">AuthenticationEntryPoint</code> will be called if the user requests a secure HTTP resource but they are not authenticated.
An appropriate <code class="literal">AuthenticationException</code> or <code class="literal">AccessDeniedException</code> will be thrown by a security interceptor further down the call stack, triggering the <code class="literal">commence</code> method on the entry point.
This does the job of presenting the appropriate response to the user so that authentication can begin.
The one we&#8217;ve used here is <code class="literal">LoginUrlAuthenticationEntryPoint</code>, which redirects the request to a different URL (typically a login page).
The actual implementation used will depend on the authentication mechanism you want to be used in your application.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="access-denied-handler" href="#access-denied-handler"></a>AccessDeniedHandler</h4></div></div></div>

<p>What happens if a user is already authenticated and they try to access a protected resource? In normal usage, this shouldn&#8217;t happen because the application workflow should be restricted to operations to which a user has access.
For example, an HTML link to an administration page might be hidden from users who do not have an admin role.
You can&#8217;t rely on hiding links for security though, as there&#8217;s always a possibility that a user will just enter the URL directly in an attempt to bypass the restrictions.
Or they might modify a RESTful URL to change some of the argument values.
Your application must be protected against these scenarios or it will definitely be insecure.
You will typically use simple web layer security to apply constraints to basic URLs and use more specific method-based security on your service layer interfaces to really nail down what is permissible.</p>
<p>If an <code class="literal">AccessDeniedException</code> is thrown and a user has already been authenticated, then this means that an operation has been attempted for which they don&#8217;t have enough permissions.
In this case, <code class="literal">ExceptionTranslationFilter</code> will invoke a second strategy, the <code class="literal">AccessDeniedHandler</code>.
By default, an <code class="literal">AccessDeniedHandlerImpl</code> is used, which just sends a 403 (Forbidden) response to the client.
Alternatively you can configure an instance explicitly (as in the above example) and set an error page URL which it will forwards the request to <a href="#ftn.d5e3841" class="footnote" name="d5e3841"><sup class="footnote">[11]</sup></a>.
This can be a simple "access denied" page, such as a JSP, or it could be a more complex handler such as an MVC controller.
And of course, you can implement the interface yourself and use your own implementation.</p>
<p>It&#8217;s also possible to supply a custom <code class="literal">AccessDeniedHandler</code> when you&#8217;re using the namespace to configure your application.
See <a class="link" href="appendix.html#nsa-access-denied-handler" title="<access-denied-handler&gt;">the namespace appendix</a> for more details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="request-caching" href="#request-caching"></a>SavedRequest s and the RequestCache Interface</h4></div></div></div>

<p>Another responsibility of <code class="literal">ExceptionTranslationFilter</code> responsibilities is to save the current request before invoking the <code class="literal">AuthenticationEntryPoint</code>.
This allows the request to be restored after the user has authenticated (see previous overview of <a class="link" href="overall-architecture.html#tech-intro-web-authentication" title="8.1.4&nbsp;Authentication in a Web Application">web authentication</a>).
A typical example would be where the user logs in with a form, and is then redirected to the original URL by the default <code class="literal">SavedRequestAwareAuthenticationSuccessHandler</code> (see <a class="link" href="web-app-security.html#form-login-flow-handling" title="Application Flow on Authentication Success and Failure">below</a>).</p>
<p>The <code class="literal">RequestCache</code> encapsulates the functionality required for storing and retrieving <code class="literal">HttpServletRequest</code> instances.
By default the <code class="literal">HttpSessionRequestCache</code> is used, which stores the request in the <code class="literal">HttpSession</code>.
The <code class="literal">RequestCacheFilter</code> has the job of actually restoring the saved request from the cache when the user is redirected to the original URL.</p>
<p>Under normal circumstances, you shouldn&#8217;t need to modify any of this functionality, but the saved-request handling is a "best-effort" approach and there may be situations which the default configuration isn&#8217;t able to handle.
The use of these interfaces makes it fully pluggable from Spring Security 3.0 onwards.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="security-context-persistence-filter" href="#security-context-persistence-filter"></a>10.2.3&nbsp;SecurityContextPersistenceFilter</h3></div></div></div>

<p>We covered the purpose of this all-important filter in the <a class="link" href="overall-architecture.html#tech-intro-sec-context-persistence" title="Storing the SecurityContext between requests">Technical Overview</a> chapter so you might want to re-read that section at this point.
Let&#8217;s first take a look at how you would configure it for use with a <code class="literal">FilterChainProxy</code>.
A basic configuration only requires the bean itself</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"securityContextPersistenceFilter"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.context.SecurityContextPersistenceFilter"</span><span class="hl-tag">/&gt;</span></pre>
<p>As we saw previously, this filter has two main tasks.
It is responsible for storage of the <code class="literal">SecurityContext</code> contents between HTTP requests and for clearing the <code class="literal">SecurityContextHolder</code> when a request is completed.
Clearing the <code class="literal">ThreadLocal</code> in which the context is stored is essential, as it might otherwise be possible for a thread to be replaced into the servlet container&#8217;s thread pool, with the security context for a particular user still attached.
This thread might then be used at a later stage, performing operations with the wrong credentials.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="security-context-repository" href="#security-context-repository"></a>SecurityContextRepository</h4></div></div></div>

<p>From Spring Security 3.0, the job of loading and storing the security context is now delegated to a separate strategy interface:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SecurityContextRepository {

SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder);

<span class="hl-keyword">void</span> saveContext(SecurityContext context, HttpServletRequest request,
        HttpServletResponse response);
}</pre>
<p>The <code class="literal">HttpRequestResponseHolder</code> is simply a container for the incoming request and response objects, allowing the implementation to replace these with wrapper classes.
The returned contents will be passed to the filter chain.</p>
<p>The default implementation is <code class="literal">HttpSessionSecurityContextRepository</code>, which stores the security context as an <code class="literal">HttpSession</code> attribute <a href="#ftn.d5e3880" class="footnote" name="d5e3880"><sup class="footnote">[12]</sup></a>.
The most important configuration parameter for this implementation is the <code class="literal">allowSessionCreation</code> property, which defaults to <code class="literal">true</code>, thus allowing the class to create a session if it needs one to store the security context for an authenticated user (it won&#8217;t create one unless authentication has taken place and the contents of the security context have changed).
If you don&#8217;t want a session to be created, then you can set this property to <code class="literal">false</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"securityContextPersistenceFilter"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.context.SecurityContextPersistenceFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">'securityContextRepository'</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">'org.springframework.security.web.context.HttpSessionSecurityContextRepository'</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">'allowSessionCreation'</span> <span class="hl-attribute">value</span>=<span class="hl-value">'false'</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Alternatively you could provide an instance of <code class="literal">NullSecurityContextRepository</code>, a <a class="ulink" href="http://en.wikipedia.org/wiki/Null_Object_pattern" target="_top">null object</a> implementation, which will prevent the security context from being stored, even if a session has already been created during the request.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="form-login-filter" href="#form-login-filter"></a>10.2.4&nbsp;UsernamePasswordAuthenticationFilter</h3></div></div></div>

<p>We&#8217;ve now seen the three main filters which are always present in a Spring Security web configuration.
These are also the three which are automatically created by the namespace <code class="literal">&lt;http&gt;</code> element and cannot be substituted with alternatives.
The only thing that&#8217;s missing now is an actual authentication mechanism, something that will allow a user to authenticate.
This filter is the most commonly used authentication filter and the one that is most often customized <a href="#ftn.d5e3895" class="footnote" name="d5e3895"><sup class="footnote">[13]</sup></a>.
It also provides the implementation used by the <code class="literal">&lt;form-login&gt;</code> element from the namespace.
There are three stages required to configure it.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Configure a <code class="literal">LoginUrlAuthenticationEntryPoint</code> with the URL of the login page, just as we did above, and set it on the <code class="literal">ExceptionTranslationFilter</code>.
</li><li class="listitem">
Implement the login page (using a JSP or MVC controller).
</li><li class="listitem">
Configure an instance of <code class="literal">UsernamePasswordAuthenticationFilter</code> in the application context
</li><li class="listitem">
Add the filter bean to your filter chain proxy (making sure you pay attention to the order).
</li></ul></div>
<p>The login form simply contains <code class="literal">username</code> and <code class="literal">password</code> input fields, and posts to the URL that is monitored by the filter (by default this is <code class="literal">/login</code>).
The basic filter configuration looks something like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"authenticationFilter"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="form-login-flow-handling" href="#form-login-flow-handling"></a>Application Flow on Authentication Success and Failure</h4></div></div></div>

<p>The filter calls the configured <code class="literal">AuthenticationManager</code> to process each authentication request.
The destination following a successful authentication or an authentication failure is controlled by the <code class="literal">AuthenticationSuccessHandler</code> and <code class="literal">AuthenticationFailureHandler</code> strategy interfaces, respectively.
The filter has properties which allow you to set these so you can customize the behaviour completely <a href="#ftn.d5e3923" class="footnote" name="d5e3923"><sup class="footnote">[14]</sup></a>.
Some standard implementations are supplied such as <code class="literal">SimpleUrlAuthenticationSuccessHandler</code>, <code class="literal">SavedRequestAwareAuthenticationSuccessHandler</code>, <code class="literal">SimpleUrlAuthenticationFailureHandler</code>, <code class="literal">ExceptionMappingAuthenticationFailureHandler</code> and <code class="literal">DelegatingAuthenticationFailureHandler</code>.
Have a look at the Javadoc for these classes and also for <code class="literal">AbstractAuthenticationProcessingFilter</code> to get an overview of how they work and the supported features.</p>
<p>If authentication is successful, the resulting <code class="literal">Authentication</code> object will be placed into the <code class="literal">SecurityContextHolder</code>.
The configured <code class="literal">AuthenticationSuccessHandler</code> will then be called to either redirect or forward the user to the appropriate destination.
By default a <code class="literal">SavedRequestAwareAuthenticationSuccessHandler</code> is used, which means that the user will be redirected to the original destination they requested before they were asked to login.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">ExceptionTranslationFilter</code> caches the original request a user makes.
When the user authenticates, the request handler makes use of this cached request to obtain the original URL and redirect to it.
The original request is then rebuilt and used as an alternative.</p>
</td></tr></table></div>
<p>If authentication fails, the configured <code class="literal">AuthenticationFailureHandler</code> will be invoked.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="servletapi" href="#servletapi"></a>10.3&nbsp;Servlet API integration</h2></div></div></div>

<p>This section describes how Spring Security is integrated with the Servlet API.
The <a class="ulink" href="https://github.com/spring-projects/spring-security/tree/master/samples/xml/servletapi" target="_top">servletapi-xml</a> sample application demonstrates the usage of each of these methods.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="servletapi-25" href="#servletapi-25"></a>10.3.1&nbsp;Servlet 2.5+ Integration</h3></div></div></div>

<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-remote-user" href="#servletapi-remote-user"></a>HttpServletRequest.getRemoteUser()</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()" target="_top">HttpServletRequest.getRemoteUser()</a> will return the result of <code class="literal">SecurityContextHolder.getContext().getAuthentication().getName()</code> which is typically the current username.
This can be useful if you want to display the current username in your application.
Additionally, checking if this is null can be used to indicate if a user has authenticated or is anonymous.
Knowing if the user is authenticated or not can be useful for determining if certain UI elements should be shown or not (i.e. a log out link should only be displayed if the user is authenticated).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-user-principal" href="#servletapi-user-principal"></a>HttpServletRequest.getUserPrincipal()</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()" target="_top">HttpServletRequest.getUserPrincipal()</a> will return the result of <code class="literal">SecurityContextHolder.getContext().getAuthentication()</code>.
This means it is an <code class="literal">Authentication</code> which is typically an instance of <code class="literal">UsernamePasswordAuthenticationToken</code> when using username and password based authentication.
This can be useful if you need additional information about your user.
For example, you might have created a custom <code class="literal">UserDetailsService</code> that returns a custom <code class="literal">UserDetails</code> containing a first and last name for your user.
You could obtain this information with the following:</p>
<pre class="programlisting">Authentication auth = httpServletRequest.getUserPrincipal();
<span class="hl-comment">// assume integrated custom UserDetails called MyCustomUserDetails</span>
<span class="hl-comment">// by default, typically instance of UserDetails</span>
MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();
String firstName = userDetails.getFirstName();
String lastName = userDetails.getLastName();</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It should be noted that it is typically bad practice to perform so much logic throughout your application.
Instead, one should centralize it to reduce any coupling of Spring Security and the Servlet API&#8217;s.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-user-in-role" href="#servletapi-user-in-role"></a>HttpServletRequest.isUserInRole(String)</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)" target="_top">HttpServletRequest.isUserInRole(String)</a> will determine if <code class="literal">SecurityContextHolder.getContext().getAuthentication().getAuthorities()</code> contains a <code class="literal">GrantedAuthority</code> with the role passed into <code class="literal">isUserInRole(String)</code>.
Typically users should not pass in the "ROLE_" prefix into this method since it is added automatically.
For example, if you want to determine if the current user has the authority "ROLE_ADMIN", you could use the following:</p>
<pre class="programlisting"><span class="hl-keyword">boolean</span> isAdmin = httpServletRequest.isUserInRole(<span class="hl-string">"ADMIN"</span>);</pre>
<p>This might be useful to determine if certain UI components should be displayed.
For example, you might display admin links only if the current user is an admin.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="servletapi-3" href="#servletapi-3"></a>10.3.2&nbsp;Servlet 3+ Integration</h3></div></div></div>

<p>The following section describes the Servlet 3 methods that Spring Security integrates with.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-authenticate" href="#servletapi-authenticate"></a>HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29" target="_top">HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</a> method can be used to ensure that a user is authenticated.
If they are not authenticated, the configured AuthenticationEntryPoint will be used to request the user to authenticate (i.e. redirect to the login page).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-login" href="#servletapi-login"></a>HttpServletRequest.login(String,String)</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29" target="_top">HttpServletRequest.login(String,String)</a> method can be used to authenticate the user with the current <code class="literal">AuthenticationManager</code>.
For example, the following would attempt to authenticate with the username "user" and password "password":</p>
<pre class="programlisting"><span class="hl-keyword">try</span> {
httpServletRequest.login(<span class="hl-string">"user"</span>,<span class="hl-string">"password"</span>);
} <span class="hl-keyword">catch</span>(ServletException e) {
<span class="hl-comment">// fail to authenticate</span>
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It is not necessary to catch the ServletException if you want Spring Security to process the failed authentication attempt.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-logout" href="#servletapi-logout"></a>HttpServletRequest.logout()</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29" target="_top">HttpServletRequest.logout()</a> method can be used to log the current user out.</p>
<p>Typically this means that the SecurityContextHolder will be cleared out, the HttpSession will be invalidated, any "Remember Me" authentication will be cleaned up, etc.
However, the configured LogoutHandler implementations will vary depending on your Spring Security configuration.
It is important to note that after HttpServletRequest.logout() has been invoked, you are still in charge of writing a response out.
Typically this would involve a redirect to the welcome page.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-start-runnable" href="#servletapi-start-runnable"></a>AsyncContext.start(Runnable)</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29" target="_top">AsynchContext.start(Runnable)</a> method that ensures your credentials will be propagated to the new Thread.
Using Spring Security&#8217;s concurrency support, Spring Security overrides the AsyncContext.start(Runnable) to ensure that the current SecurityContext is used when processing the Runnable.
For example, the following would output the current user&#8217;s Authentication:</p>
<pre class="programlisting"><span class="hl-keyword">final</span> AsyncContext async = httpServletRequest.startAsync();
async.start(<span class="hl-keyword">new</span> Runnable() {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> run() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        <span class="hl-keyword">try</span> {
            <span class="hl-keyword">final</span> HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();
            asyncResponse.setStatus(HttpServletResponse.SC_OK);
            asyncResponse.getWriter().write(String.valueOf(authentication));
            async.complete();
        } <span class="hl-keyword">catch</span>(Exception e) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(e);
        }
    }
});</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-async" href="#servletapi-async"></a>Async Servlet Support</h4></div></div></div>

<p>If you are using Java Based configuration, you are ready to go.
If you are using XML configuration, there are a few updates that are necessary.
The first step is to ensure you have updated your web.xml to use at least the 3.0 schema as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;web-app</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://java.sun.com/xml/ns/javaee"</span>
<span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span>
<span class="hl-attribute">version</span>=<span class="hl-value">"3.0"</span><span class="hl-tag">&gt;</span>

<span class="hl-tag">&lt;/web-app&gt;</span></pre>
<p>Next you need to ensure that your springSecurityFilterChain is setup for processing asynchronous requests.</p>
<pre class="programlisting"><span class="hl-tag">&lt;filter&gt;</span>
<span class="hl-tag">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="hl-tag">&lt;/filter-name&gt;</span>
<span class="hl-tag">&lt;filter-class&gt;</span>
    org.springframework.web.filter.DelegatingFilterProxy
<span class="hl-tag">&lt;/filter-class&gt;</span>
<span class="hl-tag">&lt;async-supported&gt;</span>true<span class="hl-tag">&lt;/async-supported&gt;</span>
<span class="hl-tag">&lt;/filter&gt;</span>
<span class="hl-tag">&lt;filter-mapping&gt;</span>
<span class="hl-tag">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="hl-tag">&lt;/filter-name&gt;</span>
<span class="hl-tag">&lt;url-pattern&gt;</span>/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;dispatcher&gt;</span>REQUEST<span class="hl-tag">&lt;/dispatcher&gt;</span>
<span class="hl-tag">&lt;dispatcher&gt;</span>ASYNC<span class="hl-tag">&lt;/dispatcher&gt;</span>
<span class="hl-tag">&lt;/filter-mapping&gt;</span></pre>
<p>That&#8217;s it!
Now Spring Security will ensure that your SecurityContext is propagated on asynchronous requests too.</p>
<p>So how does it work? If you are not really interested, feel free to skip the remainder of this section, otherwise read on.
Most of this is built into the Servlet specification, but there is a little bit of tweaking that Spring Security does to ensure things work with asynchronous requests properly.
Prior to Spring Security 3.2, the SecurityContext from the SecurityContextHolder was automatically saved as soon as the HttpServletResponse was committed.
This can cause issues in an Async environment.
For example, consider the following:</p>
<pre class="programlisting">httpServletRequest.startAsync();
<span class="hl-keyword">new</span> Thread(<span class="hl-string">"AsyncThread"</span>) {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> run() {
        <span class="hl-keyword">try</span> {
            <span class="hl-comment">// Do work</span>
            TimeUnit.SECONDS.sleep(<span class="hl-number">1</span>);

            <span class="hl-comment">// Write to and commit the httpServletResponse</span>
            httpServletResponse.getOutputStream().flush();
        } <span class="hl-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}.start();</pre>
<p>The issue is that this Thread is not known to Spring Security, so the SecurityContext is not propagated to it.
This means when we commit the HttpServletResponse there is no SecuriytContext.
When Spring Security automatically saved the SecurityContext on committing the HttpServletResponse it would lose our logged in user.</p>
<p>Since version 3.2, Spring Security is smart enough to no longer automatically save the SecurityContext on commiting the HttpServletResponse as soon as HttpServletRequest.startAsync() is invoked.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="servletapi-31" href="#servletapi-31"></a>10.3.3&nbsp;Servlet 3.1+ Integration</h3></div></div></div>

<p>The following section describes the Servlet 3.1 methods that Spring Security integrates with.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="servletapi-change-session-id" href="#servletapi-change-session-id"></a>HttpServletRequest#changeSessionId()</h4></div></div></div>

<p>The <a class="ulink" href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()" target="_top">HttpServletRequest.changeSessionId()</a> is the default method for protecting against <a class="link" href="ns-config.html#ns-session-fixation" title="Session Fixation Attack Protection">Session Fixation</a> attacks in Servlet 3.1 and higher.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic" href="#basic"></a>10.4&nbsp;Basic and Digest Authentication</h2></div></div></div>

<p>Basic and digest authentication are alternative authentication mechanisms which are popular in web applications.
Basic authentication is often used with stateless clients which pass their credentials on each request.
It&#8217;s quite common to use it in combination with form-based authentication where an application is used through both a browser-based user interface and as a web-service.
However, basic authentication transmits the password as plain text so it should only really be used over an encrypted transport layer such as HTTPS.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="basic-processing-filter" href="#basic-processing-filter"></a>10.4.1&nbsp;BasicAuthenticationFilter</h3></div></div></div>

<p><code class="literal">BasicAuthenticationFilter</code> is responsible for processing basic authentication credentials presented in HTTP headers.
This can be used for authenticating calls made by Spring remoting protocols (such as Hessian and Burlap), as well as normal browser user agents (such as Firefox and Internet Explorer).
The standard governing HTTP Basic Authentication is defined by RFC 1945, Section 11, and <code class="literal">BasicAuthenticationFilter</code> conforms with this RFC.
Basic Authentication is an attractive approach to authentication, because it is very widely deployed in user agents and implementation is extremely simple (it&#8217;s just a Base64 encoding of the username:password, specified in an HTTP header).</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="basic-config" href="#basic-config"></a>Configuration</h4></div></div></div>

<p>To implement HTTP Basic Authentication, you need to add a <code class="literal">BasicAuthenticationFilter</code> to your filter chain.
The application context should contain <code class="literal">BasicAuthenticationFilter</code> and its required collaborator:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"basicAuthenticationFilter"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.www.BasicAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationEntryPoint"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationEntryPoint"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"authenticationEntryPoint"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"realmName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"Name Of Your Realm"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The configured <code class="literal">AuthenticationManager</code> processes each authentication request.
If authentication fails, the configured <code class="literal">AuthenticationEntryPoint</code> will be used to retry the authentication process.
Usually you will use the filter in combination with a <code class="literal">BasicAuthenticationEntryPoint</code>, which returns a 401 response with a suitable header to retry HTTP Basic authentication.
If authentication is successful, the resulting <code class="literal">Authentication</code> object will be placed into the <code class="literal">SecurityContextHolder</code> as usual.</p>
<p>If the authentication event was successful, or authentication was not attempted because the HTTP header did not contain a supported authentication request, the filter chain will continue as normal.
The only time the filter chain will be interrupted is if authentication fails and the <code class="literal">AuthenticationEntryPoint</code> is called.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="digest-processing-filter" href="#digest-processing-filter"></a>10.4.2&nbsp;DigestAuthenticationFilter</h3></div></div></div>

<p><code class="literal">DigestAuthenticationFilter</code> is capable of processing digest authentication credentials presented in HTTP headers.
Digest Authentication attempts to solve many of the weaknesses of Basic authentication, specifically by ensuring credentials are never sent in clear text across the wire.
Many user agents support Digest Authentication, including Mozilla Firefox and Internet Explorer.
The standard governing HTTP Digest Authentication is defined by RFC 2617, which updates an earlier version of the Digest Authentication standard prescribed by RFC 2069.
Most user agents implement RFC 2617.
Spring Security&#8217;s <code class="literal">DigestAuthenticationFilter</code> is compatible with the &#8220;auth&#8221; quality of protection (<code class="literal">qop</code>) prescribed by RFC 2617, which also provides backward compatibility with RFC 2069.
Digest Authentication is a more attractive option if you need to use unencrypted HTTP (i.e. no TLS/HTTPS) and wish to maximise security of the authentication process.
Indeed Digest Authentication is a mandatory requirement for the WebDAV protocol, as noted by RFC 2518 Section 17.1.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>You should not use Digest in modern applications because it is not considered secure.
The most obvious problem is that you must store your passwords in plaintext, encrypted, or an MD5 format.
All of these storage formats are considered insecure.
Instead, you should use a one way adaptive password hash (i.e. bCrypt, PBKDF2, SCrypt, etc).</p>
</td></tr></table></div>
<p>Central to Digest Authentication is a "nonce".
This is a value the server generates.
Spring Security&#8217;s nonce adopts the following format:</p>
<pre class="programlisting">base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token</pre>
<p>The <code class="literal">DigestAuthenticatonEntryPoint</code> has a property specifying the <code class="literal">key</code> used for generating the nonce tokens, along with a <code class="literal">nonceValiditySeconds</code> property for determining the expiration time (default 300, which equals five minutes).
Whist ever the nonce is valid, the digest is computed by concatenating various strings including the username, password, nonce, URI being requested, a client-generated nonce (merely a random value which the user agent generates each request), the realm name etc, then performing an MD5 hash.
Both the server and user agent perform this digest computation, resulting in different hash codes if they disagree on an included value (eg password).
In Spring Security implementation, if the server-generated nonce has merely expired (but the digest was otherwise valid), the <code class="literal">DigestAuthenticationEntryPoint</code> will send a <code class="literal">"stale=true"</code> header.
This tells the user agent there is no need to disturb the user (as the password and username etc is correct), but simply to try again using a new nonce.</p>
<p>An appropriate value for the <code class="literal">nonceValiditySeconds</code> parameter of <code class="literal">DigestAuthenticationEntryPoint</code> depends on your application.
Extremely secure applications should note that an intercepted authentication header can be used to impersonate the principal until the <code class="literal">expirationTime</code> contained in the nonce is reached.
This is the key principle when selecting an appropriate setting, but it would be unusual for immensely secure applications to not be running over TLS/HTTPS in the first instance.</p>
<p>Because of the more complex implementation of Digest Authentication, there are often user agent issues.
For example, Internet Explorer fails to present an &#8220;opaque&#8221; token on subsequent requests in the same session.
Spring Security filters therefore encapsulate all state information into the &#8220;nonce&#8221; token instead.
In our testing, Spring Security&#8217;s implementation works reliably with Mozilla Firefox and Internet Explorer, correctly handling nonce timeouts etc.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="digest-config" href="#digest-config"></a>Configuration</h4></div></div></div>

<p>Now that we&#8217;ve reviewed the theory, let&#8217;s see how to use it.
To implement HTTP Digest Authentication, it is necessary to define <code class="literal">DigestAuthenticationFilter</code> in the filter chain.
The application context will need to define the <code class="literal">DigestAuthenticationFilter</code> and its required collaborators:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"digestFilter"</span> <span class="hl-attribute">class</span>=
    <span class="hl-value">"org.springframework.security.web.authentication.www.DigestAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userDetailsService"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"jdbcDaoImpl"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationEntryPoint"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"digestEntryPoint"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userCache"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"userCache"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"digestEntryPoint"</span> <span class="hl-attribute">class</span>=
    <span class="hl-value">"org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"realmName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"Contacts Realm via Digest Authentication"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"acegi"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"nonceValiditySeconds"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The configured <code class="literal">UserDetailsService</code> is needed because <code class="literal">DigestAuthenticationFilter</code> must have direct access to the clear text password of a user.
Digest Authentication will NOT work if you are using encoded passwords in your DAO <a href="#ftn.d5e4069" class="footnote" name="d5e4069"><sup class="footnote">[15]</sup></a>.
The DAO collaborator, along with the <code class="literal">UserCache</code>, are typically shared directly with a <code class="literal">DaoAuthenticationProvider</code>.
The <code class="literal">authenticationEntryPoint</code> property must be <code class="literal">DigestAuthenticationEntryPoint</code>, so that <code class="literal">DigestAuthenticationFilter</code> can obtain the correct <code class="literal">realmName</code> and <code class="literal">key</code> for digest calculations.</p>
<p>Like <code class="literal">BasicAuthenticationFilter</code>, if authentication is successful an <code class="literal">Authentication</code> request token will be placed into the <code class="literal">SecurityContextHolder</code>.
If the authentication event was successful, or authentication was not attempted because the HTTP header did not contain a Digest Authentication request, the filter chain will continue as normal.
The only time the filter chain will be interrupted is if authentication fails and the <code class="literal">AuthenticationEntryPoint</code> is called, as discussed in the previous paragraph.</p>
<p>Digest Authentication&#8217;s RFC offers a range of additional features to further increase security.
For example, the nonce can be changed on every request.
Despite this, Spring Security implementation was designed to minimise the complexity of the implementation (and the doubtless user agent incompatibilities that would emerge), and avoid needing to store server-side state.
You are invited to review RFC 2617 if you wish to explore these features in more detail.
As far as we are aware, Spring Security&#8217;s implementation does comply with the minimum standards of this RFC.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remember-me" href="#remember-me"></a>10.5&nbsp;Remember-Me Authentication</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="remember-me-overview" href="#remember-me-overview"></a>10.5.1&nbsp;Overview</h3></div></div></div>

<p>Remember-me or persistent-login authentication refers to web sites being able to remember the identity of a principal between sessions.
This is typically accomplished by sending a cookie to the browser, with the cookie being detected during future sessions and causing automated login to take place.
Spring Security provides the necessary hooks for these operations to take place, and has two concrete remember-me implementations.
One uses hashing to preserve the security of cookie-based tokens and the other uses a database or other persistent storage mechanism to store the generated tokens.</p>
<p>Note that both implementations require a <code class="literal">UserDetailsService</code>.
If you are using an authentication provider which doesn&#8217;t use a <code class="literal">UserDetailsService</code> (for example, the LDAP provider) then it won&#8217;t work unless you also have a <code class="literal">UserDetailsService</code> bean in your application context.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="remember-me-hash-token" href="#remember-me-hash-token"></a>10.5.2&nbsp;Simple Hash-Based Token Approach</h3></div></div></div>

<p>This approach uses hashing to achieve a useful remember-me strategy.
In essence a cookie is sent to the browser upon successful interactive authentication, with the cookie being composed as follows:</p>
<pre class="programlisting">base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token</pre>
<p>As such the remember-me token is valid only for the period specified, and provided that the username, password and key does not change.
Notably, this has a potential security issue in that a captured remember-me token will be usable from any user agent until such time as the token expires.
This is the same issue as with digest authentication.
If a principal is aware a token has been captured, they can easily change their password and immediately invalidate all remember-me tokens on issue.
If more significant security is needed you should use the approach described in the next section.
Alternatively remember-me services should simply not be used at all.</p>
<p>If you are familiar with the topics discussed in the chapter on <a class="link" href="ns-config.html" title="7.&nbsp;Security Namespace Configuration">namespace configuration</a>, you can enable remember-me authentication just by adding the <code class="literal">&lt;remember-me&gt;</code> element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
...
<span class="hl-tag">&lt;remember-me</span> <span class="hl-attribute">key</span>=<span class="hl-value">"myAppKey"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>The <code class="literal">UserDetailsService</code> will normally be selected automatically.
If you have more than one in your application context, you need to specify which one should be used with the <code class="literal">user-service-ref</code> attribute, where the value is the name of your <code class="literal">UserDetailsService</code> bean.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="remember-me-persistent-token" href="#remember-me-persistent-token"></a>10.5.3&nbsp;Persistent Token Approach</h3></div></div></div>

<p>This approach is based on the article <a class="ulink" href="http://jaspan.com/improved_persistent_login_cookie_best_practice" target="_top">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> with some minor modifications  <a href="#ftn.d5e4112" class="footnote" name="d5e4112"><sup class="footnote">[16]</sup></a>.
To use the this approach with namespace configuration, you would supply a datasource reference:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
...
<span class="hl-tag">&lt;remember-me</span> <span class="hl-attribute">data-source-ref</span>=<span class="hl-value">"someDataSource"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>The database should contain a <code class="literal">persistent_logins</code> table, created using the following SQL (or equivalent):</p>
<pre class="programlisting">create table persistent_logins (username varchar(64) not null,
                                series varchar(64) primary key,
                                token varchar(64) not null,
                                last_used timestamp not null)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="remember-me-impls" href="#remember-me-impls"></a>10.5.4&nbsp;Remember-Me Interfaces and Implementations</h3></div></div></div>

<p>Remember-me is used with <code class="literal">UsernamePasswordAuthenticationFilter</code>, and is implemented via hooks in the <code class="literal">AbstractAuthenticationProcessingFilter</code> superclass.
It is also used within <code class="literal">BasicAuthenticationFilter</code>.
The hooks will invoke a concrete <code class="literal">RememberMeServices</code> at the appropriate times.
The interface looks like this:</p>
<pre class="programlisting">Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

<span class="hl-keyword">void</span> loginFail(HttpServletRequest request, HttpServletResponse response);

<span class="hl-keyword">void</span> loginSuccess(HttpServletRequest request, HttpServletResponse response,
    Authentication successfulAuthentication);</pre>
<p>Please refer to the Javadoc for a fuller discussion on what the methods do, although note at this stage that <code class="literal">AbstractAuthenticationProcessingFilter</code> only calls the <code class="literal">loginFail()</code> and <code class="literal">loginSuccess()</code> methods.
The <code class="literal">autoLogin()</code> method is called by <code class="literal">RememberMeAuthenticationFilter</code> whenever the <code class="literal">SecurityContextHolder</code> does not contain an <code class="literal">Authentication</code>.
This interface therefore provides the underlying remember-me implementation with sufficient notification of authentication-related events, and delegates to the implementation whenever a candidate web request might contain a cookie and wish to be remembered.
This design allows any number of remember-me implementation strategies.
We&#8217;ve seen above that Spring Security provides two implementations.
We&#8217;ll look at these in turn.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="tokenbasedremembermeservices" href="#tokenbasedremembermeservices"></a>TokenBasedRememberMeServices</h4></div></div></div>

<p>This implementation supports the simpler approach described in <a class="xref" href="web-app-security.html#remember-me-hash-token" title="10.5.2&nbsp;Simple Hash-Based Token Approach">Section&nbsp;10.5.2, &#8220;Simple Hash-Based Token Approach&#8221;</a>.
<code class="literal">TokenBasedRememberMeServices</code> generates a <code class="literal">RememberMeAuthenticationToken</code>, which is processed by <code class="literal">RememberMeAuthenticationProvider</code>.
A <code class="literal">key</code> is shared between this authentication provider and the <code class="literal">TokenBasedRememberMeServices</code>.
In addition, <code class="literal">TokenBasedRememberMeServices</code> requires A UserDetailsService from which it can retrieve the username and password for signature comparison purposes, and generate the <code class="literal">RememberMeAuthenticationToken</code> to contain the correct <code class="literal">GrantedAuthority</code> s.
Some sort of logout command should be provided by the application that invalidates the cookie if the user requests this.
<code class="literal">TokenBasedRememberMeServices</code> also implements Spring Security&#8217;s <code class="literal">LogoutHandler</code> interface so can be used with <code class="literal">LogoutFilter</code> to have the cookie cleared automatically.</p>
<p>The beans required in an application context to enable remember-me services are as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rememberMeFilter"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"rememberMeServices"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"rememberMeServices"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"theAuthenticationManager"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rememberMeServices"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userDetailsService"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myUserDetailsService"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"springRocks"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rememberMeAuthenticationProvider"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.authentication.RememberMeAuthenticationProvider"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"springRocks"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Don&#8217;t forget to add your <code class="literal">RememberMeServices</code> implementation to your <code class="literal">UsernamePasswordAuthenticationFilter.setRememberMeServices()</code> property, include the <code class="literal">RememberMeAuthenticationProvider</code> in your <code class="literal">AuthenticationManager.setProviders()</code> list, and add <code class="literal">RememberMeAuthenticationFilter</code> into your <code class="literal">FilterChainProxy</code> (typically immediately after your <code class="literal">UsernamePasswordAuthenticationFilter</code>).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="persistenttokenbasedremembermeservices" href="#persistenttokenbasedremembermeservices"></a>PersistentTokenBasedRememberMeServices</h4></div></div></div>

<p>This class can be used in the same way as <code class="literal">TokenBasedRememberMeServices</code>, but it additionally needs to be configured with a <code class="literal">PersistentTokenRepository</code> to store the tokens.
There are two standard implementations.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">InMemoryTokenRepositoryImpl</code> which is intended for testing only.
</li><li class="listitem">
<code class="literal">JdbcTokenRepositoryImpl</code> which stores the tokens in a database.
</li></ul></div>
<p>The database schema is described above in <a class="xref" href="web-app-security.html#remember-me-persistent-token" title="10.5.3&nbsp;Persistent Token Approach">Section&nbsp;10.5.3, &#8220;Persistent Token Approach&#8221;</a>.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csrf" href="#csrf"></a>10.6&nbsp;Cross Site Request Forgery (CSRF)</h2></div></div></div>

<p>This section discusses Spring Security&#8217;s <a class="ulink" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_top"> Cross Site Request Forgery (CSRF)</a> support.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="csrf-attacks" href="#csrf-attacks"></a>10.6.1&nbsp;CSRF Attacks</h3></div></div></div>

<p>Before we discuss how Spring Security can protect applications from CSRF attacks, we will explain what a CSRF attack is.
Let&#8217;s take a look at a concrete example to get a better understanding.</p>
<p>Assume that your bank&#8217;s website provides a form that allows transferring money from the currently logged in user to another bank account.
For example, the HTTP request might look like:</p>
<pre class="screen">POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;routingNumber=1234&amp;account=9876</pre>
<p>Now pretend you authenticate to your bank&#8217;s website and then, without logging out, visit an evil website.
The evil website contains an HTML page with the following form:</p>
<pre class="programlisting"><span class="hl-tag">&lt;form</span> <span class="hl-attribute">action</span>=<span class="hl-value">"https://bank.example.com/transfer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"hidden"</span>
    <span class="hl-attribute">name</span>=<span class="hl-value">"amount"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"100.00"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"hidden"</span>
    <span class="hl-attribute">name</span>=<span class="hl-value">"routingNumber"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"evilsRoutingNumber"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"hidden"</span>
    <span class="hl-attribute">name</span>=<span class="hl-value">"account"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"evilsAccountNumber"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"submit"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"Win Money!"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/form&gt;</span></pre>
<p>You like to win money, so you click on the submit button.
In the process, you have unintentionally transferred $100 to a malicious user.
This happens because, while the evil website cannot see your cookies, the cookies associated with your bank are still sent along with the request.</p>
<p>Worst yet, this whole process could have been automated using JavaScript.
This means you didn&#8217;t even need to click on the button.
So how do we protect ourselves from such attacks?</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="synchronizer-token-pattern" href="#synchronizer-token-pattern"></a>10.6.2&nbsp;Synchronizer Token Pattern</h3></div></div></div>

<p>The issue is that the HTTP request from the bank&#8217;s website and the request from the evil website are exactly the same.
This means there is no way to reject requests coming from the evil website and allow requests coming from the bank&#8217;s website.
To protect against CSRF attacks we need to ensure there is something in the request that the evil site is unable to provide.</p>
<p>One solution is to use the <a class="ulink" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern" target="_top">Synchronizer Token Pattern</a>.
This solution is to ensure that each request requires, in addition to our session cookie, a randomly generated token as an HTTP parameter.
When a request is submitted, the server must look up the expected value for the parameter and compare it against the actual value in the request.
If the values do not match, the request should fail.</p>
<p>We can relax the expectations to only require the token for each HTTP request that updates state.
This can be safely done since the same origin policy ensures the evil site cannot read the response.
Additionally, we do not want to include the random token in HTTP GET as this can cause the tokens to be leaked.</p>
<p>Let&#8217;s take a look at how our example would change.
Assume the randomly generated token is present in an HTTP parameter named _csrf.
For example, the request to transfer money would look like this:</p>
<pre class="screen">POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;routingNumber=1234&amp;account=9876&amp;_csrf=&lt;secure-random&gt;</pre>
<p>You will notice that we added the _csrf parameter with a random value.
Now the evil website will not be able to guess the correct value for the _csrf parameter (which must be explicitly provided on the evil website) and the transfer will fail when the server compares the actual token to the expected token.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="when-to-use-csrf-protection" href="#when-to-use-csrf-protection"></a>10.6.3&nbsp;When to use CSRF protection</h3></div></div></div>

<p>When should you use CSRF protection? Our recommendation is to use CSRF protection for any request that could be processed by a browser by normal users.
If you are only creating a service that is used by non-browser clients, you will likely want to disable CSRF protection.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-protection-and-json" href="#csrf-protection-and-json"></a>CSRF protection and JSON</h4></div></div></div>

<p>A common question is "do I need to protect JSON requests made by javascript?" The short answer is, it depends.
However, you must be very careful as there are CSRF exploits that can impact JSON requests.
For example, a malicious user can create a <a class="ulink" href="http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html" target="_top">CSRF with JSON using the following form</a>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;form</span> <span class="hl-attribute">action</span>=<span class="hl-value">"https://bank.example.com/transfer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span> <span class="hl-attribute">enctype</span>=<span class="hl-value">"text/plain"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">name</span>=<span class="hl-value">'{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"'</span> <span class="hl-attribute">value</span>=<span class="hl-value">'test"}'</span> <span class="hl-attribute">type</span>=<span class="hl-value">'hidden'</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"submit"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"Win Money!"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/form&gt;</span></pre>
<p>This will produce the following JSON structure</p>
<pre class="programlisting">{ <span class="hl-string">"amount"</span>: <span class="hl-number">100</span>,
<span class="hl-string">"routingNumber"</span>: <span class="hl-string">"evilsRoutingNumber"</span>,
<span class="hl-string">"account"</span>: <span class="hl-string">"evilsAccountNumber"</span>,
<span class="hl-string">"ignore_me"</span>: <span class="hl-string">"=test"</span>
}</pre>
<p>If an application were not validating the Content-Type, then it would be exposed to this exploit.
Depending on the setup, a Spring MVC application that validates the Content-Type could still be exploited by updating the URL suffix to end with ".json" as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;form</span> <span class="hl-attribute">action</span>=<span class="hl-value">"https://bank.example.com/transfer.json"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span> <span class="hl-attribute">enctype</span>=<span class="hl-value">"text/plain"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">name</span>=<span class="hl-value">'{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"'</span> <span class="hl-attribute">value</span>=<span class="hl-value">'test"}'</span> <span class="hl-attribute">type</span>=<span class="hl-value">'hidden'</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"submit"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"Win Money!"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/form&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-and-stateless-browser-applications" href="#csrf-and-stateless-browser-applications"></a>CSRF and Stateless Browser Applications</h4></div></div></div>

<p>What if my application is stateless? That doesn&#8217;t necessarily mean you are protected.
In fact, if a user does not need to perform any actions in the web browser for a given request, they are likely still vulnerable to CSRF attacks.</p>
<p>For example, consider an application uses a custom cookie that contains all the state within it for authentication instead of the JSESSIONID.
When the CSRF attack is made the custom cookie will be sent with the request in the same manner that the JSESSIONID cookie was sent in our previous example.</p>
<p>Users using basic authentication are also vulnerable to CSRF attacks since the browser will automatically include the username password in any requests in the same manner that the JSESSIONID cookie was sent in our previous example.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="csrf-using" href="#csrf-using"></a>10.6.4&nbsp;Using Spring Security CSRF Protection</h3></div></div></div>

<p>So what are the steps necessary to use Spring Security&#8217;s to protect our site against CSRF attacks? The steps to using Spring Security&#8217;s CSRF protection are outlined below:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="web-app-security.html#csrf-use-proper-verbs" title="Use proper HTTP verbs">Use proper HTTP verbs</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#csrf-configure" title="Configure CSRF Protection">Configure CSRF Protection</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#csrf-include-csrf-token" title="Include the CSRF Token">Include the CSRF Token</a>
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-use-proper-verbs" href="#csrf-use-proper-verbs"></a>Use proper HTTP verbs</h4></div></div></div>

<p>The first step to protecting against CSRF attacks is to ensure your website uses proper HTTP verbs.
Specifically, before Spring Security&#8217;s CSRF support can be of use, you need to be certain that your application is using PATCH, POST, PUT, and/or DELETE for anything that modifies state.</p>
<p>This is not a limitation of Spring Security&#8217;s support, but instead a general requirement for proper CSRF prevention.
The reason is that including private information in an HTTP GET can cause the information to be leaked.
See <a class="ulink" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3" target="_top">RFC 2616 Section 15.1.3 Encoding Sensitive Information in URI&#8217;s</a> for general guidance on using POST instead of GET for sensitive information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-configure" href="#csrf-configure"></a>Configure CSRF Protection</h4></div></div></div>

<p>The next step is to include Spring Security&#8217;s CSRF protection within your application.
Some frameworks handle invalid CSRF tokens by invaliding the user&#8217;s session, but this causes <a class="link" href="web-app-security.html#csrf-logout" title="Logging Out">its own problems</a>.
Instead by default Spring Security&#8217;s CSRF protection will produce an HTTP 403 access denied.
This can be customized by configuring the <a class="link" href="web-app-security.html#access-denied-handler" title="AccessDeniedHandler">AccessDeniedHandler</a> to process <code class="literal">InvalidCsrfTokenException</code> differently.</p>
<p>As of Spring Security 4.0, CSRF protection is enabled by default with XML configuration.
If you would like to disable CSRF protection, the corresponding XML configuration can be seen below.</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>
    <span class="hl-tag">&lt;csrf</span> <span class="hl-attribute">disabled</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>CSRF protection is enabled by default with Java Configuration.
If you would like to disable CSRF, the corresponding Java configuration can be seen below.
Refer to the Javadoc of csrf() for additional customizations in how CSRF protection is configured.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
        http
            .csrf().disable();
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-include-csrf-token" href="#csrf-include-csrf-token"></a>Include the CSRF Token</h4></div></div></div>

<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="csrf-include-csrf-token-form" href="#csrf-include-csrf-token-form"></a>Form Submissions</h5></div></div></div>

<p>The last step is to ensure that you include the CSRF token in all PATCH, POST, PUT, and DELETE methods.
One way to approach this is to use the <code class="literal">_csrf</code> request attribute to obtain the current <code class="literal">CsrfToken</code>.
An example of doing this with a JSP is shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;c:url</span> <span class="hl-attribute">var</span>=<span class="hl-value">"logoutUrl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/logout"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;form</span> <span class="hl-attribute">action</span>=<span class="hl-value">"${logoutUrl}"</span>
    <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"submit"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"Log out"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"hidden"</span>
    <span class="hl-attribute">name</span>=<span class="hl-value">"${_csrf.parameterName}"</span>
    <span class="hl-attribute">value</span>=<span class="hl-value">"${_csrf.token}"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/form&gt;</span></pre>
<p>An easier approach is to use <a class="link" href="servlet-webclient.html#the-csrfinput-tag" title="13.5.5&nbsp;The csrfInput Tag">the csrfInput tag</a> from the Spring Security JSP tag library.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you are using Spring MVC <code class="literal">&lt;form:form&gt;</code> tag or <a class="ulink" href="http://www.thymeleaf.org/whatsnew21.html#reqdata" target="_top">Thymeleaf 2.1+</a> and are using <code class="literal">@EnableWebSecurity</code>, the <code class="literal">CsrfToken</code> is automatically included for you (using the <code class="literal">CsrfRequestDataValueProcessor</code>).</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="csrf-include-csrf-token-ajax" href="#csrf-include-csrf-token-ajax"></a>Ajax and JSON Requests</h5></div></div></div>

<p>If you are using JSON, then it is not possible to submit the CSRF token within an HTTP parameter.
Instead you can submit the token within a HTTP header.
A typical pattern would be to include the CSRF token within your meta tags.
An example with a JSP is shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;html&gt;</span>
<span class="hl-tag">&lt;head&gt;</span>
    <span class="hl-tag">&lt;meta</span> <span class="hl-attribute">name</span>=<span class="hl-value">"_csrf"</span> <span class="hl-attribute">content</span>=<span class="hl-value">"${_csrf.token}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-comment">&lt;!-- default header name is X-CSRF-TOKEN --&gt;</span>
    <span class="hl-tag">&lt;meta</span> <span class="hl-attribute">name</span>=<span class="hl-value">"_csrf_header"</span> <span class="hl-attribute">content</span>=<span class="hl-value">"${_csrf.headerName}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>
<span class="hl-tag">&lt;/head&gt;</span>
<span class="hl-comment">&lt;!-- ... --&gt;</span></pre>
<p>Instead of manually creating the meta tags, you can use the simpler <a class="link" href="servlet-webclient.html#the-csrfmetatags-tag" title="13.5.6&nbsp;The csrfMetaTags Tag">csrfMetaTags tag</a> from the Spring Security JSP tag library.</p>
<p>You can then include the token within all your Ajax requests.
If you were using jQuery, this could be done with the following:</p>
<pre class="programlisting">$(<span class="hl-keyword">function</span> () {
<span class="hl-keyword">var</span> token = $(<span class="hl-string">"meta[name='_csrf']"</span>).attr(<span class="hl-string">"content"</span>);
<span class="hl-keyword">var</span> header = $(<span class="hl-string">"meta[name='_csrf_header']"</span>).attr(<span class="hl-string">"content"</span>);
$(document).ajaxSend(<span class="hl-keyword">function</span>(e, xhr, options) {
    xhr.setRequestHeader(header, token);
});
});</pre>
<p>As an alternative to jQuery, we recommend using <a class="ulink" href="http://cujojs.com/" target="_top">cujoJS&#8217;s</a> rest.js.
The <a class="ulink" href="https://github.com/cujojs/rest" target="_top">rest.js</a> module provides advanced support for working with HTTP requests and responses in RESTful ways.
A core capability is the ability to contextualize the HTTP client adding behavior as needed by chaining interceptors on to the client.</p>
<pre class="programlisting"><span class="hl-keyword">var</span> client = rest.chain(csrf, {
token: $(<span class="hl-string">"meta[name='_csrf']"</span>).attr(<span class="hl-string">"content"</span>),
name: $(<span class="hl-string">"meta[name='_csrf_header']"</span>).attr(<span class="hl-string">"content"</span>)
});</pre>
<p>The configured client can be shared with any component of the application that needs to make a request to the CSRF protected resource.
One significant difference between rest.js and jQuery is that only requests made with the configured client will contain the CSRF token, vs jQuery where <span class="emphasis"><em>all</em></span> requests will include the token.
The ability to scope which requests receive the token helps guard against leaking the CSRF token to a third party.
Please refer to the <a class="ulink" href="https://github.com/cujojs/rest/tree/master/docs" target="_top">rest.js reference documentation</a> for more information on rest.js.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="csrf-cookie" href="#csrf-cookie"></a>CookieCsrfTokenRepository</h5></div></div></div>

<p>There can be cases where users will want to persist the <code class="literal">CsrfToken</code> in a cookie.
By default the <code class="literal">CookieCsrfTokenRepository</code> will write to a cookie named <code class="literal">XSRF-TOKEN</code> and read it from a header named <code class="literal">X-XSRF-TOKEN</code> or the HTTP parameter <code class="literal">_csrf</code>.
These defaults come from <a class="ulink" href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection" target="_top">AngularJS</a></p>
<p>You can configure <code class="literal">CookieCsrfTokenRepository</code> in XML using the following:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>
    <span class="hl-tag">&lt;csrf</span> <span class="hl-attribute">token-repository-ref</span>=<span class="hl-value">"tokenRepository"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span>
<span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"tokenRepository"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.csrf.CookieCsrfTokenRepository"</span>
    <span class="hl-attribute">p:cookieHttpOnly</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The sample explicitly sets <code class="literal">cookieHttpOnly=false</code>.
This is necessary to allow JavaScript (i.e. AngularJS) to read it.
If you do not need the ability to read the cookie with JavaScript directly, it is recommended to omit <code class="literal">cookieHttpOnly=false</code> to improve security.</p>
</td></tr></table></div>
<p>You can configure <code class="literal">CookieCsrfTokenRepository</code> in Java Configuration using:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
        WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
        http
            .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
    }
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The sample explicitly sets <code class="literal">cookieHttpOnly=false</code>.
This is necessary to allow JavaScript (i.e. AngularJS) to read it.
If you do not need the ability to read the cookie with JavaScript directly, it is recommended to omit <code class="literal">cookieHttpOnly=false</code> (by using <code class="literal">new CookieCsrfTokenRepository()</code> instead) to improve security.</p>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="csrf-caveats" href="#csrf-caveats"></a>10.6.5&nbsp;CSRF Caveats</h3></div></div></div>

<p>There are a few caveats when implementing CSRF.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-timeouts" href="#csrf-timeouts"></a>Timeouts</h4></div></div></div>

<p>One issue is that the expected CSRF token is stored in the HttpSession, so as soon as the HttpSession expires your configured <code class="literal">AccessDeniedHandler</code> will receive a InvalidCsrfTokenException.
If you are using the default <code class="literal">AccessDeniedHandler</code>, the browser will get an HTTP 403 and display a poor error message.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>One might ask why the expected <code class="literal">CsrfToken</code> isn&#8217;t stored in a cookie by default.
This is because there are known exploits in which headers (i.e. specify the cookies) can be set by another domain.
This is the same reason Ruby on Rails <a class="ulink" href="http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/" target="_top">no longer skips CSRF checks when the header X-Requested-With is present</a>.
See <a class="ulink" href="http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html" target="_top">this webappsec.org thread</a> for details on how to perform the exploit.
Another disadvantage is that by removing the state (i.e. the timeout) you lose the ability to forcibly terminate the token if it is compromised.</p>
</td></tr></table></div>
<p>A simple way to mitigate an active user experiencing a timeout is to have some JavaScript that lets the user know their session is about to expire.
The user can click a button to continue and refresh the session.</p>
<p>Alternatively, specifying a custom <code class="literal">AccessDeniedHandler</code> allows you to process the <code class="literal">InvalidCsrfTokenException</code> any way you like.
For an example of how to customize the <code class="literal">AccessDeniedHandler</code> refer to the provided links for both <a class="link" href="appendix.html#nsa-access-denied-handler" title="<access-denied-handler&gt;">xml</a> and <a class="ulink" href="https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/groovy/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.groovy#L64" target="_top">Java configuration</a>.</p>
<p>Finally, the application can be configured to use <a class="link" href="web-app-security.html#csrf-cookie" title="CookieCsrfTokenRepository">CookieCsrfTokenRepository</a> which will not expire.
As previously mentioned, this is not as secure as using a session, but in many cases can be good enough.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-login" href="#csrf-login"></a>Logging In</h4></div></div></div>

<p>In order to protect against <a class="ulink" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests" target="_top">forging log in requests</a> the log in form should be protected against CSRF attacks too.
Since the <code class="literal">CsrfToken</code> is stored in HttpSession, this means an HttpSession will be created as soon as <code class="literal">CsrfToken</code> token attribute is accessed.
While this sounds bad in a RESTful / stateless architecture the reality is that state is necessary to implement practical security.
Without state, we have nothing we can do if a token is compromised.
Practically speaking, the CSRF token is quite small in size and should have a negligible impact on our architecture.</p>
<p>A common technique to protect the log in form is by using a JavaScript function to obtain a valid CSRF token before the form submission.
By doing this, there is no need to think about session timeouts (discussed in the previous section) because the session is created right before the form submission (assuming that <a class="link" href="web-app-security.html#csrf-cookie" title="CookieCsrfTokenRepository">CookieCsrfTokenRepository</a> isn&#8217;t configured instead), so the user can stay on the login page and submit the username/password when he wants.
In order to achieve this, you can take advantage of the <code class="literal">CsrfTokenArgumentResolver</code> provided by Spring Security and expose an endpoint like it&#8217;s described on <a class="link" href="servlet-webclient.html#mvc-csrf-resolver" title="Resolving the CsrfToken">here</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-logout" href="#csrf-logout"></a>Logging Out</h4></div></div></div>

<p>Adding CSRF will update the LogoutFilter to only use HTTP POST.
This ensures that log out requires a CSRF token and that a malicious user cannot forcibly log out your users.</p>
<p>One approach is to use a form for log out.
If you really want a link, you can use JavaScript to have the link perform a POST (i.e. maybe on a hidden form).
For browsers with JavaScript that is disabled, you can optionally have the link take the user to a log out confirmation page that will perform the POST.</p>
<p>If you really want to use HTTP GET with logout you can do so, but remember this is generally not recommended.
For example, the following Java Configuration will perform logout with the URL /logout is requested with any HTTP method:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
        http
            .logout()
                .logoutRequestMatcher(<span class="hl-keyword">new</span> AntPathRequestMatcher(<span class="hl-string">"/logout"</span>));
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="csrf-multipart" href="#csrf-multipart"></a>Multipart (file upload)</h4></div></div></div>

<p>There are two options to using CSRF protection with multipart/form-data.
Each option has its tradeoffs.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="web-app-security.html#csrf-multipartfilter" title="Placing MultipartFilter before Spring Security">Placing MultipartFilter before Spring Security</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#csrf-include-csrf-token-in-action" title="Include CSRF token in action">Include CSRF token in action</a>
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Before you integrate Spring Security&#8217;s CSRF protection with multipart file upload, ensure that you can upload without the CSRF protection first.
More information about using multipart forms with Spring can be found within the <a class="ulink" href="http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-multipart" target="_top">17.10 Spring&#8217;s multipart (file upload) support</a> section of the Spring reference and the <a class="ulink" href="http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html" target="_top">MultipartFilter javadoc</a>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="csrf-multipartfilter" href="#csrf-multipartfilter"></a>Placing MultipartFilter before Spring Security</h5></div></div></div>

<p>The first option is to ensure that the <code class="literal">MultipartFilter</code> is specified before the Spring Security filter.
Specifying the <code class="literal">MultipartFilter</code> before the Spring Security filter means that there is no authorization for invoking the <code class="literal">MultipartFilter</code> which means anyone can place temporary files on your server.
However, only authorized users will be able to submit a File that is processed by your application.
In general, this is the recommended approach because the temporary file upload should have a negligble impact on most servers.</p>
<p>To ensure <code class="literal">MultipartFilter</code> is specified before the Spring Security filter with java configuration, users can override beforeSpringSecurityFilterChain as shown below:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SecurityApplicationInitializer <span class="hl-keyword">extends</span> AbstractSecurityWebApplicationInitializer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> beforeSpringSecurityFilterChain(ServletContext servletContext) {
        insertFilters(servletContext, <span class="hl-keyword">new</span> MultipartFilter());
    }
}</pre>
<p>To ensure <code class="literal">MultipartFilter</code> is specified before the Spring Security filter with XML configuration, users can ensure the &lt;filter-mapping&gt; element of the <code class="literal">MultipartFilter</code> is placed before the springSecurityFilterChain within the web.xml as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;filter&gt;</span>
    <span class="hl-tag">&lt;filter-name&gt;</span>MultipartFilter<span class="hl-tag">&lt;/filter-name&gt;</span>
    <span class="hl-tag">&lt;filter-class&gt;</span>org.springframework.web.multipart.support.MultipartFilter<span class="hl-tag">&lt;/filter-class&gt;</span>
<span class="hl-tag">&lt;/filter&gt;</span>
<span class="hl-tag">&lt;filter&gt;</span>
    <span class="hl-tag">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="hl-tag">&lt;/filter-name&gt;</span>
    <span class="hl-tag">&lt;filter-class&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hl-tag">&lt;/filter-class&gt;</span>
<span class="hl-tag">&lt;/filter&gt;</span>
<span class="hl-tag">&lt;filter-mapping&gt;</span>
    <span class="hl-tag">&lt;filter-name&gt;</span>MultipartFilter<span class="hl-tag">&lt;/filter-name&gt;</span>
    <span class="hl-tag">&lt;url-pattern&gt;</span>/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;/filter-mapping&gt;</span>
<span class="hl-tag">&lt;filter-mapping&gt;</span>
    <span class="hl-tag">&lt;filter-name&gt;</span>springSecurityFilterChain<span class="hl-tag">&lt;/filter-name&gt;</span>
    <span class="hl-tag">&lt;url-pattern&gt;</span>/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;/filter-mapping&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="csrf-include-csrf-token-in-action" href="#csrf-include-csrf-token-in-action"></a>Include CSRF token in action</h5></div></div></div>

<p>If allowing unauthorized users to upload temporariy files is not acceptable, an alternative is to place the <code class="literal">MultipartFilter</code> after the Spring Security filter and include the CSRF as a query parameter in the action attribute of the form.
An example with a jsp is shown below</p>
<pre class="programlisting"><span class="hl-tag">&lt;form</span> <span class="hl-attribute">action</span>=<span class="hl-value">"./upload?${_csrf.parameterName}=${_csrf.token}"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span> <span class="hl-attribute">enctype</span>=<span class="hl-value">"multipart/form-data"</span><span class="hl-tag">&gt;</span></pre>
<p>The disadvantage to this approach is that query parameters can be leaked.
More genearlly, it is considered best practice to place sensitive data within the body or headers to ensure it is not leaked.
Additional information can be found in <a class="ulink" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3" target="_top">RFC 2616 Section 15.1.3 Encoding Sensitive Information in URI&#8217;s</a>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hiddenhttpmethodfilter" href="#hiddenhttpmethodfilter"></a>HiddenHttpMethodFilter</h4></div></div></div>

<p>The HiddenHttpMethodFilter should be placed before the Spring Security filter.
In general this is true, but it could have additional implications when protecting against CSRF attacks.</p>
<p>Note that the HiddenHttpMethodFilter only overrides the HTTP method on a POST, so this is actually unlikely to cause any real problems.
However, it is still best practice to ensure it is placed before Spring Security&#8217;s filters.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overriding-defaults" href="#overriding-defaults"></a>10.6.6&nbsp;Overriding Defaults</h3></div></div></div>

<p>Spring Security&#8217;s goal is to provide defaults that protect your users from exploits.
This does not mean that you are forced to accept all of its defaults.</p>
<p>For example, you can provide a custom CsrfTokenRepository to override the way in which the <code class="literal">CsrfToken</code> is stored.</p>
<p>You can also specify a custom RequestMatcher to determine which requests are protected by CSRF (i.e. perhaps you don&#8217;t care if log out is exploited).
In short, if Spring Security&#8217;s CSRF protection doesn&#8217;t behave exactly as you want it, you are able to customize the behavior.
Refer to the <a class="xref" href="appendix.html#nsa-csrf" title="<csrf&gt;">the section called &#8220;&lt;csrf&gt;&#8221;</a> documentation for details on how to make these customizations with XML and the <code class="literal">CsrfConfigurer</code> javadoc for details on how to make these customizations when using Java configuration.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cors" href="#cors"></a>10.7&nbsp;CORS</h2></div></div></div>

<p>Spring Framework provides <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors" target="_top">first class support for CORS</a>.
CORS must be processed before Spring Security because the pre-flight request will not contain any cookies (i.e. the <code class="literal">JSESSIONID</code>).
If the request does not contain any cookies and Spring Security is first, the request will determine the user is not authenticated (since there are no cookies in the request) and reject it.</p>
<p>The easiest way to ensure that CORS is handled first is to use the <code class="literal">CorsFilter</code>.
Users can integrate the <code class="literal">CorsFilter</code> with Spring Security by providing a <code class="literal">CorsConfigurationSource</code> using the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span> WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
        http
            <span class="hl-comment">// by default uses a Bean by the name of corsConfigurationSource</span>
            .cors().and()
            ...
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = <span class="hl-keyword">new</span> CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(<span class="hl-string">"https://example.com"</span>));
        configuration.setAllowedMethods(Arrays.asList(<span class="hl-string">"GET"</span>,<span class="hl-string">"POST"</span>));
        UrlBasedCorsConfigurationSource source = <span class="hl-keyword">new</span> UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(<span class="hl-string">"/**"</span>, configuration);
        <span class="hl-keyword">return</span> source;
    }
}</pre>
<p>or in XML</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;cors</span> <span class="hl-attribute">configuration-source-ref</span>=<span class="hl-value">"corsSource"</span><span class="hl-tag">/&gt;</span>
    ...
<span class="hl-tag">&lt;/http&gt;</span>
<span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"corsSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.cors.UrlBasedCorsConfigurationSource"</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/b:bean&gt;</span></pre>
<p>If you are using Spring MVC&#8217;s CORS support, you can omit specifying the <code class="literal">CorsConfigurationSource</code> and Spring Security will leverage the CORS configuration provided to Spring MVC.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span> WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
        http
            <span class="hl-comment">// if Spring MVC is on classpath and no CorsConfigurationSource is provided,</span>
            <span class="hl-comment">// Spring Security will use CORS configuration provided to Spring MVC</span>
            .cors().and()
            ...
    }
}</pre>
<p>or in XML</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- Default to Spring MVC's CORS configuration --&gt;</span>
    <span class="hl-tag">&lt;cors /&gt;</span>
    ...
<span class="hl-tag">&lt;/http&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="headers" href="#headers"></a>10.8&nbsp;Security HTTP Response Headers</h2></div></div></div>

<p>This section discusses Spring Security&#8217;s support for adding various security headers to the response.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="default-security-headers" href="#default-security-headers"></a>10.8.1&nbsp;Default Security Headers</h3></div></div></div>

<p>Spring Security allows users to easily inject the default security headers to assist in protecting their application.
The default for Spring Security is to include the following headers:</p>
<pre class="programlisting">Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Strict-Transport-Security is only added on HTTPS requests</p>
</td></tr></table></div>
<p>For additional details on each of these headers, refer to the corresponding sections:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="web-app-security.html#headers-cache-control" title="Cache Control">Cache Control</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#headers-content-type-options" title="Content Type Options">Content Type Options</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#headers-hsts" title="HTTP Strict Transport Security (HSTS)">HTTP Strict Transport Security</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#headers-frame-options" title="X-Frame-Options">X-Frame-Options</a>
</li><li class="listitem">
<a class="link" href="web-app-security.html#headers-xss-protection" title="X-XSS-Protection">X-XSS-Protection</a>
</li></ul></div>
<p>While each of these headers are considered best practice, it should be noted that not all clients utilize the headers, so additional testing is encouraged.</p>
<p>You can customize specific headers.
For example, assume that want your HTTP response headers to look like the following:</p>
<pre class="programlisting">Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block</pre>
<p>Specifically, you want all of the default headers with the following customizations:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="web-app-security.html#headers-frame-options" title="X-Frame-Options">X-Frame-Options</a> to allow any request from same domain
</li><li class="listitem">
<a class="link" href="web-app-security.html#headers-hsts" title="HTTP Strict Transport Security (HSTS)">HTTP Strict Transport Security (HSTS)</a> will not be addded to the response
</li></ul></div>
<p>You can easily do this with the following Java Configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
        WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
        http
            <span class="hl-comment">// ...</span>
            .headers()
                .frameOptions().sameOrigin()
                .httpStrictTransportSecurity().disable();
    }
}</pre>
<p>Alternatively, if you are using Spring Security XML Configuration, you can use the following:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;frame-options</span> <span class="hl-attribute">policy</span>=<span class="hl-value">"SAMEORIGIN"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;hsts</span> <span class="hl-attribute">disable</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.
An example for both Java and XML based configuration is provided below:</p>
<p>If you are using Spring Security&#8217;s Java Configuration the following will only add <a class="link" href="web-app-security.html#headers-cache-control" title="Cache Control">Cache Control</a>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        <span class="hl-comment">// do not use any default headers unless explicitly listed</span>
        .defaultsDisabled()
        .cacheControl();
}
}</pre>
<p>The following XML will only add <a class="link" href="web-app-security.html#headers-cache-control" title="Cache Control">Cache Control</a>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers</span> <span class="hl-attribute">defaults-disabled</span>=<span class="hl-value">"true"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;cache-control/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>If necessary, you can disable all of the HTTP Security response headers with the following Java Configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers().disable();
}
}</pre>
<p>If necessary, you can disable all of the HTTP Security response headers with the following XML configuration below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers</span> <span class="hl-attribute">disabled</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-cache-control" href="#headers-cache-control"></a>Cache Control</h4></div></div></div>

<p>In the past Spring Security required you to provide your own cache control for your web application.
This seemed reasonable at the time, but browser caches have evolved to include caches for secure connections as well.
This means that a user may view an authenticated page, log out, and then a malicious user can use the browser history to view the cached page.
To help mitigate this Spring Security has added cache control support which will insert the following headers into you response.</p>
<pre class="screen">Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0</pre>
<p>Simply adding the <a class="link" href="appendix.html#nsa-headers" title="<headers&gt;">&lt;headers</a>&gt; element with no child elements will automatically add Cache Control and quite a few other protections.
However, if you only want cache control, you can enable this feature using Spring Security&#8217;s XML namespace with the <a class="link" href="appendix.html#nsa-cache-control" title="<cache-control&gt;">&lt;cache-control</a>&gt; element and the <a class="link" href="appendix.html#nsa-headers-defaults-disabled">headers@defaults-disabled</a> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers</span> <span class="hl-attribute">defaults-disable</span>=<span class="hl-value">"true"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;cache-control /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can enable only cache control within Java Configuration with the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .defaultsDisabled()
        .cacheControl();
}
}</pre>
<p>If you actually want to cache specific responses, your application can selectively invoke <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)" target="_top">HttpServletResponse.setHeader(String,String)</a> to override the header set by Spring Security.
This is useful to ensure things like CSS, JavaScript, and images are properly cached.</p>
<p>When using Spring Web MVC, this is typically done within your configuration.
For example, the following configuration will ensure that the cache headers are set for all of your resources:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebMvc</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebMvcConfiguration <span class="hl-keyword">implements</span> WebMvcConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addResourceHandlers(ResourceHandlerRegistry registry) {
        registry
            .addResourceHandler(<span class="hl-string">"/resources/**"</span>)
            .addResourceLocations(<span class="hl-string">"/resources/"</span>)
            .setCachePeriod(<span class="hl-number">31556926</span>);
    }

    <span class="hl-comment">// ...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-content-type-options" href="#headers-content-type-options"></a>Content Type Options</h4></div></div></div>

<p>Historically browsers, including Internet Explorer, would try to guess the content type of a request using <a class="ulink" href="http://en.wikipedia.org/wiki/Content_sniffing" target="_top">content sniffing</a>.
This allowed browsers to improve the user experience by guessing the content type on resources that had not specified the content type.
For example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then execute it.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>There are many additional things one should do (i.e. only display the document in a distinct domain, ensure Content-Type header is set, sanitize the document, etc) when allowing content to be uploaded.
However, these measures are out of the scope of what Spring Security provides.
It is also important to point out when disabling content sniffing, you must specify the content type in order for things to work properly.</p>
</td></tr></table></div>
<p>The problem with content sniffing is that this allowed malicious users to use polyglots (i.e. a file that is valid as multiple content types) to execute XSS attacks.
For example, some sites may allow users to submit a valid postscript document to a website and view it.
A malicious user might create a <a class="ulink" href="http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf" target="_top">postscript document that is also a valid JavaScript file</a> and execute a XSS attack with it.</p>
<p>Content sniffing can be disabled by adding the following header to our response:</p>
<pre class="screen">X-Content-Type-Options: nosniff</pre>
<p>Just as with the cache control element, the nosniff directive is added by default when using the &lt;headers&gt; element with no child elements.
However, if you want more control over which headers are added you can use the <a class="link" href="appendix.html#nsa-content-type-options" title="<content-type-options&gt;">&lt;content-type-options</a>&gt; element and the <a class="link" href="appendix.html#nsa-headers-defaults-disabled">headers@defaults-disabled</a> attribute as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers</span> <span class="hl-attribute">defaults-disabled</span>=<span class="hl-value">"true"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;content-type-options /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>The X-Content-Type-Options header is added by default with Spring Security Java configuration.
If you want more control over the headers, you can explicitly specify the content type options with the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .defaultsDisabled()
        .contentTypeOptions();
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-hsts" href="#headers-hsts"></a>HTTP Strict Transport Security (HSTS)</h4></div></div></div>

<p>When you type in your bank&#8217;s website, do you enter mybank.example.com or do you enter <a class="ulink" href="https://mybank.example.com" target="_top">https://mybank.example.com</a>? If you omit the https protocol, you are potentially vulnerable to <a class="ulink" href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_top">Man in the Middle attacks</a>.
Even if the website performs a redirect to <a class="ulink" href="https://mybank.example.com" target="_top">https://mybank.example.com</a> a malicious user could intercept the initial HTTP request and manipulate the response (i.e. redirect to <a class="ulink" href="https://mibank.example.com" target="_top">https://mibank.example.com</a> and steal their credentials).</p>
<p>Many users omit the https protocol and this is why <a class="ulink" href="http://tools.ietf.org/html/rfc6797" target="_top">HTTP Strict Transport Security (HSTS)</a> was created.
Once mybank.example.com is added as a <a class="ulink" href="http://tools.ietf.org/html/rfc6797#section-5.1" target="_top">HSTS host</a>, a browser can know ahead of time that any request to mybank.example.com should be interpreted as <a class="ulink" href="https://mybank.example.com" target="_top">https://mybank.example.com</a>.
This greatly reduces the possibility of a Man in the Middle attack occurring.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>In accordance with <a class="ulink" href="http://tools.ietf.org/html/rfc6797#section-7.2" target="_top">RFC6797</a>, the HSTS header is only injected into HTTPS responses.
In order for the browser to acknowledge the header, the browser must first trust the CA that signed the SSL certificate used to make the connection (not just the SSL certificate).</p>
</td></tr></table></div>
<p>One way for a site to be marked as a HSTS host is to have the host preloaded into the browser.
Another is to add the "Strict-Transport-Security" header to the response.
For example the following would instruct the browser to treat the domain as an HSTS host for a year (there are approximately 31536000 seconds in a year):</p>
<pre class="screen">Strict-Transport-Security: max-age=31536000 ; includeSubDomains</pre>
<p>The optional includeSubDomains directive instructs Spring Security that subdomains (i.e. secure.mybank.example.com) should also be treated as an HSTS domain.</p>
<p>As with the other headers, Spring Security adds HSTS by default.
You can customize HSTS headers with the <a class="link" href="appendix.html#nsa-hsts" title="<hsts&gt;">&lt;hsts</a>&gt; element as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;hsts</span>
            <span class="hl-attribute">include-subdomains</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">max-age-seconds</span>=<span class="hl-value">"31536000"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can enable only HSTS headers with Java Configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .httpStrictTransportSecurity()
            .includeSubdomains(true)
            .maxAgeSeconds(<span class="hl-number">31536000</span>);
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-hpkp" href="#headers-hpkp"></a>HTTP Public Key Pinning (HPKP)</h4></div></div></div>

<p>HTTP Public Key Pinning (HPKP) is a security feature that tells a web client to associate a specific cryptographic public key with a certain web server to prevent Man in the Middle (MITM) attacks with forged certificates.</p>
<p>To ensure the authenticity of a server&#8217;s public key used in TLS sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (CA).
Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names.
If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections.
HPKP can circumvent this threat for the HTTPS protocol by telling the client which public key belongs to a certain web server.
HPKP is a Trust on First Use (TOFU) technique.
The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time.
When the client visits the server again, it expects a certificate containing a public key whose fingerprint is already known via HPKP.
If the server delivers an unknown public key, the client should present a warning to the user.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Because the user-agent needs to validate the pins against the SSL certificate chain, the HPKP header is only injected into HTTPS responses.</p>
</td></tr></table></div>
<p>Enabling this feature for your site is as simple as returning the Public-Key-Pins HTTP header when your site is accessed over HTTPS.
For example, the following would instruct the user-agent to only report pin validation failures to a given URI (via the <a class="ulink" href="https://tools.ietf.org/html/rfc7469#section-2.1.4" target="_top"><span class="strong"><strong><span class="emphasis"><em>report-uri</em></span></strong></span></a> directive) for 2 pins:</p>
<pre class="screen">Public-Key-Pins-Report-Only: max-age=5184000 ; pin-sha256="d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" ; pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" ; report-uri="http://example.net/pkp-report" ; includeSubDomains</pre>
<p>A <a class="ulink" href="https://tools.ietf.org/html/rfc7469#section-3" target="_top"><span class="strong"><strong><span class="emphasis"><em>pin validation failure report</em></span></strong></span></a> is a standard JSON structure that can be captured either by the web application&#8217;s own API or by a publicly hosted HPKP reporting service, such as, <a class="ulink" href="https://report-uri.io/" target="_top"><span class="strong"><strong><span class="emphasis"><em>REPORT-URI</em></span></strong></span></a>.</p>
<p>The optional includeSubDomains directive instructs the browser to also validate subdomains with the given pins.</p>
<p>Opposed to the other headers, Spring Security does not add HPKP by default.
You can customize HPKP headers with the <a class="link" href="appendix.html#nsa-hpkp" title="<hpkp&gt;">&lt;hpkp</a>&gt; element as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;hpkp</span>
            <span class="hl-attribute">include-subdomains</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">report-uri</span>=<span class="hl-value">"http://example.net/pkp-report"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;pins&gt;</span>
                    <span class="hl-tag">&lt;pin</span> <span class="hl-attribute">algorithm</span>=<span class="hl-value">"sha256"</span><span class="hl-tag">&gt;</span>d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=<span class="hl-tag">&lt;/pin&gt;</span>
                    <span class="hl-tag">&lt;pin</span> <span class="hl-attribute">algorithm</span>=<span class="hl-value">"sha256"</span><span class="hl-tag">&gt;</span>E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=<span class="hl-tag">&lt;/pin&gt;</span>
            <span class="hl-tag">&lt;/pins&gt;</span>
        <span class="hl-tag">&lt;/hpkp&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can enable HPKP headers with Java Configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
                http
                <span class="hl-comment">// ...</span>
                .headers()
                        .httpPublicKeyPinning()
                                .includeSubdomains(true)
                                .reportUri(<span class="hl-string">"http://example.net/pkp-report"</span>)
                                .addSha256Pins(<span class="hl-string">"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM="</span>, <span class="hl-string">"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g="</span>;
        }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-frame-options" href="#headers-frame-options"></a>X-Frame-Options</h4></div></div></div>

<p>Allowing your website to be added to a frame can be a security issue.
For example, using clever CSS styling users could be tricked into clicking on something that they were not intending (<a class="ulink" href="http://www.youtube.com/watch?v=3mk0RySeNsU" target="_top">video demo</a>).
For example, a user that is logged into their bank might click a button that grants access to other users.
This sort of attack is known as <a class="ulink" href="http://en.wikipedia.org/wiki/Clickjacking" target="_top">Clickjacking</a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Another modern approach to dealing with clickjacking is to use <a class="xref" href="web-app-security.html#headers-csp" title="Content Security Policy (CSP)">the section called &#8220;Content Security Policy (CSP)&#8221;</a>.</p>
</td></tr></table></div>
<p>There are a number ways to mitigate clickjacking attacks.
For example, to protect legacy browsers from clickjacking attacks you can use <a class="ulink" href="https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script" target="_top">frame breaking code</a>.
While not perfect, the frame breaking code is the best you can do for the legacy browsers.</p>
<p>A more modern approach to address clickjacking is to use <a class="ulink" href="https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options" target="_top">X-Frame-Options</a> header:</p>
<pre class="screen">X-Frame-Options: DENY</pre>
<p>The X-Frame-Options response header instructs the browser to prevent any site with this header in the response from being rendered within a frame.
By default, Spring Security disables rendering within an iframe.</p>
<p>You can customize X-Frame-Options with the <a class="link" href="appendix.html#nsa-frame-options" title="<frame-options&gt;">frame-options</a> element.
For example, the following will instruct Spring Security to use "X-Frame-Options: SAMEORIGIN" which allows iframes within the same domain:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;frame-options</span>
        <span class="hl-attribute">policy</span>=<span class="hl-value">"SAMEORIGIN"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can customize frame options to use the same origin within Java Configuration using the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .frameOptions()
            .sameOrigin();
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-xss-protection" href="#headers-xss-protection"></a>X-XSS-Protection</h4></div></div></div>

<p>Some browsers have built in support for filtering out <a class="ulink" href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)" target="_top">reflected XSS attacks</a>.
This is by no means foolproof, but does assist in XSS protection.</p>
<p>The filtering is typically enabled by default, so adding the header typically just ensures it is enabled and instructs the browser what to do when a XSS attack is detected.
For example, the filter might try to change the content in the least invasive way to still render everything.
At times, this type of replacement can become a <a class="ulink" href="http://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/" target="_top">XSS vulnerability in itself</a>.
Instead, it is best to block the content rather than attempt to fix it.
To do this we can add the following header:</p>
<pre class="screen">X-XSS-Protection: 1; mode=block</pre>
<p>This header is included by default.
However, we can customize it if we wanted.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;xss-protection</span> <span class="hl-attribute">block</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can customize XSS protection within Java Configuration with the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .xssProtection()
            .block(false);
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-csp" href="#headers-csp"></a>Content Security Policy (CSP)</h4></div></div></div>

<p><a class="ulink" href="https://www.w3.org/TR/CSP2/" target="_top">Content Security Policy (CSP)</a> is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).
CSP is a declarative policy that provides a facility for web application authors to declare and ultimately inform the client (user-agent) about the sources from which the web application expects to load resources.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Content Security Policy is not intended to solve all content injection vulnerabilities.
Instead, CSP can be leveraged to help reduce the harm caused by content injection attacks.
As a first line of defense, web application authors should validate their input and encode their output.</p>
</td></tr></table></div>
<p>A web application may employ the use of CSP by including one of the following HTTP headers in the response:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong><span class="emphasis"><em>Content-Security-Policy</em></span></strong></span>
</li><li class="listitem">
<span class="strong"><strong><span class="emphasis"><em>Content-Security-Policy-Report-Only</em></span></strong></span>
</li></ul></div>
<p>Each of these headers are used as a mechanism to deliver a <span class="strong"><strong><span class="emphasis"><em>security policy</em></span></strong></span> to the client.
A security policy contains a set of <span class="strong"><strong><span class="emphasis"><em>security policy directives</em></span></strong></span> (for example, <span class="emphasis"><em>script-src</em></span> and <span class="emphasis"><em>object-src</em></span>), each responsible for declaring the restrictions for a particular resource representation.</p>
<p>For example, a web application can declare that it expects to load scripts from specific, trusted sources, by including the following header in the response:</p>
<pre class="screen">Content-Security-Policy: script-src https://trustedscripts.example.com</pre>
<p>An attempt to load a script from another source other than what is declared in the <span class="emphasis"><em>script-src</em></span> directive will be blocked by the user-agent.
Additionally, if the <a class="ulink" href="https://www.w3.org/TR/CSP2/#directive-report-uri" target="_top"><span class="strong"><strong><span class="emphasis"><em>report-uri</em></span></strong></span></a> directive is declared in the security policy, then the violation will be reported by the user-agent to the declared URL.</p>
<p>For example, if a web application violates the declared security policy, the following response header will instruct the user-agent to send violation reports to the URL specified in the policy&#8217;s <span class="emphasis"><em>report-uri</em></span> directive.</p>
<pre class="screen">Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/</pre>
<p><a class="ulink" href="https://www.w3.org/TR/CSP2/#violation-reports" target="_top"><span class="strong"><strong><span class="emphasis"><em>Violation reports</em></span></strong></span></a> are standard JSON structures that can be captured either by the web application&#8217;s own API or by a publicly hosted CSP violation reporting service, such as, <a class="ulink" href="https://report-uri.io/" target="_top"><span class="strong"><strong><span class="emphasis"><em>REPORT-URI</em></span></strong></span></a>.</p>
<p>The <span class="strong"><strong><span class="emphasis"><em>Content-Security-Policy-Report-Only</em></span></strong></span> header provides the capability for web application authors and administrators to monitor security policies, rather than enforce them.
This header is typically used when experimenting and/or developing security policies for a site.
When a policy is deemed effective, it can be enforced by using the <span class="emphasis"><em>Content-Security-Policy</em></span> header field instead.</p>
<p>Given the following response header, the policy declares that scripts may be loaded from one of two possible sources.</p>
<pre class="screen">Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/</pre>
<p>If the site violates this policy, by attempting to load a script from <span class="emphasis"><em>evil.com</em></span>, the user-agent will send a violation report to the declared URL specified by the <span class="emphasis"><em>report-uri</em></span> directive, but still allow the violating resource to load nevertheless.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="headers-csp-configure" href="#headers-csp-configure"></a>Configuring Content Security Policy</h5></div></div></div>

<p>It&#8217;s important to note that Spring Security <span class="strong"><strong><span class="emphasis"><em>does not add</em></span></strong></span> Content Security Policy by default.
The web application author must declare the security policy(s) to enforce and/or monitor for the protected resources.</p>
<p>For example, given the following security policy:</p>
<pre class="screen">script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</pre>
<p>You can enable the CSP header using XML configuration with the <a class="link" href="appendix.html#nsa-content-security-policy" title="<content-security-policy&gt;">&lt;content-security-policy</a>&gt; element as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;content-security-policy</span>
            <span class="hl-attribute">policy-directives</span>=<span class="hl-value">"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>To enable the CSP <span class="emphasis"><em>'report-only'</em></span> header, configure the element as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;content-security-policy</span>
            <span class="hl-attribute">policy-directives</span>=<span class="hl-value">"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"</span>
            <span class="hl-attribute">report-only</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can enable the CSP header using Java configuration as shown below:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .contentSecurityPolicy(<span class="hl-string">"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"</span>);
}
}</pre>
<p>To enable the CSP <span class="emphasis"><em>'report-only'</em></span> header, provide the following Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .contentSecurityPolicy(<span class="hl-string">"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"</span>)
        .reportOnly();
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="headers-csp-links" href="#headers-csp-links"></a>Additional Resources</h5></div></div></div>

<p>Applying Content Security Policy to a web application is often a non-trivial undertaking.
The following resources may provide further assistance in developing effective security policies for your site.</p>
<p><a class="ulink" href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/" target="_top">An Introduction to Content Security Policy</a></p>
<p><a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP" target="_top">CSP Guide - Mozilla Developer Network</a></p>
<p><a class="ulink" href="https://www.w3.org/TR/CSP2/" target="_top">W3C Candidate Recommendation</a></p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-referrer" href="#headers-referrer"></a>Referrer Policy</h4></div></div></div>

<p><a class="ulink" href="https://www.w3.org/TR/referrer-policy" target="_top">Referrer Policy</a> is a mechanism that web applications can leverage to manage the referrer field, which contains the last
page the user was on.</p>
<p>Spring Security&#8217;s approach is to use <a class="ulink" href="https://www.w3.org/TR/referrer-policy/" target="_top">Referrer Policy</a> header, which provides different <a class="ulink" href="https://www.w3.org/TR/referrer-policy/#referrer-policies" target="_top">policies</a>:</p>
<pre class="screen">Referrer-Policy: same-origin</pre>
<p>The Referrer-Policy response header instructs the browser to let the destination knows the source where the user was previously.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="headers-referrer-configure" href="#headers-referrer-configure"></a>Configuring Referrer Policy</h5></div></div></div>

<p>Spring Security <span class="strong"><strong><span class="emphasis"><em>doesn&#8217;t add</em></span></strong></span> Referrer Policy header by default.</p>
<p>You can enable the Referrer-Policy header using XML configuration with the <a class="link" href="appendix.html#nsa-referrer-policy" title="<referrer-policy&gt;">&lt;referrer-policy</a>&gt; element as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;referrer-policy</span> <span class="hl-attribute">policy</span>=<span class="hl-value">"same-origin"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can enable the Referrer Policy header using Java configuration as shown below:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .referrerPolicy(ReferrerPolicy.SAME_ORIGIN);
}
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-feature" href="#headers-feature"></a>Feature Policy</h4></div></div></div>

<p><a class="ulink" href="https://wicg.github.io/feature-policy/" target="_top">Feature Policy</a> is a mechanism that allows web developers to selectively enable, disable, and modify the behavior of certain APIs and web features in the browser.</p>
<pre class="screen">Feature-Policy: geolocation 'self'</pre>
<p>With Feature Policy, developers can opt-in to a set of "policies" for the browser to enforce on specific features used throughout your site.
These policies restrict what APIs the site can access or modify the browser&#8217;s default behavior for certain features.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="headers-feature-configure" href="#headers-feature-configure"></a>Configuring Feature Policy</h5></div></div></div>

<p>Spring Security <span class="strong"><strong><span class="emphasis"><em>doesn&#8217;t add</em></span></strong></span> Feature Policy header by default.</p>
<p>You can enable the Feature-Policy header using XML configuration with the <a class="link" href="appendix.html#nsa-feature-policy" title="<feature-policy&gt;">&lt;feature-policy</a>&gt; element as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;feature-policy</span> <span class="hl-attribute">policy-directives</span>=<span class="hl-value">"geolocation 'self'"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can enable the Feature Policy header using Java configuration as shown below:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .featurePolicy(<span class="hl-string">"geolocation 'self'"</span>);
}
}</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="headers-custom" href="#headers-custom"></a>10.8.2&nbsp;Custom Headers</h3></div></div></div>

<p>Spring Security has mechanisms to make it convenient to add the more common security headers to your application.
However, it also provides hooks to enable adding custom headers.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-static" href="#headers-static"></a>Static Headers</h4></div></div></div>

<p>There may be times you wish to inject custom security headers into your application that are not supported out of the box.
For example, given the following custom security header:</p>
<pre class="screen">X-Custom-Security-Header: header-value</pre>
<p>When using the XML namespace, these headers can be added to the response using the <a class="link" href="appendix.html#nsa-header" title="<header&gt;">&lt;header</a>&gt; element as shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"X-Custom-Security-Header"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"header-value"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, the headers could be added to the response using Java Configuration as shown in the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .addHeaderWriter(<span class="hl-keyword">new</span> StaticHeadersWriter(<span class="hl-string">"X-Custom-Security-Header"</span>,<span class="hl-string">"header-value"</span>));
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-writer" href="#headers-writer"></a>Headers Writer</h4></div></div></div>

<p>When the namespace or Java configuration does not support the headers you want, you can create a custom <code class="literal">HeadersWriter</code> instance or even provide a custom implementation of the <code class="literal">HeadersWriter</code>.</p>
<p>Let&#8217;s take a look at an example of using an custom instance of <code class="literal">XFrameOptionsHeaderWriter</code>.
Perhaps you want to allow framing of content for the same origin.
This is easily supported by setting the <a class="link" href="appendix.html#nsa-frame-options-policy">policy</a> attribute to "SAMEORIGIN", but let&#8217;s take a look at a more explicit example using the <a class="link" href="appendix.html#nsa-header-ref">ref</a> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;header</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"frameOptionsWriter"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span>
<span class="hl-comment">&lt;!-- Requires the c-namespace.
See http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
--&gt;</span>
<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"frameOptionsWriter"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"</span>
    <span class="hl-attribute">c:frameOptionsMode</span>=<span class="hl-value">"SAMEORIGIN"</span><span class="hl-tag">/&gt;</span></pre>
<p>We could also restrict framing of content to the same origin with Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .addHeaderWriter(<span class="hl-keyword">new</span> XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN));
}
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="headers-delegatingrequestmatcherheaderwriter" href="#headers-delegatingrequestmatcherheaderwriter"></a>DelegatingRequestMatcherHeaderWriter</h4></div></div></div>

<p>At times you may want to only write a header for certain requests.
For example, perhaps you want to only protect your log in page from being framed.
You could use the <code class="literal">DelegatingRequestMatcherHeaderWriter</code> to do so.
When using the XML namespace configuration, this can be done with the following:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;frame-options</span> <span class="hl-attribute">disabled</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;header</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"headerWriter"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"headerWriter"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.util.matcher.AntPathRequestMatcher"</span>
            <span class="hl-attribute">c:pattern</span>=<span class="hl-value">"/login"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/beans:constructor-arg&gt;</span>
    <span class="hl-tag">&lt;beans:constructor-arg&gt;</span>
        <span class="hl-tag">&lt;beans:bean</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/beans:constructor-arg&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span></pre>
<p>We could also prevent framing of content to the log in page using java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
WebSecurityConfigurerAdapter {

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    RequestMatcher matcher = <span class="hl-keyword">new</span> AntPathRequestMatcher(<span class="hl-string">"/login"</span>);
    DelegatingRequestMatcherHeaderWriter headerWriter =
        <span class="hl-keyword">new</span> DelegatingRequestMatcherHeaderWriter(matcher,<span class="hl-keyword">new</span> XFrameOptionsHeaderWriter());
    http
    <span class="hl-comment">// ...</span>
    .headers()
        .frameOptions().disabled()
        .addHeaderWriter(headerWriter);
}
}</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="session-mgmt" href="#session-mgmt"></a>10.9&nbsp;Session Management</h2></div></div></div>

<p>HTTP session related functionality is handled by a combination of the <code class="literal">SessionManagementFilter</code> and the <code class="literal">SessionAuthenticationStrategy</code> interface, which the filter delegates to.
Typical usage includes session-fixation protection attack prevention, detection of session timeouts and restrictions on how many sessions an authenticated user may have open concurrently.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sessionmanagementfilter" href="#sessionmanagementfilter"></a>10.9.1&nbsp;SessionManagementFilter</h3></div></div></div>

<p>The <code class="literal">SessionManagementFilter</code> checks the contents of the <code class="literal">SecurityContextRepository</code> against the current contents of the <code class="literal">SecurityContextHolder</code> to determine whether a user has been authenticated during the current request, typically by a non-interactive authentication mechanism, such as pre-authentication or remember-me  <a href="#ftn.d5e4709" class="footnote" name="d5e4709"><sup class="footnote">[17]</sup></a>.
If the repository contains a security context, the filter does nothing.
If it doesn&#8217;t, and the thread-local <code class="literal">SecurityContext</code> contains a (non-anonymous) <code class="literal">Authentication</code> object, the filter assumes they have been authenticated by a previous filter in the stack.
It will then invoke the configured <code class="literal">SessionAuthenticationStrategy</code>.</p>
<p>If the user is not currently authenticated, the filter will check whether an invalid session ID has been requested (because of a timeout, for example) and will invoke the configured <code class="literal">InvalidSessionStrategy</code>, if one is set.
The most common behaviour is just to redirect to a fixed URL and this is encapsulated in the standard implementation <code class="literal">SimpleRedirectInvalidSessionStrategy</code>.
The latter is also used when configuring an invalid session URL through the namespace,<a class="link" href="ns-config.html#ns-session-mgmt" title="7.3.3&nbsp;Session Management">as described earlier</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sessionauthenticationstrategy" href="#sessionauthenticationstrategy"></a>10.9.2&nbsp;SessionAuthenticationStrategy</h3></div></div></div>

<p><code class="literal">SessionAuthenticationStrategy</code> is used by both <code class="literal">SessionManagementFilter</code> and <code class="literal">AbstractAuthenticationProcessingFilter</code>, so if you are using a customized form-login class, for example, you will need to inject it into both of these.
In this case, a typical configuration, combining the namespace and custom beans might look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
<span class="hl-tag">&lt;custom-filter</span> <span class="hl-attribute">position</span>=<span class="hl-value">"FORM_LOGIN_FILTER"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myAuthFilter"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;session-management</span> <span class="hl-attribute">session-authentication-strategy-ref</span>=<span class="hl-value">"sas"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAuthFilter"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionAuthenticationStrategy"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sas"</span><span class="hl-tag"> /&gt;</span>
    ...
<span class="hl-tag">&lt;/beans:bean&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sas"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"</span><span class="hl-tag"> /&gt;</span></pre>
<p>Note that the use of the default, <code class="literal">SessionFixationProtectionStrategy</code> may cause issues if you are storing beans in the session which implement <code class="literal">HttpSessionBindingListener</code>, including Spring session-scoped beans.
See the Javadoc for this class for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="concurrent-sessions" href="#concurrent-sessions"></a>10.9.3&nbsp;Concurrency Control</h3></div></div></div>

<p>Spring Security is able to prevent a principal from concurrently authenticating to the same application more than a specified number of times.
Many ISVs take advantage of this to enforce licensing, whilst network administrators like this feature because it helps prevent people from sharing login names.
You can, for example, stop user "Batman" from logging onto the web application from two different sessions.
You can either expire their previous login or you can report an error when they try to log in again, preventing the second login.
Note that if you are using the second approach, a user who has not explicitly logged out (but who has just closed their browser, for example) will not be able to log in again until their original session expires.</p>
<p>Concurrency control is supported by the namespace, so please check the earlier namespace chapter for the simplest configuration.
Sometimes you need to customize things though.</p>
<p>The implementation uses a specialized version of <code class="literal">SessionAuthenticationStrategy</code>, called <code class="literal">ConcurrentSessionControlAuthenticationStrategy</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Previously the concurrent authentication check was made by the <code class="literal">ProviderManager</code>, which could be injected with a <code class="literal">ConcurrentSessionController</code>.
The latter would check if the user was attempting to exceed the number of permitted sessions.
However, this approach required that an HTTP session be created in advance, which is undesirable.
In Spring Security 3, the user is first authenticated by the <code class="literal">AuthenticationManager</code> and once they are successfully authenticated, a session is created and the check is made whether they are allowed to have another session open.</p>
</td></tr></table></div>
<p>To use concurrent session support, you&#8217;ll need to add the following to <code class="literal">web.xml</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;listener&gt;</span>
    <span class="hl-tag">&lt;listener-class&gt;</span>
    org.springframework.security.web.session.HttpSessionEventPublisher
    <span class="hl-tag">&lt;/listener-class&gt;</span>
<span class="hl-tag">&lt;/listener&gt;</span></pre>
<p>In addition, you will need to add the <code class="literal">ConcurrentSessionFilter</code> to your <code class="literal">FilterChainProxy</code>.
The <code class="literal">ConcurrentSessionFilter</code> requires two constructor arguments, <code class="literal">sessionRegistry</code>, which generally points to an instance of <code class="literal">SessionRegistryImpl</code>, and <code class="literal">sessionInformationExpiredStrategy</code>, which defines the strategy to apply when a session has expired.
A configuration using the namespace to create the <code class="literal">FilterChainProxy</code> and other default beans might look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
<span class="hl-tag">&lt;custom-filter</span> <span class="hl-attribute">position</span>=<span class="hl-value">"CONCURRENT_SESSION_FILTER"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"concurrencyFilter"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;custom-filter</span> <span class="hl-attribute">position</span>=<span class="hl-value">"FORM_LOGIN_FILTER"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myAuthFilter"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;session-management</span> <span class="hl-attribute">session-authentication-strategy-ref</span>=<span class="hl-value">"sas"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redirectSessionInformationExpiredStrategy"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.session.SimpleRedirectSessionInformationExpiredStrategy"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;beans:constructor-arg</span> <span class="hl-attribute">name</span>=<span class="hl-value">"invalidSessionUrl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/session-expired.htm"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"concurrencyFilter"</span>
<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.session.ConcurrentSessionFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;beans:constructor-arg</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionRegistry"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionRegistry"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;beans:constructor-arg</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionInformationExpiredStrategy"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"redirectSessionInformationExpiredStrategy"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myAuthFilter"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionAuthenticationStrategy"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sas"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sas"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.session.CompositeSessionAuthenticationStrategy"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;beans:constructor-arg&gt;</span>
    <span class="hl-tag">&lt;beans:list&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;beans:constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionRegistry"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maximumSessions"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"exceptionIfMaximumExceeded"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/beans:bean&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;/beans:bean&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;beans:constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionRegistry"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/beans:bean&gt;</span>
    <span class="hl-tag">&lt;/beans:list&gt;</span>
<span class="hl-tag">&lt;/beans:constructor-arg&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sessionRegistry"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.core.session.SessionRegistryImpl"</span><span class="hl-tag"> /&gt;</span></pre>
<p>Adding the listener to <code class="literal">web.xml</code> causes an <code class="literal">ApplicationEvent</code> to be published to the Spring <code class="literal">ApplicationContext</code> every time a <code class="literal">HttpSession</code> commences or terminates.
This is critical, as it allows the <code class="literal">SessionRegistryImpl</code> to be notified when a session ends.
Without it, a user will never be able to log back in again once they have exceeded their session allowance, even if they log out of another session or it times out.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="list-authenticated-principals" href="#list-authenticated-principals"></a>Querying the SessionRegistry for currently authenticated users and their sessions</h4></div></div></div>

<p>Setting up concurrency-control, either through the namespace or using plain beans has the useful side effect of providing you with a reference to the <code class="literal">SessionRegistry</code> which you can use directly within your application, so even if you don&#8217;t want to restrict the number of sessions a user may have, it may be worth setting up the infrastructure anyway.
You can set the <code class="literal">maximumSession</code> property to -1 to allow unlimited sessions.
If you&#8217;re using the namespace, you can set an alias for the internally-created <code class="literal">SessionRegistry</code> using the <code class="literal">session-registry-alias</code> attribute, providing a reference which you can inject into your own beans.</p>
<p>The <code class="literal">getAllPrincipals()</code> method supplies you with a list of the currently authenticated users.
You can list a user&#8217;s sessions by calling the <code class="literal">getAllSessions(Object principal, boolean includeExpiredSessions)</code> method, which returns a list of <code class="literal">SessionInformation</code> objects.
You can also expire a user&#8217;s session by calling <code class="literal">expireNow()</code> on a <code class="literal">SessionInformation</code> instance.
When the user returns to the application, they will be prevented from proceeding.
You may find these methods useful in an administration application, for example.
Have a look at the Javadoc for more information.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anonymous" href="#anonymous"></a>10.10&nbsp;Anonymous Authentication</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="anonymous-overview" href="#anonymous-overview"></a>10.10.1&nbsp;Overview</h3></div></div></div>

<p>It&#8217;s generally considered good security practice to adopt a "deny-by-default" where you explicitly specify what is allowed and disallow everything else.
Defining what is accessible to unauthenticated users is a similar situation, particularly for web applications.
Many sites require that users must be authenticated for anything other than a few URLs (for example the home and login pages).
In this case it is easiest to define access configuration attributes for these specific URLs rather than have for every secured resource.
Put differently, sometimes it is nice to say <code class="literal">ROLE_SOMETHING</code> is required by default and only allow certain exceptions to this rule, such as for login, logout and home pages of an application.
You could also omit these pages from the filter chain entirely, thus bypassing the access control checks, but this may be undesirable for other reasons, particularly if the pages behave differently for authenticated users.</p>
<p>This is what we mean by anonymous authentication.
Note that there is no real conceptual difference between a user who is "anonymously authenticated" and an unauthenticated user.
Spring Security&#8217;s anonymous authentication just gives you a more convenient way to configure your access-control attributes.
Calls to servlet API calls such as <code class="literal">getCallerPrincipal</code>, for example, will still return null even though there is actually an anonymous authentication object in the <code class="literal">SecurityContextHolder</code>.</p>
<p>There are other situations where anonymous authentication is useful, such as when an auditing interceptor queries the <code class="literal">SecurityContextHolder</code> to identify which principal was responsible for a given operation.
Classes can be authored more robustly if they know the <code class="literal">SecurityContextHolder</code> always contains an <code class="literal">Authentication</code> object, and never <code class="literal">null</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="anonymous-config" href="#anonymous-config"></a>10.10.2&nbsp;Configuration</h3></div></div></div>

<p>Anonymous authentication support is provided automatically when using the HTTP configuration Spring Security 3.0 and can be customized (or disabled) using the <code class="literal">&lt;anonymous&gt;</code> element.
You don&#8217;t need to configure the beans described here unless you are using traditional bean configuration.</p>
<p>Three classes that together provide the anonymous authentication feature.
<code class="literal">AnonymousAuthenticationToken</code> is an implementation of <code class="literal">Authentication</code>, and stores the <code class="literal">GrantedAuthority</code> s which apply to the anonymous principal.
There is a corresponding <code class="literal">AnonymousAuthenticationProvider</code>, which is chained into the <code class="literal">ProviderManager</code> so that <code class="literal">AnonymousAuthenticationToken</code> s are accepted.
Finally, there is an <code class="literal">AnonymousAuthenticationFilter</code>, which is chained after the normal authentication mechanisms and automatically adds an <code class="literal">AnonymousAuthenticationToken</code> to the <code class="literal">SecurityContextHolder</code> if there is no existing <code class="literal">Authentication</code> held there.
The definition of the filter and authentication provider appears as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"anonymousAuthFilter"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.authentication.AnonymousAuthenticationFilter"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foobar"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userAttribute"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"anonymousUser,ROLE_ANONYMOUS"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"anonymousAuthenticationProvider"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.authentication.AnonymousAuthenticationProvider"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foobar"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The <code class="literal">key</code> is shared between the filter and authentication provider, so that tokens created by the former are accepted by the latter <a href="#ftn.d5e4804" class="footnote" name="d5e4804"><sup class="footnote">[18]</sup></a>.
The <code class="literal">userAttribute</code> is expressed in the form of <code class="literal">usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]</code>.
This is the same syntax as used after the equals sign for the <code class="literal">userMap</code> property of <code class="literal">InMemoryDaoImpl</code>.</p>
<p>As explained earlier, the benefit of anonymous authentication is that all URI patterns can have security applied to them.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filterSecurityInterceptor"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.access.intercept.FilterSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpRequestAccessDecisionManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadata"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;security:filter-security-metadata-source&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/index.jsp'</span> <span class="hl-attribute">access</span>=<span class="hl-value">'ROLE_ANONYMOUS,ROLE_USER'</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/hello.htm'</span> <span class="hl-attribute">access</span>=<span class="hl-value">'ROLE_ANONYMOUS,ROLE_USER'</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/logoff.jsp'</span> <span class="hl-attribute">access</span>=<span class="hl-value">'ROLE_ANONYMOUS,ROLE_USER'</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/login.jsp'</span> <span class="hl-attribute">access</span>=<span class="hl-value">'ROLE_ANONYMOUS,ROLE_USER'</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">'/**'</span> <span class="hl-attribute">access</span>=<span class="hl-value">'ROLE_USER'</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/security:filter-security-metadata-source&gt;</span>" +
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="anonymous-auth-trust-resolver" href="#anonymous-auth-trust-resolver"></a>10.10.3&nbsp;AuthenticationTrustResolver</h3></div></div></div>

<p>Rounding out the anonymous authentication discussion is the <code class="literal">AuthenticationTrustResolver</code> interface, with its corresponding <code class="literal">AuthenticationTrustResolverImpl</code> implementation.
This interface provides an <code class="literal">isAnonymous(Authentication)</code> method, which allows interested classes to take into account this special type of authentication status.
The <code class="literal">ExceptionTranslationFilter</code> uses this interface in processing <code class="literal">AccessDeniedException</code> s.
If an <code class="literal">AccessDeniedException</code> is thrown, and the authentication is of an anonymous type, instead of throwing a 403 (forbidden) response, the filter will instead commence the <code class="literal">AuthenticationEntryPoint</code> so the principal can authenticate properly.
This is a necessary distinction, otherwise principals would always be deemed "authenticated" and never be given an opportunity to login via form, basic, digest or some other normal authentication mechanism.</p>
<p>You will often see the <code class="literal">ROLE_ANONYMOUS</code> attribute in the above interceptor configuration replaced with <code class="literal">IS_AUTHENTICATED_ANONYMOUSLY</code>, which is effectively the same thing when defining access controls.
This is an example of the use of the <code class="literal">AuthenticatedVoter</code> which we will see in the <a class="link" href="authorization.html#authz-authenticated-voter" title="AuthenticatedVoter">authorization chapter</a>.
It uses an <code class="literal">AuthenticationTrustResolver</code> to process this particular configuration attribute and grant access to anonymous users.
The <code class="literal">AuthenticatedVoter</code> approach is more powerful, since it allows you to differentiate between anonymous, remember-me and fully-authenticated users.
If you don&#8217;t need this functionality though, then you can stick with <code class="literal">ROLE_ANONYMOUS</code>, which will be processed by Spring Security&#8217;s standard <code class="literal">RoleVoter</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="websocket" href="#websocket"></a>10.11&nbsp;WebSocket Security</h2></div></div></div>

<p>Spring Security 4 added support for securing <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html" target="_top">Spring&#8217;s WebSocket support</a>.
This section describes how to use Spring Security&#8217;s WebSocket support.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>You can find a complete working sample of WebSocket security at <a class="ulink" href="https://github.com/spring-projects/spring-session/tree/master/samples/boot/websocket" target="_top">https://github.com/spring-projects/spring-session/tree/master/samples/boot/websocket</a>.</p>
</td></tr></table></div>
<div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>Direct JSR-356 Support</b></p></div></div></div>

<p>Spring Security does not provide direct JSR-356 support because doing so would provide little value.
This is because the format is unknown, so there is <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol" target="_top">little Spring can do to secure an unknown format</a>.
Additionally, JSR-356 does not provide a way to intercept messages, so security would be rather invasive.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="websocket-configuration" href="#websocket-configuration"></a>10.11.1&nbsp;WebSocket Configuration</h3></div></div></div>

<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code class="literal">AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code class="literal">MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSocketSecurityConfig
      <span class="hl-keyword">extends</span> AbstractSecurityWebSocketMessageBrokerConfigurer { <a name="CO14-1" href="#CO14-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span> <a name="CO14-2" href="#CO14-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .simpDestMatchers(<span class="hl-string">"/user/*"</span>).authenticated() <a name="CO14-3" href="#CO14-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    }
}</pre>
<p>This will ensure that:</p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any inbound CONNECT message requires a valid CSRF token to enforce <a class="link" href="web-app-security.html#websocket-sameorigin" title="10.11.4&nbsp;Enforcing Same Origin Policy">Same Origin Policy</a></p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a class="xref" href="web-app-security.html#websocket-authorization" title="10.11.3&nbsp;WebSocket Authorization">Section&nbsp;10.11.3, &#8220;WebSocket Authorization&#8221;</a></p>
</td></tr></table></div>
<p>Spring Security also provides <a class="link" href="appendix.html#nsa-websocket-security" title="15.2.2&nbsp;WebSocket Security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
<pre class="programlisting"><span class="hl-tag">&lt;websocket-message-broker&gt;</span> <a name="CO15-1" href="#CO15-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span> <a name="CO15-2" href="#CO15-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    <a name="CO15-3" href="#CO15-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/user/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('USER')"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/websocket-message-broker&gt;</span></pre>
<p>This will ensure that:</p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any inbound CONNECT message requires a valid CSRF token to enforce <a class="link" href="web-app-security.html#websocket-sameorigin" title="10.11.4&nbsp;Enforcing Same Origin Policy">Same Origin Policy</a></p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Our messages require the proper authorization. Specifically, any inbound message that starts with "/user/" will require ROLE_USER. Additional details on authorization can be found in <a class="xref" href="web-app-security.html#websocket-authorization" title="10.11.3&nbsp;WebSocket Authorization">Section&nbsp;10.11.3, &#8220;WebSocket Authorization&#8221;</a></p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="websocket-authentication" href="#websocket-authentication"></a>10.11.2&nbsp;WebSocket Authentication</h3></div></div></div>

<p>WebSockets reuse the same authentication information that is found in the HTTP request when the WebSocket connection was made.
This means that the <code class="literal">Principal</code> on the <code class="literal">HttpServletRequest</code> will be handed off to WebSockets.
If you are using Spring Security, the <code class="literal">Principal</code> on the <code class="literal">HttpServletRequest</code> is overridden automatically.</p>
<p>More concretely, to ensure a user has authenticated to your WebSocket application, all that is necessary is to ensure that you setup Spring Security to authenticate your HTTP based web application.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="websocket-authorization" href="#websocket-authorization"></a>10.11.3&nbsp;WebSocket Authorization</h3></div></div></div>

<p>Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.
To configure authorization using Java Configuration, simply extend the <code class="literal">AbstractSecurityWebSocketMessageBrokerConfigurer</code> and configure the <code class="literal">MessageSecurityMetadataSourceRegistry</code>.
For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSocketSecurityConfig <span class="hl-keyword">extends</span> AbstractSecurityWebSocketMessageBrokerConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .nullDestMatcher().authenticated() <a name="CO16-1" href="#CO16-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                .simpSubscribeDestMatchers(<span class="hl-string">"/user/queue/errors"</span>).permitAll() <a name="CO16-2" href="#CO16-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                .simpDestMatchers(<span class="hl-string">"/app/**"</span>).hasRole(<span class="hl-string">"USER"</span>) <a name="CO16-3" href="#CO16-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
                .simpSubscribeDestMatchers(<span class="hl-string">"/user/**"</span>, <span class="hl-string">"/topic/friends/*"</span>).hasRole(<span class="hl-string">"USER"</span>) <a name="CO16-4" href="#CO16-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
                .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() <a name="CO16-5" href="#CO16-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
                .anyMessage().denyAll(); <a name="CO16-6" href="#CO16-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>

    }
}</pre>
<p>This will ensure that:</p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any message without a destination (i.e. anything other than Message type of MESSAGE or SUBSCRIBE) will require the user to be authenticated</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Anyone can subscribe to /user/queue/errors</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any other Message is rejected. This is a good idea to ensure that you do not miss any messages.</p>
</td></tr></table></div>
<p>Spring Security also provides <a class="link" href="appendix.html#nsa-websocket-security" title="15.2.2&nbsp;WebSocket Security">XML Namespace</a> support for securing WebSockets.
A comparable XML based configuration looks like the following:</p>
<pre class="programlisting"><span class="hl-tag">&lt;websocket-message-broker&gt;</span>
    <a name="CO17-1" href="#CO17-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">type</span>=<span class="hl-value">"CONNECT"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"permitAll"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">type</span>=<span class="hl-value">"UNSUBSCRIBE"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"permitAll"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">type</span>=<span class="hl-value">"DISCONNECT"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"permitAll"</span><span class="hl-tag"> /&gt;</span>

    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/user/queue/errors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"SUBSCRIBE"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"permitAll"</span><span class="hl-tag"> /&gt;</span> <a name="CO17-2" href="#CO17-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/app/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('USER')"</span><span class="hl-tag"> /&gt;</span>      <a name="CO17-3" href="#CO17-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>

    <a name="CO17-4" href="#CO17-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/user/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('USER')"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/topic/friends/*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('USER')"</span><span class="hl-tag"> /&gt;</span>

    <a name="CO17-5" href="#CO17-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">type</span>=<span class="hl-value">"MESSAGE"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"denyAll"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">type</span>=<span class="hl-value">"SUBSCRIBE"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"denyAll"</span><span class="hl-tag"> /&gt;</span>

    <span class="hl-tag">&lt;intercept-message</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"denyAll"</span><span class="hl-tag"> /&gt;</span> <a name="CO17-6" href="#CO17-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
<span class="hl-tag">&lt;/websocket-message-broker&gt;</span></pre>
<p>This will ensure that:</p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO17-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any message of type CONNECT, UNSUBSCRIBE, or DISCONNECT will require the user to be authenticated</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO17-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Anyone can subscribe to /user/queue/errors</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO17-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any message that has a destination starting with "/app/" will be require the user to have the role ROLE_USER</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO17-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any message that starts with "/user/" or "/topic/friends/" that is of type SUBSCRIBE will require ROLE_USER</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO17-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO17-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Any other message with a destination is rejected. This is a good idea to ensure that you do not miss any messages.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-authorization-notes" href="#websocket-authorization-notes"></a>WebSocket Authorization Notes</h4></div></div></div>

<p>In order to properly secure your application it is important to understand Spring&#8217;s WebSocket support.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="websocket-authorization-notes-messagetypes" href="#websocket-authorization-notes-messagetypes"></a>WebSocket Authorization on Message Types</h5></div></div></div>

<p>It is important to understand the distinction between SUBSCRIBE and MESSAGE types of messages and how it works within Spring.</p>
<p>Consider a chat application.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The system can send notifications MESSAGE to all users through a destination of "/topic/system/notifications"
</li><li class="listitem">
Clients can receive notifications by SUBSCRIBE to the "/topic/system/notifications".
</li></ul></div>
<p>While we want clients to be able to SUBSCRIBE to "/topic/system/notifications", we do not want to enable them to send a MESSAGE to that destination.
If we allowed sending a MESSAGE to "/topic/system/notifications", then clients could send a message directly to that endpoint and impersonate the system.</p>
<p>In general, it is common for applications to deny any MESSAGE sent to a message that starts with the <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp" target="_top">broker prefix</a> (i.e. "/topic/" or "/queue/").</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="websocket-authorization-notes-destinations" href="#websocket-authorization-notes-destinations"></a>WebSocket Authorization on Destinations</h5></div></div></div>

<p>It is also is important to understand how destinations are transformed.</p>
<p>Consider a chat application.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Users can send messages to a specific user by sending a message to the destination of "/app/chat".
</li><li class="listitem">
The application sees the message, ensures that the "from" attribute is specified as the current user (we cannot trust the client).
</li><li class="listitem">
The application then sends the message to the recipient using <code class="literal">SimpMessageSendingOperations.convertAndSendToUser("toUser", "/queue/messages", message)</code>.
</li><li class="listitem">
The message gets turned into the destination of "/queue/user/messages-&lt;sessionid&gt;"
</li></ul></div>
<p>With the application above, we want to allow our client to listen to "/user/queue" which is transformed into "/queue/user/messages-&lt;sessionid&gt;".
However, we do not want the client to be able to listen to "/queue/*" because that would allow the client to see messages for every user.</p>
<p>In general, it is common for applications to deny any SUBSCRIBE sent to a message that starts with the <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp" target="_top">broker prefix</a> (i.e. "/topic/" or "/queue/").
Of course we may provide exceptions to account for things like</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-authorization-notes-outbound" href="#websocket-authorization-notes-outbound"></a>Outbound Messages</h4></div></div></div>

<p>Spring contains a section titled <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow" target="_top">Flow of Messages</a> that describes how messages flow through the system.
It is important to note that Spring Security only secures the <code class="literal">clientInboundChannel</code>.
Spring Security does not attempt to secure the <code class="literal">clientOutboundChannel</code>.</p>
<p>The most important reason for this is performance.
For every message that goes in, there are typically many more that go out.
Instead of securing the outbound messages, we encourage securing the subscription to the endpoints.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="websocket-sameorigin" href="#websocket-sameorigin"></a>10.11.4&nbsp;Enforcing Same Origin Policy</h3></div></div></div>

<p>It is important to emphasize that the browser does not enforce the <a class="ulink" href="http://en.wikipedia.org/wiki/Same-origin_policy" target="_top">Same Origin Policy</a> for WebSocket connections.
This is an extremely important consideration.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-sameorigin-why" href="#websocket-sameorigin-why"></a>Why Same Origin?</h4></div></div></div>

<p>Consider the following scenario.
A user visits bank.com and authenticates to their account.
The same user opens another tab in their browser and visits evil.com.
The Same Origin Policy ensures that evil.com cannot read or write data to bank.com.</p>
<p>With WebSockets the Same Origin Policy does not apply.
In fact, unless bank.com explicitly forbids it, evil.com can read and write data on behalf of the user.
This means that anything the user can do over the webSocket (i.e. transfer money), evil.com can do on that users behalf.</p>
<p>Since SockJS tries to emulate WebSockets it also bypasses the Same Origin Policy.
This means developers need to explicitly protect their applications from external domains when using SockJS.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-sameorigin-spring" href="#websocket-sameorigin-spring"></a>Spring WebSocket Allowed Origin</h4></div></div></div>

<p>Fortunately, since Spring 4.1.5 Spring&#8217;s WebSocket and SockJS support restricts access to the <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins" target="_top">current domain</a>.
Spring Security adds an additional layer of protection to provide <a class="ulink" href="http://en.wikipedia.org/wiki/Defense_in_depth_%28computing%29" target="_top">defence in depth</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-sameorigin-csrf" href="#websocket-sameorigin-csrf"></a>Adding CSRF to Stomp Headers</h4></div></div></div>

<p>By default Spring Security requires the <a class="link" href="web-app-security.html#csrf" title="10.6&nbsp;Cross Site Request Forgery (CSRF)">CSRF token</a> in any CONNECT message type.
This ensures that only a site that has access to the CSRF token can connect.
Since only the <span class="strong"><strong>Same Origin</strong></span> can access the CSRF token, external domains are not allowed to make a connection.</p>
<p>Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers</p>
<p>Applications can <a class="link" href="web-app-security.html#csrf-include-csrf-token" title="Include the CSRF Token">obtain a CSRF token</a> by accessing the request attribute named _csrf.
For example, the following will allow accessing the <code class="literal">CsrfToken</code> in a JSP:</p>
<pre class="programlisting"><span class="hl-keyword">var</span> headerName = <span class="hl-string">"${_csrf.headerName}"</span>;
<span class="hl-keyword">var</span> token = <span class="hl-string">"${_csrf.token}"</span>;</pre>
<p>If you are using static HTML, you can expose the <code class="literal">CsrfToken</code> on a REST endpoint.
For example, the following would expose the <code class="literal">CsrfToken</code> on the URL /csrf</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CsrfController {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/csrf")</span></em>
    <span class="hl-keyword">public</span> CsrfToken csrf(CsrfToken token) {
        <span class="hl-keyword">return</span> token;
    }
}</pre>
<p>The JavaScript can make a REST call to the endpoint and use the response to populate the headerName and the token.</p>
<p>We can now include the token in our Stomp client.
For example:</p>
<pre class="programlisting">...
<span class="hl-keyword">var</span> headers = {};
headers[headerName] = token;
stompClient.connect(headers, <span class="hl-keyword">function</span>(frame) {
  ...

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-sameorigin-disable" href="#websocket-sameorigin-disable"></a>Disable CSRF within WebSockets</h4></div></div></div>

<p>If you want to allow other domains to access your site, you can disable Spring Security&#8217;s protection.
For example, in Java Configuration you can use the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSocketSecurityConfig <span class="hl-keyword">extends</span> AbstractSecurityWebSocketMessageBrokerConfigurer {

    ...

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">boolean</span> sameOriginDisabled() {
        <span class="hl-keyword">return</span> true;
    }
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="websocket-sockjs" href="#websocket-sockjs"></a>10.11.5&nbsp;Working with SockJS</h3></div></div></div>

<p><a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback" target="_top">SockJS</a> provides fallback transports to support older browsers.
When using the fallback options we need to relax a few security constraints to allow SockJS to work with Spring Security.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-sockjs-sameorigin" href="#websocket-sockjs-sameorigin"></a>SockJS &amp; frame-options</h4></div></div></div>

<p>SockJS may use an <a class="ulink" href="https://github.com/sockjs/sockjs-client/tree/v0.3.4" target="_top">transport that leverages an iframe</a>.
By default Spring Security will <a class="link" href="web-app-security.html#headers-frame-options" title="X-Frame-Options">deny</a> the site from being framed to prevent Clickjacking attacks.
To allow SockJS frame based transports to work, we need to configure Spring Security to allow the same origin to frame the content.</p>
<p>You can customize X-Frame-Options with the <a class="link" href="appendix.html#nsa-frame-options" title="<frame-options&gt;">frame-options</a> element.
For example, the following will instruct Spring Security to use "X-Frame-Options: SAMEORIGIN" which allows iframes within the same domain:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-comment">&lt;!-- ... --&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;frame-options</span>
          <span class="hl-attribute">policy</span>=<span class="hl-value">"SAMEORIGIN"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Similarly, you can customize frame options to use the same origin within Java Configuration using the following:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig <span class="hl-keyword">extends</span>
   WebSecurityConfigurerAdapter {

  <em><span class="hl-annotation" style="color: gray">@Override</span></em>
  <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {
    http
      <span class="hl-comment">// ...</span>
      .headers()
        .frameOptions()
            .sameOrigin();
  }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="websocket-sockjs-csrf" href="#websocket-sockjs-csrf"></a>SockJS &amp; Relaxing CSRF</h4></div></div></div>

<p>SockJS uses a POST on the CONNECT messages for any HTTP based transport.
Typically we need to include the CSRF token in an HTTP header or an HTTP parameter.
However, SockJS does not allow for these options.
Instead, we must include the token in the Stomp headers as described in <a class="xref" href="web-app-security.html#websocket-sameorigin-csrf" title="Adding CSRF to Stomp Headers">the section called &#8220;Adding CSRF to Stomp Headers&#8221;</a>.</p>
<p>It also means we need to relax our CSRF protection with the web layer.
Specifically, we want to disable CSRF protection for our connect URLs.
We do NOT want to disable CSRF protection for every URL.
Otherwise our site will be vulnerable to CSRF attacks.</p>
<p>We can easily achieve this by providing a CSRF RequestMatcher.
Our Java Configuration makes this extremely easy.
For example, if our stomp endpoint is "/chat" we can disable CSRF protection for only URLs that start with "/chat/" using the following configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurityConfig
    <span class="hl-keyword">extends</span> WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configure(HttpSecurity http) <span class="hl-keyword">throws</span> Exception {

        http
            .csrf()
                <span class="hl-comment">// ignore our stomp endpoints since they are protected using Stomp headers</span>
                .ignoringAntMatchers(<span class="hl-string">"/chat/**"</span>)
                .and()
            .headers()
                <span class="hl-comment">// allow same origin to frame our site to support iframe SockJS</span>
                .frameOptions().sameOrigin()
                .and()
            .authorizeRequests()

            ...</pre>
<p>If we are using XML based configuration, we can use the <a class="link" href="appendix.html#nsa-csrf-request-matcher-ref">csrf@request-matcher-ref</a>.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http</span> <span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">&lt;csrf</span> <span class="hl-attribute">request-matcher-ref</span>=<span class="hl-value">"csrfMatcher"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;headers&gt;</span>
        <span class="hl-tag">&lt;frame-options</span> <span class="hl-attribute">policy</span>=<span class="hl-value">"SAMEORIGIN"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/headers&gt;</span>

    ...
<span class="hl-tag">&lt;/http&gt;</span>

<span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"csrfMatcher"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"AndRequestMatcher"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;b:constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;b:constructor-arg&gt;</span>
        <span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.util.matcher.NegatedRequestMatcher"</span><span class="hl-tag">&gt;</span>
          <span class="hl-tag">&lt;b:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.web.util.matcher.AntPathRequestMatcher"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;b:constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/chat/**"</span><span class="hl-tag">/&gt;</span>
          <span class="hl-tag">&lt;/b:bean&gt;</span>
        <span class="hl-tag">&lt;/b:bean&gt;</span>
    <span class="hl-tag">&lt;/b:constructor-arg&gt;</span>
<span class="hl-tag">&lt;/b:bean&gt;</span></pre>
</div>
</div>
</div>
<div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.d5e3604" class="footnote"><p><a href="#d5e3604" class="simpara"><sup class="simpara">[6] </sup></a>Note that you&#8217;ll need to include the security namespace in your application context XML file in order to use this syntax. The older syntax which used a <code class="literal">filter-chain-map</code> is still supported, but is deprecated in favour of the constructor argument injection.</p></div><div id="ftn.d5e3610" class="footnote"><p><a href="#d5e3610" class="simpara"><sup class="simpara">[7] </sup></a>Instead of a path pattern, the <code class="literal">request-matcher-ref</code> attribute can be used to specify a <code class="literal">RequestMatcher</code> instance for more powerful matching</p></div><div id="ftn.d5e3708" class="footnote"><p><a href="#d5e3708" class="simpara"><sup class="simpara">[8] </sup></a>You have probably seen this when a browser doesn&#8217;t support cookies and the <code class="literal">jsessionid</code> parameter is appended to the URL after a semi-colon. However the RFC allows the presence of these parameters in any path segment of the URL</p></div><div id="ftn.d5e3713" class="footnote"><p><a href="#d5e3713" class="simpara"><sup class="simpara">[9] </sup></a>The original values will be returned once the request leaves the <code class="literal">FilterChainProxy</code>, so will still be available to the application.</p></div><div id="ftn.d5e3720" class="footnote"><p><a href="#d5e3720" class="simpara"><sup class="simpara">[10] </sup></a>So, for example, an original request path <code class="literal">/secure;hack=1/somefile.html;hack=2</code> will be returned as <code class="literal">/secure/somefile.html</code>.</p></div><div id="ftn.d5e3841" class="footnote"><p><a href="#d5e3841" class="simpara"><sup class="simpara">[11] </sup></a>We use a forward so that the SecurityContextHolder still contains details of the principal, which may be useful for displaying to the user. In old releases of Spring Security we relied upon the servlet container to handle a 403 error message, which lacked this useful contextual information.</p></div><div id="ftn.d5e3880" class="footnote"><p><a href="#d5e3880" class="simpara"><sup class="simpara">[12] </sup></a>In Spring Security 2.0 and earlier, this filter was called <code class="literal">HttpSessionContextIntegrationFilter</code> and performed all the work of storing the context was performed by the filter itself. If you were familiar with this class, then most of the configuration options which were available can now be found on <code class="literal">HttpSessionSecurityContextRepository</code>.</p></div><div id="ftn.d5e3895" class="footnote"><p><a href="#d5e3895" class="simpara"><sup class="simpara">[13] </sup></a>For historical reasons, prior to Spring Security 3.0, this filter was called <code class="literal">AuthenticationProcessingFilter</code> and the entry point was called <code class="literal">AuthenticationProcessingFilterEntryPoint</code>. Since the framework now supports many different forms of authentication, they have both been given more specific names in 3.0.</p></div><div id="ftn.d5e3923" class="footnote"><p><a href="#d5e3923" class="simpara"><sup class="simpara">[14] </sup></a>In versions prior to 3.0, the application flow at this point had evolved to a stage was controlled by a mix of properties on this class and strategy plugins. The decision was made for 3.0 to refactor the code to make these two strategies entirely responsible.</p></div><div id="ftn.d5e4069" class="footnote"><p><a href="#d5e4069" class="simpara"><sup class="simpara">[15] </sup></a>It is possible to encode the password in the format HEX( MD5(username:realm:password) ) provided the <code class="literal">DigestAuthenticationFilter.passwordAlreadyEncoded</code> is set to <code class="literal">true</code>. However, other password encodings will not work with digest authentication.</p></div><div id="ftn.d5e4112" class="footnote"><p><a href="#d5e4112" class="simpara"><sup class="simpara">[16] </sup></a>Essentially, the username is not included in the cookie, to prevent exposing a valid login name unecessarily. There is a discussion on this in the comments section of this article.</p></div><div id="ftn.d5e4709" class="footnote"><p><a href="#d5e4709" class="simpara"><sup class="simpara">[17] </sup></a>Authentication by mechanisms which perform a redirect after authenticating (such as form-login) will not be detected by <code class="literal">SessionManagementFilter</code>, as the filter will not be invoked during the authenticating request. Session-management functionality has to be handled separately in these cases.</p></div><div id="ftn.d5e4804" class="footnote"><p><a href="#d5e4804" class="simpara"><sup class="simpara">[18] </sup></a>The use of the <code class="literal">key</code> property should not be regarded as providing any real security here. It is merely a book-keeping exercise. If you are sharing a <code class="literal">ProviderManager</code> which contains an <code class="literal">AnonymousAuthenticationProvider</code> in a scenario where it is possible for an authenticating client to construct the <code class="literal">Authentication</code> object (such as with RMI invocations), then a malicious client could submit an <code class="literal">AnonymousAuthenticationToken</code> which it had created itself (with chosen username and authority list). If the <code class="literal">key</code> is guessable or can be found out, then the token would be accepted by the anonymous provider. This isn&#8217;t a problem with normal usage but if you are using RMI you would be best to use a customized <code class="literal">ProviderManager</code> which omits the anonymous provider rather than sharing the one you use for your HTTP authentication mechanisms.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="test.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="servlet-applications.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="authorization.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">9.&nbsp;Testing&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;11.&nbsp;Authorization</td></tr></table></div></body></html>