<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>9.&nbsp;Testing</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Security Reference"><link rel="up" href="servlet-applications.html" title="Part&nbsp;II.&nbsp;Servlet Applications"><link rel="prev" href="overall-architecture.html" title="8.&nbsp;Architecture and Implementation"><link rel="next" href="web-app-security.html" title="10.&nbsp;Web Application Security"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9.&nbsp;Testing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="overall-architecture.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Servlet Applications</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="web-app-security.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="test" href="#test"></a>9.&nbsp;Testing</h2></div></div></div>

<p>This section describes the testing support provided by Spring Security.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>To use the Spring Security test support, you must include <code class="literal">spring-security-test-5.1.3.RELEASE.jar</code> as a dependency of your project.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="test-method" href="#test-method"></a>9.1&nbsp;Testing Method Security</h2></div></div></div>

<p>This section demonstrates how to use Spring Security&#8217;s Test support to test method based security.
We first introduce a <code class="literal">MessageService</code> that requires the user to be authenticated in order to access it.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloMessageService <span class="hl-keyword">implements</span> MessageService {

    <em><span class="hl-annotation" style="color: gray">@PreAuthorize("authenticated")</span></em>
    <span class="hl-keyword">public</span> String getMessage() {
        Authentication authentication = SecurityContextHolder.getContext()
            .getAuthentication();
        <span class="hl-keyword">return</span> <span class="hl-string">"Hello "</span> + authentication;
    }
}</pre>
<p>The result of <code class="literal">getMessage</code> is a String saying "Hello" to the current Spring Security <code class="literal">Authentication</code>.
An example of the output is displayed below.</p>
<pre class="programlisting">Hello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER</pre>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-method-setup" href="#test-method-setup"></a>9.1.1&nbsp;Security Test Setup</h3></div></div></div>

<p>Before we can use Spring Security Test support, we must perform some setup. An example can be seen below:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></em> <a name="CO12-1" href="#CO12-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em> <a name="CO12-2" href="#CO12-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WithMockUserTests {</pre>
<p>This is a basic example of how to setup Spring Security Test. The highlights are:</p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p><code class="literal">@RunWith</code> instructs the spring-test module that it should create an <code class="literal">ApplicationContext</code>. This is no different than using the existing Spring Test support. For additional information, refer to the <a class="ulink" href="http://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#integration-testing-annotations-standard" target="_top">Spring Reference</a></p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p><code class="literal">@ContextConfiguration</code> instructs the spring-test the configuration to use to create the <code class="literal">ApplicationContext</code>. Since no configuration is specified, the default configuration locations will be tried. This is no different than using the existing Spring Test support. For additional information, refer to the <a class="ulink" href="http://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#testcontext-ctx-management" target="_top">Spring Reference</a></p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Spring Security hooks into Spring Test support using the <code class="literal">WithSecurityContextTestExecutionListener</code> which will ensure our tests are ran with the correct user.
It does this by populating the <code class="literal">SecurityContextHolder</code> prior to running our tests.
If you are using reactive method security, you will also need <code class="literal">ReactorContextTestExecutionListener</code> which populates <code class="literal">ReactiveSecurityContextHolder</code>.
After the test is done, it will clear out the <code class="literal">SecurityContextHolder</code>.
If you only need Spring Security related support, you can replace <code class="literal">@ContextConfiguration</code> with <code class="literal">@SecurityTestExecutionListeners</code>.</p>
</td></tr></table></div>
<p>Remember we added the <code class="literal">@PreAuthorize</code> annotation to our <code class="literal">HelloMessageService</code> and so it requires an authenticated user to invoke it.
If we ran the following test, we would expect the following test will pass:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test(expected = AuthenticationCredentialsNotFoundException.class)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageUnauthenticated() {
    messageService.getMessage();
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-method-withmockuser" href="#test-method-withmockuser"></a>9.1.2&nbsp;@WithMockUser</h3></div></div></div>

<p>The question is "How could we most easily run the test as a specific user?"
The answer is to use <code class="literal">@WithMockUser</code>.
The following test will be run as a user with the username "user", the password "password", and the roles "ROLE_USER".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithMockUser() {
String message = messageService.getMessage();
...
}</pre>
<p>Specifically the following is true:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The user with the username "user" does not have to exist since we are mocking the user
</li><li class="listitem">
The <code class="literal">Authentication</code> that is populated in the <code class="literal">SecurityContext</code> is of type <code class="literal">UsernamePasswordAuthenticationToken</code>
</li><li class="listitem">
The principal on the <code class="literal">Authentication</code> is Spring Security&#8217;s <code class="literal">User</code> object
</li><li class="listitem">
The <code class="literal">User</code> will have the username of "user", the password "password", and a single <code class="literal">GrantedAuthority</code> named "ROLE_USER" is used.
</li></ul></div>
<p>Our example is nice because we are able to leverage a lot of defaults.
What if we wanted to run the test with a different username?
The following test would run with the username "customUser". Again, the user does not need to actually exist.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser("customUsername")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithMockUserCustomUsername() {
    String message = messageService.getMessage();
...
}</pre>
<p>We can also easily customize the roles.
For example, this test will be invoked with the username "admin" and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser(username="admin",roles={"USER","ADMIN"})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithMockUserCustomUser() {
    String message = messageService.getMessage();
    ...
}</pre>
<p>If we do not want the value to automatically be prefixed with ROLE_ we can leverage the authorities attribute.
For example, this test will be invoked with the username "admin" and the authorities "USER" and "ADMIN".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser(username = "admin", authorities = { "ADMIN", "USER" })</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithMockUserCustomAuthorities() {
    String message = messageService.getMessage();
    ...
}</pre>
<p>Of course it can be a bit tedious placing the annotation on every test method.
Instead, we can place the annotation at the class level and every test will use the specified user.
For example, the following would run every test with a user with the username "admin", the password "password", and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser(username="admin",roles={"USER","ADMIN"})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WithMockUserTests {</pre>
<p>By default the <code class="literal">SecurityContext</code> is set during the <code class="literal">TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code class="literal">@Before</code>.
You can change this to happen during the <code class="literal">TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code class="literal">@Before</code> but before the test method is invoked.</p>
<pre class="programlisting">@WithMockUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-method-withanonymoususer" href="#test-method-withanonymoususer"></a>9.1.3&nbsp;@WithAnonymousUser</h3></div></div></div>

<p>Using <code class="literal">@WithAnonymousUser</code> allows running as an anonymous user.
This is especially convenient when you wish to run most of your tests with a specific user, but want to run a few tests as an anonymous user.
For example, the following will run withMockUser1 and withMockUser2 using <a class="link" href="test.html#test-method-withmockuser" title="9.1.2&nbsp;@WithMockUser">@WithMockUser</a> and anonymous as an anonymous user.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WithUserClassLevelAuthenticationTests {

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> withMockUser1() {
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> withMockUser2() {
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <em><span class="hl-annotation" style="color: gray">@WithAnonymousUser</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> anonymous() <span class="hl-keyword">throws</span> Exception {
        <span class="hl-comment">// override default to run as anonymous user</span>
    }
}</pre>
<p>By default the <code class="literal">SecurityContext</code> is set during the <code class="literal">TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code class="literal">@Before</code>.
You can change this to happen during the <code class="literal">TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code class="literal">@Before</code> but before the test method is invoked.</p>
<pre class="programlisting">@WithAnonymousUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-method-withuserdetails" href="#test-method-withuserdetails"></a>9.1.4&nbsp;@WithUserDetails</h3></div></div></div>

<p>While <code class="literal">@WithMockUser</code> is a very convenient way to get started, it may not work in all instances.
For example, it is common for applications to expect that the <code class="literal">Authentication</code> principal be of a specific type.
This is done so that the application can refer to the principal as the custom type and reduce coupling on Spring Security.</p>
<p>The custom principal is often times returned by a custom <code class="literal">UserDetailsService</code> that returns an object that implements both <code class="literal">UserDetails</code> and the custom type.
For situations like this, it is useful to create the test user using the custom <code class="literal">UserDetailsService</code>.
That is exactly what <code class="literal">@WithUserDetails</code> does.</p>
<p>Assuming we have a <code class="literal">UserDetailsService</code> exposed as a bean, the following test will be invoked with an <code class="literal">Authentication</code> of type <code class="literal">UsernamePasswordAuthenticationToken</code> and a principal that is returned from the <code class="literal">UserDetailsService</code> with the username of "user".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithUserDetails</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithUserDetails() {
    String message = messageService.getMessage();
    ...
}</pre>
<p>We can also customize the username used to lookup the user from our <code class="literal">UserDetailsService</code>.
For example, this test would be executed with a principal that is returned from the <code class="literal">UserDetailsService</code> with the username of "customUsername".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithUserDetails("customUsername")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithUserDetailsCustomUsername() {
    String message = messageService.getMessage();
    ...
}</pre>
<p>We can also provide an explicit bean name to look up the <code class="literal">UserDetailsService</code>.
For example, this test would look up the username of "customUsername" using the <code class="literal">UserDetailsService</code> with the bean name "myUserDetailsService".</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithUserDetails(value="customUsername", userDetailsServiceBeanName="myUserDetailsService")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getMessageWithUserDetailsServiceBeanName() {
    String message = messageService.getMessage();
    ...
}</pre>
<p>Like <code class="literal">@WithMockUser</code> we can also place our annotation at the class level so that every test uses the same user.
However unlike <code class="literal">@WithMockUser</code>, <code class="literal">@WithUserDetails</code> requires the user to exist.</p>
<p>By default the <code class="literal">SecurityContext</code> is set during the <code class="literal">TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code class="literal">@Before</code>.
You can change this to happen during the <code class="literal">TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code class="literal">@Before</code> but before the test method is invoked.</p>
<pre class="programlisting">@WithUserDetails(setupBefore = TestExecutionEvent.TEST_EXECUTION)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-method-withsecuritycontext" href="#test-method-withsecuritycontext"></a>9.1.5&nbsp;@WithSecurityContext</h3></div></div></div>

<p>We have seen that <code class="literal">@WithMockUser</code> is an excellent choice if we are not using a custom <code class="literal">Authentication</code> principal.
Next we discovered that <code class="literal">@WithUserDetails</code> would allow us to use a custom <code class="literal">UserDetailsService</code> to create our <code class="literal">Authentication</code> principal but required the user to exist.
We will now see an option that allows the most flexibility.</p>
<p>We can create our own annotation that uses the <code class="literal">@WithSecurityContext</code> to create any <code class="literal">SecurityContext</code> we want.
For example, we might create an annotation named <code class="literal">@WithMockCustomUser</code> as shown below:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class)</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> WithMockCustomUser {

    String username() <span class="hl-keyword">default</span> <span class="hl-string">"rob"</span>;

    String name() <span class="hl-keyword">default</span> <span class="hl-string">"Rob Winch"</span>;
}</pre>
<p>You can see that <code class="literal">@WithMockCustomUser</code> is annotated with the <code class="literal">@WithSecurityContext</code> annotation.
This is what signals to Spring Security Test support that we intend to create a <code class="literal">SecurityContext</code> for the test.
The <code class="literal">@WithSecurityContext</code> annotation requires we specify a <code class="literal">SecurityContextFactory</code> that will create a new <code class="literal">SecurityContext</code> given our <code class="literal">@WithMockCustomUser</code> annotation.
You can find our <code class="literal">WithMockCustomUserSecurityContextFactory</code> implementation below:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WithMockCustomUserSecurityContextFactory
    <span class="hl-keyword">implements</span> WithSecurityContextFactory&lt;WithMockCustomUser&gt; {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> SecurityContext createSecurityContext(WithMockCustomUser customUser) {
        SecurityContext context = SecurityContextHolder.createEmptyContext();

        CustomUserDetails principal =
            <span class="hl-keyword">new</span> CustomUserDetails(customUser.name(), customUser.username());
        Authentication auth =
            <span class="hl-keyword">new</span> UsernamePasswordAuthenticationToken(principal, <span class="hl-string">"password"</span>, principal.getAuthorities());
        context.setAuthentication(auth);
        <span class="hl-keyword">return</span> context;
    }
}</pre>
<p>We can now annotate a test class or a test method with our new annotation and Spring Security&#8217;s <code class="literal">WithSecurityContextTestExecutionListener</code> will ensure that our <code class="literal">SecurityContext</code> is populated appropriately.</p>
<p>When creating your own <code class="literal">WithSecurityContextFactory</code> implementations, it is nice to know that they can be annotated with standard Spring annotations.
For example, the <code class="literal">WithUserDetailsSecurityContextFactory</code> uses the <code class="literal">@Autowired</code> annotation to acquire the <code class="literal">UserDetailsService</code>:</p>
<pre class="programlisting"><span class="hl-keyword">final</span> <span class="hl-keyword">class</span> WithUserDetailsSecurityContextFactory
    <span class="hl-keyword">implements</span> WithSecurityContextFactory&lt;WithUserDetails&gt; {

    <span class="hl-keyword">private</span> UserDetailsService userDetailsService;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">public</span> WithUserDetailsSecurityContextFactory(UserDetailsService userDetailsService) {
        <span class="hl-keyword">this</span>.userDetailsService = userDetailsService;
    }

    <span class="hl-keyword">public</span> SecurityContext createSecurityContext(WithUserDetails withUser) {
        String username = withUser.value();
        Assert.hasLength(username, <span class="hl-string">"value() must be non-empty String"</span>);
        UserDetails principal = userDetailsService.loadUserByUsername(username);
        Authentication authentication = <span class="hl-keyword">new</span> UsernamePasswordAuthenticationToken(principal, principal.getPassword(), principal.getAuthorities());
        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        <span class="hl-keyword">return</span> context;
    }
}</pre>
<p>By default the <code class="literal">SecurityContext</code> is set during the <code class="literal">TestExecutionListener.beforeTestMethod</code> event.
This is the equivalent of happening before JUnit&#8217;s <code class="literal">@Before</code>.
You can change this to happen during the <code class="literal">TestExecutionListener.beforeTestExecution</code> event which is after JUnit&#8217;s <code class="literal">@Before</code> but before the test method is invoked.</p>
<pre class="programlisting">@WithSecurityContext(setupBefore = TestExecutionEvent.TEST_EXECUTION)</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-method-meta-annotations" href="#test-method-meta-annotations"></a>9.1.6&nbsp;Test Meta Annotations</h3></div></div></div>

<p>If you reuse the same user within your tests often, it is not ideal to have to repeatedly specify the attributes.
For example, if there are many tests related to an administrative user with the username "admin" and the roles <code class="literal">ROLE_USER</code> and <code class="literal">ROLE_ADMIN</code> you would have to write:</p>
<pre class="programlisting">@WithMockUser(username=<span class="hl-string">"admin"</span>,roles={<span class="hl-string">"USER"</span>,<span class="hl-string">"ADMIN"</span>})</pre>
<p>Rather than repeating this everywhere, we can use a meta annotation.
For example, we could create a meta annotation named <code class="literal">WithMockAdmin</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser(value="rob",roles="ADMIN")</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> WithMockAdmin { }</pre>
<p>Now we can use <code class="literal">@WithMockAdmin</code> in the same way as the more verbose <code class="literal">@WithMockUser</code>.</p>
<p>Meta annotations work with any of the testing annotations described above.
For example, this means we could create a meta annotation for <code class="literal">@WithUserDetails("admin")</code> as well.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="test-mockmvc" href="#test-mockmvc"></a>9.2&nbsp;Spring MVC Test Integration</h2></div></div></div>

<p>Spring Security provides comprehensive integration with <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework" target="_top">Spring MVC Test</a></p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-mockmvc-setup" href="#test-mockmvc-setup"></a>9.2.1&nbsp;Setting Up MockMvc and Spring Security</h3></div></div></div>

<p>In order to use Spring Security with Spring MVC Test it is necessary to add the Spring Security <code class="literal">FilterChainProxy</code> as a <code class="literal">Filter</code>.
It is also necessary to add Spring Security&#8217;s <code class="literal">TestSecurityContextHolderPostProcessor</code> to support <a class="link" href="test.html#running-as-a-user-in-spring-mvc-test-with-annotations" title="Running as a User in Spring MVC Test with Annotations">Running as a User in Spring MVC Test with Annotations</a>.
This can be done using Spring Security&#8217;s <code class="literal">SecurityMockMvcConfigurers.springSecurity()</code>.
For example:</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Spring Security&#8217;s testing support requires spring-test-4.1.3.RELEASE or greater.</p>
</td></tr></table></div>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CsrfShowcaseTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> WebApplicationContext context;

    <span class="hl-keyword">private</span> MockMvc mvc;

    <em><span class="hl-annotation" style="color: gray">@Before</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        mvc = MockMvcBuilders
                .webAppContextSetup(context)
                .apply(springSecurity()) <a name="CO13-1" href="#CO13-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                .build();
    }

...</pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO13-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p><code class="literal">SecurityMockMvcConfigurers.springSecurity()</code> will perform all of the initial setup we need to integrate Spring Security with Spring MVC Test</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test-mockmvc-smmrpp" href="#test-mockmvc-smmrpp"></a>9.2.2&nbsp;SecurityMockMvcRequestPostProcessors</h3></div></div></div>

<p>Spring MVC Test provides a convenient interface called a <code class="literal">RequestPostProcessor</code> that can be used to modify a request.
Spring Security provides a number of <code class="literal">RequestPostProcessor</code> implementations that make testing easier.
In order to use Spring Security&#8217;s <code class="literal">RequestPostProcessor</code> implementations ensure the following static import is used:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;</pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="test-mockmvc-csrf" href="#test-mockmvc-csrf"></a>Testing with CSRF Protection</h4></div></div></div>

<p>When testing any non-safe HTTP methods and using Spring Security&#8217;s CSRF protection, you must be sure to include a valid CSRF Token in the request.
To specify a valid CSRF token as a request parameter using the following:</p>
<pre class="programlisting">mvc
    .perform(post(<span class="hl-string">"/"</span>).with(csrf()))</pre>
<p>If you like you can include CSRF token in the header instead:</p>
<pre class="programlisting">mvc
    .perform(post(<span class="hl-string">"/"</span>).with(csrf().asHeader()))</pre>
<p>You can also test providing an invalid CSRF token using the following:</p>
<pre class="programlisting">mvc
    .perform(post(<span class="hl-string">"/"</span>).with(csrf().useInvalidToken()))</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="test-mockmvc-securitycontextholder" href="#test-mockmvc-securitycontextholder"></a>Running a Test as a User in Spring MVC Test</h4></div></div></div>

<p>It is often desirable to run tests as a specific user.
There are two simple ways of populating the user:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="test.html#test-mockmvc-securitycontextholder-rpp" title="Running as a User in Spring MVC Test with RequestPostProcessor">Running as a User in Spring MVC Test with RequestPostProcessor</a>
</li><li class="listitem">
<a class="link" href="test.html#running-as-a-user-in-spring-mvc-test-with-annotations" title="Running as a User in Spring MVC Test with Annotations">Running as a User in Spring MVC Test with Annotations</a>
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="test-mockmvc-securitycontextholder-rpp" href="#test-mockmvc-securitycontextholder-rpp"></a>Running as a User in Spring MVC Test with RequestPostProcessor</h4></div></div></div>

<p>There are a number of options available to associate a user to the current <code class="literal">HttpServletRequest</code>.
For example, the following will run as a user (which does not need to exist) with the username "user", the password "password", and the role "ROLE_USER":</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The support works by associating the user to the <code class="literal">HttpServletRequest</code>.
To associate the request to the <code class="literal">SecurityContextHolder</code> you need to ensure that the <code class="literal">SecurityContextPersistenceFilter</code> is associated with the <code class="literal">MockMvc</code> instance.
A few ways to do this are:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Invoking <a class="link" href="test.html#test-mockmvc-setup" title="9.2.1&nbsp;Setting Up MockMvc and Spring Security">apply(springSecurity())</a>
</li><li class="listitem">
Adding Spring Security&#8217;s <code class="literal">FilterChainProxy</code> to <code class="literal">MockMvc</code>
</li><li class="listitem">
Manually adding <code class="literal">SecurityContextPersistenceFilter</code> to the <code class="literal">MockMvc</code> instance may make sense when using <code class="literal">MockMvcBuilders.standaloneSetup</code>
</li></ul></div>
</td></tr></table></div>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/"</span>).with(user(<span class="hl-string">"user"</span>)))</pre>
<p>You can easily make customizations.
For example, the following will run as a user (which does not need to exist) with the username "admin", the password "pass", and the roles "ROLE_USER" and "ROLE_ADMIN".</p>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/admin"</span>).with(user(<span class="hl-string">"admin"</span>).password(<span class="hl-string">"pass"</span>).roles(<span class="hl-string">"USER"</span>,<span class="hl-string">"ADMIN"</span>)))</pre>
<p>If you have a custom <code class="literal">UserDetails</code> that you would like to use, you can easily specify that as well.
For example, the following will use the specified <code class="literal">UserDetails</code> (which does not need to exist) to run with a <code class="literal">UsernamePasswordAuthenticationToken</code> that has a principal of the specified <code class="literal">UserDetails</code>:</p>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/"</span>).with(user(userDetails)))</pre>
<p>You can run as anonymous user using the following:</p>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/"</span>).with(anonymous()))</pre>
<p>This is especially useful if you are running with a default user and wish to execute a few requests as an anonymous user.</p>
<p>If you want a custom <code class="literal">Authentication</code> (which does not need to exist) you can do so using the following:</p>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/"</span>).with(authentication(authentication)))</pre>
<p>You can even customize the <code class="literal">SecurityContext</code> using the following:</p>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/"</span>).with(securityContext(securityContext)))</pre>
<p>We can also ensure to run as a specific user for every request by using <code class="literal">MockMvcBuilders</code>'s default request.
For example, the following will run as a user (which does not need to exist) with the username "admin", the password "password", and the role "ROLE_ADMIN":</p>
<pre class="programlisting">mvc = MockMvcBuilders
        .webAppContextSetup(context)
        .defaultRequest(get(<span class="hl-string">"/"</span>).with(user(<span class="hl-string">"user"</span>).roles(<span class="hl-string">"ADMIN"</span>)))
        .apply(springSecurity())
        .build();</pre>
<p>If you find you are using the same user in many of your tests, it is recommended to move the user to a method.
For example, you can specify the following in your own class named <code class="literal">CustomSecurityMockMvcRequestPostProcessors</code>:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> RequestPostProcessor rob() {
    <span class="hl-keyword">return</span> user(<span class="hl-string">"rob"</span>).roles(<span class="hl-string">"ADMIN"</span>);
}</pre>
<p>Now you can perform a static import on <code class="literal">SecurityMockMvcRequestPostProcessors</code> and use that within your tests:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> sample.CustomSecurityMockMvcRequestPostProcessors.*;

...

mvc
    .perform(get(<span class="hl-string">"/"</span>).with(rob()))</pre>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="running-as-a-user-in-spring-mvc-test-with-annotations" href="#running-as-a-user-in-spring-mvc-test-with-annotations"></a>Running as a User in Spring MVC Test with Annotations</h5></div></div></div>

<p>As an alternative to using a <code class="literal">RequestPostProcessor</code> to create your user, you can use annotations described in <a class="xref" href="test.html#test-method" title="9.1&nbsp;Testing Method Security">Section&nbsp;9.1, &#8220;Testing Method Security&#8221;</a>.
For example, the following will run the test with the user with username "user", password "password", and role "ROLE_USER":</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> requestProtectedUrlWithUser() <span class="hl-keyword">throws</span> Exception {
mvc
        .perform(get(<span class="hl-string">"/"</span>))
        ...
}</pre>
<p>Alternatively, the following will run the test with the user with username "user", password "password", and role "ROLE_ADMIN":</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@WithMockUser(roles="ADMIN")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> requestProtectedUrlWithUser() <span class="hl-keyword">throws</span> Exception {
mvc
        .perform(get(<span class="hl-string">"/"</span>))
        ...
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testing-http-basic-authentication" href="#testing-http-basic-authentication"></a>Testing HTTP Basic Authentication</h4></div></div></div>

<p>While it has always been possible to authenticate with HTTP Basic, it was a bit tedious to remember the header name, format, and encode the values.
Now this can be done using Spring Security&#8217;s <code class="literal">httpBasic</code> <code class="literal">RequestPostProcessor</code>.
For example, the snippet below:</p>
<pre class="programlisting">mvc
    .perform(get(<span class="hl-string">"/"</span>).with(httpBasic(<span class="hl-string">"user"</span>,<span class="hl-string">"password"</span>)))</pre>
<p>will attempt to use HTTP Basic to authenticate a user with the username "user" and the password "password" by ensuring the following header is populated on the HTTP Request:</p>
<pre class="programlisting">Authorization: Basic dXNlcjpwYXNzd29yZA==</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="securitymockmvcrequestbuilders" href="#securitymockmvcrequestbuilders"></a>9.2.3&nbsp;SecurityMockMvcRequestBuilders</h3></div></div></div>

<p>Spring MVC Test also provides a <code class="literal">RequestBuilder</code> interface that can be used to create the <code class="literal">MockHttpServletRequest</code> used in your test.
Spring Security provides a few <code class="literal">RequestBuilder</code> implementations that can be used to make testing easier.
In order to use Spring Security&#8217;s <code class="literal">RequestBuilder</code> implementations ensure the following static import is used:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;</pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testing-form-based-authentication" href="#testing-form-based-authentication"></a>Testing Form Based Authentication</h4></div></div></div>

<p>You can easily create a request to test a form based authentication using Spring Security&#8217;s testing support.
For example, the following will submit a POST to "/login" with the username "user", the password "password", and a valid CSRF token:</p>
<pre class="programlisting">mvc
    .perform(formLogin())</pre>
<p>It is easy to customize the request.
For example, the following will submit a POST to "/auth" with the username "admin", the password "pass", and a valid CSRF token:</p>
<pre class="programlisting">mvc
    .perform(formLogin(<span class="hl-string">"/auth"</span>).user(<span class="hl-string">"admin"</span>).password(<span class="hl-string">"pass"</span>))</pre>
<p>We can also customize the parameters names that the username and password are included on.
For example, this is the above request modified to include the username on the HTTP parameter "u" and the password on the HTTP parameter "p".</p>
<pre class="programlisting">mvc
    .perform(formLogin(<span class="hl-string">"/auth"</span>).user(<span class="hl-string">"u"</span>,<span class="hl-string">"admin"</span>).password(<span class="hl-string">"p"</span>,<span class="hl-string">"pass"</span>))</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="test-logout" href="#test-logout"></a>Testing Logout</h4></div></div></div>

<p>While fairly trivial using standard Spring MVC Test, you can use Spring Security&#8217;s testing support to make testing log out easier.
For example, the following will submit a POST to "/logout" with a valid CSRF token:</p>
<pre class="programlisting">mvc
    .perform(logout())</pre>
<p>You can also customize the URL to post to.
For example, the snippet below will submit a POST to "/signout" with a valid CSRF token:</p>
<pre class="programlisting">mvc
    .perform(logout(<span class="hl-string">"/signout"</span>))</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="securitymockmvcresultmatchers" href="#securitymockmvcresultmatchers"></a>9.2.4&nbsp;SecurityMockMvcResultMatchers</h3></div></div></div>

<p>At times it is desirable to make various security related assertions about a request.
To accommodate this need, Spring Security Test support implements Spring MVC Test&#8217;s <code class="literal">ResultMatcher</code> interface.
In order to use Spring Security&#8217;s <code class="literal">ResultMatcher</code> implementations ensure the following static import is used:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;</pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="unauthenticated-assertion" href="#unauthenticated-assertion"></a>Unauthenticated Assertion</h4></div></div></div>

<p>At times it may be valuable to assert that there is no authenticated user associated with the result of a <code class="literal">MockMvc</code> invocation.
For example, you might want to test submitting an invalid username and password and verify that no user is authenticated.
You can easily do this with Spring Security&#8217;s testing support using something like the following:</p>
<pre class="programlisting">mvc
    .perform(formLogin().password(<span class="hl-string">"invalid"</span>))
    .andExpect(unauthenticated());</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="authenticated-assertion" href="#authenticated-assertion"></a>Authenticated Assertion</h4></div></div></div>

<p>It is often times that we must assert that an authenticated user exists.
For example, we may want to verify that we authenticated successfully.
We could verify that a form based login was successful with the following snippet of code:</p>
<pre class="programlisting">mvc
    .perform(formLogin())
    .andExpect(authenticated());</pre>
<p>If we wanted to assert the roles of the user, we could refine our previous code as shown below:</p>
<pre class="programlisting">mvc
    .perform(formLogin().user(<span class="hl-string">"admin"</span>))
    .andExpect(authenticated().withRoles(<span class="hl-string">"USER"</span>,<span class="hl-string">"ADMIN"</span>));</pre>
<p>Alternatively, we could verify the username:</p>
<pre class="programlisting">mvc
    .perform(formLogin().user(<span class="hl-string">"admin"</span>))
    .andExpect(authenticated().withUsername(<span class="hl-string">"admin"</span>));</pre>
<p>We can also combine the assertions:</p>
<pre class="programlisting">mvc
    .perform(formLogin().user(<span class="hl-string">"admin"</span>).roles(<span class="hl-string">"USER"</span>,<span class="hl-string">"ADMIN"</span>))
    .andExpect(authenticated().withUsername(<span class="hl-string">"admin"</span>));</pre>
<p>We can also make arbitrary assertions on the authentication</p>
<pre class="programlisting">mvc
    .perform(formLogin())
    .andExpect(authenticated().withAuthentication(auth -&gt;
        assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.<span class="hl-keyword">class</span>)));</pre>
</div>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overall-architecture.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="servlet-applications.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="web-app-security.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.&nbsp;Architecture and Implementation&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;10.&nbsp;Web Application Security</td></tr></table></div></body></html>