<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>11.&nbsp;Authorization</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Security Reference"><link rel="up" href="servlet-applications.html" title="Part&nbsp;II.&nbsp;Servlet Applications"><link rel="prev" href="web-app-security.html" title="10.&nbsp;Web Application Security"><link rel="next" href="advanced-topics.html" title="12.&nbsp;Additional Topics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.&nbsp;Authorization</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="web-app-security.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Servlet Applications</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="advanced-topics.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="authorization" href="#authorization"></a>11.&nbsp;Authorization</h2></div></div></div>

<p>The advanced authorization capabilities within Spring Security represent one of the most compelling reasons for its popularity.
Irrespective of how you choose to authenticate - whether using a Spring Security-provided mechanism and provider, or integrating with a container or other non-Spring Security authentication authority - you will find the authorization services can be used within your application in a consistent and simple way.</p>
<p>In this part we&#8217;ll explore the different <code class="literal">AbstractSecurityInterceptor</code> implementations, which were introduced in Part I.
We then move on to explore how to fine-tune authorization through use of domain access control lists.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="authz-arch" href="#authz-arch"></a>11.1&nbsp;Authorization Architecture</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="authz-authorities" href="#authz-authorities"></a>11.1.1&nbsp;Authorities</h3></div></div></div>

<p>As we saw in the <a class="link" href="overall-architecture.html#tech-granted-authority" title="GrantedAuthority">technical overview</a>, all <code class="literal">Authentication</code> implementations store a list of <code class="literal">GrantedAuthority</code> objects.
These represent the authorities that have been granted to the principal.
the <code class="literal">GrantedAuthority</code> objects are inserted into the <code class="literal">Authentication</code> object by the <code class="literal">AuthenticationManager</code> and are later read by <code class="literal">AccessDecisionManager</code> s when making authorization decisions.</p>
<p><code class="literal">GrantedAuthority</code> is an interface with only one method:</p>
<pre class="programlisting">String getAuthority();</pre>
<p>This method allows
			<code class="literal">AccessDecisionManager</code> s to obtain a precise <code class="literal">String</code> representation of the <code class="literal">GrantedAuthority</code>.
By returning a representation as a <code class="literal">String</code>, a <code class="literal">GrantedAuthority</code> can be easily "read" by most <code class="literal">AccessDecisionManager</code> s.
If a <code class="literal">GrantedAuthority</code> cannot be precisely represented as a <code class="literal">String</code>, the <code class="literal">GrantedAuthority</code> is considered "complex" and <code class="literal">getAuthority()</code> must return <code class="literal">null</code>.</p>
<p>An example of a "complex" <code class="literal">GrantedAuthority</code> would be an implementation that stores a list of operations and authority thresholds that apply to different customer account numbers.
Representing this complex <code class="literal">GrantedAuthority</code> as a <code class="literal">String</code> would be quite difficult, and as a result the <code class="literal">getAuthority()</code> method should return <code class="literal">null</code>.
This will indicate to any <code class="literal">AccessDecisionManager</code> that it will need to specifically support the <code class="literal">GrantedAuthority</code> implementation in order to understand its contents.</p>
<p>Spring Security includes one concrete <code class="literal">GrantedAuthority</code> implementation, <code class="literal">SimpleGrantedAuthority</code>.
This allows any user-specified <code class="literal">String</code> to be converted into a <code class="literal">GrantedAuthority</code>.
All <code class="literal">AuthenticationProvider</code> s included with the security architecture use <code class="literal">SimpleGrantedAuthority</code> to populate the <code class="literal">Authentication</code> object.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="authz-pre-invocation" href="#authz-pre-invocation"></a>11.1.2&nbsp;Pre-Invocation Handling</h3></div></div></div>

<p>As we&#8217;ve also seen in the <a class="link" href="overall-architecture.html#secure-objects" title="Secure Objects and the AbstractSecurityInterceptor">Technical Overview</a> chapter, Spring Security provides interceptors which control access to secure objects such as method invocations or web requests.
A pre-invocation decision on whether the invocation is allowed to proceed is made by the <code class="literal">AccessDecisionManager</code>.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="authz-access-decision-manager" href="#authz-access-decision-manager"></a>The AccessDecisionManager</h4></div></div></div>

<p>The <code class="literal">AccessDecisionManager</code> is called by the <code class="literal">AbstractSecurityInterceptor</code> and is responsible for making final access control decisions.
the <code class="literal">AccessDecisionManager</code> interface contains three methods:</p>
<pre class="programlisting"><span class="hl-keyword">void</span> decide(Authentication authentication, Object secureObject,
    Collection&lt;ConfigAttribute&gt; attrs) <span class="hl-keyword">throws</span> AccessDeniedException;

<span class="hl-keyword">boolean</span> supports(ConfigAttribute attribute);

<span class="hl-keyword">boolean</span> supports(Class clazz);</pre>
<p>The <code class="literal">AccessDecisionManager</code>'s <code class="literal">decide</code> method is passed all the relevant information it needs in order to make an authorization decision.
In particular, passing the secure <code class="literal">Object</code> enables those arguments contained in the actual secure object invocation to be inspected.
For example, let&#8217;s assume the secure object was a <code class="literal">MethodInvocation</code>.
It would be easy to query the <code class="literal">MethodInvocation</code> for any <code class="literal">Customer</code> argument, and then implement some sort of security logic in the <code class="literal">AccessDecisionManager</code> to ensure the principal is permitted to operate on that customer.
Implementations are expected to throw an <code class="literal">AccessDeniedException</code> if access is denied.</p>
<p>The <code class="literal">supports(ConfigAttribute)</code> method is called by the <code class="literal">AbstractSecurityInterceptor</code> at startup time to determine if the <code class="literal">AccessDecisionManager</code> can process the passed <code class="literal">ConfigAttribute</code>.
The <code class="literal">supports(Class)</code> method is called by a security interceptor implementation to ensure the configured <code class="literal">AccessDecisionManager</code> supports the type of secure object that the security interceptor will present.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="authz-voting-based" href="#authz-voting-based"></a>Voting-Based AccessDecisionManager Implementations</h4></div></div></div>

<p>Whilst users can implement their own <code class="literal">AccessDecisionManager</code> to control all aspects of authorization, Spring Security includes several <code class="literal">AccessDecisionManager</code> implementations that are based on voting.
<a class="xref" href="authorization.html#authz-access-voting" title="Figure&nbsp;11.1.&nbsp;Voting Decision Manager">Figure&nbsp;11.1, &#8220;Voting Decision Manager&#8221;</a> illustrates the relevant classes.</p>
<div class="figure"><a name="authz-access-voting" href="#authz-access-voting"></a><p class="title"><b>Figure&nbsp;11.1.&nbsp;Voting Decision Manager</b></p><div class="figure-contents">

<div class="mediaobject"><img src="images/access-decision-voting.png" alt="access decision voting"></div>
</div></div><br class="figure-break">
<p>Using this approach, a series of <code class="literal">AccessDecisionVoter</code> implementations are polled on an authorization decision.
The <code class="literal">AccessDecisionManager</code> then decides whether or not to throw an <code class="literal">AccessDeniedException</code> based on its assessment of the votes.</p>
<p>The <code class="literal">AccessDecisionVoter</code> interface has three methods:</p>
<pre class="programlisting"><span class="hl-keyword">int</span> vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attrs);

<span class="hl-keyword">boolean</span> supports(ConfigAttribute attribute);

<span class="hl-keyword">boolean</span> supports(Class clazz);</pre>
<p>Concrete implementations return an <code class="literal">int</code>, with possible values               being reflected in the <code class="literal">AccessDecisionVoter</code> static fields <code class="literal">ACCESS_ABSTAIN</code>, <code class="literal">ACCESS_DENIED</code> and <code class="literal">ACCESS_GRANTED</code>.
A voting implementation will return <code class="literal">ACCESS_ABSTAIN</code> if it has no opinion on an authorization decision.
If it does have an opinion, it must return either <code class="literal">ACCESS_DENIED</code> or <code class="literal">ACCESS_GRANTED</code>.</p>
<p>There are three concrete <code class="literal">AccessDecisionManager</code> s provided with Spring Security that tally the votes.
The <code class="literal">ConsensusBased</code> implementation will grant or deny access based on the consensus of non-abstain votes.
Properties are provided to control behavior in the event of an equality of votes or if all votes are abstain.
The <code class="literal">AffirmativeBased</code> implementation will grant access if one or more <code class="literal">ACCESS_GRANTED</code> votes were received (i.e. a deny vote will be ignored, provided there was at least one grant vote).
Like the <code class="literal">ConsensusBased</code> implementation, there is a parameter that controls the behavior if all voters abstain.
The <code class="literal">UnanimousBased</code> provider expects unanimous <code class="literal">ACCESS_GRANTED</code> votes in order to grant access, ignoring abstains.
It will deny access if there is any <code class="literal">ACCESS_DENIED</code> vote.
Like the other implementations, there is a parameter that controls the behaviour if all voters abstain.</p>
<p>It is possible to implement a custom <code class="literal">AccessDecisionManager</code> that tallies votes differently.
For example, votes from a particular <code class="literal">AccessDecisionVoter</code> might receive additional weighting, whilst a deny vote from a particular voter may have a veto effect.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="authz-role-voter" href="#authz-role-voter"></a>RoleVoter</h5></div></div></div>

<p>The most commonly used <code class="literal">AccessDecisionVoter</code> provided with Spring Security is the simple <code class="literal">RoleVoter</code>, which treats configuration attributes as simple role names and votes to grant access if the user has been assigned that role.</p>
<p>It will vote if any <code class="literal">ConfigAttribute</code> begins with the prefix <code class="literal">ROLE_</code>.
It will vote to grant access if there is a <code class="literal">GrantedAuthority</code> which returns a <code class="literal">String</code> representation (via the <code class="literal">getAuthority()</code> method) exactly equal to one or more <code class="literal">ConfigAttributes</code> starting with the prefix <code class="literal">ROLE_</code>.
If there is no exact match of any <code class="literal">ConfigAttribute</code> starting with <code class="literal">ROLE_</code>, the <code class="literal">RoleVoter</code> will vote to deny access.
If no <code class="literal">ConfigAttribute</code> begins with <code class="literal">ROLE_</code>, the voter will abstain.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="authz-authenticated-voter" href="#authz-authenticated-voter"></a>AuthenticatedVoter</h5></div></div></div>

<p>Another voter which we&#8217;ve implicitly seen is the <code class="literal">AuthenticatedVoter</code>, which can be used to differentiate between anonymous, fully-authenticated and remember-me authenticated users.
Many sites allow certain limited access under remember-me authentication, but require a user to confirm their identity by logging in for full access.</p>
<p>When we&#8217;ve used the attribute <code class="literal">IS_AUTHENTICATED_ANONYMOUSLY</code> to grant anonymous access, this attribute was being processed by the <code class="literal">AuthenticatedVoter</code>.
See the Javadoc for this class for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="authz-custom-voter" href="#authz-custom-voter"></a>Custom Voters</h5></div></div></div>

<p>Obviously, you can also implement a custom <code class="literal">AccessDecisionVoter</code> and you can put just about any access-control logic you want in it.
It might be specific to your application (business-logic related) or it might implement some security administration logic.
For example, you&#8217;ll find a <a class="ulink" href="http://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time" target="_top">blog article</a> on the Spring web site which describes how to use a voter to deny access in real-time to users whose accounts have been suspended.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="authz-after-invocation-handling" href="#authz-after-invocation-handling"></a>11.1.3&nbsp;After Invocation Handling</h3></div></div></div>

<p>Whilst the <code class="literal">AccessDecisionManager</code> is called by the <code class="literal">AbstractSecurityInterceptor</code> before proceeding with the secure object invocation, some applications need a way of modifying the object actually returned by the secure object invocation.
Whilst you could easily implement your own AOP concern to achieve this, Spring Security provides a convenient hook that has several concrete implementations that integrate with its ACL capabilities.</p>
<p><a class="xref" href="authorization.html#authz-after-invocation" title="Figure&nbsp;11.2.&nbsp;After Invocation Implementation">Figure&nbsp;11.2, &#8220;After Invocation Implementation&#8221;</a> illustrates Spring Security&#8217;s <code class="literal">AfterInvocationManager</code> and its concrete implementations.</p>
<div class="figure"><a name="authz-after-invocation" href="#authz-after-invocation"></a><p class="title"><b>Figure&nbsp;11.2.&nbsp;After Invocation Implementation</b></p><div class="figure-contents">

<div class="mediaobject"><img src="images/after-invocation.png" alt="after invocation"></div>
</div></div><br class="figure-break">
<p>Like many other parts of Spring Security, <code class="literal">AfterInvocationManager</code> has a single concrete implementation, <code class="literal">AfterInvocationProviderManager</code>, which polls a list of <code class="literal">AfterInvocationProvider</code> s.
Each <code class="literal">AfterInvocationProvider</code> is allowed to modify the return object or throw an <code class="literal">AccessDeniedException</code>.
Indeed multiple providers can modify the object, as the result of the previous provider is passed to the next in the list.</p>
<p>Please be aware that if you&#8217;re using <code class="literal">AfterInvocationManager</code>, you will still need configuration attributes that allow the <code class="literal">MethodSecurityInterceptor</code>'s <code class="literal">AccessDecisionManager</code> to allow an operation.
If you&#8217;re using the typical Spring Security included <code class="literal">AccessDecisionManager</code> implementations, having no configuration attributes defined for a particular secure method invocation will cause each <code class="literal">AccessDecisionVoter</code> to abstain from voting.
In turn, if the <code class="literal">AccessDecisionManager</code> property           &#8220;allowIfAllAbstainDecisions&#8221; is <code class="literal">false</code>, an <code class="literal">AccessDeniedException</code> will be thrown.
You may avoid this potential issue by either (i) setting &#8220;allowIfAllAbstainDecisions&#8221; to <code class="literal">true</code> (although this is generally not recommended) or (ii) simply ensure that there is at least one configuration attribute that an <code class="literal">AccessDecisionVoter</code> will vote to grant access for.
This latter (recommended) approach is usually achieved through a <code class="literal">ROLE_USER</code> or <code class="literal">ROLE_AUTHENTICATED</code> configuration attribute.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="authz-hierarchical-roles" href="#authz-hierarchical-roles"></a>11.1.4&nbsp;Hierarchical Roles</h3></div></div></div>

<p>It is a common requirement that a particular role in an application should automatically "include" other roles.
For example, in an application which has the concept of an "admin" and a "user" role, you may want an admin to be able to do everything a normal user can.
To achieve this, you can either make sure that all admin users are also assigned the "user" role.
Alternatively, you can modify every access constraint which requires the "user" role to also include the "admin" role.
This can get quite complicated if you have a lot of different roles in your application.</p>
<p>The use of a role-hierarchy allows you to configure which roles (or authorities) should include others.
An extended version of Spring Security&#8217;s <a class="link" href="authorization.html#authz-role-voter" title="RoleVoter">RoleVoter</a>, <code class="literal">RoleHierarchyVoter</code>, is configured with a <code class="literal">RoleHierarchy</code>, from which it obtains all the "reachable authorities" which the user is assigned.
A typical configuration might look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"roleVoter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.access.vote.RoleHierarchyVoter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"roleHierarchy"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"roleHierarchy"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hierarchy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;value&gt;</span>
            ROLE_ADMIN &gt; ROLE_STAFF
            ROLE_STAFF &gt; ROLE_USER
            ROLE_USER &gt; ROLE_GUEST
        <span class="hl-tag">&lt;/value&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Here we have four roles in a hierarchy <code class="literal">ROLE_ADMIN &#8658; ROLE_STAFF &#8658; ROLE_USER &#8658; ROLE_GUEST</code>.
A user who is authenticated with <code class="literal">ROLE_ADMIN</code>, will behave as if they have all four roles when security constraints are evaluated against an <code class="literal">AccessDecisionManager</code> configured with the above <code class="literal">RoleHierarchyVoter</code>.
The <code class="literal">&gt;</code> symbol can be thought of as meaning "includes".</p>
<p>Role hierarchies offer a convenient means of simplifying the access-control configuration data for your application and/or reducing the number of authorities which you need to assign to a user.
For more complex requirements you may wish to define a logical mapping between the specific access-rights your application requires and the roles that are assigned to users, translating between the two when loading the user information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="secure-object-impls" href="#secure-object-impls"></a>11.2&nbsp;Secure Object Implementations</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-alliance" href="#aop-alliance"></a>11.2.1&nbsp;AOP Alliance (MethodInvocation) Security Interceptor</h3></div></div></div>

<p>Prior to Spring Security 2.0, securing <code class="literal">MethodInvocation</code> s needed quite a lot of boiler plate configuration.
Now the recommended approach for method security is to use <a class="link" href="ns-config.html#ns-method-security" title="7.4&nbsp;Method Security">namespace configuration</a>.
This way the method security infrastructure beans are configured automatically for you so you don&#8217;t really need to know about the implementation classes.
We&#8217;ll just provide a quick overview of the classes that are involved here.</p>
<p>Method security is enforced using a <code class="literal">MethodSecurityInterceptor</code>, which secures <code class="literal">MethodInvocation</code> s.
Depending on the configuration approach, an interceptor may be specific to a single bean or shared between multiple beans.
The interceptor uses a <code class="literal">MethodSecurityMetadataSource</code> instance to obtain the configuration attributes that apply to a particular method invocation.
<code class="literal">MapBasedMethodSecurityMetadataSource</code> is used to store configuration attributes keyed by method names (which can be wildcarded) and will be used internally when the attributes are defined in the application context using the <code class="literal">&lt;intercept-methods&gt;</code> or <code class="literal">&lt;protect-point&gt;</code> elements.
Other implementations will be used to handle annotation-based configuration.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="explicit-methodsecurityinterceptor-configuration" href="#explicit-methodsecurityinterceptor-configuration"></a>Explicit MethodSecurityInterceptor Configuration</h4></div></div></div>

<p>You can of course configure a <code class="literal">MethodSecurityIterceptor</code> directly in your application context for use with one of Spring AOP&#8217;s proxying mechanisms:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"bankManagerSecurity"</span> <span class="hl-attribute">class</span>=
    <span class="hl-value">"org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDecisionManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"afterInvocationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"afterInvocationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadataSource"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;sec:method-security-metadata-source&gt;</span>
    <span class="hl-tag">&lt;sec:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"com.mycompany.BankManager.delete*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_SUPERVISOR"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;sec:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"com.mycompany.BankManager.getBalance"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_TELLER,ROLE_SUPERVISOR"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/sec:method-security-metadata-source&gt;</span>
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aspectj" href="#aspectj"></a>11.2.2&nbsp;AspectJ (JoinPoint) Security Interceptor</h3></div></div></div>

<p>The AspectJ security interceptor is very similar to the AOP Alliance security interceptor discussed in the previous section.
Indeed we will only discuss the differences in this section.</p>
<p>The AspectJ interceptor is named <code class="literal">AspectJSecurityInterceptor</code>.
Unlike the AOP Alliance security interceptor, which relies on the Spring application context to weave in the security interceptor via proxying, the <code class="literal">AspectJSecurityInterceptor</code> is weaved in via the AspectJ compiler.
It would not be uncommon to use both types of security interceptors in the same application, with <code class="literal">AspectJSecurityInterceptor</code> being used for domain object instance security and the AOP Alliance <code class="literal">MethodSecurityInterceptor</code> being used for services layer security.</p>
<p>Let&#8217;s first consider how the <code class="literal">AspectJSecurityInterceptor</code> is configured in the Spring application context:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"bankManagerSecurity"</span> <span class="hl-attribute">class</span>=
    <span class="hl-value">"org.springframework.security.access.intercept.aspectj.AspectJMethodSecurityInterceptor"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authenticationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"authenticationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessDecisionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accessDecisionManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"afterInvocationManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"afterInvocationManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityMetadataSource"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;sec:method-security-metadata-source&gt;</span>
    <span class="hl-tag">&lt;sec:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"com.mycompany.BankManager.delete*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_SUPERVISOR"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;sec:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"com.mycompany.BankManager.getBalance"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_TELLER,ROLE_SUPERVISOR"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/sec:method-security-metadata-source&gt;</span>
<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>As you can see, aside from the class name, the <code class="literal">AspectJSecurityInterceptor</code> is exactly the same as the AOP Alliance security interceptor.
Indeed the two interceptors can share the same <code class="literal">securityMetadataSource</code>, as the <code class="literal">SecurityMetadataSource</code> works with <code class="literal">java.lang.reflect.Method</code> s rather than an AOP library-specific class.
Of course, your access decisions have access to the relevant AOP library-specific invocation (ie <code class="literal">MethodInvocation</code> or <code class="literal">JoinPoint</code>) and as such can consider a range of addition criteria when making access decisions (such as method arguments).</p>
<p>Next you&#8217;ll need to define an AspectJ <code class="literal">aspect</code>.
For example:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.security.samples.aspectj;

<span class="hl-keyword">import</span> org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor;
<span class="hl-keyword">import</span> org.springframework.security.access.intercept.aspectj.AspectJCallback;
<span class="hl-keyword">import</span> org.springframework.beans.factory.InitializingBean;

<span class="hl-keyword">public</span> aspect DomainObjectInstanceSecurityAspect <span class="hl-keyword">implements</span> InitializingBean {

    <span class="hl-keyword">private</span> AspectJSecurityInterceptor securityInterceptor;

    pointcut domainObjectInstanceExecution(): target(PersistableEntity)
        &amp;&amp; execution(<span class="hl-keyword">public</span> * *(..)) &amp;&amp; !within(DomainObjectInstanceSecurityAspect);

    Object around(): domainObjectInstanceExecution() {
        <span class="hl-keyword">if</span> (<span class="hl-keyword">this</span>.securityInterceptor == null) {
            <span class="hl-keyword">return</span> proceed();
        }

        AspectJCallback callback = <span class="hl-keyword">new</span> AspectJCallback() {
            <span class="hl-keyword">public</span> Object proceedWithObject() {
                <span class="hl-keyword">return</span> proceed();
            }
        };

        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.securityInterceptor.invoke(thisJoinPoint, callback);
    }

    <span class="hl-keyword">public</span> AspectJSecurityInterceptor getSecurityInterceptor() {
        <span class="hl-keyword">return</span> securityInterceptor;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSecurityInterceptor(AspectJSecurityInterceptor securityInterceptor) {
        <span class="hl-keyword">this</span>.securityInterceptor = securityInterceptor;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterPropertiesSet() <span class="hl-keyword">throws</span> Exception {
        <span class="hl-keyword">if</span> (<span class="hl-keyword">this</span>.securityInterceptor == null)
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(<span class="hl-string">"securityInterceptor required"</span>);
        }
    }
}</pre>
<p>In the above example, the security interceptor will be applied to every instance of <code class="literal">PersistableEntity</code>, which is an abstract class not shown (you can use any other class or <code class="literal">pointcut</code> expression you like).
For those curious, <code class="literal">AspectJCallback</code> is needed because the <code class="literal">proceed();</code> statement has special meaning only within an <code class="literal">around()</code> body.
The <code class="literal">AspectJSecurityInterceptor</code> calls this anonymous <code class="literal">AspectJCallback</code> class when it wants the target object to continue.</p>
<p>You will need to configure Spring to load the aspect and wire it with the <code class="literal">AspectJSecurityInterceptor</code>.
A bean declaration which achieves this is shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"domainObjectInstanceSecurityAspect"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"security.samples.aspectj.DomainObjectInstanceSecurityAspect"</span>
    <span class="hl-attribute">factory-method</span>=<span class="hl-value">"aspectOf"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"securityInterceptor"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"bankManagerSecurity"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>That&#8217;s it!
Now you can create your beans from anywhere within your application, using whatever means you think fit (eg <code class="literal">new Person();</code>) and they will have the security interceptor applied.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="el-access" href="#el-access"></a>11.3&nbsp;Expression-Based Access Control</h2></div></div></div>

<p>Spring Security 3.0 introduced the ability to use Spring EL expressions as an authorization mechanism in addition to the simple use of configuration attributes and access-decision voters which have seen before.
Expression-based access control is built on the same architecture but allows complicated Boolean logic to be encapsulated in a single expression.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview" href="#overview"></a>11.3.1&nbsp;Overview</h3></div></div></div>

<p>Spring Security uses Spring EL for expression support and you should look at how that works if you are interested in understanding the topic in more depth.
Expressions are evaluated with a "root object" as part of the evaluation context.
Spring Security uses specific classes for web and method security as the root object, in order to provide built-in expressions and access to values such as the current principal.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="el-common-built-in" href="#el-common-built-in"></a>Common Built-In Expressions</h4></div></div></div>

<p>The base class for expression root objects is <code class="literal">SecurityExpressionRoot</code>.
This provides some common expressions which are available in both web and method security.</p>
<div class="table"><a name="common-expressions" href="#common-expressions"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;Common built-in expressions</b></p><div class="table-contents">

<table summary="Common built-in expressions" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Expression</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">hasRole([role])</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the current principal has the specified role.
By default if the supplied role does not start with 'ROLE_' it will be added.
This can be customized by modifying the <code class="literal">defaultRolePrefix</code> on <code class="literal">DefaultWebSecurityExpressionHandler</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">hasAnyRole([role1,role2])</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the current principal has any of the supplied roles (given as a comma-separated list of strings).
By default if the supplied role does not start with 'ROLE_' it will be added.
This can be customized by modifying the <code class="literal">defaultRolePrefix</code> on <code class="literal">DefaultWebSecurityExpressionHandler</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">hasAuthority([authority])</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the current principal has the specified authority.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">hasAnyAuthority([authority1,authority2])</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the current principal has any of the supplied authorities (given as a comma-separated list of strings)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">principal</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Allows direct access to the principal object representing the current user</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">authentication</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Allows direct access to the current <code class="literal">Authentication</code> object obtained from the <code class="literal">SecurityContext</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">permitAll</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Always evaluates to <code class="literal">true</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">denyAll</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Always evaluates to <code class="literal">false</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">isAnonymous()</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the current principal is an anonymous user</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">isRememberMe()</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the current principal is a remember-me user</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">isAuthenticated()</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the user is not anonymous</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">isFullyAuthenticated()</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the user is not an anonymous or a remember-me user</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">hasPermission(Object target, Object permission)</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Returns <code class="literal">true</code> if the user has access to the provided target for the given permission.
For example, <code class="literal">hasPermission(domainObject, 'read')</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">hasPermission(Object targetId, String targetType, Object permission)</code></p></td><td style="" align="left" valign="top"><p>Returns <code class="literal">true</code> if the user has access to the provided target for the given permission.
For example, <code class="literal">hasPermission(1, 'com.example.domain.Message', 'read')</code></p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="el-access-web" href="#el-access-web"></a>11.3.2&nbsp;Web Security Expressions</h3></div></div></div>

<p>To use expressions to secure individual URLs, you would first need to set the <code class="literal">use-expressions</code> attribute in the <code class="literal">&lt;http&gt;</code> element to <code class="literal">true</code>.
Spring Security will then expect the <code class="literal">access</code> attributes of the <code class="literal">&lt;intercept-url&gt;</code> elements to contain Spring EL expressions.
The expressions should evaluate to a Boolean, defining whether access should be allowed or not.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/admin*"</span>
        <span class="hl-attribute">access</span>=<span class="hl-value">"hasRole('admin') and hasIpAddress('192.168.1.0/24')"</span><span class="hl-tag">/&gt;</span>
    ...
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>Here we have defined that the "admin" area of an application (defined by the URL pattern) should only be available to users who have the granted authority "admin" and whose IP address matches a local subnet.
We&#8217;ve already seen the built-in <code class="literal">hasRole</code> expression in the previous section.
The expression <code class="literal">hasIpAddress</code> is an additional built-in expression which is specific to web security.
It is defined by the <code class="literal">WebSecurityExpressionRoot</code> class, an instance of which is used as the expression root object when evaluation web-access expressions.
This object also directly exposed the <code class="literal">HttpServletRequest</code> object under the name <code class="literal">request</code> so you can invoke the request directly in an expression.
If expressions are being used, a <code class="literal">WebExpressionVoter</code> will be added to the <code class="literal">AccessDecisionManager</code> which is used by the namespace.
So if you aren&#8217;t using the namespace and want to use expressions, you will have to add one of these to your configuration.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="el-access-web-beans" href="#el-access-web-beans"></a>Referring to Beans in Web Security Expressions</h4></div></div></div>

<p>If you wish to extend the expressions that are available, you can easily refer to any Spring Bean you expose.
For example, assuming you have a Bean with the name of <code class="literal">webSecurity</code> that contains the following method signature:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurity {
        <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> check(Authentication authentication, HttpServletRequest request) {
                ...
        }
}</pre>
<p>You could refer to the method using:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/user/**"</span>
        <span class="hl-attribute">access</span>=<span class="hl-value">"@webSecurity.check(authentication,request)"</span><span class="hl-tag">/&gt;</span>
    ...
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>or in Java configuration</p>
<pre class="programlisting">http
        .authorizeRequests()
                .antMatchers(<span class="hl-string">"/user/**"</span>).access(<span class="hl-string">"@webSecurity.check(authentication,request)"</span>)
                ...</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="el-access-web-path-variables" href="#el-access-web-path-variables"></a>Path Variables in Web Security Expressions</h4></div></div></div>

<p>At times it is nice to be able to refer to path variables within a URL.
For example, consider a RESTful application that looks up a user by id from the URL path in the format <code class="literal">/user/{userId}</code>.</p>
<p>You can easily refer to the path variable by placing it in the pattern.
For example, if you had a Bean with the name of <code class="literal">webSecurity</code> that contains the following method signature:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebSecurity {
        <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> checkUserId(Authentication authentication, <span class="hl-keyword">int</span> id) {
                ...
        }
}</pre>
<p>You could refer to the method using:</p>
<pre class="programlisting"><span class="hl-tag">&lt;http&gt;</span>
    <span class="hl-tag">&lt;intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/user/{userId}/**"</span>
        <span class="hl-attribute">access</span>=<span class="hl-value">"@webSecurity.checkUserId(authentication,#userId)"</span><span class="hl-tag">/&gt;</span>
    ...
<span class="hl-tag">&lt;/http&gt;</span></pre>
<p>or in Java configuration</p>
<pre class="programlisting">http
        .authorizeRequests()
                .antMatchers(<span class="hl-string">"/user/{userId}/**"</span>).access(<span class="hl-string">"@webSecurity.checkUserId(authentication,#userId)"</span>)
                ...</pre>
<p>In both configurations URLs that match would pass in the path variable (and convert it) into checkUserId method.
For example, if the URL were <code class="literal">/user/123/resource</code>, then the id passed in would be <code class="literal">123</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="method-security-expressions" href="#method-security-expressions"></a>11.3.3&nbsp;Method Security Expressions</h3></div></div></div>

<p>Method security is a bit more complicated than a simple allow or deny rule.
Spring Security 3.0 introduced some new annotations in order to allow comprehensive support for the use of expressions.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="el-pre-post-annotations" href="#el-pre-post-annotations"></a>@Pre and @Post Annotations</h4></div></div></div>

<p>There are four annotations which support expression attributes to allow pre and post-invocation authorization checks and also to support filtering of submitted collection arguments or return values.
They are <code class="literal">@PreAuthorize</code>, <code class="literal">@PreFilter</code>, <code class="literal">@PostAuthorize</code> and <code class="literal">@PostFilter</code>.
Their use is enabled through the <code class="literal">global-method-security</code> namespace element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;global-method-security</span> <span class="hl-attribute">pre-post-annotations</span>=<span class="hl-value">"enabled"</span><span class="hl-tag">/&gt;</span></pre>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="access-control-using-preauthorize-and-postauthorize" href="#access-control-using-preauthorize-and-postauthorize"></a>Access Control using @PreAuthorize and @PostAuthorize</h5></div></div></div>

<p>The most obviously useful annotation is <code class="literal">@PreAuthorize</code> which decides whether a method can actually be invoked or not.
For example (from the"Contacts" sample application)</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@PreAuthorize("hasRole('USER')")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> create(Contact contact);</pre>
<p>which means that access will only be allowed for users with the role "ROLE_USER".
Obviously the same thing could easily be achieved using a traditional configuration and a simple configuration attribute for the required role.
But what about:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@PreAuthorize("hasPermission(#contact, 'admin')")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> deletePermission(Contact contact, Sid recipient, Permission permission);</pre>
<p>Here we&#8217;re actually using a method argument as part of the expression to decide whether the current user has the "admin"permission for the given contact.
The built-in <code class="literal">hasPermission()</code> expression is linked into the Spring Security ACL module through the application context, as we&#8217;ll<a class="link" href="authorization.html#el-permission-evaluator" title="The PermissionEvaluator interface">see below</a>.
You can access any of the method arguments by name as expression variables.</p>
<p>There are a number of ways in which Spring Security can resolve the method arguments.
Spring Security uses <code class="literal">DefaultSecurityParameterNameDiscoverer</code> to discover the parameter names.
By default, the following options are tried for a method as a whole.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<p class="simpara">If Spring Security&#8217;s <code class="literal">@P</code> annotation is present on a single argument to the method, the value will be used.
This is useful for interfaces compiled with a JDK prior to JDK 8 which do not contain any information about the parameter names.
For example:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.security.access.method.P;

...

<em><span class="hl-annotation" style="color: gray">@PreAuthorize("#c.name == authentication.name")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomething(<em><span class="hl-annotation" style="color: gray">@P("c")</span></em> Contact contact);</pre>
<p class="simpara">Behind the scenes this use implemented using <code class="literal">AnnotationParameterNameDiscoverer</code> which can be customized to support the value attribute of any specified annotation.</p>
</li><li class="listitem">
<p class="simpara">If Spring Data&#8217;s <code class="literal">@Param</code> annotation is present on at least one parameter for the method, the value will be used.
This is useful for interfaces compiled with a JDK prior to JDK 8 which do not contain any information about the parameter names.
For example:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.data.repository.query.Param;

...

<em><span class="hl-annotation" style="color: gray">@PreAuthorize("#n == authentication.name")</span></em>
Contact findContactByName(<em><span class="hl-annotation" style="color: gray">@Param("n")</span></em> String name);</pre>
<p class="simpara">Behind the scenes this use implemented using <code class="literal">AnnotationParameterNameDiscoverer</code> which can be customized to support the value attribute of any specified annotation.</p>
</li><li class="listitem">
If JDK 8 was used to compile the source with the -parameters argument and Spring 4+ is being used, then the standard JDK reflection API is used to discover the parameter names.
This works on both classes and interfaces.
</li><li class="listitem">
Last, if the code was compiled with the debug symbols, the parameter names will be discovered using the debug symbols.
This will not work for interfaces since they do not have debug information about the parameter names.
For interfaces, annotations or the JDK 8 approach must be used.
</li></ul></div>
<p>Any Spring-EL functionality is available within the expression, so you can also access properties on the arguments.
For example, if you wanted a particular method to only allow access to a user whose username matched that of the contact, you could write</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@PreAuthorize("#contact.name == authentication.name")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomething(Contact contact);</pre>
<p>Here we are accessing another built-in expression, <code class="literal">authentication</code>, which is the <code class="literal">Authentication</code> stored in the security context.
You can also access its "principal" property directly, using the expression <code class="literal">principal</code>.
The value will often be a <code class="literal">UserDetails</code> instance, so you might use an expression like <code class="literal">principal.username</code> or <code class="literal">principal.enabled</code>.</p>
<p>Less commonly, you may wish to perform an access-control check after the method has been invoked.
This can be achieved using the <code class="literal">@PostAuthorize</code> annotation.
To access the return value from a method, use the built-in name <code class="literal">returnObject</code> in the expression.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="filtering-using-prefilter-and-postfilter" href="#filtering-using-prefilter-and-postfilter"></a>Filtering using @PreFilter and @PostFilter</h5></div></div></div>

<p>As you may already be aware, Spring Security supports filtering of collections and arrays and this can now be achieved using expressions.
This is most commonly performed on the return value of a method.
For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@PreAuthorize("hasRole('USER')")</span></em>
<em><span class="hl-annotation" style="color: gray">@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")</span></em>
<span class="hl-keyword">public</span> List&lt;Contact&gt; getAll();</pre>
<p>When using the <code class="literal">@PostFilter</code> annotation, Spring Security iterates through the returned collection and removes any elements for which the supplied expression is false.
The name <code class="literal">filterObject</code> refers to the current object in the collection.
You can also filter before the method call, using <code class="literal">@PreFilter</code>, though this is a less common requirement.
The syntax is just the same, but if there is more than one argument which is a collection type then you have to select one by name using the <code class="literal">filterTarget</code> property of this annotation.</p>
<p>Note that filtering is obviously not a substitute for tuning your data retrieval queries.
If you are filtering large collections and removing many of the entries then this is likely to be inefficient.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="el-method-built-in" href="#el-method-built-in"></a>Built-In Expressions</h4></div></div></div>

<p>There are some built-in expressions which are specific to method security, which we have already seen in use above.
The <code class="literal">filterTarget</code> and <code class="literal">returnValue</code> values are simple enough, but the use of the <code class="literal">hasPermission()</code> expression warrants a closer look.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="el-permission-evaluator" href="#el-permission-evaluator"></a>The PermissionEvaluator interface</h5></div></div></div>

<p><code class="literal">hasPermission()</code> expressions are delegated to an instance of <code class="literal">PermissionEvaluator</code>.
It is intended to bridge between the expression system and Spring Security&#8217;s ACL system, allowing you to specify authorization constraints on domain objects, based on abstract permissions.
It has no explicit dependencies on the ACL module, so you could swap that out for an alternative implementation if required.
The interface has two methods:</p>
<pre class="programlisting"><span class="hl-keyword">boolean</span> hasPermission(Authentication authentication, Object targetDomainObject,
                            Object permission);

<span class="hl-keyword">boolean</span> hasPermission(Authentication authentication, Serializable targetId,
                            String targetType, Object permission);</pre>
<p>which map directly to the available versions of the expression, with the exception that the first argument (the <code class="literal">Authentication</code> object) is not supplied.
The first is used in situations where the domain object, to which access is being controlled, is already loaded.
Then expression will return true if the current user has the given permission for that object.
The second version is used in cases where the object is not loaded, but its identifier is known.
An abstract "type" specifier for the domain object is also required, allowing the correct ACL permissions to be loaded.
This has traditionally been the Java class of the object, but does not have to be as long as it is consistent with how the permissions are loaded.</p>
<p>To use <code class="literal">hasPermission()</code> expressions, you have to explicitly configure a <code class="literal">PermissionEvaluator</code> in your application context.
This would look something like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;security:global-method-security</span> <span class="hl-attribute">pre-post-annotations</span>=<span class="hl-value">"enabled"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;security:expression-handler</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"expressionHandler"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/security:global-method-security&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"expressionHandler"</span> <span class="hl-attribute">class</span>=
<span class="hl-value">"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"permissionEvaluator"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myPermissionEvaluator"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Where <code class="literal">myPermissionEvaluator</code> is the bean which implements <code class="literal">PermissionEvaluator</code>.
Usually this will be the implementation from the ACL module which is called <code class="literal">AclPermissionEvaluator</code>.
See the "Contacts" sample application configuration for more details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="method-security-meta-annotations" href="#method-security-meta-annotations"></a>Method Security Meta Annotations</h5></div></div></div>

<p>You can make use of meta annotations for method security to make your code more readable.
This is especially convenient if you find that you are repeating the same complex expression throughout your code base.
For example, consider the following:</p>
<pre class="programlisting">@PreAuthorize(<span class="hl-string">"#contact.name == authentication.name"</span>)</pre>
<p>Instead of repeating this everywhere, we can create a meta annotation that can be used instead.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@PreAuthorize("#contact.name == authentication.name")</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> ContactPermission {}</pre>
<p>Meta annotations can be used for any of the Spring Security method security annotations.
In order to remain compliant with the specification JSR-250 annotations do not support meta annotations.</p>
</div>
</div>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="web-app-security.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="servlet-applications.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="advanced-topics.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">10.&nbsp;Web Application Security&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;12.&nbsp;Additional Topics</td></tr></table></div></body></html>