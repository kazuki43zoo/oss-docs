<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>28.&nbsp;SFTP Adapters</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="rmi.html" title="27.&nbsp;RMI Support"><link rel="next" href="stomp.html" title="29.&nbsp;STOMP Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">28.&nbsp;SFTP Adapters</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="rmi.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="stomp.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="sftp" href="#sftp"></a>28.&nbsp;SFTP Adapters</h2></div></div></div>

<p>Spring Integration provides support for file transfer operations via SFTP.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-intro" href="#sftp-intro"></a>28.1&nbsp;Introduction</h2></div></div></div>

<p>The Secure File Transfer Protocol (SFTP) is a network protocol which allows you to transfer files between two computers on the Internet over any reliable stream.</p>
<p>The SFTP protocol requires a secure channel, such as SSH, as well as visibility to a client&#8217;s identity throughout the SFTP session.</p>
<p>Spring Integration supports sending and receiving files over SFTP by providing three <span class="emphasis"><em>client</em></span> side endpoints: <span class="emphasis"><em>Inbound Channel Adapter</em></span>, <span class="emphasis"><em>Outbound Channel Adapter</em></span>, and <span class="emphasis"><em>Outbound Gateway</em></span> It also provides convenient namespace configuration to define these <span class="emphasis"><em>client</em></span> components.</p>
<pre class="programlisting">xmlns:int-sftp="http://www.springframework.org/schema/integration/sftp"
xsi:schemaLocation="http://www.springframework.org/schema/integration/sftp
    http://www.springframework.org/schema/integration/sftp/spring-integration-sftp.xsd"</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-session-factory" href="#sftp-session-factory"></a>28.2&nbsp;SFTP Session Factory</h2></div></div></div>

<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with version 3.0, sessions are no longer cached by default.
See <a class="xref" href="sftp.html#sftp-session-caching" title="28.5&nbsp;SFTP Session Caching">Section&nbsp;28.5, &#8220;SFTP Session Caching&#8221;</a>.</p>
</td></tr></table></div>
<p>Before configuring SFTP adapters, you must configure an <span class="emphasis"><em>SFTP Session Factory</em></span>.
You can configure the <span class="emphasis"><em>SFTP Session Factory</em></span> via a regular bean definition:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sftpSessionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.sftp.session.DefaultSftpSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"host"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"privateKey"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:META-INF/keys/sftpTest"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"privateKeyPassphrase"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"springIntegration"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"22"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;beans:property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"kermit"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span></pre>
<p>Every time an adapter requests a session object from its <code class="literal">SessionFactory</code>, a new SFTP session is being created.
Under the covers, the SFTP Session Factory relies on the <a class="ulink" href="http://www.jcraft.com/jsch/" target="_top">JSch</a> library to provide the SFTP capabilities.</p>
<p>However, Spring Integration also supports the caching of SFTP sessions, please see <a class="xref" href="sftp.html#sftp-session-caching" title="28.5&nbsp;SFTP Session Caching">Section&nbsp;28.5, &#8220;SFTP Session Caching&#8221;</a> for more information.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>JSch supports multiple channels (operations) over a connection to the server.
By default, the Spring Integration session factory uses a separate physical connection for each channel.
Since <span class="emphasis"><em>Spring Integration 3.0</em></span>, you can configure the session factory (using a boolean constructor arg - default <code class="literal">false</code>) to use a single connection to the server and create multiple <code class="literal">JSch</code> channels on that single connection.</p>
<p>When using this feature, you must wrap the session factory in a caching session factory, as described below, so that the connection is not physically closed when an operation completes.</p>
<p>If the cache is reset, the session is disconnected only when the last channel is closed.</p>
<p>The connection will be refreshed if it is found to be disconnected when a new operation obtains a session.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you experience connectivity problems and would like to trace Session creation as well as see which Sessions are polled you may enable it by setting the logger to TRACE level (e.g., log4j.category.org.springframework.integration.sftp=TRACE).
Please also see <a class="xref" href="sftp.html#sftp-jsch-logging" title="28.12&nbsp;SFTP/JSCH Logging">Section&nbsp;28.12, &#8220;SFTP/JSCH Logging&#8221;</a>.</p>
</td></tr></table></div>
<p>Now all you need to do is inject this <span class="emphasis"><em>SFTP Session Factory</em></span> into your adapters.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>A more practical way to provide values for the <span class="emphasis"><em>SFTP Session Factory</em></span> would be via Spring&#8217;s <a class="ulink" href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-placeholderconfigurer" target="_top">property placeholder support</a>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sftp-session-factory-properties" href="#sftp-session-factory-properties"></a>28.2.1&nbsp;Configuration Properties</h3></div></div></div>

<p>Below you will find all properties that are exposed by the <a class="ulink" href="http://static.springsource.org/spring-integration/api/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.html" target="_top">DefaultSftpSessionFactory</a>.</p>
<p><span class="strong"><strong>isSharedSession (constructor argument)</strong></span></p>
<p>When true, a single connection will be used and <code class="literal">JSch Channels</code> will be multiplexed.
Defaults to false.</p>
<p><span class="strong"><strong>clientVersion</strong></span></p>
<p>Allows you to set the client version property.
It&#8217;s default depends on the underlying JSch version but it will look like:_SSH-2.0-JSCH-0.1.45_</p>
<p><span class="strong"><strong>enableDaemonThread</strong></span></p>
<p>If <code class="literal">true</code>, all threads will be daemon threads.
If set to <code class="literal">false</code>, normal non-daemon threads will be used instead.
This property will be set on the underlying <a class="ulink" href="http://epaul.github.io/jsch-documentation/javadoc/com/jcraft/jsch/Session.html" target="_top">Session</a>.
There, this property will default to <code class="literal">false</code>, if not explicitly set.</p>
<p><span class="strong"><strong>host</strong></span></p>
<p>The url of the host you want connect to.
<span class="emphasis"><em>Mandatory</em></span>.</p>
<p><span class="strong"><strong>hostKeyAlias</strong></span></p>
<p>Sets the host key alias, used when comparing the host key to the known hosts list.</p>
<p><span class="strong"><strong>knownHosts</strong></span></p>
<p>Specifies the filename that will be used for a host key repository.
The file has the same format as OpenSSH&#8217;s <span class="emphasis"><em>known_hosts</em></span> file and is required and must be pre-populated if
<code class="literal">allowUnknownKeys</code> is false.</p>
<p><span class="strong"><strong>password</strong></span></p>
<p>The password to authenticate against the remote host.
If a <span class="emphasis"><em>password</em></span> is not provided, then the <span class="emphasis"><em>privateKey</em></span> property is mandatory.
Not allowed if <code class="literal">userInfo</code> is set; the password is obtained from that object.</p>
<p><span class="strong"><strong>port</strong></span></p>
<p>The port over which the SFTP connection shall be established.
If not specified, this value defaults to <code class="literal">22</code>.
If specified, this properties must be a positive number.</p>
<p><span class="strong"><strong>privateKey</strong></span></p>
<p>Allows you to set a <a class="ulink" href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/Resource.html" target="_top">Resource</a>,
which represents the location of the private key used for authenticating against the remote host.
If the <span class="emphasis"><em>privateKey</em></span> is not provided, then the <span class="emphasis"><em>password</em></span> property is mandatory.</p>
<p><span class="strong"><strong>privateKeyPassphrase</strong></span></p>
<p>The password for the private key.
Not allowed if <code class="literal">userInfo</code> is set; the passphrase is obtained from that object.
Optional.</p>
<p><span class="strong"><strong>proxy</strong></span></p>
<p>Allows for specifying a JSch-based <a class="ulink" href="http://epaul.github.com/jsch-documentation/javadoc/com/jcraft/jsch/Proxy.html" target="_top">Proxy</a>.
If set, then the proxy object is used to create the connection to the remote host via the proxy.
See <a class="xref" href="sftp.html#sftp-proxy-factory-bean" title="28.3&nbsp;Proxy Factory Bean">Section&nbsp;28.3, &#8220;Proxy Factory Bean&#8221;</a> for a convenient way to configure the proxy.</p>
<p><span class="strong"><strong>serverAliveCountMax</strong></span></p>
<p>Specifies the number of server-alive messages, which will be sent without any reply from the server before disconnecting.
If not set, this property defaults to <code class="literal">1</code>.</p>
<p><span class="strong"><strong>serverAliveInterval</strong></span></p>
<p>Sets the timeout interval (milliseconds) before a server alive message is sent, in case no message is received from the server.</p>
<p><span class="strong"><strong>sessionConfig</strong></span></p>
<p>Using <code class="literal">Properties</code>, you can set additional configuration setting on the underlying JSch Session.</p>
<p><span class="strong"><strong>socketFactory</strong></span></p>
<p>Allows you to pass in a <a class="ulink" href="http://epaul.github.com/jsch-documentation/javadoc/com/jcraft/jsch/SocketFactory.html" target="_top">SocketFactory</a>.
The socket factory is used to create a socket to the target host.
When a proxy is used, the socket factory is passed to the proxy.
By default plain TCP sockets are used.</p>
<p><span class="strong"><strong>timeout</strong></span></p>
<p>The timeout property is used as the socket timeout parameter, as well as the default connection timeout.
Defaults to <code class="literal">0</code>, which means, that no timeout will occur.</p>
<p><span class="strong"><strong>user</strong></span></p>
<p>The remote user to use.
<span class="emphasis"><em>Mandatory</em></span>.</p>
<p><a name="sftp-unk-hosts" href="#sftp-unk-hosts"></a><span class="strong"><strong>allowUnknownKeys</strong></span></p>
<p>Set to <code class="literal">true</code> to allow connections to hosts with unknown (or changed) keys.
Default <span class="emphasis"><em>false</em></span> (since 4.2 - defaults to <code class="literal">true</code> in 4.1.7 and was not configurable before that version).
Only applied if no <code class="literal">userInfo</code> is provided.
If false, a pre-populated knownHosts file is required.</p>
<p><span class="strong"><strong>userInfo</strong></span></p>
<p>Set a custom <code class="literal">UserInfo</code> used during authentication.
In particular, be aware that <code class="literal">promptYesNo()</code> is invoked when an unknown (or changed) host key is received.
Also see <code class="literal">allowUnknownHosts</code>.
When a <code class="literal">UserInfo</code> is provided, the <code class="literal">password</code> and private key <code class="literal">passphrase</code> is obtained from it, and discrete
<code class="literal">password</code> and <code class="literal">privateKeyPassprase</code> properties cannot be set.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-proxy-factory-bean" href="#sftp-proxy-factory-bean"></a>28.3&nbsp;Proxy Factory Bean</h2></div></div></div>

<p><code class="literal">Jsch</code> provides a mechanism to connect to the server via an HTTP or SOCKS proxy.
To use this feature, configure the <code class="literal">Proxy</code> and provide a reference to the <code class="literal">DefaultSftpSessionFactory</code> as discussed
above.
Three implementations are provided by <code class="literal">Jsch</code>, <code class="literal">HTTP</code>, <code class="literal">SOCKS4</code> and <code class="literal">SOCKS5</code>.
<span class="emphasis"><em>Spring Integration 4.3</em></span> provides a <code class="literal">FactoryBean</code> making configuration of these proxies easier, allowing property
injection:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"proxySocks5"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.sftp.session.JschProxyFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SOCKS5"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${sftp.proxy.address}"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${sftp.proxy.port}"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${sftp.proxy.user}"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${sftp.proxy.pw}"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sessionFactory"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.sftp.session.DefaultSftpSessionFactory"</span><span class="hl-tag"> &gt;</span>
    ...
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"proxy"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"proxySocks5"</span><span class="hl-tag"> /&gt;</span>
    ...
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-dsf" href="#sftp-dsf"></a>28.4&nbsp;Delegating Session Factory</h2></div></div></div>

<p><span class="emphasis"><em>Version 4.2</em></span> introduced the <code class="literal">DelegatingSessionFactory</code> which allows the selection of the actual session factory at
runtime.
Prior to invoking the ftp endpoint, call <code class="literal">setThreadKey()</code> on the factory to associate a key with the current thread.
That key is then used to lookup the actual session factory to be used.
The key can be cleared by calling <code class="literal">clearThreadKey()</code> after use.</p>
<p>Convenience methods have been added so this can easily be done from a message flow:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dsf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.remote.session.DelegatingSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.file.remote.session.DefaultSessionFactoryLocator"</span><span class="hl-tag">&gt;</span>
            <span class="hl-comment">&lt;!-- delegate factories here --&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"c1"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"@dsf.setThreadKey(#root, headers['factoryToUse'])"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int-sftp:outbound-gateway</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"c1"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"c2"</span> <span class="hl-attribute">...</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"c2"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"@dsf.clearThreadKey(#root)"</span><span class="hl-tag"> /&gt;</span></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When using session caching (see <a class="xref" href="sftp.html#sftp-session-caching" title="28.5&nbsp;SFTP Session Caching">Section&nbsp;28.5, &#8220;SFTP Session Caching&#8221;</a>), each of the delegates should be cached; you
cannot cache the <code class="literal">DelegatingSessionFactory</code> itself.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-session-caching" href="#sftp-session-caching"></a>28.5&nbsp;SFTP Session Caching</h2></div></div></div>

<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>Spring Integration version 3.0</em></span>, sessions are no longer cached by default; the <code class="literal">cache-sessions</code> attribute is no longer supported on endpoints.
You must use a <code class="literal">CachingSessionFactory</code> (see below) if you wish to cache sessions.</p>
</td></tr></table></div>
<p>In versions prior to 3.0, the sessions were cached automatically by default.
A <code class="literal">cache-sessions</code> attribute was available for disabling the auto caching, but that solution did not provide a way to configure other session caching attributes.
For example, you could not limit on the number of sessions created.
To support that requirement and other configuration options, a <code class="literal">CachingSessionFactory</code> was provided.
It provides <code class="literal">sessionCacheSize</code> and <code class="literal">sessionWaitTimeout</code> properties.
As its name suggests, the <code class="literal">sessionCacheSize</code> property controls how many active sessions the factory will maintain in its cache (the DEFAULT is unbounded).
If the <code class="literal">sessionCacheSize</code> threshold has been reached, any attempt to acquire another session will block until either one of the cached sessions becomes available or until the wait time for a Session expires (the DEFAULT wait time is Integer.MAX_VALUE).
The <code class="literal">sessionWaitTimeout</code> property enables configuration of that value.</p>
<p>If you want your Sessions to be cached, simply configure your default Session Factory as described above and then wrap it in an instance of <code class="literal">CachingSessionFactory</code> where you may provide those additional properties.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sftpSessionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.sftp.session.DefaultSftpSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"host"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cachingSessionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.remote.session.CachingSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sftpSessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionWaitTimeout"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>In the above example you see a <code class="literal">CachingSessionFactory</code> created with the <code class="literal">sessionCacheSize</code> set to 10 and the <code class="literal">sessionWaitTimeout</code> set to 1 second (its value is in milliseconds).</p>
<p>Starting with <span class="emphasis"><em>Spring Integration version 3.0</em></span>, the <code class="literal">CachingConnectionFactory</code> provides a <code class="literal">resetCache()</code> method.
When invoked, all idle sessions are immediately closed and in-use sessions are closed when they are returned to the cache.
When using <code class="literal">isSharedSession=true</code>, the channel is closed, and the shared session is closed only when the last channel is closed.
New requests for sessions will establish new sessions as necessary.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-rft" href="#sftp-rft"></a>28.6&nbsp;RemoteFileTemplate</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>Spring Integration version 3.0</em></span>, a new abstraction is provided over the <code class="literal">SftpSession</code> object.
The template provides methods to send, retrieve (as an <code class="literal">InputStream</code>), remove, and rename files.
In addition an <code class="literal">execute</code> method is provided allowing the caller to execute multiple operations on the session.
In all cases, the template takes care of reliably closing the session.
For more information, refer to the <a class="ulink" href="http://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html" target="_top">javadocs for <code class="literal">RemoteFileTemplate</code></a> There is a subclass for SFTP: <code class="literal">SftpRemoteFileTemplate</code>.</p>
<p>Additional methods were added in <span class="emphasis"><em>version 4.1</em></span> including <code class="literal">getClientInstance()</code> which provides access to the underlying <code class="literal">ChannelSftp</code> enabling access to low-level APIs.</p>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the new <code class="literal">RemoteFileOperations.invoke(OperationsCallback&lt;F, T&gt; action)</code> method is available.
This method allows several <code class="literal">RemoteFileOperations</code> calls to be called in the scope of the same, thread-bounded, <code class="literal">Session</code>.
This is useful when you need to perform several high-level operations of the <code class="literal">RemoteFileTemplate</code> as one unit of work.
For example <code class="literal">AbstractRemoteFileOutboundGateway</code> uses it with the <span class="emphasis"><em>mput</em></span> command implementation, where we perform a <span class="emphasis"><em>put</em></span> operation for each file in the provided directory and recursively for its sub-directories.
See the JavaDocs for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-inbound" href="#sftp-inbound"></a>28.7&nbsp;SFTP Inbound Channel Adapter</h2></div></div></div>

<p>The <span class="emphasis"><em>SFTP Inbound Channel Adapter</em></span> is a special listener that will connect to the server and listen for the remote directory events (e.g., new file created) at which point it will initiate a file transfer.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-sftp:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sftpAdapterAutoCreate"</span>
              <span class="hl-attribute">session-factory</span>=<span class="hl-value">"sftpSessionFactory"</span>
            <span class="hl-attribute">channel</span>=<span class="hl-value">"requestChannel"</span>
            <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"*.txt"</span>
            <span class="hl-attribute">remote-directory</span>=<span class="hl-value">"/foo/bar"</span>
            <span class="hl-attribute">preserve-timestamp</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">local-directory</span>=<span class="hl-value">"file:target/foo"</span>
            <span class="hl-attribute">auto-create-local-directory</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">local-filename-generator-expression</span>=<span class="hl-value">"#this.toUpperCase() + '.a'"</span>
            <span class="hl-attribute">scanner</span>=<span class="hl-value">"myDirScanner"</span>
            <span class="hl-attribute">local-filter</span>=<span class="hl-value">"myFilter"</span>
            <span class="hl-attribute">temporary-file-suffix</span>=<span class="hl-value">".writing"</span>
            <span class="hl-attribute">max-fetch-size</span>=<span class="hl-value">"-1"</span>
            <span class="hl-attribute">delete-remote-files</span>=<span class="hl-value">"false"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-sftp:inbound-channel-adapter&gt;</span></pre>
<p>As you can see from the configuration above you can configure the <span class="emphasis"><em>SFTP Inbound Channel Adapter</em></span> via the <code class="literal">inbound-channel-adapter</code> element while also providing values for various attributes such as <code class="literal">local-directory</code> - where files are going to be transferred TO and <code class="literal">remote-directory</code> - the remote source directory where files are going to be transferred FROM - as well as other attributes including a <code class="literal">session-factory</code> reference to the bean we configured earlier.</p>
<p>By default the transferred file will carry the same name as the original file.
If you want to override this behavior you can set the <code class="literal">local-filename-generator-expression</code> attribute which allows you to provide a SpEL Expression to generate the name of the local file.
Unlike outbound gateways and adapters where the root object of the SpEL Evaluation Context is a <code class="literal">Message</code>, this inbound adapter does not yet have the Message at the time of evaluation since that&#8217;s what it ultimately generates with the transferred file as its payload.
So, the root object of the SpEL Evaluation Context is the original name of the remote file (String).</p>
<p>The inbound channel adapter first retrieves the file to a local directory and then emits each file according to the poller configuration.
Starting with <span class="emphasis"><em>version 5.0</em></span> you can now limit the number of files fetched from the FTP server when new file retrievals are needed.
This can be beneficial when the target files are very large and/or when running in a clustered system with a persistent file list filter discussed below.
Use <code class="literal">max-fetch-size</code> for this purpose; a negative value (default) means no limit and all matching files will be retrieved; see <a class="xref" href="sftp.html#sftp-max-fetch" title="28.9&nbsp;Inbound Channel Adapters: Controlling Remote File Fetching">Section&nbsp;28.9, &#8220;Inbound Channel Adapters: Controlling Remote File Fetching&#8221;</a> for more information.
Since <span class="emphasis"><em>version 5.0</em></span>, you can also provide a custom <code class="literal">DirectoryScanner</code> implementation to the <code class="literal">inbound-channel-adapter</code> via the <code class="literal">scanner</code> attribute.</p>
<p>Starting with <span class="emphasis"><em>Spring Integration 3.0</em></span>, you can specify the <code class="literal">preserve-timestamp</code> attribute (default <code class="literal">false</code>); when <code class="literal">true</code>, the local file&#8217;s modified timestamp will be set to the value retrieved from the server; otherwise it will be set to the current time.</p>
<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, you can specify <code class="literal">remote-directory-expression</code> instead of <code class="literal">remote-directory</code>, allowing
you to dynamically determine the directory on each poll.
e.g <code class="literal">remote-directory-expression="@myBean.determineRemoteDir()"</code>.</p>
<p>Sometimes file filtering based on the simple pattern specified via <code class="literal">filename-pattern</code> attribute might not be sufficient.
If this is the case, you can use the <code class="literal">filename-regex</code> attribute to specify a Regular Expression (e.g.
<code class="literal">filename-regex=".*\.test$"</code>).
And of course if you need complete control you can use the <code class="literal">filter</code> attribute to provide a reference to a custom implementation of the <code class="literal">org.springframework.integration.file.filters.FileListFilter</code> - a strategy interface for filtering a list of files.
This filter determines which remote files are retrieved.
You can also combine a pattern based filter with other filters, such as an <code class="literal">AcceptOnceFileListFilter</code> to avoid synchronizing files that have previously been fetched, by using a <code class="literal">CompositeFileListFilter</code>.</p>
<p>The <code class="literal">AcceptOnceFileListFilter</code> stores its state in memory.
If you wish the state to survive a system restart, consider using the <code class="literal">SftpPersistentAcceptOnceFileListFilter</code> instead.
This filter stores the accepted file names in an instance of the <code class="literal">MetadataStore</code> strategy (<a class="xref" href="system-management-chapter.html#metadata-store" title="10.5&nbsp;Metadata Store">Section&nbsp;10.5, &#8220;Metadata Store&#8221;</a>).
This filter matches on the filename and the remote modified time.</p>
<p>Since <span class="emphasis"><em>version 4.0</em></span>, this filter requires a <code class="literal">ConcurrentMetadataStore</code>.
When used with a shared data store (such as <code class="literal">Redis</code> with the <code class="literal">RedisMetadataStore</code>) this allows filter keys to be shared across multiple application or server instances.</p>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the <code class="literal">SftpPersistentAcceptOnceFileListFilter</code> with in-memory <code class="literal">SimpleMetadataStore</code> is applied by default for the <code class="literal">SftpInboundFileSynchronizer</code>.
This filter is also applied together with the <code class="literal">regex</code> or <code class="literal">pattern</code> option in the XML configuration as well as via <code class="literal">FtpInboundChannelAdapterSpec</code> in Java DSL.
Any other use-cases can be reached via <code class="literal">CompositeFileListFilter</code> (or <code class="literal">ChainFileListFilter</code>).</p>
<p>The above discussion refers to filtering the files before retrieving them.
Once the files have been retrieved, an additional filter is applied to the files on the file system.
By default, this is an`AcceptOnceFileListFilter` which, as discussed, retains state in memory and does not consider the file&#8217;s modified time.
Unless your application removes files after processing, the adapter will re-process the files on disk by default after an application restart.</p>
<p>Also, if you configure the <code class="literal">filter</code> to use a <code class="literal">FtpPersistentAcceptOnceFileListFilter</code>, and the remote file timestamp changes (causing it to be re-fetched), the default local filter will not allow this new file to be processed.</p>
<p>Use the <code class="literal">local-filter</code> attribute to configure the behavior of the local file system filter.
Starting with <span class="emphasis"><em>version 4.3.8</em></span>, a <code class="literal">FileSystemPersistentAcceptOnceFileListFilter</code> is configured by default.
This filter stores the accepted file names and modified timestamp in an instance of the <code class="literal">MetadataStore</code> strategy (<a class="xref" href="system-management-chapter.html#metadata-store" title="10.5&nbsp;Metadata Store">Section&nbsp;10.5, &#8220;Metadata Store&#8221;</a>), and will detect changes to the local file modified time.
The default <code class="literal">MetadataStore</code> is a <code class="literal">SimpleMetadataStore</code> which stores state in memory.</p>
<p>Since <span class="emphasis"><em>version 4.1.5</em></span>, these filters have a new property <code class="literal">flushOnUpdate</code> which will cause them to flush the
metadata store on every update (if the store implements <code class="literal">Flushable</code>).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Further, if you use a distributed <code class="literal">MetadataStore</code> (such as <a class="xref" href="redis.html#redis-metadata-store" title="25.5&nbsp;Redis Metadata Store">Section&nbsp;25.5, &#8220;Redis Metadata Store&#8221;</a> or <a class="xref" href="gemfire.html#gemfire-metadata-store" title="17.7&nbsp;Gemfire Metadata Store">Section&nbsp;17.7, &#8220;Gemfire Metadata Store&#8221;</a>) you can have multiple instances of the same adapter/application and be sure that one and only one will process a file.</p>
</td></tr></table></div>
<p>The actual local filter is a <code class="literal">CompositeFileListFilter</code> containing the supplied filter and a pattern filter that prevents processing files that are in the process of being downloaded (based on the <code class="literal">temporary-file-suffix</code>); files are downloaded with this suffix (default: <code class="literal">.writing</code>) and the file is renamed to its final name when the transfer is complete, making it <span class="emphasis"><em>visible</em></span> to the filter.</p>
<p>Please refer to the schema for more detail on these attributes.</p>
<p>It is also important to understand that <span class="emphasis"><em>SFTP Inbound Channel Adapter</em></span> is a Polling Consumer and therefore you must configure a poller (either a global default or a local sub-element).
Once the file has been transferred to a local directory, a Message with <code class="literal">java.io.File</code> as its payload type will be generated and sent to the channel identified by the <code class="literal">channel</code> attribute.</p>
<p><span class="emphasis"><em>More on File Filtering and Large Files</em></span></p>
<p>Sometimes a file that just appeared in the monitored (remote) directory is not complete.
Typically such a file will be written with some temporary extension (e.g., foo.txt.writing) and then renamed after the writing process completes.
As a user in most cases you are only interested in files that are complete and would like to filter only those files.
To handle these scenarios, use filtering support provided via the <code class="literal">filename-pattern</code>, <code class="literal">filename-regex</code> and <code class="literal">filter</code> attributes.
If you need a custom filter implementation simply include a reference in your adapter via the <code class="literal">filter</code> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-sftp:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sftpInbondAdapter"</span>
            <span class="hl-attribute">channel</span>=<span class="hl-value">"receiveChannel"</span>
            <span class="hl-attribute">session-factory</span>=<span class="hl-value">"sftpSessionFactory"</span>
            <span class="hl-attribute">filter</span>=<span class="hl-value">"customFilter"</span>
            <span class="hl-attribute">local-directory</span>=<span class="hl-value">"file:/local-test-dir"</span>
            <span class="hl-attribute">remote-directory</span>=<span class="hl-value">"/remote-test-dir"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"10"</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"executor"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-sftp:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customFilter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.CustomFilter"</span><span class="hl-tag">/&gt;</span></pre>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_recovering_from_failures_2" href="#_recovering_from_failures_2"></a>28.7.1&nbsp;Recovering from Failures</h3></div></div></div>

<p>It is important to understand the architecture of the adapter.
There is a file synchronizer which fetches the files, and a <code class="literal">FileReadingMessageSource</code> to emit a message for each
synchronized file.
As discussed above, there are two filters involved.
The <code class="literal">filter</code> attribute (and patterns) refers to the remote (SFTP) file list - to avoid fetching files that have already
been fetched.
The <code class="literal">local-filter</code> is used by the <code class="literal">FileReadingMessageSource</code> to determine which files are to be sent as messages.</p>
<p>The synchronizer lists the remote files and consults its filter; the files are then transferred.
If an IO error occurs during file transfer, any files that have already been added to the filter are removed so they
are eligible to be re-fetched on the next poll.
This only applies if the filter implements <code class="literal">ReversibleFileListFilter</code> (such as the <code class="literal">AcceptOnceFileListFilter</code>).</p>
<p>If, after synchronizing the files, an error occurs on the downstream flow processing a file, there is <span class="emphasis"><em>no</em></span> automatic
rollback of the filter so the failed file will <span class="emphasis"><em>not</em></span> be reprocessed by default.</p>
<p>If you wish to reprocess such files after a failure, you can use configuration similar to the following to facilitate
the removal of the failed file from the filter.
This will work for any <code class="literal">ResettableFileListFilter</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-sftp:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sftpAdapter"</span>
        <span class="hl-attribute">session-factory</span>=<span class="hl-value">"sftpSessionFactory"</span>
        <span class="hl-attribute">channel</span>=<span class="hl-value">"requestChannel"</span>
        <span class="hl-attribute">remote-directory-expression</span>=<span class="hl-value">"'/sftpSource'"</span>
        <span class="hl-attribute">local-directory</span>=<span class="hl-value">"file:myLocalDir"</span>
        <span class="hl-attribute">auto-create-local-directory</span>=<span class="hl-value">"true"</span>
        <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"*.txt"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">synchronization-factory</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int-sftp:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"acceptOnceFilter"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.filters.AcceptOnceFileListFilter"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:transaction-synchronization-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:after-rollback</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload.delete()"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:transaction-synchronization-factory&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.transaction.PseudoTransactionManager"</span><span class="hl-tag"> /&gt;</span></pre>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the Inbound Channel Adapter can build sub-directories locally according the generated local file name.
That can be a remote sub-path as well.
To be able to read local directory recursively for modification according the hierarchy support, an internal <code class="literal">FileReadingMessageSource</code> now can bve supplied with a new <code class="literal">RecursiveDirectoryScanner</code> based on the <code class="literal">Files.walk()</code> algorithm.
See <code class="literal">AbstractInboundFileSynchronizingMessageSource.setScanner()</code> for more information.
Also the <code class="literal">AbstractInboundFileSynchronizingMessageSource</code> can now be switched to the <code class="literal">WatchService</code> -based <code class="literal">DirectoryScanner</code> via <code class="literal">setUseWatchService()</code> option.
It is also configured for all the <code class="literal">WatchEventType</code> s to react for any modifications in local directory.
The reprocessing sample above is based on the build-in functionality of the <code class="literal">FileReadingMessageSource.WatchServiceDirectoryScanner</code> to perform <code class="literal">ResettableFileListFilter.remove()</code> when the file is deleted (<code class="literal">StandardWatchEventKinds.ENTRY_DELETE</code>) from the local directory.
See <a class="xref" href="files.html#watch-service-directory-scanner" title="15.2.2&nbsp;WatchServiceDirectoryScanner">Section&nbsp;15.2.2, &#8220;WatchServiceDirectoryScanner&#8221;</a> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_23" href="#_configuring_with_java_configuration_23"></a>28.7.2&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the inbound adapter using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;LsEntry&gt; sftpSessionFactory() {
        DefaultSftpSessionFactory factory = <span class="hl-keyword">new</span> DefaultSftpSessionFactory(true);
        factory.setHost(<span class="hl-string">"localhost"</span>);
        factory.setPort(port);
        factory.setUser(<span class="hl-string">"foo"</span>);
        factory.setPassword(<span class="hl-string">"foo"</span>);
        factory.setAllowUnknownKeys(true);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;LsEntry&gt;(factory);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SftpInboundFileSynchronizer sftpInboundFileSynchronizer() {
        SftpInboundFileSynchronizer fileSynchronizer = <span class="hl-keyword">new</span> SftpInboundFileSynchronizer(sftpSessionFactory());
        fileSynchronizer.setDeleteRemoteFiles(false);
        fileSynchronizer.setRemoteDirectory(<span class="hl-string">"foo"</span>);
        fileSynchronizer.setFilter(<span class="hl-keyword">new</span> SftpSimplePatternFileListFilter(<span class="hl-string">"*.xml"</span>));
        <span class="hl-keyword">return</span> fileSynchronizer;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = "sftpChannel", poller = @Poller(fixedDelay = "5000"))</span></em>
    <span class="hl-keyword">public</span> MessageSource&lt;File&gt; sftpMessageSource() {
        SftpInboundFileSynchronizingMessageSource source =
                <span class="hl-keyword">new</span> SftpInboundFileSynchronizingMessageSource(sftpInboundFileSynchronizer());
        source.setLocalDirectory(<span class="hl-keyword">new</span> File(<span class="hl-string">"sftp-inbound"</span>));
        source.setAutoCreateLocalDirectory(true);
        source.setLocalFilter(<span class="hl-keyword">new</span> AcceptOnceFileListFilter&lt;File&gt;());
        source.setMaxFetchSize(<span class="hl-number">1</span>);
        <span class="hl-keyword">return</span> source;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "sftpChannel")</span></em>
    <span class="hl-keyword">public</span> MessageHandler handler() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> MessageHandler() {

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handleMessage(Message&lt;?&gt; message) <span class="hl-keyword">throws</span> MessagingException {
                System.out.println(message.getPayload());
            }

        };
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl_19" href="#_configuring_with_the_java_dsl_19"></a>28.7.3&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the inbound adapter using the Java DSL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow sftpInboundFlow() {
        <span class="hl-keyword">return</span> IntegrationFlows
            .from(s -&gt; s.sftp(<span class="hl-keyword">this</span>.sftpSessionFactory)
                    .preserveTimestamp(true)
                    .remoteDirectory(<span class="hl-string">"foo"</span>)
                    .regexFilter(<span class="hl-string">".*\\.txt$"</span>)
                    .localFilenameExpression(<span class="hl-string">"#this.toUpperCase() + '.a'"</span>)
                    .localDirectory(<span class="hl-keyword">new</span> File(<span class="hl-string">"sftp-inbound"</span>)),
                 e -&gt; e.id(<span class="hl-string">"sftpInboundAdapter"</span>)
                    .autoStartup(true)
                    .poller(Pollers.fixedDelay(<span class="hl-number">5000</span>)))
            .handle(m -&gt; System.out.println(m.getPayload()))
            .get();
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sftp-incomplete" href="#sftp-incomplete"></a>28.7.4&nbsp;Dealing With Incomplete Data</h3></div></div></div>

<p>See <a class="xref" href="files.html#file-incomplete" title="15.2.7&nbsp;Dealing With Incomplete Data">Section&nbsp;15.2.7, &#8220;Dealing With Incomplete Data&#8221;</a>.</p>
<p>The <code class="literal">SftpSystemMarkerFilePresentFileListFilter</code> is provided to filter remote files that don&#8217;t have the corresponding marker file on the remote system.
See the javadocs for configuration information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-streaming" href="#sftp-streaming"></a>28.8&nbsp;SFTP Streaming Inbound Channel Adapter</h2></div></div></div>

<p>The streaming inbound channel adapter was introduced in <span class="emphasis"><em>version 4.3</em></span>.
This adapter produces message with payloads of type <code class="literal">InputStream</code>, allowing files to be fetched without writing to the
local file system.
Since the session remains open, the consuming application is responsible for closing the session when the file has been
consumed.
The session is provided in the <code class="literal">closeableResource</code> header (<code class="literal">IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE</code>).
Standard framework components, such as the <code class="literal">FileSplitter</code> and <code class="literal">StreamTransformer</code> will automatically close the session.
See <a class="xref" href="files.html#file-splitter" title="15.5&nbsp;File Splitter">Section&nbsp;15.5, &#8220;File Splitter&#8221;</a> and <a class="xref" href="messaging-transformation-chapter.html#stream-transformer" title="Stream Transformer">the section called &#8220;Stream Transformer&#8221;</a> for more information about these components.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-sftp:inbound-streaming-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpInbound"</span>
            <span class="hl-attribute">channel</span>=<span class="hl-value">"ftpChannel"</span>
            <span class="hl-attribute">session-factory</span>=<span class="hl-value">"sessionFactory"</span>
            <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"*.txt"</span>
            <span class="hl-attribute">filename-regex</span>=<span class="hl-value">".*\.txt"</span>
            <span class="hl-attribute">filter</span>=<span class="hl-value">"filter"</span>
            <span class="hl-attribute">filter-expression</span>=<span class="hl-value">"@myFilterBean.check(#root)"</span>
            <span class="hl-attribute">remote-file-separator</span>=<span class="hl-value">"/"</span>
            <span class="hl-attribute">comparator</span>=<span class="hl-value">"comparator"</span>
            <span class="hl-attribute">max-fetch-size</span>=<span class="hl-value">"1"</span>
            <span class="hl-attribute">remote-directory-expression</span>=<span class="hl-value">"'foo/bar'"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int-sftp:inbound-streaming-channel-adapter&gt;</span></pre>
<p>Only one of <code class="literal">filename-pattern</code>, <code class="literal">filename-regex</code>, <code class="literal">filter</code> or <code class="literal">filter-expression</code> is allowed.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, by default, the <code class="literal">SftpStreamingMessageSource</code> adapter prevents duplicates for remote files via <code class="literal">SftpPersistentAcceptOnceFileListFilter</code> based on the in-memory <code class="literal">SimpleMetadataStore</code>.
This filter is also applied by default together with the filename pattern (or regex) as well.
If there is a requirement to allow duplicates, the <code class="literal">AcceptAllFileListFilter</code> can be used.
Any other use-cases can be reached via <code class="literal">CompositeFileListFilter</code> (or <code class="literal">ChainFileListFilter</code>).
The java configuration below shows one technique to remove the remote file after processing, avoiding duplicates.</p>
</td></tr></table></div>
<p>Use the <code class="literal">max-fetch-size</code> attribute to limit the number of files fetched on each poll when a fetch is necessary; set to 1 and use a persistent filter when running in a clustered environment; see <a class="xref" href="sftp.html#sftp-max-fetch" title="28.9&nbsp;Inbound Channel Adapters: Controlling Remote File Fetching">Section&nbsp;28.9, &#8220;Inbound Channel Adapters: Controlling Remote File Fetching&#8221;</a> for more information.</p>
<p>The adapter puts the remote directory and file name in headers <code class="literal">FileHeaders.REMOTE_DIRECTORY</code> and <code class="literal">FileHeaders.REMOTE_FILE</code> respectively.
Starting with <span class="emphasis"><em>version 5.0</em></span>, additional remote file information, in JSON, is provided in the <code class="literal">FileHeaders.REMOTE_FILE_INFO</code> header.
If you set the <code class="literal">fileInfoJson</code> property on the <code class="literal">SftpStreamingMessageSource</code> to <code class="literal">false</code>, the header will contain an <code class="literal">SftpFileInfo</code> object.
The <code class="literal">LsEntry</code> object provided by the underlying Jsch library can be accessed using the <code class="literal">SftpFileInfo.getFileInfo()</code> method.
The <code class="literal">fileInfoJson</code> property is not available when using XML configuration but you can set it by injecting the <code class="literal">SftpStreamingMessageSource</code> into one of your configuration classes.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_24" href="#_configuring_with_java_configuration_24"></a>28.8.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the inbound adapter using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = "stream")</span></em>
    <span class="hl-keyword">public</span> MessageSource&lt;InputStream&gt; ftpMessageSource() {
        SftpStreamingMessageSource messageSource = <span class="hl-keyword">new</span> SftpStreamingMessageSource(template());
        messageSource.setRemoteDirectory(<span class="hl-string">"sftpSource/"</span>);
        messageSource.setFilter(<span class="hl-keyword">new</span> AcceptAllFileListFilter&lt;&gt;());
        messageSource.setMaxFetchSize(<span class="hl-number">1</span>);
        <span class="hl-keyword">return</span> messageSource;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = "stream", outputChannel = "data")</span></em>
    <span class="hl-keyword">public</span> org.springframework.integration.transformer.Transformer transformer() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> StreamTransformer(<span class="hl-string">"UTF-8"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SftpRemoteFileTemplate template() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SftpRemoteFileTemplate(sftpSessionFactory());
    }

    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "data", adviceChain = "after")</span></em>
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> MessageHandler handle() {
        <span class="hl-keyword">return</span> System.out::println;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> ExpressionEvaluatingRequestHandlerAdvice after() {
        ExpressionEvaluatingRequestHandlerAdvice advice = <span class="hl-keyword">new</span> ExpressionEvaluatingRequestHandlerAdvice();
        advice.setOnSuccessExpression(
                <span class="hl-string">"@template.remove(headers['file_remoteDirectory'] + headers['file_remoteFile'])"</span>);
        advice.setPropagateEvaluationFailures(true);
        <span class="hl-keyword">return</span> advice;
    }

}</pre>
<p>Notice that, in this example, the message handler downstream of the transformer has an advice that removes the remote file after processing.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-max-fetch" href="#sftp-max-fetch"></a>28.9&nbsp;Inbound Channel Adapters: Controlling Remote File Fetching</h2></div></div></div>

<p>There are two properties that should be considered when configuring inbound channel adapters.
<code class="literal">max-messages-per-poll</code>, as with all pollers, can be used to limit the number of messages emitted on each poll (if more than the configured value are ready).
<code class="literal">max-fetch-size</code> (since <span class="emphasis"><em>version 5.0</em></span>) can limit the number of files retrieved from the remote server at a time.</p>
<p>The following scenarios assume the starting state is an empty local directory.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">max-messages-per-poll=2</code> and <code class="literal">max-fetch-size=1</code>, the adapter will fetch one file, emit it, fetch the next file, emit it; then sleep until the next poll.
</li><li class="listitem">
<code class="literal">max-messages-per-poll=2</code> and <code class="literal">max-fetch-size=2</code>), the adapter will fetch both files, then emit each one.
</li><li class="listitem">
<code class="literal">max-messages-per-poll=2</code> and <code class="literal">max-fetch-size=4</code>, the adapter will fetch up to 4 files (if available) and emit the first two (if there are at least two); the next two files will be emitted on the next poll.
</li><li class="listitem">
<code class="literal">max-messages-per-poll=2</code> and <code class="literal">max-fetch-size</code> not specified, the adapter will fetch all remote files and emit the first two (if there are at least two); the subsequent files will be emitted on subsequent polls (2-at-a-time); when all are consumed, the remote fetch will be attempted again, to pick up any new files.
</li></ul></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When deploying multiple instances of an application, a small <code class="literal">max-fetch-size</code> is recommended to avoid one instance "grabbing" all the files and starving other instances.</p>
</td></tr></table></div>
<p>Another use for <code class="literal">max-fetch-size</code> is if you want to stop fetching remote files, but continue to process files that have already been fetched.
Setting the <code class="literal">maxFetchSize</code> property on the <code class="literal">MessageSource</code> (programmatically, via JMX, or via a <a class="link" href="system-management-chapter.html#control-bus" title="10.6&nbsp;Control Bus">control bus</a>) effectively stops the adapter from fetching more files, but allows the poller to continue to emit messages for files that have previously been fetched.
If the poller is active when the property is changed, the change will take effect on the next poll.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-outbound" href="#sftp-outbound"></a>28.10&nbsp;SFTP Outbound Channel Adapter</h2></div></div></div>

<p>The <span class="emphasis"><em>SFTP Outbound Channel Adapter</em></span> is a special <code class="literal">MessageHandler</code> that will connect to the remote directory and will
initiate a file transfer for every file it will receive as the payload of an incoming <code class="literal">Message</code>.
It also supports several representations of the File so you are not limited to the File object.
Similar to the FTP outbound adapter, the <span class="emphasis"><em>SFTP Outbound Channel Adapter</em></span> supports the following payloads:
1) <code class="literal">java.io.File</code> - the actual file object;
2) <code class="literal">byte[]</code> - byte array that represents the file contents;
3) <code class="literal">java.lang.String</code> - text that represents the file contents.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-sftp:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sftpOutboundAdapter"</span>
    <span class="hl-attribute">session-factory</span>=<span class="hl-value">"sftpSessionFactory"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"inputChannel"</span>
    <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>
    <span class="hl-attribute">remote-file-separator</span>=<span class="hl-value">"/"</span>
    <span class="hl-attribute">remote-directory</span>=<span class="hl-value">"foo/bar"</span>
    <span class="hl-attribute">remote-filename-generator-expression</span>=<span class="hl-value">"payload.getName() + '-foo'"</span>
    <span class="hl-attribute">filename-generator</span>=<span class="hl-value">"fileNameGenerator"</span>
    <span class="hl-attribute">use-temporary-filename</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">chmod</span>=<span class="hl-value">"600"</span>
    <span class="hl-attribute">mode</span>=<span class="hl-value">"REPLACE"</span><span class="hl-tag">/&gt;</span></pre>
<p>As you can see from the configuration above you can configure the <span class="emphasis"><em>SFTP Outbound Channel Adapter</em></span> via the <code class="literal">outbound-channel-adapter</code> element.
Please refer to the schema for more detail on these attributes.</p>
<p><span class="emphasis"><em>SpEL and the SFTP Outbound Adapter</em></span></p>
<p>As with many other components in Spring Integration, you can benefit from the Spring Expression Language (SpEL) support when configuring an <span class="emphasis"><em>SFTP Outbound Channel Adapter</em></span>, by specifying two attributes <code class="literal">remote-directory-expression</code> and <code class="literal">remote-filename-generator-expression</code> (see above).
The expression evaluation context will have the Message as its root object, thus allowing you to provide expressions which can dynamically compute the <span class="emphasis"><em>file name</em></span> or the existing <span class="emphasis"><em>directory path</em></span> based on the data in the Message (either from <span class="emphasis"><em>payload</em></span> or <span class="emphasis"><em>headers</em></span>).
In the example above we are defining the <code class="literal">remote-filename-generator-expression</code> attribute with an expression value that computes the <span class="emphasis"><em>file name</em></span> based on its original name while also appending a suffix: <span class="emphasis"><em>-foo</em></span>.</p>
<p>Starting with <span class="emphasis"><em>version 4.1</em></span>, you can specify the <code class="literal">mode</code> when transferring the file.
By default, an existing file will be overwritten; the modes are defined on <code class="literal">enum</code> <code class="literal">FileExistsMode</code>, having values <code class="literal">REPLACE</code> (default), <code class="literal">APPEND</code>, <code class="literal">IGNORE</code>, and <code class="literal">FAIL</code>.
With <code class="literal">IGNORE</code> and <code class="literal">FAIL</code>, the file is not transferred; <code class="literal">FAIL</code> causes an exception to be thrown whereas <code class="literal">IGNORE</code> silently ignores the transfer (although a <code class="literal">DEBUG</code> log entry is produced).</p>
<p><span class="emphasis"><em>Avoiding Partially Written Files</em></span></p>
<p>One of the common problems, when dealing with file transfers, is the possibility of processing a <span class="emphasis"><em>partial file</em></span> - a file might appear in the file system before its transfer is actually complete.</p>
<p>To deal with this issue, Spring Integration SFTP adapters use a very common algorithm where files are transferred under a temporary name and than renamed once they are fully transferred.</p>
<p>By default, every file that is in the process of being transferred will appear in the file system with an additional suffix which, by default, is <code class="literal">.writing</code>; this can be changed using the <code class="literal">temporary-file-suffix</code> attribute.</p>
<p>However, there may be situations where you don&#8217;t want to use this technique (for example, if the server does not permit renaming files).
For situations like this, you can disable this feature by setting <code class="literal">use-temporary-file-name</code> to <code class="literal">false</code> (default is <code class="literal">true</code>).
When this attribute is <code class="literal">false</code>, the file is written with its final name and the consuming application will need some other mechanism to detect that the file is completely uploaded before accessing it.</p>
<p><span class="emphasis"><em>Version 4.3</em></span> introduced the <code class="literal">chmod</code> attribute which changes the remote file permissions after upload.
Use the conventional Unix octal format, e.g. <code class="literal">600</code> allows read-write for the file owner only.
When configuring the adapter using java, you can use <code class="literal">setChmodOctal("600")</code> or <code class="literal">setChmodDecimal(384)</code>.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_25" href="#_configuring_with_java_configuration_25"></a>28.10.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Adapter using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@IntegrationComponentScan</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context =
                    <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
                        .web(false)
                        .run(args);
        MyGateway gateway = context.getBean(MyGateway.<span class="hl-keyword">class</span>);
        gateway.sendToSftp(<span class="hl-keyword">new</span> File(<span class="hl-string">"/foo/bar.txt"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;LsEntry&gt; sftpSessionFactory() {
        DefaultSftpSessionFactory factory = <span class="hl-keyword">new</span> DefaultSftpSessionFactory(true);
        factory.setHost(<span class="hl-string">"localhost"</span>);
        factory.setPort(port);
        factory.setUser(<span class="hl-string">"foo"</span>);
        factory.setPassword(<span class="hl-string">"foo"</span>);
        factory.setAllowUnknownKeys(true);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;LsEntry&gt;(factory);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "toSftpChannel")</span></em>
    <span class="hl-keyword">public</span> MessageHandler handler() {
        SftpMessageHandler handler = <span class="hl-keyword">new</span> SftpMessageHandler(sftpSessionFactory());
        handler.setRemoteDirectoryExpressionString(<span class="hl-string">"headers['remote-target-dir']"</span>);
        handler.setFileNameGenerator(<span class="hl-keyword">new</span> FileNameGenerator() {

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span class="hl-keyword">public</span> String generateFileName(Message&lt;?&gt; message) {
                 <span class="hl-keyword">return</span> <span class="hl-string">"handlerContent.test"</span>;
            }

        });
        <span class="hl-keyword">return</span> handler;
    }

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

         <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "toSftpChannel")</span></em>
         <span class="hl-keyword">void</span> sendToSftp(File file);

    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl_20" href="#_configuring_with_the_java_dsl_20"></a>28.10.2&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Adapter using the Java DSL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow sftpOutboundFlow() {
        <span class="hl-keyword">return</span> IntegrationFlows.from(<span class="hl-string">"toSftpChannel"</span>)
            .handle(Sftp.outboundAdapter(<span class="hl-keyword">this</span>.sftpSessionFactory, FileExistsMode.FAIL)
                         .useTemporaryFileName(false)
                         .remoteDirectory(<span class="hl-string">"/foo"</span>)
            ).get();
    }

}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-outbound-gateway" href="#sftp-outbound-gateway"></a>28.11&nbsp;SFTP Outbound Gateway</h2></div></div></div>

<p>The <span class="emphasis"><em>SFTP Outbound Gateway</em></span> provides a limited set of commands to interact with a remote SFTP server.
Commands supported are:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
ls (list files)
</li><li class="listitem">
nlst (list file names)
</li><li class="listitem">
get (retrieve file)
</li><li class="listitem">
mget (retrieve file(s))
</li><li class="listitem">
rm (remove file(s))
</li><li class="listitem">
mv (move/rename file)
</li><li class="listitem">
put (send file)
</li><li class="listitem">
mput (send multiple files)
</li></ul></div>
<p><span class="strong"><strong>ls</strong></span></p>
<p>ls lists remote file(s) and supports the following options:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-1 - just retrieve a list of filenames, default is to retrieve a list of <code class="literal">FileInfo</code> objects.
</li><li class="listitem">
-a - include all files (including those starting with <span class="emphasis"><em>.</em></span>)
</li><li class="listitem">
-f - do not sort the list
</li><li class="listitem">
-dirs - include directories (excluded by default)
</li><li class="listitem">
-links - include symbolic links (excluded by default)
</li><li class="listitem">
-R - list the remote directory recursively
</li></ul></div>
<p>In addition, filename filtering is provided, in the same manner as the <code class="literal">inbound-channel-adapter</code>.</p>
<p>The message payload resulting from an <span class="emphasis"><em>ls</em></span> operation is a list of file names, or a list of <code class="literal">FileInfo</code> objects.
These objects provide information such as modified time, permissions etc.</p>
<p>The remote directory that the <span class="emphasis"><em>ls</em></span> command acted on is provided in the <code class="literal">file_remoteDirectory</code> header.</p>
<p>When using the recursive option (<code class="literal">-R</code>), the <code class="literal">fileName</code> includes any subdirectory elements, representing a relative path to the file (relative to the remote directory).
If the <code class="literal">-dirs</code> option is included, each recursive directory is also returned as an element in the list.
In this case, it is recommended that the <code class="literal">-1</code> is not used because you would not be able to determine files Vs.
directories, which is achievable using the <code class="literal">FileInfo</code> objects.</p>
<p><span class="strong"><strong>nlst</strong></span></p>
<p>(Since <span class="emphasis"><em>version 5.0</em></span>)</p>
<p>Lists remote file names and supports the following options:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-f - do not sort the list
</li></ul></div>
<p>The message payload resulting from an <span class="emphasis"><em>nlst</em></span> operation is a list of file names.</p>
<p>The remote directory that the <span class="emphasis"><em>nlst</em></span> command acted on is provided in the <code class="literal">file_remoteDirectory</code> header.</p>
<p>The SFTP protocol doesn&#8217;t provide <span class="emphasis"><em>list names</em></span> functionality, s this command is fully equivalent of the <span class="emphasis"><em>ls</em></span> command with <code class="literal">-1</code> option and added here for convenience.</p>
<p><span class="strong"><strong>get</strong></span></p>
<p><span class="emphasis"><em>get</em></span> retrieves a remote file and supports the following option:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-P - preserve the timestamp of the remote file.
</li><li class="listitem">
-stream - retrieve the remote file as a stream.
</li><li class="listitem">
-D - delete the remote file after successful transfer.
The remote file is NOT deleted if the transfer is ignored because the <code class="literal">FileExistsMode</code> is <code class="literal">IGNORE</code> and the local file already exists.
</li></ul></div>
<p>The remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the filename is provided in the <code class="literal">file_remoteFile</code> header.</p>
<p>The message payload resulting from a <span class="emphasis"><em>get</em></span> operation is a <code class="literal">File</code> object representing the retrieved file, or
an <code class="literal">InputStream</code> when the <code class="literal">-stream</code> option is provided.
This option allows retrieving the file as a stream.
For text files, a common use case is to combine this operation with a <a class="link" href="files.html#file-splitter" title="15.5&nbsp;File Splitter">File Splitter</a> or
<a class="link" href="messaging-transformation-chapter.html#stream-transformer" title="Stream Transformer">Stream Transformer</a>.
When consuming remote files as streams, the user is responsible for closing the <code class="literal">Session</code> after the stream is
consumed.
For convenience, the <code class="literal">Session</code> is provided in the <code class="literal">closeableResource</code> header, a convenience method is provided on the
<code class="literal">IntegrationMessageHeaderAccessor</code>:</p>
<pre class="programlisting">Closeable closeable = <span class="hl-keyword">new</span> IntegrationMessageHeaderAccessor(message).getCloseableResource();
<span class="hl-keyword">if</span> (closeable != null) {
    closeable.close();
}</pre>
<p>Framework components such as the <a class="link" href="files.html#file-splitter" title="15.5&nbsp;File Splitter">File Splitter</a> and <a class="link" href="messaging-transformation-chapter.html#stream-transformer" title="Stream Transformer">Stream Transformer</a> will
automatically close the session after the data is transferred.</p>
<p>The following shows an example of consuming a file as a stream:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-sftp:outbound-gateway</span> <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
                            <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inboundGetStream"</span>
                            <span class="hl-attribute">command</span>=<span class="hl-value">"get"</span>
                            <span class="hl-attribute">command-options</span>=<span class="hl-value">"-stream"</span>
                            <span class="hl-attribute">expression</span>=<span class="hl-value">"payload"</span>
                            <span class="hl-attribute">remote-directory</span>=<span class="hl-value">"ftpTarget"</span>
                            <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"stream"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int-file:splitter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"stream"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"lines"</span><span class="hl-tag"> /&gt;</span></pre>
<p>Note: if you consume the input stream in a custom component, you <span class="strong"><strong>must</strong></span> close the <code class="literal">Session</code>.
You can either do that in your custom code, or route a copy of the message to a <code class="literal">service-activator</code> and use SpEL:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"closeSession"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"headers['closeableResource'].close()"</span><span class="hl-tag"> /&gt;</span></pre>
<p><span class="strong"><strong>mget</strong></span></p>
<p><span class="emphasis"><em>mget</em></span> retrieves multiple remote files based on a pattern and supports the following options:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-P - preserve the timestamps of the remote files.
</li><li class="listitem">
-R - retrieve the entire directory tree recursively.
</li><li class="listitem">
-x - Throw an exception if no files match the pattern (otherwise an empty list is returned).
</li><li class="listitem">
-D - delete each remote file after successful transfer.
The remote file is NOT deleted if the transfer is ignored because the <code class="literal">FileExistsMode</code> is <code class="literal">IGNORE</code> and the local file already exists.
</li></ul></div>
<p>The message payload resulting from an <span class="emphasis"><em>mget</em></span> operation is a <code class="literal">List&lt;File&gt;</code> object - a List of File objects, each representing a retrieved file.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, if the <code class="literal">FileExistsMode</code> is <code class="literal">IGNORE</code>, the payload of the output message will no longer contain files that were not fetched due to the file already existing.
Previously, the array contained all files, including those that already existed.</p>
</td></tr></table></div>
<p>The expression used to determine the remote path should produce a result that ends with <code class="literal">*</code> - e.g. <code class="literal">foo/*</code> will fetch the complete tree under <code class="literal">foo</code>.</p>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, a recursive <code class="literal">MGET</code>, combined with the new <code class="literal">FileExistsMode.REPLACE_IF_MODIFIED</code> mode, can be used to periodically synchronize an entire remote directory tree locally.
This mode will set the local file last modified timestamp to the remote file timestamp, regardless of the <code class="literal">-P</code> (preserve timestamp) option.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important: Notes for when using recursion (-R)"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Notes for when using recursion (<code class="literal">-R</code>)</th></tr><tr><td align="left" valign="top">

<p>The pattern is ignored, and <code class="literal">*</code> is assumed.
By default, the entire remote tree is retrieved.
However, files in the tree can be filtered, by providing a <code class="literal">FileListFilter</code>; directories in the tree can also be filtered this way.
A <code class="literal">FileListFilter</code> can be provided by reference or by <code class="literal">filename-pattern</code> or <code class="literal">filename-regex</code> attributes.
For example, <code class="literal">filename-regex="(subDir|.*1.txt)"</code> will retrieve all files ending with <code class="literal">1.txt</code> in the remote directory and the subdirectory <code class="literal">subDir</code>.
However, see below for an alternative available in <span class="emphasis"><em>version 5.0</em></span>.</p>
<p>If a subdirectory is filtered, no additional traversal of that subdirectory is performed.</p>
<p>The <code class="literal">-dirs</code> option is not allowed (the recursive mget uses the recursive <code class="literal">ls</code> to obtain the directory tree and the directories themselves cannot be included in the list).</p>
<p>Typically, you would use the <code class="literal">#remoteDirectory</code> variable in the <code class="literal">local-directory-expression</code> so that the remote directory structure is retained locally.</p>
</td></tr></table></div>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the <code class="literal">SftpSimplePatternFileListFilter</code> and <code class="literal">SftpRegexPatternFileListFilter</code> can be configured to always pass directories by setting the <code class="literal">alwaysAcceptDirectorties</code> to <code class="literal">true</code>.
This allows recursion for a simple pattern; examples follow:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"starDotTxtFilter"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.sftp.filters.SftpSimplePatternFileListFilter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"*.txt"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"alwaysAcceptDirectories"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dotStarDotTxtFilter"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.sftp.filters.SftpRegexPatternFileListFilter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"^.*\.txt$"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"alwaysAcceptDirectories"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>and provide one of these filters using <code class="literal">filter</code> property on the gateway.</p>
<p>See also <a class="xref" href="sftp.html#sftp-partial" title="28.11.3&nbsp;Outbound Gateway Partial Success (mget and mput)">Section&nbsp;28.11.3, &#8220;Outbound Gateway Partial Success (mget and mput)&#8221;</a></p>
<p><span class="strong"><strong>put</strong></span></p>
<p><span class="emphasis"><em>put</em></span> sends a file to the remote server; the payload of the message can be a <code class="literal">java.io.File</code>, a <code class="literal">byte[]</code> or a <code class="literal">String</code>.
A <code class="literal">remote-filename-generator</code> (or expression) is used to name the remote file.
Other available attributes include <code class="literal">remote-directory</code>, <code class="literal">temporary-remote-directory</code> (and their <code class="literal">*-expression</code>) equivalents, <code class="literal">use-temporary-file-name</code>, and <code class="literal">auto-create-directory</code>.
Refer to the schema documentation for more information.</p>
<p>The message payload resulting from a <span class="emphasis"><em>put</em></span> operation is a <code class="literal">String</code> representing the full path of the file on the server after transfer.</p>
<p><span class="emphasis"><em>Version 4.3</em></span> introduced the <code class="literal">chmod</code> attribute which changes the remote file permissions after upload.
Use the conventional Unix octal format, e.g. <code class="literal">600</code> allows read-write for the file owner only.
When configuring the adapter using java, you can use <code class="literal">setChmod(0600)</code>.</p>
<p><span class="strong"><strong>mput</strong></span></p>
<p><span class="emphasis"><em>mput</em></span> sends multiple files to the server and supports the following option:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-R - Recursive - send all files (possibly filtered) in the directory and subdirectories
</li></ul></div>
<p>The message payload must be a <code class="literal">java.io.File</code> representing a local directory.</p>
<p>The same attributes as the <code class="literal">put</code> command are supported.
In addition, files in the local directory can be filtered with one of <code class="literal">mput-pattern</code>, <code class="literal">mput-regex</code>, <code class="literal">mput-filter</code> or <code class="literal">mput-filter-expression</code>.
The filter works with recursion, as long as the subdirectories themselves pass the filter.
Subdirectories that do not pass the filter are not recursed.</p>
<p>The message payload resulting from an <span class="emphasis"><em>mget</em></span> operation is a <code class="literal">List&lt;String&gt;</code> object - a List of remote file paths resulting from the transfer.</p>
<p>See also <a class="xref" href="sftp.html#sftp-partial" title="28.11.3&nbsp;Outbound Gateway Partial Success (mget and mput)">Section&nbsp;28.11.3, &#8220;Outbound Gateway Partial Success (mget and mput)&#8221;</a></p>
<p><span class="emphasis"><em>Version 4.3</em></span> introduced the <code class="literal">chmod</code> attribute which changes the remote file permissions after upload.
Use the conventional Unix octal format, e.g. <code class="literal">600</code> allows read-write for the file owner only.
When configuring the adapter using java, you can use <code class="literal">setChmodOctal("600")</code> or <code class="literal">setChmodDecimal(384)</code>.</p>
<p><span class="strong"><strong>rm</strong></span></p>
<p>The <span class="emphasis"><em>rm</em></span> command has no options.</p>
<p>The message payload resulting from an <span class="emphasis"><em>rm</em></span> operation is Boolean.TRUE if the remove was successful, Boolean.FALSE otherwise.
The remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the filename is provided in the <code class="literal">file_remoteFile</code> header.</p>
<p><span class="strong"><strong>mv</strong></span></p>
<p>The <span class="emphasis"><em>mv</em></span> command has no options.</p>
<p>The <span class="emphasis"><em>expression</em></span> attribute defines the "from" path and the <span class="emphasis"><em>rename-expression</em></span> attribute defines the "to" path.
By default, the <span class="emphasis"><em>rename-expression</em></span> is <code class="literal">headers['file_renameTo']</code>.
This expression must not evaluate to null, or an empty <code class="literal">String</code>.
If necessary, any remote directories needed will be created.
The payload of the result message is <code class="literal">Boolean.TRUE</code>.
The original remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the filename is provided in the <code class="literal">file_remoteFile</code> header.
The new path is in the <code class="literal">file_renameTo</code> header.</p>
<p><span class="strong"><strong>Additional Information</strong></span></p>
<p>The <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>mget</em></span> commands support the <span class="emphasis"><em>local-filename-generator-expression</em></span> attribute.
It defines a SpEL expression to generate the name of local file(s) during the transfer.
The root object of the evaluation context is the request Message but, in addition, the <code class="literal">remoteFileName</code> variable is also available, which is particularly useful for <span class="emphasis"><em>mget</em></span>, for example: <code class="literal">local-filename-generator-expression="#remoteFileName.toUpperCase() + headers.foo"</code></p>
<p>The <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>mget</em></span> commands support the <span class="emphasis"><em>local-directory-expression</em></span> attribute.
It defines a SpEL expression to generate the name of local directory(ies) during the transfer.
The root object of the evaluation context is the request Message but, in addition, the <code class="literal">remoteDirectory</code> variable is also available, which is particularly useful for <span class="emphasis"><em>mget</em></span>, for example: <code class="literal">local-directory-expression="'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.foo"</code>.
This attribute is mutually exclusive with <span class="emphasis"><em>local-directory</em></span> attribute.</p>
<p>For all commands, the PATH that the command acts on is provided by the <span class="emphasis"><em>expression</em></span> property of the gateway.
For the mget command, the expression might evaluate to <span class="emphasis"><em><span class="strong"><strong></strong></span>, meaning retrieve all files, or <span class="emphasis"><em>somedirectory/</em></span></em></span> etc.</p>
<p>Here is an example of a gateway configured for an ls command&#8230;&#8203;</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gateway1"</span>
        <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
        <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inbound1"</span>
        <span class="hl-attribute">command</span>=<span class="hl-value">"ls"</span>
        <span class="hl-attribute">command-options</span>=<span class="hl-value">"-1"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"payload"</span>
        <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"toSplitter"</span><span class="hl-tag">/&gt;</span></pre>
<p>The payload of the message sent to the toSplitter channel is a list of String objects containing the filename of each file.
If the <code class="literal">command-options</code> was omitted, it would be a list of <code class="literal">FileInfo</code> objects.
Options are provided space-delimited, e.g.
<code class="literal">command-options="-1 -dirs -links"</code>.</p>
<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, the <code class="literal">GET</code>, <code class="literal">MGET</code>, <code class="literal">PUT</code> and <code class="literal">MPUT</code> commands support a <code class="literal">FileExistsMode</code> property (<code class="literal">mode</code>
when using the namespace support). This affects the behavior when the local file exists (<code class="literal">GET</code> and <code class="literal">MGET</code>) or the remote
file exists (<code class="literal">PUT</code> and <code class="literal">MPUT</code>). Supported modes are <code class="literal">REPLACE</code>, <code class="literal">APPEND</code>, <code class="literal">FAIL</code> and <code class="literal">IGNORE</code>.
For backwards compatibility, the default mode for <code class="literal">PUT</code> and <code class="literal">MPUT</code> operations is <code class="literal">REPLACE</code> and for <code class="literal">GET</code> and <code class="literal">MGET</code>
operations, the default is <code class="literal">FAIL</code>.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_26" href="#_configuring_with_java_configuration_26"></a>28.11.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Gateway using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "sftpChannel")</span></em>
    <span class="hl-keyword">public</span> MessageHandler handler() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SftpOutboundGateway(ftpSessionFactory(), <span class="hl-string">"ls"</span>, <span class="hl-string">"'my_remote_dir/'"</span>);
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl_21" href="#_configuring_with_the_java_dsl_21"></a>28.11.2&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Gateway using the Java DSL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SftpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(SftpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;LsEntry&gt; sftpSessionFactory() {
        DefaultFtpSessionFactory sf = <span class="hl-keyword">new</span> DefaultFtpSessionFactory();
        sf.setHost(<span class="hl-string">"localhost"</span>);
        sf.setPort(port);
        sf.setUsername(<span class="hl-string">"foo"</span>);
        sf.setPassword(<span class="hl-string">"foo"</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;LsEntry&gt;(sf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> QueueChannelSpec remoteFileOutputChannel() {
        <span class="hl-keyword">return</span> MessageChannels.queue();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow sftpMGetFlow() {
        <span class="hl-keyword">return</span> IntegrationFlows.from(<span class="hl-string">"sftpMgetInputChannel"</span>)
            .handleWithAdapter(h -&gt;
                h.sftpGateway(sftpSessionFactory(), AbstractRemoteFileOutboundGateway.Command.MGET,
                    <span class="hl-string">"payload"</span>)
                    .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)
                    .regexFileNameFilter(<span class="hl-string">"(subSftpSource|.*1.txt)"</span>)
                    .localDirectoryExpression(<span class="hl-string">"'myDir/' + #remoteDirectory"</span>)
                    .localFilenameExpression(<span class="hl-string">"#remoteFileName.replaceFirst('sftpSource', 'localTarget')"</span>))
            .channel(<span class="hl-string">"remoteFileOutputChannel"</span>)
            .get();
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sftp-partial" href="#sftp-partial"></a>28.11.3&nbsp;Outbound Gateway Partial Success (mget and mput)</h3></div></div></div>

<p>When performing operations on multiple files (<code class="literal">mget</code> and <code class="literal">mput</code>) it is possible that an exception occurs some time after
one or more files have been transferred.
In this case (starting with <span class="emphasis"><em>version 4.2</em></span>), a <code class="literal">PartialSuccessException</code> is thrown.
As well as the usual <code class="literal">MessagingException</code> properties (<code class="literal">failedMessage</code> and <code class="literal">cause</code>), this exception has two additional
properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">partialResults</code> - the successful transfer results.
</li><li class="listitem">
<code class="literal">derivedInput</code> - the list of files generated from the request message (e.g. local files to transfer for an <code class="literal">mput</code>).
</li></ul></div>
<p>This will enable you to determine which files were successfully transferred, and which were not.</p>
<p>In the case of a recursive <code class="literal">mput</code>, the <code class="literal">PartialSuccessException</code> may have nested <code class="literal">PartialSuccessException</code> s.</p>
<p>Consider:</p>
<pre class="screen">root/
|- file1.txt
|- subdir/
   | - file2.txt
   | - file3.txt
|- zoo.txt</pre>
<p>If the exception occurs on <code class="literal">file3.txt</code>, the <code class="literal">PartialSuccessException</code> thrown by the gateway will have <code class="literal">derivedInput</code>
of <code class="literal">file1.txt</code>, <code class="literal">subdir</code>, <code class="literal">zoo.txt</code> and <code class="literal">partialResults</code> of <code class="literal">file1.txt</code>.
It&#8217;s <code class="literal">cause</code> will be another <code class="literal">PartialSuccessException</code> with <code class="literal">derivedInput</code> of <code class="literal">file2.txt</code>, <code class="literal">file3.txt</code> and
<code class="literal">partialResults</code> of <code class="literal">file2.txt</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-jsch-logging" href="#sftp-jsch-logging"></a>28.12&nbsp;SFTP/JSCH Logging</h2></div></div></div>

<p>Since we use JSch libraries (<a class="ulink" href="http://www.jcraft.com/jsch/" target="_top">http://www.jcraft.com/jsch/</a>) to provide SFTP support, at times you may require more information from the JSch API itself, especially if something is not working properly (e.g., Authentication exceptions).
Unfortunately JSch does not use commons-logging but instead relies on custom implementations of their <code class="literal">com.jcraft.jsch.Logger</code> interface.
As of Spring Integration 2.0.1, we have implemented this interface.
So, now all you need to do to enable JSch logging is to configure your logger the way you usually do.
For example, here is valid configuration of a logger using Log4J.</p>
<pre class="programlisting">log4j.category.com.jcraft.jsch=DEBUG</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sftp-session-callback" href="#sftp-session-callback"></a>28.13&nbsp;MessageSessionCallback</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>Spring Integration version 4.2</em></span>, a <code class="literal">MessageSessionCallback&lt;F, T&gt;</code> implementation can be used with the
<code class="literal">&lt;int-sftp:outbound-gateway/&gt;</code> (<code class="literal">SftpOutboundGateway</code>) to perform any operation(s) on the <code class="literal">Session&lt;LsEntry&gt;</code> with
the <code class="literal">requestMessage</code> context.
It can be used for any non-standard or low-level FTP operation (or several); for example, allowing access
from an integration flow definition, and <span class="emphasis"><em>functional</em></span> interface (Lambda) implementation injection:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "sftpChannel")</span></em>
<span class="hl-keyword">public</span> MessageHandler sftpOutboundGateway(SessionFactory&lt;ChannelSftp.LsEntry&gt; sessionFactory) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SftpOutboundGateway(sessionFactory,
         (session, requestMessage) -&gt; session.list(requestMessage.getPayload()));
}</pre>
<p>Another example might be to pre- or post- process the file data being sent/retrieved.</p>
<p>When using XML configuration, the <code class="literal">&lt;int-sftp:outbound-gateway/&gt;</code> provides a <code class="literal">session-callback</code> attribute to allow you
to specify the <code class="literal">MessageSessionCallback</code> bean name.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">session-callback</code> is mutually exclusive with the <code class="literal">command</code> and <code class="literal">expression</code> attributes.
When configuring with Java, different constructors are available in the <code class="literal">SftpOutboundGateway</code> class.</p>
</td></tr></table></div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rmi.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="stomp.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">27.&nbsp;RMI Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;29.&nbsp;STOMP Support</td></tr></table></div></body></html>