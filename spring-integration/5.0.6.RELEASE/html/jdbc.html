<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>19.&nbsp;JDBC Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="http.html" title="18.&nbsp;HTTP Support"><link rel="next" href="jpa.html" title="20.&nbsp;JPA Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">19.&nbsp;JDBC Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="http.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="jpa.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="jdbc" href="#jdbc"></a>19.&nbsp;JDBC Support</h2></div></div></div>

<p>Spring Integration provides Channel Adapters for receiving and sending messages via database queries.
Through those adapters Spring Integration supports not only plain JDBC SQL Queries, but also Stored Procedure and Stored Function calls.</p>
<p>The following JDBC components are available by default:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em><a class="link" href="jdbc.html#jdbc-inbound-channel-adapter" title="19.1&nbsp;Inbound Channel Adapter">Inbound Channel Adapter</a></em></span>
</li><li class="listitem">
<span class="emphasis"><em><a class="link" href="jdbc.html#jdbc-outbound-channel-adapter" title="19.2&nbsp;Outbound Channel Adapter">Outbound Channel Adapter</a></em></span>
</li><li class="listitem">
<span class="emphasis"><em><a class="link" href="jdbc.html#jdbc-outbound-gateway" title="19.3&nbsp;Outbound Gateway">Outbound Gateway</a></em></span>
</li><li class="listitem">
<span class="emphasis"><em><a class="link" href="jdbc.html#stored-procedure-inbound-channel-adapter" title="19.5.6&nbsp;Stored Procedure Inbound Channel Adapter">Stored Procedure Inbound Channel Adapter</a></em></span>
</li><li class="listitem">
<span class="emphasis"><em><a class="link" href="jdbc.html#stored-procedure-outbound-channel-adapter" title="19.5.7&nbsp;Stored Procedure Outbound Channel Adapter">Stored Procedure Outbound Channel Adapter</a></em></span>
</li><li class="listitem">
<span class="emphasis"><em><a class="link" href="jdbc.html#stored-procedure-outbound-gateway" title="19.5.8&nbsp;Stored Procedure Outbound Gateway">Stored Procedure Outbound Gateway</a></em></span>
</li></ul></div>
<p>Furthermore, the Spring Integration JDBC Module also provides a <span class="emphasis"><em><a class="link" href="jdbc.html#jdbc-message-store" title="19.4&nbsp;JDBC Message Store">JDBC Message Store</a></em></span></p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-inbound-channel-adapter" href="#jdbc-inbound-channel-adapter"></a>19.1&nbsp;Inbound Channel Adapter</h2></div></div></div>

<p>The main function of an inbound Channel Adapter is to execute a SQL <code class="literal">SELECT</code> query and turn the result set as a message.
The message payload is the whole result set, expressed as a <code class="literal">List</code>, and the types of the items in the list depend on the row-mapping strategy that is used.
The default strategy is a generic mapper that just returns a <code class="literal">Map</code> for each row in the query result.
Optionally, this can be changed by adding a reference to a <code class="literal">RowMapper</code> instance (see the <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html" target="_top">Spring JDBC</a> documentation for more detailed information about row mapping).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you want to convert rows in the SELECT query result to individual messages you can use a downstream splitter.</p>
</td></tr></table></div>
<p>The inbound adapter also requires a reference to either a <code class="literal">JdbcTemplate</code> instance or a <code class="literal">DataSource</code>.</p>
<p>As well as the <code class="literal">SELECT</code> statement to generate the messages, the adapter above also has an <code class="literal">UPDATE</code> statement that is being used to mark the records as processed so that they don&#8217;t show up in the next poll.
The update can be parameterized by the list of ids from the original select.
This is done through a naming convention by default (a column in the input result set called "id" is translated into a list in the parameter map for the update called "id").
The following example defines an inbound Channel Adapter with an update query and a <code class="literal">DataSource</code> reference.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:inbound-channel-adapter</span> <span class="hl-attribute">query</span>=<span class="hl-value">"select * from item where status=2"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"target"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
    <span class="hl-attribute">update</span>=<span class="hl-value">"update item set status=10 where id in (:id)"</span><span class="hl-tag"> /&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The parameters in the update query are specified with a colon (:) prefix to the name of a parameter (which in this case is an expression to be applied to each of the rows in the polled result set).
This is a standard feature of the named parameter JDBC support in Spring JDBC combined with a convention (projection onto the polled result list) adopted in Spring Integration.
The underlying Spring JDBC features limit the available expressions (e.g.
most special characters other than period are disallowed), but since the target is usually a list of or an individual object addressable by simple bean paths this isn&#8217;t unduly restrictive.</p>
</td></tr></table></div>
<p>To change the parameter generation strategy you can inject a <code class="literal">SqlParameterSourceFactory</code> into the adapter to override the default behavior (the adapter has a <code class="literal">sql-parameter-source-factory</code> attribute).
Spring Integration provides a <code class="literal">ExpressionEvaluatingSqlParameterSourceFactory</code> which will create a SpEL-based parameter source, with the results of the query as the <code class="literal">#root</code> object.
(If <code class="literal">update-per-row</code> is true, the root object is the row).
If the same parameter name appears multiple times in the update query, it is evaluated only one time, and its result is cached.</p>
<p>You can also use a parameter source for the select query.
In this case, since there is no "result" object to evaluate against, a single parameter source is used each time (rather than using a parameter source factory).
Starting with <span class="emphasis"><em>version 4.0</em></span>, you can use Spring to create a SpEL based parameter source as follows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:inbound-channel-adapter</span> <span class="hl-attribute">query</span>=<span class="hl-value">"select * from item where status=:status"</span>
	<span class="hl-attribute">channel</span>=<span class="hl-value">"target"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
	<span class="hl-attribute">select-sql-parameter-source</span>=<span class="hl-value">"parameterSource"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"parameterSource"</span> <span class="hl-attribute">factory-bean</span>=<span class="hl-value">"parameterSourceFactory"</span>
			<span class="hl-attribute">factory-method</span>=<span class="hl-value">"createParameterSourceNoCache"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"parameterSourceFactory"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"parameterExpressions"</span><span class="hl-tag">&gt;</span>
		<span class="hl-tag">&lt;map&gt;</span>
			<span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"status"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"@statusBean.which()"</span><span class="hl-tag"> /&gt;</span>
		<span class="hl-tag">&lt;/map&gt;</span>
	<span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"statusBean"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.StatusDetermination"</span><span class="hl-tag"> /&gt;</span></pre>
<p>The <code class="literal">value</code> in each parameter expression can be any valid SpEL expression.
The <code class="literal">#root</code> object for the expression evaluation is the constructor argument defined on the <code class="literal">parameterSource</code> bean.
It is static for all evaluations (in this case, an empty String).</p>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the <code class="literal">ExpressionEvaluatingSqlParameterSourceFactory</code> can be supplied with the <code class="literal">sqlParameterTypes</code> to specify the target SQL type for the particular parameter.</p>
<p>Below example provides sql type for the parameters being used in the query.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:inbound-channel-adapter</span> <span class="hl-attribute">query</span>=<span class="hl-value">"select * from item where status=:status"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"target"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
    <span class="hl-attribute">select-sql-parameter-source</span>=<span class="hl-value">"parameterSource"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"parameterSource"</span> <span class="hl-attribute">factory-bean</span>=<span class="hl-value">"parameterSourceFactory"</span>
            <span class="hl-attribute">factory-method</span>=<span class="hl-value">"createParameterSourceNoCache"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"parameterSourceFactory"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sqlParameterTypes"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"status"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-attribute">#{</span> <span class="hl-attribute">T(java.sql.Types).BINARY}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Use the <code class="literal">createParameterSourceNoCache</code> factory method; otherwise the parameter source will cache the result of the evaluation.
Also note that, because caching is disabled, if the same parameter name appears in the select query multiple times, it will be re-evaluated for each occurrence.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_polling_and_transactions" href="#_polling_and_transactions"></a>19.1.1&nbsp;Polling and Transactions</h3></div></div></div>

<p>The inbound adapter accepts a regular Spring Integration poller as a sub element, so for instance the frequency of the polling can be controlled.
A very important feature of the poller for JDBC usage is the option to wrap the poll operation in a transaction, for example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:inbound-channel-adapter</span> <span class="hl-attribute">query</span>=<span class="hl-value">"..."</span>
        <span class="hl-attribute">channel</span>=<span class="hl-value">"target"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">update</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:transactional/&gt;</span>
    <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int-jdbc:inbound-channel-adapter&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If a poller is not explicitly specified, a default value will be used (and as per normal with Spring Integration can be defined as a top level bean).</p>
</td></tr></table></div>
<p>In this example the database is polled every 1000 milliseconds, and the update and select queries are both executed in the same transaction.
The transaction manager configuration is not shown, but as long as it is aware of the data source then the poll is transactional.
A common use case is for the downstream channels to be direct channels (the default), so that the endpoints are invoked in the same thread, and hence the same transaction.
Then if any of them fail, the transaction rolls back and the input data is reverted to its original state.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-max-rows-per-poll-versus-max-messages-per-poll" href="#jdbc-max-rows-per-poll-versus-max-messages-per-poll"></a>19.1.2&nbsp;Max-rows-per-poll versus Max-messages-per-poll</h3></div></div></div>

<p>The <span class="emphasis"><em>JDBC Inbound Channel Adapter</em></span> defines an attribute <code class="literal">max-rows-per-poll</code>.
When you specify the adapter&#8217;s <span class="emphasis"><em>Poller</em></span>, you can also define a property called <code class="literal">max-messages-per-poll</code>.
While these two attributes look similar, their meaning is quite different.</p>
<p><code class="literal">max-messages-per-poll</code> specifies the number of times the query is executed per polling interval, whereas <code class="literal">max-rows-per-poll</code> specifies the number of rows returned for each execution.</p>
<p>Under normal circumstances, you would likely not want to set the Poller&#8217;s <code class="literal">max-messages-per-poll</code> property when using the <span class="emphasis"><em>JDBC Inbound Channel Adapter</em></span>.
Its default value is <span class="emphasis"><em>1</em></span>, which means that the <span class="emphasis"><em>JDBC Inbound Channel Adapter</em></span>'s <a class="ulink" href="https://docs.spring.io/spring-integration/api/org/springframework/integration/jdbc/JdbcPollingChannelAdapter.html#receive()" target="_top"><code class="literal">receive()</code></a> method is executed exactly once for each poll interval.</p>
<p>Setting the <code class="literal">max-messages-per-poll</code> attribute to a larger value means that the query is executed that many times back to back.
For more information regarding the <code class="literal">max-messages-per-poll</code> attribute, please see <a class="xref" href="messaging-channels-section.html#channel-adapter-namespace-inbound" title="4.3.1&nbsp;Configuring An Inbound Channel Adapter">Section&nbsp;4.3.1, &#8220;Configuring An Inbound Channel Adapter&#8221;</a>.</p>
<p>In contrast, the <code class="literal">max-rows-per-poll</code> attribute, if greater than <span class="emphasis"><em>0</em></span>, specifies the maximum number of rows that will be used from the query result set, per execution of the <code class="literal">receive()</code> method.
If the attribute is set to <span class="emphasis"><em>0</em></span>, then all rows will be included in the resulting message.
If not explicitly set, the attribute defaults to <span class="emphasis"><em>0</em></span>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-outbound-channel-adapter" href="#jdbc-outbound-channel-adapter"></a>19.2&nbsp;Outbound Channel Adapter</h2></div></div></div>

<p>The outbound Channel Adapter is the inverse of the inbound: its role is to handle a message and use it to execute a SQL query.
The message payload and headers are available by default as input parameters to the query, for instance:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:outbound-channel-adapter</span>
    <span class="hl-attribute">query</span>=<span class="hl-value">"insert into foos (id, status, name) values (:headers[id], 0, :payload[foo])"</span>
    <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"input"</span><span class="hl-tag">/&gt;</span></pre>
<p>In the example above, messages arriving on the channel labelled <span class="emphasis"><em>input</em></span> have a payload of a map with key <span class="emphasis"><em>foo</em></span>, so the <code class="literal">[]</code> operator dereferences that value from the map.
The headers are also accessed as a map.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The parameters in the query above are bean property expressions on the incoming message (not Spring EL expressions).
This behavior is part of the <code class="literal">SqlParameterSource</code> which is the default source created by the outbound adapter.
Other behavior is possible in the adapter, and requires the user to inject a different <code class="literal">SqlParameterSourceFactory</code>.</p>
</td></tr></table></div>
<p>The outbound adapter requires a reference to either a <code class="literal">DataSource</code> or a <code class="literal">JdbcTemplate</code>.
It can also have a <code class="literal">SqlParameterSourceFactory</code> injected to control the binding of each incoming message to a query.</p>
<p>If the input channel is a direct channel, then the outbound adapter runs its query in the same thread, and therefore the same transaction (if there is one) as the sender of the message.</p>
<p><span class="emphasis"><em>Passing Parameters using SpEL Expressions</em></span></p>
<p>A common requirement for most JDBC Channel Adapters is to pass parameters as part of Sql queries or Stored Procedures/Functions.
As mentioned above, these parameters are by default bean property expressions, not SpEL expressions.
However, if you need to pass SpEL expression as parameters, you must inject a <code class="literal">SqlParameterSourceFactory</code> explicitly.</p>
<p>The following example uses a <code class="literal">ExpressionEvaluatingSqlParameterSourceFactory</code> to achieve that requirement.</p>
<pre class="programlisting"><span class="hl-tag">&lt;jdbc:outbound-channel-adapter</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"input"</span>
    <span class="hl-attribute">query</span>=<span class="hl-value">"insert into MESSAGES (MESSAGE_ID,PAYLOAD,CREATED_DATE)     \
    values (:id, :payload, :createdDate)"</span>
    <span class="hl-attribute">sql-parameter-source-factory</span>=<span class="hl-value">"spelSource"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"spelSource"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"parameterExpressions"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"id"</span>          <span class="hl-attribute">value</span>=<span class="hl-value">"headers['id'].toString()"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"createdDate"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"new java.util.Date()"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"payload"</span>     <span class="hl-attribute">value</span>=<span class="hl-value">"payload"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>For further information, please also see <a class="xref" href="jdbc.html#sp-defining-parameter-sources" title="19.5.5&nbsp;Defining Parameter Sources">Section&nbsp;19.5.5, &#8220;Defining Parameter Sources&#8221;</a></p>
<p><span class="emphasis"><em>PreparedStatement Callback</em></span></p>
<p>There are some cases when the flexibility and loose-coupling of <code class="literal">SqlParameterSourceFactory</code> isn&#8217;t enough for the target
<code class="literal">PreparedStatement</code> or we need to do some low-level JDBC work.
The Spring JDBC module provides APIs to configure the execution environment (e.g. <code class="literal">ConnectionCallback</code>
or <code class="literal">PreparedStatementCreator</code>) and manipulation of parameter values (e.g. <code class="literal">SqlParameterSource</code>).
Or even APIs for low level operations, for example <code class="literal">StatementCallback</code>.</p>
<p>Starting with <span class="emphasis"><em>Spring Integration 4.2</em></span>, the <code class="literal">MessagePreparedStatementSetter</code> is available to allow
the specification of parameters on the <code class="literal">PreparedStatement</code> manually, in the <code class="literal">requestMessage</code> context.
This class plays exactly the same role as <code class="literal">PreparedStatementSetter</code> in the standard Spring JDBC API.
Actually it is invoked directly from an inline <code class="literal">PreparedStatementSetter</code> implementation, when the <code class="literal">JdbcMessageHandler</code>
invokes <code class="literal">execute</code> on the <code class="literal">JdbcTemplate</code>.</p>
<p>This functional interface option is mutually exclusive with <code class="literal">sqlParameterSourceFactory</code> and can be used as a more
powerful alternative to populate parameters of the <code class="literal">PreparedStatement</code> from the <code class="literal">requestMessage</code>.
For example it is useful when we need to store <code class="literal">File</code> data to the DataBase <code class="literal">BLOB</code> column in a stream manner:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "storeFileChannel")</span></em>
<span class="hl-keyword">public</span> MessageHandler jdbcMessageHandler(DataSource dataSource) {
    JdbcMessageHandler jdbcMessageHandler = <span class="hl-keyword">new</span> JdbcMessageHandler(dataSource,
            <span class="hl-string">"INSERT INTO imagedb (image_name, content, description) VALUES (?, ?, ?)"</span>);
    jdbcMessageHandler.setPreparedStatementSetter((ps, m) -&gt; {
        ps.setString(<span class="hl-number">1</span>, m.getHeaders().get(FileHeaders.FILENAME));
        <span class="hl-keyword">try</span> (FileInputStream inputStream = <span class="hl-keyword">new</span> FileInputStream((File) m.getPayload())) {
            ps.setBlob(<span class="hl-number">2</span>, inputStream);
        }
        <span class="hl-keyword">catch</span> (Exception e) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> MessageHandlingException(m, e);
        }
        ps.setClob(<span class="hl-number">3</span>, <span class="hl-keyword">new</span> StringReader(m.getHeaders().get(<span class="hl-string">"description"</span>, String.<span class="hl-keyword">class</span>)));
    });
    <span class="hl-keyword">return</span> jdbcMessageHandler;
}</pre>
<p>From the XML configuration perspective, the <code class="literal">prepared-statement-setter</code> attribute is available on the
<code class="literal">&lt;int-jdbc:outbound-channel-adapter&gt;</code> component, to specify a  <code class="literal">MessagePreparedStatementSetter</code>
bean reference.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-outbound-gateway" href="#jdbc-outbound-gateway"></a>19.3&nbsp;Outbound Gateway</h2></div></div></div>

<p>The outbound Gateway is like a combination of the outbound and inbound adapters: its role is to handle a message and use it to execute a SQL query and then respond with the result sending it to a reply channel.
The message payload and headers are available by default as input parameters to the query, for instance:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:outbound-gateway</span>
    <span class="hl-attribute">update</span>=<span class="hl-value">"insert into foos (id, status, name) values (:headers[id], 0, :payload[foo])"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"output"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag"> /&gt;</span></pre>
<p>The result of the above would be to insert a record into the "foos" table and return a message to the output channel indicating the number of rows affected (the payload is a map: <code class="literal">{UPDATED=1}</code>).</p>
<p>If the update query is an insert with auto-generated keys, the reply message can be populated with the generated keys by adding <code class="literal">keys-generated="true"</code> to the above example (this is not the default because it is not supported by some database platforms).
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:outbound-gateway</span>
    <span class="hl-attribute">update</span>=<span class="hl-value">"insert into foos (status, name) values (0, :payload[foo])"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"output"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
    <span class="hl-attribute">keys-generated</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>
<p>Instead of the update count or the generated keys, you can also provide a select query to execute and generate a reply message from the result (like the inbound adapter), e.g:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:outbound-gateway</span>
    <span class="hl-attribute">update</span>=<span class="hl-value">"insert into foos (id, status, name) values (:headers[id], 0, :payload[foo])"</span>
    <span class="hl-attribute">query</span>=<span class="hl-value">"select * from foos where id=:headers[$id]"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"output"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span></pre>
<p>Since <span class="emphasis"><em>Spring Integration 2.2</em></span> the update SQL query is no longer mandatory.
You can now solely provide a select query, using either the <span class="emphasis"><em>query attribute</em></span> or the <span class="emphasis"><em>query sub-element</em></span>.
This is extremely useful if you need to actively retrieve data using e.g.
a generic Gateway or a Payload Enricher.
The reply message is then generated from the result, like the inbound adapter, and passed to the reply channel.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:outbound-gateway</span>
    <span class="hl-attribute">query</span>=<span class="hl-value">"select * from foos where id=:headers[id]"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"input"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>By default the component for the SELECT query returns only one, first row from the cursor.
This can be adjusted with the <code class="literal">max-rows-per-poll</code> option.
Consider to specify <code class="literal">max-rows-per-poll="0"</code> if you need to return all the rows from the SELECT.</p>
</td></tr></table></div>
<p>As with the channel adapters, there is also the option to provide <code class="literal">SqlParameterSourceFactory</code> instances for request and reply.
The default is the same as for the outbound adapter, so the request message is available as the root of an expression.
If <code class="literal">keys-generated="true"</code> then the root of the expression is the generated keys (a map if there is only one or a list of maps if multi-valued).</p>
<p>The outbound gateway requires a reference to either a DataSource or a JdbcTemplate.
It can also have a <code class="literal">SqlParameterSourceFactory</code> injected to control the binding of the incoming message to the query.</p>
<p>Starting with the <span class="emphasis"><em>version 4.2</em></span> the <code class="literal">request-prepared-statement-setter</code> attribute is available on the
<code class="literal">&lt;int-jdbc:outbound-gateway&gt;</code> as an alternative to the <code class="literal">request-sql-parameter-source-factory</code>.
It allows you to specify a <code class="literal">MessagePreparedStatementSetter</code> bean reference, which implements more sophisticated
<code class="literal">PreparedStatement</code> preparation before its execution.</p>
<p>See <a class="xref" href="jdbc.html#jdbc-outbound-channel-adapter" title="19.2&nbsp;Outbound Channel Adapter">Section&nbsp;19.2, &#8220;Outbound Channel Adapter&#8221;</a> for more information about <code class="literal">MessagePreparedStatementSetter</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-message-store" href="#jdbc-message-store"></a>19.4&nbsp;JDBC Message Store</h2></div></div></div>

<p>Spring Integration provides 2 JDBC specific Message Store implementations.
The first one, is the <code class="literal">JdbcMessageStore</code> which is suitable to be used in conjunction with <span class="emphasis"><em>Aggregators</em></span> and the <span class="emphasis"><em>Claim-Check</em></span> pattern.
While it can be used for backing <span class="emphasis"><em>Message Channels</em></span> as well, you may want to consider using the <code class="literal">JdbcChannelMessageStore</code> implementation instead, as it provides a more targeted and scalable implementation.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_initializing_the_database" href="#_initializing_the_database"></a>19.4.1&nbsp;Initializing the Database</h3></div></div></div>

<p>Before starting to use JDBC Message Store components, it is important to provision target data base with the appropriate objects.</p>
<p>Spring Integration ships with some sample scripts that can be used to initialize a database.
In the <code class="literal">spring-integration-jdbc</code> JAR file you can find scripts in the <code class="literal">org.springframework.integration.jdbc</code> package: there is a create and a drop script example for a range of common database platforms.
A common way to use these scripts is to reference them in a <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-intializing-datasource" target="_top">Spring JDBC data source initializer</a>.
Note that the scripts are provided as samples or specifications of the the required table and column names.
You may find that you need to enhance them for production use (e.g. with index declarations).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-message-store-generic" href="#jdbc-message-store-generic"></a>19.4.2&nbsp;The Generic JDBC Message Store</h3></div></div></div>

<p>The JDBC module provides an implementation of the Spring Integration <code class="literal">MessageStore</code> (important in the Claim Check pattern) and <code class="literal">MessageGroupStore</code> (important in stateful patterns like Aggregator) backed by a database.
Both interfaces are implemented by the <code class="literal">JdbcMessageStore</code>, and there is also support for configuring store instances in XML.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:message-store</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageStore"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span></pre>
<p>A <code class="literal">JdbcTemplate</code> can be specified instead of a <code class="literal">DataSource</code>.</p>
<p>Other optional attributes are show in the next example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:message-store</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageStore"</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
    <span class="hl-attribute">lob-handler</span>=<span class="hl-value">"lobHandler"</span> <span class="hl-attribute">table-prefix</span>=<span class="hl-value">"MY_INT_"</span><span class="hl-tag">/&gt;</span></pre>
<p>Here we have specified a <code class="literal">LobHandler</code> for dealing with messages as large objects (e.g.
often necessary if using Oracle) and a prefix for the table names in the queries generated by the store.
The table name prefix defaults to <code class="literal">INT_</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-message-store-channels" href="#jdbc-message-store-channels"></a>19.4.3&nbsp;Backing Message Channels</h3></div></div></div>

<p>If you intend backing <span class="emphasis"><em>Message Channels</em></span> using JDBC, it is recommended to use the provided <code class="literal">JdbcChannelMessageStore</code> implementation instead.
It can only be used in conjunction with <span class="emphasis"><em>Message Channels</em></span>.</p>
<p><span class="strong"><strong>Supported Databases</strong></span></p>
<p>The <code class="literal">JdbcChannelMessageStore</code> uses database specific SQL queries to retrieve messages from the database.
Therefore, users must set the <code class="literal">ChannelMessageStoreQueryProvider</code> property on the <code class="literal">JdbcChannelMessageStore</code>.
This <code class="literal">channelMessageStoreQueryProvider</code> provides the SQL queries and Spring Integration provides support for the following relational databases:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
PostgreSQL
</li><li class="listitem">
HSQLDB
</li><li class="listitem">
MySQL
</li><li class="listitem">
Oracle
</li><li class="listitem">
Derby
</li><li class="listitem">
H2
</li><li class="listitem">
SqlServer
</li><li class="listitem">
Sybase
</li><li class="listitem">
DB2
</li></ul></div>
<p>If your database is not listed, you can easily extend the <code class="literal">AbstractChannelMessageStoreQueryProvider</code> class and provide your own custom queries.</p>
<p>Since <span class="emphasis"><em>version 4.0</em></span>, the <code class="literal">MESSAGE_SEQUENCE</code> column has been added to the table to ensure first-in-first-out (FIFO) queueing even when messages are stored in the same millisecond.</p>
<p>Since <span class="emphasis"><em>version 5.0</em></span>, by overloading <code class="literal">ChannelMessageStorePreparedStatementSetter</code> class you can provide custom implementation for message insertion in the <code class="literal">JdbcChannelMessageStore</code>.
It might be different columns or table structure or serialization strategy.
For example, instead of default serialization to <code class="literal">byte[]</code>, we can store its structure in JSON string.</p>
<p>Below example uses the default implementation of <code class="literal">setValues</code> to store common columns and overrides the behavior just to store the message payload as varchar.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JsonPreparedStatementSetter <span class="hl-keyword">extends</span> ChannelMessageStorePreparedStatementSetter {

    <span class="hl-keyword">public</span> JsonPreparedStatementSetter() {
        <span class="hl-keyword">super</span>();
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValues(PreparedStatement preparedStatement, Message&lt;?&gt; requestMessage,
        Object groupId, String region, 	<span class="hl-keyword">boolean</span> priorityEnabled) <span class="hl-keyword">throws</span> SQLException {
        <span class="hl-comment">// Populate common columns</span>
        <span class="hl-keyword">super</span>.setValues(preparedStatement, requestMessage, groupId, region, priorityEnabled);
        <span class="hl-comment">// Store message payload as varchar</span>
        preparedStatement.setString(<span class="hl-number">6</span>, requestMessage.getPayload().toString());
    }
}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Generally it is not recommended to use a relational database for the purpose of queuing.
Instead, if possible, consider using either JMS or AMQP backed channels instead.
For further reference please see the following resources:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="ulink" href="https://www.engineyard.com/blog/2011/5-subtle-ways-youre-using-mysql-as-a-queue-and-why-itll-bite-you/" target="_top">5 subtle ways you&#8217;re using MySQL as a queue, and why it&#8217;ll bite you</a>.
</li><li class="listitem">
<a class="ulink" href="https://mikehadlow.blogspot.com/2012/04/database-as-queue-anti-pattern.html" target="_top">The Database As Queue Anti-Pattern</a>.
</li></ul></div>
</td></tr></table></div>
<p><span class="strong"><strong>Concurrent Polling</strong></span></p>
<p>When polling a <span class="emphasis"><em>Message Channel</em></span>, you have the option to configure the associated <code class="literal">Poller</code> with a <code class="literal">TaskExecutor</code> reference.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Keep in mind, though, that if you use a JDBC backed <span class="emphasis"><em>Message Channel</em></span> and you are planning on polling the channel and consequently the message store transactionally with multiple threads, you should ensure that you use a relational database that supports <a class="ulink" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_top">Multiversion Concurrency Control</a> (MVCC).
Otherwise, locking may be an issue and the performance, when using multiple threads, may not materialize as expected.
For example Apache Derby is problematic in that regard.</p>
<p>To achieve better JDBC queue throughput, and avoid issues when different threads may poll the same <code class="literal">Message</code> from the queue, it is <span class="strong"><strong>important</strong></span> to set the <code class="literal">usingIdCache</code> property of <code class="literal">JdbcChannelMessageStore</code> to <code class="literal">true</code> when using databases that do not support MVCC:</p>
</td></tr></table></div>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"queryProvider"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.jdbc.store.channel.PostgresChannelMessageStoreQueryProvider"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:transaction-synchronization-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:after-commit</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"@store.removeFromIdCache(headers.id.toString())"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;int:after-rollback</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"@store.removeFromIdCache(headers.id.toString())"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transaction-synchronization-factory&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pool"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"10"</span>
    <span class="hl-attribute">queue-capacity</span>=<span class="hl-value">"10"</span> <span class="hl-attribute">rejection-policy</span>=<span class="hl-value">"CALLER_RUNS"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"store"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.jdbc.store.JdbcChannelMessageStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelMessageStoreQueryProvider"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"queryProvider"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"region"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"TX_TIMEOUT"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"usingIdCache"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inputChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:queue</span> <span class="hl-attribute">message-store</span>=<span class="hl-value">"store"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span>

<span class="hl-tag">&lt;int:bridge</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inputChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"outputChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-delay</span>=<span class="hl-value">"500"</span> <span class="hl-attribute">receive-timeout</span>=<span class="hl-value">"500"</span>
        <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"pool"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span> <span class="hl-attribute">synchronization-factory</span>=<span class="hl-value">"syncFactory"</span>
        <span class="hl-attribute">isolation</span>=<span class="hl-value">"READ_COMMITTED"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int:bridge&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outputChannel"</span><span class="hl-tag"> /&gt;</span></pre>
<p><span class="strong"><strong>Priority Channel</strong></span></p>
<p>Starting with <span class="emphasis"><em>version 4.0</em></span>, the <code class="literal">JdbcChannelMessageStore</code> implements <code class="literal">PriorityCapableChannelMessageStore</code> and provides the <code class="literal">priorityEnabled</code> option allowing it to be used as a <code class="literal">message-store</code> reference for <code class="literal">priority-queue</code> s.
For this purpose, the <code class="literal">INT_CHANNEL_MESSAGE</code> has a <code class="literal">MESSAGE_PRIORITY</code> column to store the value of <code class="literal">PRIORITY</code> Message header.
In addition, a new <code class="literal">MESSAGE_SEQUENCE</code> column is also provided to achieve a robust first-in-first-out (FIFO) polling mechanism, even when multiple messages are stored with the same priority in the same millisecond.
Messages are polled (selected) from the database with <code class="literal">order by MESSAGE_PRIORITY DESC NULLS LAST, CREATED_DATE, MESSAGE_SEQUENCE</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It&#8217;s not recommended to use the same <code class="literal">JdbcChannelMessageStore</code> bean for priority and non-priority queue channel, because <code class="literal">priorityEnabled</code> option applies to the entire store and proper FIFO queue semantics will not be retained for the queue channel.
However the same <code class="literal">INT_CHANNEL_MESSAGE</code> table, and even <code class="literal">region</code>, can be used for both <code class="literal">JdbcChannelMessageStore</code> types.
To configure that scenario, simply extend one message store bean from the other:</p>
</td></tr></table></div>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"channelStore"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.jdbc.store.JdbcChannelMessageStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelMessageStoreQueryProvider"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"queryProvider"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"queueChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:queue</span> <span class="hl-attribute">message-store</span>=<span class="hl-value">"channelStore"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"priorityStore"</span> <span class="hl-attribute">parent</span>=<span class="hl-value">"channelStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"priorityEnabled"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"priorityChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:priority-queue</span> <span class="hl-attribute">message-store</span>=<span class="hl-value">"priorityStore"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_partitioning_a_message_store" href="#_partitioning_a_message_store"></a>19.4.4&nbsp;Partitioning a Message Store</h3></div></div></div>

<p>It is common to use a <code class="literal">JdbcMessageStore</code> as a global store for a group of applications, or nodes in the same application.
To provide some protection against name clashes, and to give control over the database meta-data configuration, the message store allows the tables to be partitioned in two ways.
One is to use separate table names, by changing the prefix as described above, and the other is to specify a "region" name for partitioning data within a single table.
An important use case for this is when the MessageStore is managing persistent queues backing a Spring Integration Message Channel.
The message data for a persistent channel is keyed in the store on the channel name, so if the channel names are not globally unique then there is the danger of channels picking up data that was not intended for them.
To avoid this, the message store <span class="emphasis"><em>region</em></span> can be used to keep data separate for different physical channels that happen to have the same logical name.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-procedures" href="#stored-procedures"></a>19.5&nbsp;Stored Procedures</h2></div></div></div>

<p>In certain situations plain JDBC support is not sufficient.
Maybe you deal with legacy relational database schemas or you have complex data processing needs, but ultimately you have to use <a class="ulink" href="https://en.wikipedia.org/wiki/Stored_procedure" target="_top">Stored Procedures</a> or Stored Functions.
Since Spring Integration 2.1, we provide three components in order to execute Stored Procedures or Stored Functions:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Stored Procedures Inbound Channel Adapter
</li><li class="listitem">
Stored Procedures Outbound Channel Adapter
</li><li class="listitem">
Stored Procedures Outbound Gateway
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sp-supported-databases" href="#sp-supported-databases"></a>19.5.1&nbsp;Supported Databases</h3></div></div></div>

<p>In order to enable calls to <span class="emphasis"><em>Stored Procedures</em></span> and <span class="emphasis"><em>Stored Functions</em></span>, the Stored Procedure components use the <a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html" target="_top"><code class="literal">org.springframework.jdbc.core.simple.SimpleJdbcCall</code></a> class.
Consequently, the following databases are fully supported for executing Stored Procedures:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Apache Derby
</li><li class="listitem">
DB2
</li><li class="listitem">
MySQL
</li><li class="listitem">
Microsoft SQL Server
</li><li class="listitem">
Oracle
</li><li class="listitem">
PostgreSQL
</li><li class="listitem">
Sybase
</li></ul></div>
<p>If you want to execute Stored Functions instead, the following databases are fully supported:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
MySQL
</li><li class="listitem">
Microsoft SQL Server
</li><li class="listitem">
Oracle
</li><li class="listitem">
PostgreSQL
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Even though your particular database may not be fully supported, chances are, that you can use the Stored Procedure Spring Integration components quite successfully anyway, provided your RDBMS supports Stored Procedures or Functions.</p>
<p>As a matter of fact, some of the provided integration tests use the <a class="ulink" href="http://www.h2database.com/" target="_top">H2 database</a>.
Nevertheless, it is very important to thoroughly test those usage scenarios.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sp-configuration" href="#sp-configuration"></a>19.5.2&nbsp;Configuration</h3></div></div></div>

<p>The Stored Procedure components provide full XML Namespace support and configuring the components is similar as for the general purpose JDBC components discussed earlier.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sp-common-config-params" href="#sp-common-config-params"></a>19.5.3&nbsp;Common Configuration Attributes</h3></div></div></div>

<p>Certain configuration parameters are shared among all Stored Procedure components and are described below:</p>
<p><span class="strong"><strong>auto-startup</strong></span></p>
<p>Lifecycle attribute signaling if this component should be started during Application Context startup.
Defaults to <code class="literal">true</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
<p><span class="strong"><strong>data-source</strong></span></p>
<p>Reference to a <code class="literal">javax.sql.DataSource</code>, which is used to access the database. <span class="emphasis"><em>Required</em></span>.</p>
<p><span class="strong"><strong>id</strong></span></p>
<p>Identifies the underlying Spring bean definition, which is an instance of either <code class="literal">EventDrivenConsumer</code> or <code class="literal">PollingConsumer</code>, depending on whether the Outbound Channel Adapter&#8217;s <code class="literal">channel</code> attribute references a <code class="literal">SubscribableChannel</code> or a <code class="literal">PollableChannel</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
<p><span class="strong"><strong>ignore-column-meta-data</strong></span></p>
<p>For fully supported databases, the underlying <a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html" target="_top"><code class="literal">SimpleJdbcCall</code></a> class can automatically retrieve the parameter information for the to be invoked Stored Procedure or Function from the JDBC Meta-data.</p>
<p>However, if the used database does not support meta data lookups or if you like to provide customized parameter definitions, this flag can be set to <code class="literal">true</code>.
It defaults to <code class="literal">false</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
<p><span class="strong"><strong>is-function</strong></span></p>
<p>If <code class="literal">true</code>, a SQL Function is called.
In that case the <code class="literal">stored-procedure-name</code> or <code class="literal">stored-procedure-name-expression</code> attributes define the name of the called function.
Defaults to <code class="literal">false</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
<p><span class="strong"><strong>stored-procedure-name</strong></span></p>
<p>The attribute specifies the name of the stored procedure.
If the <code class="literal">is-function</code> attribute is set to <code class="literal">true</code>, this attribute specifies the function name instead.
Either this property or <code class="literal">stored-procedure-name-expression</code> must be specified.</p>
<p><span class="strong"><strong>stored-procedure-name-expression</strong></span></p>
<p>This attribute specifies the name of the stored procedure using a SpEL expression.
Using SpEL you have access to the full message (if available), including its headers and payload.
You can use this attribute to invoke different Stored Procedures at runtime.
For example, you can provide Stored Procedure names that you would like to execute as a Message Header.
The expression must resolve to a String.</p>
<p>If the <code class="literal">is-function</code> attribute is set to <code class="literal">true</code>, this attribute specifies a Stored Function.
Either this property or <span class="emphasis"><em>stored-procedure-name</em></span> must be specified.</p>
<p><span class="strong"><strong>jdbc-call-operations-cache-size</strong></span></p>
<p>Defines the maximum number of cached <code class="literal">SimpleJdbcCallOperations</code> instances.
Basically, for each Stored Procedure Name a new <a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCallOperations.html" target="_top"><code class="literal">SimpleJdbcCallOperations</code></a> instance is created that in return is being cached.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">stored-procedure-name-expression</code> attribute and the <code class="literal">jdbc-call-operations-cache-size</code> were added with Spring Integration 2.2.</p>
</td></tr></table></div>
<p>The default cache size is <span class="emphasis"><em>10</em></span>.
A value of <span class="emphasis"><em>0</em></span> disables caching.
Negative values are not permitted.</p>
<p>If you enable JMX, statistical information about the <code class="literal">jdbc-call-operations-cache</code> is exposed as MBean.
Please see <a class="xref" href="system-management-chapter.html#jmx-mbean-exporter" title="10.2.7&nbsp;MBean Exporter">Section&nbsp;10.2.7, &#8220;MBean Exporter&#8221;</a> for more information.</p>
<p><span class="strong"><strong>sql-parameter-source-factory</strong></span> (Not available for the Stored Procedure Inbound Channel Adapter.)</p>
<p>Reference to a <code class="literal">SqlParameterSourceFactory</code>.
By default bean properties of the passed in <code class="literal">Message</code> payload will be used as a source for the Stored Procedure&#8217;s input parameters using a <code class="literal">BeanPropertySqlParameterSourceFactory</code>.</p>
<p>This may be sufficient for basic use cases.
For more sophisticated options, consider passing in one or more <code class="literal">ProcedureParameter</code>.
Please also refer to <a class="xref" href="jdbc.html#sp-defining-parameter-sources" title="19.5.5&nbsp;Defining Parameter Sources">Section&nbsp;19.5.5, &#8220;Defining Parameter Sources&#8221;</a>.
<span class="emphasis"><em>Optional</em></span>.</p>
<p><span class="strong"><strong>use-payload-as-parameter-source</strong></span> (Not available for the Stored Procedure Inbound Channel Adapter.)</p>
<p>If set to <code class="literal">true</code>, the payload of the Message will be used as a source for providing parameters.
If false, however, the entire Message will be available as a source for parameters.</p>
<p>If no Procedure Parameters are passed in, this property will default to <code class="literal">true</code>.
This means that using a default <code class="literal">BeanPropertySqlParameterSourceFactory</code> the bean properties of the payload will be used as a source for parameter values for the to-be-executed Stored Procedure or Stored Function.</p>
<p>However, if Procedure Parameters are passed in, then this property will by default evaluate to <code class="literal">false</code>.
<code class="literal">ProcedureParameter</code> allow for SpEL Expressions to be provided and therefore it is highly beneficial to have access to the entire Message.
The property is set on the underlying <code class="literal">StoredProcExecutor</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sp-common-config-subelements" href="#sp-common-config-subelements"></a>19.5.4&nbsp;Common Configuration Sub-Elements</h3></div></div></div>

<p>The Stored Procedure components share a common set of sub-elements to define and pass parameters to Stored Procedures or Functions.
The following elements are available:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">parameter</code>
</li><li class="listitem">
<code class="literal">returning-resultset</code>
</li><li class="listitem">
<code class="literal">sql-parameter-definition</code>
</li><li class="listitem">
<code class="literal">poller</code>
</li></ul></div>
<p><span class="strong"><strong>parameter</strong></span></p>
<p>Provides a mechanism to provide Stored Procedure parameters.
Parameters can be either static or provided using a SpEL Expressions. <span class="emphasis"><em>Optional</em></span>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span>     <a name="CO23-1" href="#CO23-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                    type=""     <a name="CO23-2" href="#CO23-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                    value=""/&gt;  <a name="CO23-3" href="#CO23-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>

<span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span>
                    <span class="hl-attribute">expression</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span> <a name="CO23-4" href="#CO23-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO23-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The name of the parameter to be passed into the Stored Procedure or Stored Function. <span class="emphasis"><em>Required</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO23-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>This attribute specifies the type of the value.
If nothing is provided this attribute will default to <code class="literal">java.lang.String</code>.
This attribute is only used when the <code class="literal">value</code> attribute is used. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO23-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The value of the parameter.
You have to provider either this attribute or the <code class="literal">expression</code> attribute must be provided instead. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO23-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Instead of the <code class="literal">value</code> attribute, you can also specify a SpEL expression for passing the value of the parameter.
If you specify the <code class="literal">expression</code> the <code class="literal">value</code> attribute is not allowed.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr></table></div>
<p><span class="strong"><strong>returning-resultset</strong></span></p>
<p>Stored Procedures may return multiple result sets.
By setting one or more <code class="literal">returning-resultset</code> elements, you can specify <code class="literal">RowMappers</code> in order to convert each returned <code class="literal">ResultSet</code> to meaningful objects.
<span class="emphasis"><em>Optional</em></span>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:returning-resultset</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">row-mapper</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span></pre>
<p><span class="strong"><strong>sql-parameter-definition</strong></span></p>
<p>If you are using a database that is fully supported, you typically don&#8217;t have to specify the Stored Procedure parameter definitions.
Instead, those parameters can be automatically derived from the JDBC Meta-data.
However, if you are using databases that are not fully supported, you must set those parameters explicitly using the <code class="literal">sql-parameter-definition</code> sub-element.</p>
<p>You can also choose to turn off any processing of parameter meta data information obtained via JDBC using the <code class="literal">ignore-column-meta-data</code> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:sql-parameter-definition</span>
                                   <span class="hl-attribute">name</span>=<span class="hl-value">""</span>                           <a name="CO24-1" href="#CO24-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                                   direction="IN"                    <a name="CO24-2" href="#CO24-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                                   type="STRING"                     <a name="CO24-3" href="#CO24-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
                                   scale="5"                         <a name="CO24-4" href="#CO24-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
                                   type-name="FOO_STRUCT"            <a name="CO24-5" href="#CO24-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
                                   return-type="fooSqlReturnType"/&gt;  <a name="CO24-6" href="#CO24-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO24-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies the name of the SQL parameter.
<span class="emphasis"><em>Required</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO24-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies the direction of the SQL parameter definition.
Defaults to <code class="literal">IN</code>.
Valid values are: <code class="literal">IN</code>, <code class="literal">OUT</code> and <code class="literal">INOUT</code>.
If your procedure is returning ResultSets, please use the <code class="literal">returning-resultset</code> element.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO24-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The SQL type used for this SQL parameter definition.
Will translate into the integer value as defined by java.sql.Types.
Alternatively you can provide the integer value as well.
If this attribute is not explicitly set, then it will default to <span class="emphasis"><em>VARCHAR</em></span>. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO24-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The scale of the SQL parameter.
Only used for numeric and decimal parameters. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO24-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The typeName for types that are user-named like: <code class="literal">STRUCT</code>, <code class="literal">DISTINCT</code>, <code class="literal">JAVA_OBJECT</code>, named array types.
This attribute is mutually exclusive with the <span class="emphasis"><em>scale</em></span> attribute.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO24-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The reference to a custom value handler for complex types.
An implementation of <a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/SqlReturnType.html" target="_top">SqlReturnType</a>.
This attribute is mutually exclusive with the <span class="emphasis"><em>scale</em></span> attribute and is applicable for OUT(INOUT)-parameters only. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr></table></div>
<p><span class="strong"><strong>poller</strong></span></p>
<p>Allows you to configure a Message Poller if this endpoint is a <code class="literal">PollingConsumer</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sp-defining-parameter-sources" href="#sp-defining-parameter-sources"></a>19.5.5&nbsp;Defining Parameter Sources</h3></div></div></div>

<p>Parameter Sources govern the techniques of retrieving and mapping the Spring Integration Message properties to the relevant Stored Procedure input parameters.
The Stored Procedure components follow certain rules.</p>
<p>By default bean properties of the passed in <code class="literal">Message</code> payload will be used as a source for the Stored Procedure&#8217;s input parameters.
In that case a <code class="literal">BeanPropertySqlParameterSourceFactory</code> will be used.
This may be sufficient for basic use cases.
The following example illustrates that default behavior.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Please be aware that for the "automatic" lookup of bean properties using the <code class="literal">BeanPropertySqlParameterSourceFactory</code> to work, your bean properties must be defined in lower case.
This is due to the fact that in <code class="literal">org.springframework.jdbc.core.metadata.CallMetaDataContext</code> (method <code class="literal">matchInParameterValuesWithCallParameters()</code>), the retrieved Stored Procedure parameter declarations are converted to lower case.
As a result, if you have camel-case bean properties such as "lastName", the lookup will fail.
In that case, please provide an explicit <code class="literal">ProcedureParameter</code>.</p>
</td></tr></table></div>
<p>Let&#8217;s assume we have a payload that consists of a simple bean with the following three properties: <span class="emphasis"><em>id</em></span>, <span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>description</em></span>.
Furthermore, we have a simplistic Stored Procedure called <span class="emphasis"><em>INSERT_COFFEE</em></span> that accepts three input parameters: <span class="emphasis"><em>id</em></span>, <span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>description</em></span>.
We also use a fully supported database.
In that case the following configuration for a Stored Procedure Outbound Adapter will be sufficient:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:stored-proc-outbound-channel-adapter</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"insertCoffeeProcedureRequestChannel"</span>
    <span class="hl-attribute">stored-procedure-name</span>=<span class="hl-value">"INSERT_COFFEE"</span><span class="hl-tag">/&gt;</span></pre>
<p>For more sophisticated options consider passing in one or more <code class="literal">ProcedureParameter</code>.</p>
<p>If you do provide <code class="literal">ProcedureParameter</code> explicitly, then as default an <code class="literal">ExpressionEvaluatingSqlParameterSourceFactory</code> will be used for parameter processing in order to enable the full power of SpEL expressions.</p>
<p>Furthermore, if you need even more control over how parameters are retrieved, consider passing in a custom implementation of a <code class="literal">SqlParameterSourceFactory</code> using the <code class="literal">sql-parameter-source-factory</code> attribute.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-procedure-inbound-channel-adapter" href="#stored-procedure-inbound-channel-adapter"></a>19.5.6&nbsp;Stored Procedure Inbound Channel Adapter</h3></div></div></div>

<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:stored-proc-inbound-channel-adapter</span>
                                   <span class="hl-attribute">channel</span>=<span class="hl-value">""</span>                                    <a name="CO25-1" href="#CO25-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                                   stored-procedure-name=""
                                   data-source=""
                                   auto-startup="true"
                                   id=""
                                   ignore-column-meta-data="false"
                                   is-function="false"
                                   max-rows-per-poll=""                          <a name="CO25-2" href="#CO25-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                                   skip-undeclared-results=""                    <a name="CO25-3" href="#CO25-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
                                   return-value-required="false"                 <a name="CO25-4" href="#CO25-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
    <span class="hl-tag">&lt;int:poller/&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:sql-parameter-definition</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">direction</span>=<span class="hl-value">"IN"</span>
                                               <span class="hl-attribute">type</span>=<span class="hl-value">"STRING"</span>
                                               <span class="hl-attribute">scale</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">type</span>=<span class="hl-value">""</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">expression</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:returning-resultset</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">row-mapper</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int-jdbc:stored-proc-inbound-channel-adapter&gt;</span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO25-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Channel to which polled messages will be sent.
If the stored procedure or function does not return any data, the payload of the Message will be Null.
<span class="emphasis"><em>Required</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO25-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Limits the number of rows extracted per query.
Otherwise all rows are extracted into the outgoing message. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO25-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>If this attribute is set to <code class="literal">true</code>, then all results from a stored procedure call that don&#8217;t have a corresponding <code class="literal">SqlOutParameter</code> declaration will be bypassed.
E.g. Stored Procedures may return an update count value, even though your Stored Procedure only declared a single result parameter.
The exact behavior depends on the used database.
The value is set on the underlying <code class="literal">JdbcTemplate</code>.
Few developers will probably ever want to process update counts, thus the value defaults to <code class="literal">true</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO25-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Indicates whether this procedure&#8217;s return value should be included.
Since <span class="emphasis"><em>Spring Integration 3.0</em></span>. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>When you declare a Poller, you may notice the Poller&#8217;s <code class="literal">max-messages-per-poll</code> attribute.
For information about how it relates to the <code class="literal">max-rows-per-poll</code> attribute of the <span class="emphasis"><em>Stored Procedure Inbound Channel Adapter</em></span>, please see <a class="xref" href="jdbc.html#jdbc-max-rows-per-poll-versus-max-messages-per-poll" title="19.1.2&nbsp;Max-rows-per-poll versus Max-messages-per-poll">Section&nbsp;19.1.2, &#8220;Max-rows-per-poll versus Max-messages-per-poll&#8221;</a> for a thorough discussion.
The meaning of the attributes is the same as for the <span class="emphasis"><em>JDBC Inbound Channel Adapter</em></span>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-procedure-outbound-channel-adapter" href="#stored-procedure-outbound-channel-adapter"></a>19.5.7&nbsp;Stored Procedure Outbound Channel Adapter</h3></div></div></div>

<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:stored-proc-outbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">""</span>                        <a name="CO26-1" href="#CO26-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                                               stored-procedure-name=""
                                               data-source=""
                                               auto-startup="true"
                                               id=""
                                               ignore-column-meta-data="false"
                                               order=""                          <a name="CO26-2" href="#CO26-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                                               sql-parameter-source-factory=""
                                               use-payload-as-parameter-source=""&gt;
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:sql-parameter-definition</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/int-jdbc:stored-proc-outbound-channel-adapter&gt;</span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO26-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The receiving Message Channel of this endpoint.
<span class="emphasis"><em>Required</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO26-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel is using a <span class="emphasis"><em>failover</em></span> dispatching strategy.
It has no effect when this endpoint itself is a Polling Consumer for a channel with a queue.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-procedure-outbound-gateway" href="#stored-procedure-outbound-gateway"></a>19.5.8&nbsp;Stored Procedure Outbound Gateway</h3></div></div></div>

<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:stored-proc-outbound-gateway</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">""</span>                        <a name="CO27-1" href="#CO27-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                                       stored-procedure-name=""
                                       data-source=""
                                   auto-startup="true"
                                   id=""
                                   ignore-column-meta-data="false"
                                   is-function="false"
                                   order=""
                                   reply-channel=""                              <a name="CO27-2" href="#CO27-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                                   reply-timeout=""                              <a name="CO27-3" href="#CO27-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
                                   return-value-required="false"                 <a name="CO27-4" href="#CO27-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
                                   skip-undeclared-results=""                    <a name="CO27-5" href="#CO27-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
                                   sql-parameter-source-factory=""
                                   use-payload-as-parameter-source=""&gt;
<span class="hl-tag">&lt;int-jdbc:sql-parameter-definition</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">direction</span>=<span class="hl-value">"IN"</span>
                                   <span class="hl-attribute">type</span>=<span class="hl-value">""</span>
                                   <span class="hl-attribute">scale</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;int-jdbc:sql-parameter-definition</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">type</span>=<span class="hl-value">""</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">expression</span>=<span class="hl-value">""</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;int-jdbc:returning-resultset</span> <span class="hl-attribute">name</span>=<span class="hl-value">""</span> <span class="hl-attribute">row-mapper</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO27-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The receiving Message Channel of this endpoint.
<span class="emphasis"><em>Required</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO27-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Message Channel to which replies should be sent, after receiving the database response. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO27-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Allows you to specify how long this gateway will wait for the reply message to be sent successfully before throwing an exception.
Keep in mind that when sending to a <code class="literal">DirectChannel</code>, the invocation will occur in the sender&#8217;s thread so the failing of the send operation may be caused by other components further downstream.
By default the Gateway will wait indefinitely.
The value is specified in milliseconds. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO27-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Indicates whether this procedure&#8217;s return value should be included. <span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO27-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>If the <code class="literal">skip-undeclared-results</code> attribute is set to <code class="literal">true</code>, then all results from a stored procedure call that don&#8217;t have a corresponding <code class="literal">SqlOutParameter</code> declaration will be bypassed.
E.g. Stored Procedures may return an update count value, even though your Stored Procedure only declared a single result parameter.
The exact behavior depends on the used database.
The value is set on the underlying <code class="literal">JdbcTemplate</code>.
Few developers will probably ever want to process update counts, thus the value defaults to <code class="literal">true</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sp-examples" href="#sp-examples"></a>19.5.9&nbsp;Examples</h3></div></div></div>

<p>In the following two examples we call <a class="ulink" href="https://db.apache.org/derby/" target="_top">Apache Derby</a> Stored Procedures.
The first procedure will call a Stored Procedure that returns a <code class="literal">ResultSet</code>, and using a <code class="literal">RowMapper</code> the data is converted into a domain object, which then becomes the Spring Integration message payload.</p>
<p>In the second sample we call a Stored Procedure that uses Output Parameters instead, in order to return data.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Please have a look at the <span class="emphasis"><em>Spring Integration Samples</em></span> project, located at null</p>
<p>The project contains the Apache Derby example referenced here, as well as instruction on how to run it.
The <span class="emphasis"><em>Spring Integration Samples</em></span> project also provides an <a class="ulink" href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/stored-procedures-oracle" target="_top">example</a> using Oracle Stored Procedures.</p>
</td></tr></table></div>
<p>In the first example, we call a Stored Procedure named <span class="emphasis"><em>FIND_ALL_COFFEE_BEVERAGES</em></span> that does not define any input parameters but which returns a <code class="literal">ResultSet</code>.</p>
<p>In Apache Derby, Stored Procedures are implemented using Java.
Here is the method signature followed by the corresponding Sql:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> findAllCoffeeBeverages(ResultSet[] coffeeBeverages)
            <span class="hl-keyword">throws</span> SQLException {
    ...
}</pre>
<pre class="programlisting">CREATE PROCEDURE FIND_ALL_COFFEE_BEVERAGES() \
PARAMETER STYLE JAVA LANGUAGE JAVA MODIFIES SQL DATA DYNAMIC RESULT SETS 1 \
EXTERNAL NAME 'org.springframework.integration.jdbc.storedproc.derby.DerbyStoredProcedures.findAllCoffeeBeverages';</pre>
<p>In Spring Integration, you can now call this Stored Procedure using e.g.
a <code class="literal">stored-proc-outbound-gateway</code></p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:stored-proc-outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outbound-gateway-storedproc-find-all"</span>
                                       <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
                                       <span class="hl-attribute">request-channel</span>=<span class="hl-value">"findAllProcedureRequestChannel"</span>
                                       <span class="hl-attribute">expect-single-result</span>=<span class="hl-value">"true"</span>
                                       <span class="hl-attribute">stored-procedure-name</span>=<span class="hl-value">"FIND_ALL_COFFEE_BEVERAGES"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;int-jdbc:returning-resultset</span> <span class="hl-attribute">name</span>=<span class="hl-value">"coffeeBeverages"</span>
    <span class="hl-attribute">row-mapper</span>=<span class="hl-value">"org.springframework.integration.support.CoffeBeverageMapper"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-jdbc:stored-proc-outbound-gateway&gt;</span></pre>
<p>In the second example, we call a Stored Procedure named <span class="emphasis"><em>FIND_COFFEE</em></span> that has one input parameter.
Instead of returning a ResultSet, an output parameter is used:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> findCoffee(<span class="hl-keyword">int</span> coffeeId, String[] coffeeDescription)
            <span class="hl-keyword">throws</span> SQLException {
    ...
}</pre>
<pre class="programlisting"><span class="hl-keyword">CREATE</span> <span class="hl-keyword">PROCEDURE</span> FIND_COFFEE(<span class="hl-keyword">IN</span> ID <span class="hl-keyword">INTEGER</span>, <span class="hl-keyword">OUT</span> COFFEE_DESCRIPTION <span class="hl-keyword">VARCHAR</span>(<span class="hl-number">200</span>)) \
<span class="hl-keyword">PARAMETER</span> <span class="hl-keyword">STYLE</span> JAVA <span class="hl-keyword">LANGUAGE</span> JAVA <span class="hl-keyword">EXTERNAL</span> <span class="hl-keyword">NAME</span> \
<span class="hl-string">'org.springframework.integration.jdbc.storedproc.derby.DerbyStoredProcedures.findCoffee'</span>;</pre>
<p>In Spring Integration, you can now call this Stored Procedure using e.g.
a <code class="literal">stored-proc-outbound-gateway</code></p>
<pre class="programlisting"><span class="hl-tag">&lt;int-jdbc:stored-proc-outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outbound-gateway-storedproc-find-coffee"</span>
                                       <span class="hl-attribute">data-source</span>=<span class="hl-value">"dataSource"</span>
                                       <span class="hl-attribute">request-channel</span>=<span class="hl-value">"findCoffeeProcedureRequestChannel"</span>
                                       <span class="hl-attribute">skip-undeclared-results</span>=<span class="hl-value">"true"</span>
                                       <span class="hl-attribute">stored-procedure-name</span>=<span class="hl-value">"FIND_COFFEE"</span>
                                       <span class="hl-attribute">expect-single-result</span>=<span class="hl-value">"true"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int-jdbc:parameter</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ID"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int-jdbc:stored-proc-outbound-gateway&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-lock-registry" href="#jdbc-lock-registry"></a>19.6&nbsp;JDBC Lock Registry</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, the <code class="literal">JdbcLockRegistry</code> is available.
Certain components (for example aggregator and resequencer) use a lock obtained from a <code class="literal">LockRegistry</code> instance to ensure that only one thread is manipulating a group at a time.
The <code class="literal">DefaultLockRegistry</code> performs this function within a single component; you can now configure an external lock registry on these components.
When used with a shared <code class="literal">MessageGroupStore</code>, the <code class="literal">JdbcLockRegistry</code> can be use to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.</p>
<p>When a lock is released by a local thread, another local thread will generally be able to acquire the lock immediately.
If a lock is released by a thread using a different registry instance, it can take up to 100ms to acquire the lock.</p>
<p>The <code class="literal">JdbcLockRegistry</code> is based on the <code class="literal">LockRepository</code> abstraction, where a <code class="literal">DefaultLockRepository</code> implementation is present.
The data base schema scripts are located in the <code class="literal">org.springframework.integration.jdbc</code> package divided to the particular RDBMS vendors.
For example the H2 DDL for lock table looks like:</p>
<pre class="programlisting"><span class="hl-keyword">CREATE</span> <span class="hl-keyword">TABLE</span> INT_LOCK  (
    LOCK_KEY <span class="hl-keyword">CHAR</span>(<span class="hl-number">36</span>),
    REGION <span class="hl-keyword">VARCHAR</span>(<span class="hl-number">100</span>),
    CLIENT_ID <span class="hl-keyword">CHAR</span>(<span class="hl-number">36</span>),
    CREATED_DATE <span class="hl-keyword">TIMESTAMP</span> <span class="hl-keyword">NOT</span> <span class="hl-keyword">NULL</span>,
    <span class="hl-keyword">constraint</span> LOCK_PK <span class="hl-keyword">primary</span> <span class="hl-keyword">key</span> (LOCK_KEY, REGION)
);</pre>
<p>The <code class="literal">INT_</code> can be changed according to the target data base design requirements.
Therefore <code class="literal">prefix</code> property must be used on the <code class="literal">DefaultLockRepository</code> bean definition.</p>
<p>Sometimes it happens that one application has moved to the state when it can&#8217;t release distributed lock - remove the particular record in the data base.
For this purpose such dead locks can be expired by the other application on the next locking invocation.
The <code class="literal">timeToLive</code> (TTL) option on the <code class="literal">DefaultLockRepository</code> is provided for this purpose.
The user may also want to specify <code class="literal">CLIENT_ID</code> for the locks stored for a given <code class="literal">DefaultLockRepository</code> instance.
In this case you can specify the <code class="literal">id</code> to be associated with the <code class="literal">DefaultLockRepository</code> as a constructor parameter.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-metadata-store" href="#jdbc-metadata-store"></a>19.7&nbsp;JDBC Metadata Store</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the JDBC <code class="literal">MetadataStore</code> (<a class="xref" href="system-management-chapter.html#metadata-store" title="10.5&nbsp;Metadata Store">Section&nbsp;10.5, &#8220;Metadata Store&#8221;</a>) implementation is available.
The <code class="literal">JdbcMetadataStore</code> can be used to maintain metadata state across application restarts.
This <code class="literal">MetadataStore</code> implementation can be used with adapters such as:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="xref" href="twitter.html#twitter-inbound" title="33.4&nbsp;Twitter Inbound Adapters">Section&nbsp;33.4, &#8220;Twitter Inbound Adapters&#8221;</a>
</li><li class="listitem">
<a class="xref" href="feed.html#feed-inbound-channel-adapter" title="14.2&nbsp;Feed Inbound Channel Adapter">Section&nbsp;14.2, &#8220;Feed Inbound Channel Adapter&#8221;</a>
</li><li class="listitem">
<a class="xref" href="files.html#file-reading" title="15.2&nbsp;Reading Files">Section&nbsp;15.2, &#8220;Reading Files&#8221;</a>
</li><li class="listitem">
<a class="xref" href="ftp.html#ftp-inbound" title="16.4&nbsp;FTP Inbound Channel Adapter">Section&nbsp;16.4, &#8220;FTP Inbound Channel Adapter&#8221;</a>
</li><li class="listitem">
<a class="xref" href="sftp.html#sftp-inbound" title="28.7&nbsp;SFTP Inbound Channel Adapter">Section&nbsp;28.7, &#8220;SFTP Inbound Channel Adapter&#8221;</a>
</li></ul></div>
<p>In order to configure these adapters to use the <code class="literal">JdbcMetadataStore</code>, simply declare a Spring bean using the
bean name <span class="strong"><strong>metadataStore</strong></span>. The <span class="emphasis"><em>Twitter Inbound Channel Adapter</em></span> and the <span class="emphasis"><em>Feed Inbound Channel Adapter</em></span> will both
automatically pick up and use the declared <code class="literal">JdbcMetadataStore</code>:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> MetadataStore metadataStore(DataSource dataSource) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> JdbcMetadataStore(dataSource);
}</pre>
<p>Data base schema scripts for several RDMBS vendors are located in the <code class="literal">org.springframework.integration.jdbc</code> package.
For example the H2 DDL for metadata table looks like:</p>
<pre class="programlisting"><span class="hl-keyword">CREATE</span> <span class="hl-keyword">TABLE</span> INT_METADATA_STORE  (
	METADATA_KEY <span class="hl-keyword">VARCHAR</span>(<span class="hl-number">255</span>) <span class="hl-keyword">NOT</span> <span class="hl-keyword">NULL</span>,
	METADATA_VALUE <span class="hl-keyword">VARCHAR</span>(<span class="hl-number">4000</span>),
	REGION <span class="hl-keyword">VARCHAR</span>(<span class="hl-number">100</span>) <span class="hl-keyword">NOT</span> <span class="hl-keyword">NULL</span>,
	<span class="hl-keyword">constraint</span> METADATA_STORE <span class="hl-keyword">primary</span> <span class="hl-keyword">key</span> (METADATA_KEY, REGION)
);</pre>
<p>The <code class="literal">INT_</code> prefix can be changed according to the target data base design requirements and the <code class="literal">JdbcMetadataStore</code> can be configured to use the custom prefix.</p>
<p>The <code class="literal">JdbcMetadataStore</code> implements <code class="literal">ConcurrentMetadataStore</code>, allowing it to be reliably shared across multiple
application instances where only one instance will be allowed to store or modify a key&#8217;s value.
All of these operations are <span class="emphasis"><em>atomic</em></span> via transaction guarantees.</p>
<p>Transaction management is required to use <code class="literal">JdbcMetadataStore</code>.
Inbound Channel Adapters can be supplied with a reference to the <code class="literal">TransactionManager</code> in the poller configuration.
Unlike non-transactional <code class="literal">MetadataStore</code> implementations, with <code class="literal">JdbcMetadataStore</code>, the entry appears in the target table only after the transaction commits.
When a rollback occurs, no entries is added to the <code class="literal">INT_METADATA_STORE</code> table.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="http.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="jpa.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">18.&nbsp;HTTP Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;20.&nbsp;JPA Support</td></tr></table></div></body></html>