<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>38.&nbsp;XMPP Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="xml.html" title="37.&nbsp;XML Support - Dealing with XML Payloads"><link rel="next" href="zookeeper.html" title="39.&nbsp;Zookeeper Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">38.&nbsp;XMPP Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="xml.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="zookeeper.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="xmpp" href="#xmpp"></a>38.&nbsp;XMPP Support</h2></div></div></div>

<p>Spring Integration provides Channel Adapters for <a class="ulink" href="http://www.xmpp.org" target="_top">XMPP</a>.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-intro" href="#xmpp-intro"></a>38.1&nbsp;Introduction</h2></div></div></div>

<p>XMPP describes a way for multiple agents to communicate with each other in a distributed system.
The canonical use case is to send and receive chat messages, though XMPP can be, and is, used for far more applications.
XMPP is used to describe a network of actors.
Within that network, actors may address each other directly, as well as broadcast status changes (e.g.
"presence").</p>
<p>XMPP provides the messaging fabric that underlies some of the biggest Instant Messaging networks in the world, including Google Talk (GTalk) - which is also available from within GMail - and Facebook Chat.
There are many good open-source XMPP servers available.
Two popular implementations are <a class="ulink" href="http://www.igniterealtime.org/projects/openfire/" target="_top"><span class="emphasis"><em>Openfire</em></span></a> and <a class="ulink" href="http://www.ejabberd.im" target="_top"><span class="emphasis"><em>ejabberd</em></span></a></p>
<p>Spring integration provides support for XMPP via XMPP adapters which support sending and receiving both XMPP chat messages and presence changes from other entries in your roster.
As with other adapters, the XMPP adapters come with support for a convenient namespace-based configuration.
To configure the XMPP namespace, include the following elements in the headers of your XML configuration file:</p>
<pre class="programlisting">xmlns:int-xmpp="http://www.springframework.org/schema/integration/xmpp"
xsi:schemaLocation="http://www.springframework.org/schema/integration/xmpp
	http://www.springframework.org/schema/integration/xmpp/spring-integration-xmpp.xsd"</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-connection" href="#xmpp-connection"></a>38.2&nbsp;XMPP Connection</h2></div></div></div>

<p>Before using inbound or outbound XMPP adapters to participate in the XMPP network, an actor must establish its XMPP connection.
This connection object could be shared by all XMPP adapters connected to a particular account.
Typically this requires - at a minimum -<code class="literal">user</code>, <code class="literal">password</code>, and <code class="literal">host</code>.
To create a basic XMPP connection, you can utilize the convenience of the namespace.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:xmpp-connection</span>
    <span class="hl-attribute">id</span>=<span class="hl-value">"myConnection"</span>
    <span class="hl-attribute">user</span>=<span class="hl-value">"user"</span>
    <span class="hl-attribute">password</span>=<span class="hl-value">"password"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"host"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"port"</span>
    <span class="hl-attribute">resource</span>=<span class="hl-value">"theNameOfTheResource"</span>
    <span class="hl-attribute">subscription-mode</span>=<span class="hl-value">"accept_all"</span><span class="hl-tag">/&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For added convenience you can rely on the default naming convention and omit the <code class="literal">id</code> attribute.
The default name <span class="emphasis"><em>xmppConnection</em></span> will be used for this connection bean.</p>
</td></tr></table></div>
<p>If the XMPP Connection goes stale, reconnection attempts will be made with an automatic login as long as the previous connection state was logged (authenticated).
We also register a <code class="literal">ConnectionListener</code> which will log connection events if the DEBUG logging level is enabled.</p>
<p>The <code class="literal">subscription-mode</code> initiates the Roster listener to deal with incoming subscriptions from other users.
This functionality isn&#8217;t always available for the target XMPP servers.
For example GCM/FCM fully disables it.
To switch off the Roster listener for subscriptions you should configure it with an empty string when using XML configuration: <code class="literal">subscription-mode=""</code>, or with <code class="literal">XmppConnectionFactoryBean.setSubscriptionMode(null)</code> when using Java Configuration. Doing so will disable Roster at the login phase as well.
See <code class="literal">Roster.setRosterLoadedAtLogin(Boolean)</code> for more information.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-messages" href="#xmpp-messages"></a>38.3&nbsp;XMPP Messages</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xmpp-message-inbound-channel-adapter" href="#xmpp-message-inbound-channel-adapter"></a>38.3.1&nbsp;Inbound Message Channel Adapter</h3></div></div></div>

<p>The Spring Integration adapters support receiving chat messages from other users in the system.
To do this, the <span class="emphasis"><em>Inbound Message Channel Adapter</em></span> "logs in" as a user on your behalf and receives the messages sent to that user.
Those messages are then forwarded to your Spring Integration client.
Configuration support for the XMPP <span class="emphasis"><em>Inbound Message Channel Adapter</em></span> is provided via the <code class="literal">inbound-channel-adapter</code> element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"xmppInboundAdapter"</span>
	<span class="hl-attribute">channel</span>=<span class="hl-value">"xmppInbound"</span>
	<span class="hl-attribute">xmpp-connection</span>=<span class="hl-value">"testConnection"</span>
	<span class="hl-attribute">payload-expression</span>=<span class="hl-value">"getExtension('google:mobile:data').json"</span>
	<span class="hl-attribute">stanza-filter</span>=<span class="hl-value">"stanzaFilter"</span>
	<span class="hl-attribute">auto-startup</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>
<p>As you can see amongst the usual attributes this adapter also requires a reference to an XMPP Connection.</p>
<p>It is also important to mention that the XMPP inbound adapter is an <span class="emphasis"><em>event driven adapter</em></span> and a <code class="literal">Lifecycle</code> implementation.
When started it will register a <code class="literal">PacketListener</code> that will listen for incoming XMPP Chat Messages.
It forwards any received messages to the underlying adapter which will convert them to Spring Integration Messages and send them to the specified <code class="literal">channel</code>.
It will unregister the <code class="literal">PacketListener</code> when it is stopped.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span> the <code class="literal">ChatMessageListeningEndpoint</code> (and its <code class="literal">&lt;int-xmpp:inbound-channel-adapter&gt;</code>)
supports a <code class="literal">org.jivesoftware.smack.filter.StanzaFilter</code> injection to be registered on the provided <code class="literal">XMPPConnection</code>
together with an internal <code class="literal">StanzaListener</code> implementation.
See their <a class="ulink" href="https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/XMPPConnection.html#addAsyncStanzaListener%28org.jivesoftware.smack.StanzaListener,%20org.jivesoftware.smack.filter.StanzaFilter%29" target="_top">JavaDocs</a> for more information.</p>
<p>Also with the <span class="emphasis"><em>version 4.3</em></span> the <code class="literal">payload-expression</code> has been introduced for the <code class="literal">ChatMessageListeningEndpoint</code>.
The incoming <code class="literal">org.jivesoftware.smack.packet.Message</code> represents a root object of evaluation context.
This option is useful in case of <a class="xref" href="xmpp.html#xmpp-extensions" title="38.7&nbsp;XMPP Extensions">Section&nbsp;38.7, &#8220;XMPP Extensions&#8221;</a>.
For example, for the GCM protocol we can extract the body using expression:</p>
<pre class="programlisting">payload-expression="getExtension('google:mobile:data').json"</pre>
<p>for the XHTML protocol:</p>
<pre class="programlisting">payload-expression="getExtension(T(org.jivesoftware.smackx.xhtmlim.packet.XHTMLExtension).NAMESPACE).bodies[0]"</pre>
<p>To simplify the access to the Extension in the XMPP Message, the <code class="literal">extension</code> variable is added into the
<code class="literal">EvaluationContext</code>.
Note, it is done only when one and only one Extension is present in the Message.
The samples above with the <code class="literal">namespace</code> manipulations can be simplified to something like:</p>
<pre class="programlisting"> ----
 payload-expression="#extension.json"
 payload-expression="#extension.bodies[0]"
 ----</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xmpp-message-outbound-channel-adapter" href="#xmpp-message-outbound-channel-adapter"></a>38.3.2&nbsp;Outbound Message Channel Adapter</h3></div></div></div>

<p>You may also send chat messages to other users on XMPP using the <span class="emphasis"><em>Outbound Message Channel Adapter</em></span>.
Configuration support for the XMPP <span class="emphasis"><em>Outbound Message Channel Adapter</em></span> is provided via the <code class="literal">outbound-channel-adapter</code> element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundEventAdapter"</span>
						<span class="hl-attribute">channel</span>=<span class="hl-value">"outboundEventChannel"</span>
						<span class="hl-attribute">xmpp-connection</span>=<span class="hl-value">"testConnection"</span><span class="hl-tag">/&gt;</span></pre>
<p>The adapter expects as its input - at a minimum - a payload of type <code class="literal">java.lang.String</code>, and a header value for
<code class="literal">XmppHeaders.CHAT_TO</code> that specifies to which user the Message should be sent.
To create a message you might use the following Java code:</p>
<pre class="programlisting">Message&lt;String&gt; xmppOutboundMsg = MessageBuilder.withPayload(<span class="hl-string">"Hello, XMPP!"</span> )
						.setHeader(XmppHeaders.CHAT_TO, <span class="hl-string">"userhandle"</span>)
						.build();</pre>
<p>Another mechanism of setting the header is by using the XMPP header-enricher support.
Here is an example.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:header-enricher</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int-xmpp:chat-to</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test1@example.org"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-xmpp:header-enricher&gt;</span></pre>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span> the packet extension support has been added to the <code class="literal">ChatMessageSendingMessageHandler</code>
(<code class="literal">&lt;int-xmpp:outbound-channel-adapter&gt;</code>).
Alongside with the regular <code class="literal">String</code> and <code class="literal">org.jivesoftware.smack.packet.Message</code> <code class="literal">payload</code>, now you can send a message
with a <code class="literal">payload</code> as a <code class="literal">org.jivesoftware.smack.packet.ExtensionElement</code> which is populated to the
<code class="literal">org.jivesoftware.smack.packet.Message.addExtension()</code> instead of <code class="literal">setBody()</code>.
For the convenience an <code class="literal">extension-provider</code> option has been added for the <code class="literal">ChatMessageSendingMessageHandler</code>
to allow to inject <code class="literal">org.jivesoftware.smack.provider.ExtensionElementProvider</code>, which builds an <code class="literal">ExtensionElement</code>
against the <code class="literal">payload</code> at runtime.
For this case the payload must be <code class="literal">String</code> in JSON or XML format depending of the XEP protocol.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-presence" href="#xmpp-presence"></a>38.4&nbsp;XMPP Presence</h2></div></div></div>

<p>XMPP also supports broadcasting state.
You can use this capability to let people who have you on their roster see your state changes.
This happens all the time with your IM clients; you change your away status, and then set an away message, and everybody who has you on their roster sees your icon or username change to reflect this new state, and additionally might see your new "away" message.
If you would like to receive notification, or notify others, of state changes, you can use Spring Integration&#8217;s "presence" adapters.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xmpp-roster-inbound-channel-adapter" href="#xmpp-roster-inbound-channel-adapter"></a>38.4.1&nbsp;Inbound Presence Message Channel Adapter</h3></div></div></div>

<p>Spring Integration provides an <span class="emphasis"><em>Inbound Presence Message Channel Adapter</em></span> which supports receiving Presence events from other users in the system who happen to be on your Roster.
To do this, the adapter "logs in" as a user on your behalf, registers a <code class="literal">RosterListener</code> and forwards received Presence update events as Messages to the channel identified by the <code class="literal">channel</code> attribute.
The payload of the Message will be a <code class="literal">org.jivesoftware.smack.packet.Presence</code> object (see <a class="ulink" href="https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.html" target="_top">https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.html</a>).</p>
<p>Configuration support for the XMPP <span class="emphasis"><em>Inbound Presence Message Channel Adapter</em></span> is provided via the <code class="literal">presence-inbound-channel-adapter</code> element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:presence-inbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"outChannel"</span>
		<span class="hl-attribute">xmpp-connection</span>=<span class="hl-value">"testConnection"</span> <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span></pre>
<p>As you can see amongst the usual attributes this adapter also requires a reference to an XMPP Connection.
It is also important to mention that this adapter is an event driven adapter and a <code class="literal">Lifecycle</code> implementation.
It will register a <code class="literal">RosterListener</code> when started and will unregister that <code class="literal">RosterListener</code> when stopped.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xmpp-roster-outbound-channel-adapter" href="#xmpp-roster-outbound-channel-adapter"></a>38.4.2&nbsp;Outbound Presence Message Channel Adapter</h3></div></div></div>

<p>Spring Integration also supports sending Presence events to be seen by other users in the network who happen to have you on their Roster.
When you send a Message to the <span class="emphasis"><em>Outbound Presence Message Channel Adapter</em></span> it extracts the payload, which is expected to be of type <code class="literal">org.jivesoftware.smack.packet.Presence</code> and sends it to the XMPP Connection, thus advertising your presence events to the rest of the network.</p>
<p>Configuration support for the XMPP <span class="emphasis"><em>Outbound Presence Message Channel Adapter</em></span> is provided via the <code class="literal">presence-outbound-channel-adapter</code> element.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:presence-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"eventOutboundPresenceChannel"</span>
	<span class="hl-attribute">xmpp-connection</span>=<span class="hl-value">"testConnection"</span><span class="hl-tag">/&gt;</span></pre>
<p>It can also be a <span class="emphasis"><em>Polling Consumer</em></span> (if it receives Messages from a Pollable Channel) in which case you would need to register a Poller.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-xmpp:presence-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pollingOutboundPresenceAdapter"</span>
		<span class="hl-attribute">xmpp-connection</span>=<span class="hl-value">"testConnection"</span>
		<span class="hl-attribute">channel</span>=<span class="hl-value">"pollingChannel"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-xmpp:presence-outbound-channel-adapter&gt;</span></pre>
<p>Like its inbound counterpart, it requires a reference to an XMPP Connection.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you are relying on the default naming convention for an XMPP Connection bean (described earlier), and you have only one XMPP Connection bean configured in your Application Context, you may omit the <code class="literal">xmpp-connection</code> attribute.
In that case, the bean with the name <span class="emphasis"><em>xmppConnection</em></span> will be located and injected into the adapter.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-advanced" href="#xmpp-advanced"></a>38.5&nbsp;Advanced Configuration</h2></div></div></div>

<p>Since Spring Integration XMPP support is based on the Smack 4.0 API (<a class="ulink" href="http://www.igniterealtime.org/projects/smack/" target="_top">http://www.igniterealtime.org/projects/smack/</a>), it is important to know a few details related to more complex configuration of the XMPP Connection object.</p>
<p>As stated earlier the <code class="literal">xmpp-connection</code> namespace support is designed to simplify basic connection configuration and only supports a few common configuration attributes.
However, the <code class="literal">org.jivesoftware.smack.ConnectionConfiguration</code> object defines about 20 attributes, and there is no real value of adding namespace support for all of them.
So, for more complex connection configurations, simply configure an instance of our <code class="literal">XmppConnectionFactoryBean</code> as a regular bean, and inject a <code class="literal">org.jivesoftware.smack.ConnectionConfiguration</code> as a constructor argument to that FactoryBean.
Every property you need, can be specified directly on that ConnectionConfiguration instance (a bean definition with the <span class="emphasis"><em>p</em></span> namespace would work well).
This way SSL, or any other attributes, could be set directly.
Here&#8217;s an example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"xmppConnection"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.xmpp.XmppConnectionFactoryBean"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.jivesoftware.smack.ConnectionConfiguration"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myServiceName"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"socketFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"..."</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundEventChannel"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-xmpp:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundEventAdapter"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"outboundEventChannel"</span>
    <span class="hl-attribute">xmpp-connection</span>=<span class="hl-value">"xmppConnection"</span><span class="hl-tag">/&gt;</span></pre>
<p>Another important aspect of the Smack API is static initializers.
For more complex cases (e.g., registering a SASL Mechanism), you may need to execute certain static initializers.
One of those static initializers is <code class="literal">SASLAuthentication</code>, which allows you to register supported SASL mechanisms.
For that level of complexity, we would recommend Spring JavaConfig-style of the XMPP Connection configuration.
Then, you can configure the entire component through Java code and execute all other necessary Java code including static initializers at the appropriate time.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomConnectionConfiguration {
  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span class="hl-keyword">public</span> XMPPConnection xmppConnection() {
	SASLAuthentication.supportSASLMechanism(<span class="hl-string">"EXTERNAL"</span>, <span class="hl-number">0</span>); <span class="hl-comment">// static initializer</span>

	ConnectionConfiguration config = <span class="hl-keyword">new</span> ConnectionConfiguration(<span class="hl-string">"localhost"</span>, <span class="hl-number">5223</span>);
	config.setTrustorePath(<span class="hl-string">"path_to_truststore.jks"</span>);
	config.setSecurityEnabled(true);
	config.setSocketFactory(SSLSocketFactory.getDefault());
	<span class="hl-keyword">return</span> <span class="hl-keyword">new</span> XMPPConnection(config);
  }
}</pre>
<p>For more information on the JavaConfig style of Application Context configuration, refer to the following section
in the <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-java" target="_top">Spring Reference Manual</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-message-headers" href="#xmpp-message-headers"></a>38.6&nbsp;XMPP Message Headers</h2></div></div></div>

<p>The Spring Integration XMPP Adapters will map standard XMPP properties automatically.
These properties will be copied by default to and from Spring Integration <code class="literal">MessageHeaders</code> using the
<a class="ulink" href="http://docs.spring.io/spring-integration/api/org/springframework/integration/xmpp/support/DefaultXmppHeaderMapper.html" target="_top">DefaultXmppHeaderMapper</a>.</p>
<p>Any user-defined headers will NOT be copied to or from an XMPP Message, unless explicitly specified by the
<span class="emphasis"><em>requestHeaderNames</em></span> and/or <span class="emphasis"><em>replyHeaderNames</em></span> properties of the <code class="literal">DefaultXmppHeaderMapper</code>.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>When mapping user-defined headers, the values can also contain simple wildcard patterns (e.g. "foo*" or "*foo") to
be matched.</p>
</td></tr></table></div>
<p>Starting with <span class="emphasis"><em>version 4.1</em></span>, the <code class="literal">AbstractHeaderMapper</code> (a <code class="literal">DefaultXmppHeaderMapper</code> superclass) allows the
<code class="literal">NON_STANDARD_HEADERS</code> token to be configured for the <span class="emphasis"><em>requestHeaderNames</em></span> property (in addition to existing
<code class="literal">STANDARD_REQUEST_HEADERS</code>) to map all user-defined headers.</p>
<p>Class <code class="literal">org.springframework.xmpp.XmppHeaders</code> identifies the default headers that will be used by the <code class="literal">DefaultXmppHeaderMapper</code>:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
xmpp_from
</li><li class="listitem">
xmpp_subject
</li><li class="listitem">
xmpp_thread
</li><li class="listitem">
xmpp_to
</li><li class="listitem">
xmpp_type
</li></ul></div>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, patterns in the header mappings can be negated by preceding the pattern with <code class="literal">!</code>.
Negated patterns get priority, so a list such as
<code class="literal">STANDARD_REQUEST_HEADERS,foo,ba*,!bar,!baz,qux,!foo</code> will <span class="strong"><strong>NOT</strong></span> map <code class="literal">foo</code>
(nor <code class="literal">bar</code> nor <code class="literal">baz</code>); the standard headers plus <code class="literal">bad</code>, <code class="literal">qux</code> will be mapped.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>If you have a user defined header that begins with <code class="literal">!</code> that you <span class="strong"><strong>do</strong></span> wish to map, you need to escape it with
<code class="literal">\</code> thus: <code class="literal">STANDARD_REQUEST_HEADERS,\!myBangHeader</code> and it <span class="strong"><strong>WILL</strong></span> be mapped.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xmpp-extensions" href="#xmpp-extensions"></a>38.7&nbsp;XMPP Extensions</h2></div></div></div>

<p>The XMPP protocol stands for <span class="strong"><strong>eXstensible Messaging and Presence Protocol</strong></span>.
The "extensible" part is important.
XMPP is based around XML, a data format that supports a concept known as <span class="emphasis"><em>namespacing</em></span>.</p>
<p>Through namespacing, you can add bits to XMPP that are not defined in the original specifications.
This is important because the XMPP specification deliberately describes only a set of core things like:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
How a client connects to a server
</li><li class="listitem">
Encryption (SSL/TLS)
</li><li class="listitem">
Authentication
</li><li class="listitem">
How servers can communicate with each other to relay messages
</li><li class="listitem">
and a few other basic building blocks.
</li></ul></div>
<p>Once you have implemented this, you have an XMPP client and can send any kind of data you like.
But that&#8217;s not the end.</p>
<p>For example, perhaps you decide that you want to include formatting in a message (bold, italic, etc.) which is not
defined in the core XMPP specification.
Well, you can make up a way to do that, but unless everyone else does it the same way as you,
no other software will be able interpret it (they will just ignore namespaces they don&#8217;t understand).</p>
<p>So the XMPP Standards Foundation (XSF) publishes a series of extra documents, known as
<a class="ulink" href="http://xmpp.org/extensions/xep-0001.html" target="_top">XMPP Enhancement Proposals</a> (XEPs).
In general each XEP describes a particular activity (from message formatting, to file transfers, multi-user
chats and many more), and they provide a standard format for everyone to use for that activity.</p>
<p>The Smack API provides many XEP implementations with its <code class="literal">extensions</code> and <code class="literal">experimental</code>
<a class="ulink" href="http://www.igniterealtime.org/builds/smack/docs/latest/documentation/extensions/index.html" target="_top">projects</a>.
And starting with Spring Integration <span class="emphasis"><em>version 4.3</em></span> any XEP can be use with the existing XMPP channel adapters.</p>
<p>To be able to process XEPs or any other custom XMPP extensions, the Smack&#8217;s <code class="literal">ProviderManager</code> pre-configuration
must be provided.
It can be done via direct usage from the <code class="literal">static</code> Java code:</p>
<pre class="programlisting">ProviderManager.addIQProvider(<span class="hl-string">"element"</span>, <span class="hl-string">"namespace"</span>, <span class="hl-keyword">new</span> MyIQProvider());
ProviderManager.addExtensionProvider(<span class="hl-string">"element"</span>, <span class="hl-string">"namespace"</span>, <span class="hl-keyword">new</span> MyExtProvider());</pre>
<p>or via <code class="literal">.providers</code> configuration file in the specific instance and JVM argument:</p>
<pre class="programlisting">-Dsmack.provider.file=file:///c:/my/provider/mycustom.providers</pre>
<p>where <code class="literal">mycustom.providers</code> might be like this:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0"?&gt;</span>
<span class="hl-tag">&lt;smackProviders&gt;</span>
<span class="hl-tag">&lt;iqProvider&gt;</span>
    <span class="hl-tag">&lt;elementName&gt;</span>query<span class="hl-tag">&lt;/elementName&gt;</span>
    <span class="hl-tag">&lt;namespace&gt;</span>jabber:iq:time<span class="hl-tag">&lt;/namespace&gt;</span>
    <span class="hl-tag">&lt;className&gt;</span>org.jivesoftware.smack.packet.Time<span class="hl-tag">&lt;/className&gt;</span>
<span class="hl-tag">&lt;/iqProvider&gt;</span>

<span class="hl-tag">&lt;iqProvider&gt;</span>
    <span class="hl-tag">&lt;elementName&gt;</span>query<span class="hl-tag">&lt;/elementName&gt;</span>
    <span class="hl-tag">&lt;namespace&gt;</span>http://jabber.org/protocol/disco#items<span class="hl-tag">&lt;/namespace&gt;</span>
    <span class="hl-tag">&lt;className&gt;</span>org.jivesoftware.smackx.provider.DiscoverItemsProvider<span class="hl-tag">&lt;/className&gt;</span>
<span class="hl-tag">&lt;/iqProvider&gt;</span>

<span class="hl-tag">&lt;extensionProvider&gt;</span>
    <span class="hl-tag">&lt;elementName&gt;</span>subscription<span class="hl-tag">&lt;/elementName&gt;</span>
    <span class="hl-tag">&lt;namespace&gt;</span>http://jabber.org/protocol/pubsub<span class="hl-tag">&lt;/namespace&gt;</span>
    <span class="hl-tag">&lt;className&gt;</span>org.jivesoftware.smackx.pubsub.provider.SubscriptionProvider<span class="hl-tag">&lt;/className&gt;</span>
<span class="hl-tag">&lt;/extensionProvider&gt;</span>
<span class="hl-tag">&lt;/smackProviders&gt;</span></pre>
<p>For example the most popular XMPP messaging extension is
<a class="ulink" href="https://developers.google.com/cloud-messaging/" target="_top">Google Cloud Messaging</a> (GCM).
The Smack provides the particular <code class="literal">org.jivesoftware.smackx.gcm.provider.GcmExtensionProvider</code> for that and
registers that by default with the <code class="literal">smack-experimental</code> jar in the classpath using <code class="literal">experimental.providers</code> resource:</p>
<pre class="programlisting"><span class="hl-comment">&lt;!-- GCM JSON payload --&gt;</span>
<span class="hl-tag">&lt;extensionProvider&gt;</span>
    <span class="hl-tag">&lt;elementName&gt;</span>gcm<span class="hl-tag">&lt;/elementName&gt;</span>
    <span class="hl-tag">&lt;namespace&gt;</span>google:mobile:data<span class="hl-tag">&lt;/namespace&gt;</span>
    <span class="hl-tag">&lt;className&gt;</span>org.jivesoftware.smackx.gcm.provider.GcmExtensionProvider<span class="hl-tag">&lt;/className&gt;</span>
<span class="hl-tag">&lt;/extensionProvider&gt;</span></pre>
<p>Also the <code class="literal">GcmPacketExtension</code> is present for the target messaging protocol to parse incoming packets and build outgoing:</p>
<pre class="programlisting">GcmPacketExtension gcmExtension = (GcmPacketExtension) xmppMessage.getExtension(GcmPacketExtension.NAMESPACE);
String message = gcmExtension.getJson());</pre>
<pre class="programlisting">GcmPacketExtension packetExtension = <span class="hl-keyword">new</span> GcmPacketExtension(gcmJson);
Message smackMessage = <span class="hl-keyword">new</span> Message();
smackMessage.addExtension(packetExtension);</pre>
<p>See <a class="xref" href="xmpp.html#xmpp-message-inbound-channel-adapter" title="38.3.1&nbsp;Inbound Message Channel Adapter">Section&nbsp;38.3.1, &#8220;Inbound Message Channel Adapter&#8221;</a> and <a class="xref" href="xmpp.html#xmpp-message-outbound-channel-adapter" title="38.3.2&nbsp;Outbound Message Channel Adapter">Section&nbsp;38.3.2, &#8220;Outbound Message Channel Adapter&#8221;</a> above for more information.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xml.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="zookeeper.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.&nbsp;XML Support - Dealing with XML Payloads&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;39.&nbsp;Zookeeper Support</td></tr></table></div></body></html>