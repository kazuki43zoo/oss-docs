<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Appendix&nbsp;C.&nbsp;Transaction Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-appendices.html" title="Part&nbsp;VI.&nbsp;Appendices"><link rel="prev" href="message-publishing.html" title="Appendix&nbsp;B.&nbsp;Message Publishing"><link rel="next" href="security.html" title="Appendix&nbsp;D.&nbsp;Security in Spring Integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix&nbsp;C.&nbsp;Transaction Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="message-publishing.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;VI.&nbsp;Appendices</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr></table><hr></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="transactions" href="#transactions"></a>Appendix&nbsp;C.&nbsp;Transaction Support</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-support" href="#transaction-support"></a>C.1&nbsp;Understanding Transactions in Message flows</h2></div></div></div>

<p>Spring Integration exposes several hooks to address transactional needs of you message flows.
But to better understand these hooks and how you can benefit from them we must first revisit the 6 mechanisms that could be used to initiate Message flows and see how transactional needs of these flows could be addressed within each of these mechanisms.</p>
<p>Here are the 6 mechanisms to initiate a Message flow and their short summary (details for each are provided throughout this manual):</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>Gateway Proxy</em></span> - Your basic Messaging Gateway
</li><li class="listitem">
<span class="emphasis"><em>MessageChannel</em></span> - Direct interactions with MessageChannel methods (e.g., channel.send(message))
</li><li class="listitem">
<span class="emphasis"><em>Message Publisher</em></span> - the way to initiate message flow as the by-product of method invocations on Spring beans
</li><li class="listitem">
<span class="emphasis"><em>Inbound Channel Adapters/Gateways</em></span> - the way to initiate message flow based on connecting third-party system with Spring Integration messaging system(e.g., [JmsMessage] &#8594; Jms Inbound Adapter[SI Message] &#8594; SI Channel)
</li><li class="listitem">
<span class="emphasis"><em>Scheduler</em></span> - the way to initiate message flow based on scheduling events distributed by a pre-configured Scheduler
</li><li class="listitem">
<span class="emphasis"><em>Poller</em></span> - similar to the Scheduler and is the way to initiate message flow based on scheduling or interval-based events distributed by a pre-configured Poller
</li></ul></div>
<p>These 6 could be split in 2 general categories:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>Message flows initiated by a USER process</em></span> - Example scenarios in this category would be invoking a Gateway method or explicitly sending a Message to a MessageChannel.
In other words, these message flows depend on a third party process (e.g., some code that we wrote) to be initiated.
</li><li class="listitem">
<span class="emphasis"><em>Message flows initiated by a DAEMON process</em></span> - Example scenarios in this category would be a Poller polling a Message queue to initiate a new Message flow with the polled Message or a Scheduler scheduling the process by creating a new Message and initiating a message flow at a predefined time.
</li></ul></div>
<p>Clearly the&nbsp;<span class="emphasis"><em>Gateway Proxy</em></span>, <span class="emphasis"><em>MessageChannel.send(..)</em></span> and <span class="emphasis"><em>MessagePublisher</em></span> all belong to the 1st category and <span class="emphasis"><em>Inbound Adapters/Gateways</em></span>, <span class="emphasis"><em>Scheduler</em></span> and <span class="emphasis"><em>Poller</em></span> belong to the 2nd.</p>
<p>So, how do we address transactional needs in various scenarios within each category and is there a need for Spring Integration to provide something explicitly with regard to transactions for a particular scenario? Or, can Spring&#8217;s Transaction Support be leveraged instead?.</p>
<p>The first and most obvious goal is NOT to re-invent something that has already been invented unless you can provide a better solution.
In our case Spring itself provides first class support for transaction management.
So our goal here is not to provide something new but rather delegate/use Spring to benefit from the existing support for transactions.
In other words as a framework we must expose hooks to the Transaction management functionality provided by Spring.
But since Spring Integration configuration is based on Spring Configuration it is not always necessary to expose these hooks as they are already exposed via Spring natively.
Remember every Spring Integration component is a Spring Bean after all.</p>
<p>With this goal in mind let&#8217;s look at the two scenarios.&nbsp;</p>
<p>If you think about it, Message flows that are initiated by the <span class="emphasis"><em>USER process</em></span> (Category 1) and obviously configured in a Spring Application Context, are subject to transactional configuration of such processes and therefore don&#8217;t need to be explicitly configured by Spring Integration to support transactions.
The transaction could and should be initiated through standard Transaction support provided by Spring.
The Spring Integration message flow will honor the transactional semantics of the components naturally because it is Spring configured.
For example, a Gateway or ServiceActivator method could be annotated with <code class="literal">@Transactional</code> or <code class="literal">TransactionInterceptor</code> could be defined in an XML configuration with a point-cut expression pointing to specific methods that should be transactional.
The bottom line is that you have full control over transaction configuration and boundaries in these scenarios.</p>
<p>However, things are a bit different when it comes to Message flows initiated by the <span class="emphasis"><em>DAEMON process</em></span> (Category 2).
Although configured by the developer these flows do not directly involve a human or some other process to be initiated.
These are trigger-based flows that are initiated by a trigger process (DAEMON process) based on the configuration of such process.
For example, we could have a Scheduler initiating a message flow every Friday night of every week.
We can also configure a trigger that initiates a Message flow every second, etc.
So, we obviously need a way to let these trigger-based processes know of our intention to make the resulting Message flows transactional so that a Transaction context could be created whenever a new Message flow is initiated.
In other words we need to expose some Transaction configuration, but ONLY enough to delegate to Transaction support already provided by Spring (as we do in other scenarios).</p>
<p>Spring Integration provides transactional support for Pollers.
Pollers are a special type of component because we can call receive() within that poller task against a resource that is itself transactional thus including <span class="emphasis"><em>receive()</em></span> call in the the boundaries of the Transaction allowing it to be rolled back in case of a task failure.
If we were to add the same support for channels, the added transactions would affect all downstream components starting with that <span class="emphasis"><em>send()</em></span> call.
That is providing a rather wide scope for transaction demarcation without any strong reason especially when Spring already provides several ways to address the transactional needs of any component downstream.
However the <span class="emphasis"><em>receive()</em></span> method being&nbsp;included&nbsp;in a transaction boundary is the "strong reason" for pollers.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-poller" href="#transaction-poller"></a>C.1.1&nbsp;Poller Transaction Support</h3></div></div></div>

<p>Any time you configure a Poller you can provide transactional configuration via the <span class="emphasis"><em>transactional</em></span> sub-element and its attributes:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span><span class="hl-attribute">&nbsp;</span>
                   <span class="hl-attribute">isolation</span>=<span class="hl-value">"DEFAULT"</span>
                   <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-attribute">&nbsp;</span>
                   <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-attribute">&nbsp;</span>
                   <span class="hl-attribute">timeout</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/poller&gt;</span></pre>
<p>As you can see this configuration looks very similar to native Spring transaction configuration.
You must still provide a reference to a Transaction manager and specify transaction attributes or rely on defaults (e.g., if the <span class="emphasis"><em>transaction-manager</em></span> attribute is not specified, it will default to the bean with the name <span class="emphasis"><em>transactionManager</em></span>).
Internally the process would be wrapped in Spring&#8217;s native Transaction where <code class="literal">TransactionInterceptor</code> is responsible for handling transactions.
For more information on how to configure a Transaction Manager, the types of Transaction Managers (e.g., JTA, Datasource etc.) and other details related to transaction configuration please refer to Spring&#8217;s Reference manual (Chapter 10 - Transaction Management).</p>
<p>With the above configuration all Message flows initiated by this poller will be transactional.
For more information and details on a Poller&#8217;s transactional configuration please refer to section - <span class="emphasis"><em>21.1.1.
Polling and Transactions</em></span>.</p>
<p>Along with transactions, several more cross cutting concerns might need to be addressed when running a Poller.
To help with that, the Poller element accepts an <span class="emphasis"><em>&lt;advice-chain&gt; _ sub-element which allows you to define a custom chain of Advice instances to be applied on the Poller.
(see section 4.4 for more details) In Spring Integration 2.0, the Poller went through the a refactoring effort and is now using a proxy mechanism to address transactional concerns as well as other cross cutting concerns.
One of the significant changes evolving from this effort is that we made _&lt;transactional&gt;</em></span> and <span class="emphasis"><em>&lt;advice-chain&gt;</em></span> elements mutually exclusive.
The rationale behind this is that if you need more than one advice, and one of them is Transaction advice, then you can simply include it in the <span class="emphasis"><em>&lt;advice-chain&gt;</em></span> with the same convenience as before but with much more control since you now have an option to position any advice in the desired order.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"10000"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;advice-chain&gt;</span>
    <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"txAdvice"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"someAotherAdviceBean"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.SampleAdvice"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/advice-chain&gt;</span>
<span class="hl-tag">&lt;/poller&gt;</span>

<span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"get*"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre>
<p>As you can see from the example above, we have provided a very basic XML-based configuration of Spring Transaction advice &nbsp;- "txAdvice" and included it within the <span class="emphasis"><em>&lt;advice-chain&gt;</em></span> defined by the Poller.
If you only need to address transactional concerns of the Poller, then you can still use the <span class="emphasis"><em>&lt;transactional&gt;</em></span> element as a convenience.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-boundaries" href="#transaction-boundaries"></a>C.2&nbsp;Transaction Boundaries</h2></div></div></div>

<p>Another important factor is the boundaries of Transactions within a Message flow.
When a transaction is started, the transaction context is bound to the current thread.
So regardless of how many endpoints and channels you have in your Message flow your transaction context will be preserved as long as you are ensuring that the flow continues on the same thread.
As soon as you break it by introducing a <span class="emphasis"><em>Pollable Channel</em></span> or <span class="emphasis"><em>Executor Channel</em></span> or initiate a new thread manually in some service, the Transactional boundary will be broken as well.
Essentially the Transaction will END right there, and if a successful handoff has transpired between the threads, the flow would be considered a success and a COMMIT signal would be sent even though the flow will continue and might still result in an Exception somewhere downstream.
If such a flow were synchronous, that Exception could be thrown back to the initiator of the Message flow who is also the initiator of the transactional context and the transaction would result in a ROLLBACK.
The middle ground is to use transactional channels at any point where a thread boundary is being broken.
For example, you can use a Queue-backed Channel that delegates to a transactional MessageStore strategy, or you could use a JMS-backed channel.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-synchronization" href="#transaction-synchronization"></a>C.3&nbsp;Transaction Synchronization</h2></div></div></div>

<p>In some environments, it is advantageous to synchronize operations with a transaction that encompasses the entire flow.
For example, consider a &lt;file:inbound-channel-adapter/&gt; at the start of a flow, that performs a number of database updates.
If the transaction commits, we might want to move the file to a <span class="emphasis"><em>success</em></span> directory, while we might want to move it to a <span class="emphasis"><em>failures</em></span> directory if the transaction rolls back.</p>
<p>Spring Integration 2.2 introduces the capability of synchronizing these operations with a transaction.
In addition, you can configure a <code class="literal">PseudoTransactionManager</code> if you don&#8217;t have a <span class="emphasis"><em>real</em></span> transaction, but still want to perform different actions on success, or failure.
For more information, see <a class="xref" href="transactions.html#pseudo-transactions" title="C.4&nbsp;Pseudo Transactions">Section&nbsp;C.4, &#8220;Pseudo Transactions&#8221;</a>.</p>
<p>Key strategy interfaces for this feature are</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TransactionSynchronizationFactory {

    TransactionSynchronization create(Object key);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TransactionSynchronizationProcessor {

    <span class="hl-keyword">void</span> processBeforeCommit(IntegrationResourceHolder holder);

    <span class="hl-keyword">void</span> processAfterCommit(IntegrationResourceHolder holder);

    <span class="hl-keyword">void</span> processAfterRollback(IntegrationResourceHolder holder);

}</pre>
<p>The factory is responsible for creating a <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionSynchronization.html" target="_top">TransactionSynchronization</a> object.
You can implement your own, or use the one provided by the framework: <code class="literal">DefaultTransactionSynchronizationFactory</code>.
This implementation returns a <code class="literal">TransactionSynchronization</code> that delegates to a default implementation of <code class="literal">TransactionSynchronizationProcessor</code>, the <code class="literal">ExpressionEvaluatingTransactionSynchronizationProcessor</code>.
This processor supports three SpEL expressions, <span class="emphasis"><em>beforeCommitExpression</em></span>, <span class="emphasis"><em>afterCommitExpression</em></span>, and <span class="emphasis"><em>afterRollbackExpression</em></span>.</p>
<p>These actions should be self-explanatory to those familiar with transactions.
In each case, the <span class="emphasis"><em>#root</em></span> variable is the original <code class="literal">Message</code>; in some cases, other SpEL variables are made available, depending on the <code class="literal">MessageSource</code> being polled by the poller.
For example, the <code class="literal">MongoDbMessageSource</code> provides the <span class="emphasis"><em>#mongoTemplate</em></span> variable which references the message source&#8217;s <code class="literal">MongoTemplate</code>; the <code class="literal">RedisStoreMessageSource</code> provides the <span class="emphasis"><em>#store</em></span> variable which references the <code class="literal">RedisStore</code> created by the poll.</p>
<p>To enable the feature for a particular poller, you provide a reference to the <code class="literal">TransactionSynchronizationFactory</code> on the poller&#8217;s &lt;transactional/&gt; element using the <span class="emphasis"><em>synchronization-factory</em></span> attribute.</p>
<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, a new <code class="literal">PassThroughTransactionSynchronizationFactory</code> is provided which is applied by default to polling endpoints when no <code class="literal">TransactionSynchronizationFactory</code> is configured but an advice of type TransactionInterceptor exists in the advice chain.
When using any out-of-the-box <code class="literal">TransactionSynchronizationFactory</code> implementation, polling endpoints bind a polled message to the current transactional context and provide it as a <code class="literal">failedMessage</code> in a <code class="literal">MessagingException</code> if an exception is thrown after the TX advice.
When using a custom TX advice that does not implement <code class="literal">TransactionInterceptor</code>, a <code class="literal">PassThroughTransactionSynchronizationFactory</code> can be configured explicitly to achieve this behavior.
In either case, the <code class="literal">MessagingException</code> becomes the payload of the <code class="literal">ErrorMessage</code> that is sent to the <code class="literal">errorChannel</code> and the cause is the raw exception thrown by the advice.
Previously, the <code class="literal">ErrorMessage</code> had a payload that was the raw exception thrown by the advice and did not provide a reference to the <code class="literal">failedMessage</code> information, making it difficult to determine the reasons for the transaction commit problem.</p>
<p>To simplify configuration of these components, namespace support for the default factory has been provided.
Configuration is best described using an example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-file:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inputDirPoller"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"someChannel"</span>
    <span class="hl-attribute">directory</span>=<span class="hl-value">"/foo/bar"</span>
    <span class="hl-attribute">filter</span>=<span class="hl-value">"filter"</span>
    <span class="hl-attribute">comparator</span>=<span class="hl-value">"testComparator"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"5000"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">synchronization-factory</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int-file:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;int:transaction-synchronization-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:after-commit</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload.renameTo('/success/' + payload.name)"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"committedChannel"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;int:after-rollback</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload.renameTo('/failed/' + payload.name)"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"rolledBackChannel"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:transaction-synchronization-factory&gt;</span></pre>
<p>The result of the SpEL evaluation is sent as the payload to either the <span class="emphasis"><em>committedChannel</em></span> or <span class="emphasis"><em>rolledBackChannel</em></span> (in this case, this would be <code class="literal">Boolean.TRUE</code> or <code class="literal">Boolean.FALSE</code> - the result of the <code class="literal">java.io.File.renameTo()</code> method call).</p>
<p>If you wish to send the entire payload for further Spring Integration processing, simply use the expression <span class="emphasis"><em>payload</em></span>.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>It is important to understand that this is simply synchronizing the actions with a transaction, it does not make a resource that is not inherently transactional actually transactional.
Instead, the transaction (be it JDBC or otherwise) is started before the poll, and committed/rolled back when the flow completes, followed by the synchronized action.</p>
<p>It is also important to understand that if you provide a custom <code class="literal">TransactionSynchronizationFactory</code>, it is responsible for creating a resource synchronization that will cause the bound resource to be unbound automatically, when the transaction completes.
The default <code class="literal">TransactionSynchronizationFactory</code> does this by returning a subclass of <code class="literal">ResourceHolderSynchronization</code>, with the default <span class="emphasis"><em>shouldUnbindAtCompletion()</em></span> returning <code class="literal">true</code>.</p>
</td></tr></table></div>
<p>In addition to the <span class="emphasis"><em>after-commit</em></span> and <span class="emphasis"><em>after-rollback</em></span> expressions, <span class="emphasis"><em>before-commit</em></span> is also supported.
In that case, if the evaluation (or downstream processing) throws an exception, the transaction will be rolled back instead of being committed.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pseudo-transactions" href="#pseudo-transactions"></a>C.4&nbsp;Pseudo Transactions</h2></div></div></div>

<p>Referring to the above section, you may be thinking it would be useful to take these <span class="emphasis"><em>success</em></span> or <span class="emphasis"><em>failure</em></span> actions when a flow completes, even if there is no <span class="emphasis"><em>real</em></span> transactional resources (such as JDBC) downstream of the poller.
For example, consider a &lt;file:inbound-channel-adapter/&gt; followed by an &lt;ftp:outbout-channel-adapter/&gt;.
Neither of these components is transactional but we might want to move the input file to different directories, based on the success or failure of the ftp transfer.</p>
<p>To provide this functionality, the framework provides a <code class="literal">PseudoTransactionManager</code>, enabling the above configuration even when there is no real transactional resource involved.
If the flow completes normally, the <span class="emphasis"><em>beforeCommit</em></span> and <span class="emphasis"><em>afterCommit</em></span> synchronizations will be called, on failure the <span class="emphasis"><em>afterRollback</em></span> will be called.
Of course, because it is not a real transaction there will be no actual commit or rollback.
The pseudo transaction is simply a vehicle used to enable the synchronization features.</p>
<p>To use a <code class="literal">PseudoTransactionManager</code>, simply define it as a &lt;bean/&gt;, in the same way you would configure a real transaction manager:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.transaction.PseudoTransactionManager"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="message-publishing.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-appendices.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Appendix&nbsp;B.&nbsp;Message Publishing&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Appendix&nbsp;D.&nbsp;Security in Spring Integration</td></tr></table></div></body></html>