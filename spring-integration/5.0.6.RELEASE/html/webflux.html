<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>34.&nbsp;WebFlux Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="twitter.html" title="33.&nbsp;Twitter Support"><link rel="next" href="web-sockets.html" title="35.&nbsp;WebSockets Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">34.&nbsp;WebFlux Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="twitter.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="web-sockets.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="webflux" href="#webflux"></a>34.&nbsp;WebFlux Support</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webflux-intro" href="#webflux-intro"></a>34.1&nbsp;Introduction</h2></div></div></div>

<p>The WebFlux Spring Integration module (<code class="literal">spring-integration-webflux</code>) allows for the execution of HTTP requests and the processing of inbound HTTP requests in Reactive manner.
The WebFlux support consists of the following gateway implementations: <code class="literal">WebFluxInboundEndpoint</code>, <code class="literal">WebFluxRequestExecutingMessageHandler</code>.
The implementation is fully based on the Spring <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux" target="_top">WebFlux</a> and <a class="ulink" href="https://projectreactor.io/" target="_top">Project Reactor</a> foundations.
Also see <a class="xref" href="http.html" title="18.&nbsp;HTTP Support">Chapter&nbsp;18, <i>HTTP Support</i></a> for more information since many options are shared between reactive and regular HTTP components.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webflux-inbound" href="#webflux-inbound"></a>34.2&nbsp;WebFlux Inbound Components</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>version 5.0</em></span>, the <code class="literal">WebFluxInboundEndpoint</code>, <code class="literal">WebHandler</code>, implementation is provided.
This component is similar to the MVC-based <code class="literal">HttpRequestHandlingEndpointSupport</code> with which it shares some common options via the newly extracted <code class="literal">BaseHttpInboundEndpoint</code>.
Instead of MVC, it is used in the Spring WebFlux Reactive environment.
A simple sample for explanation:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableWebFlux</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableIntegration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ReactiveHttpConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> WebFluxInboundEndpoint simpleInboundEndpoint() {
        WebFluxInboundEndpoint endpoint = <span class="hl-keyword">new</span> WebFluxInboundEndpoint();
        RequestMapping requestMapping = <span class="hl-keyword">new</span> RequestMapping();
        requestMapping.setPathPatterns(<span class="hl-string">"/test"</span>);
        endpoint.setRequestMapping(requestMapping);
        endpoint.setRequestChannelName(<span class="hl-string">"serviceChannel"</span>);
        <span class="hl-keyword">return</span> endpoint;
    }

    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "serviceChannel")</span></em>
    String service() {
        <span class="hl-keyword">return</span> <span class="hl-string">"It works!"</span>;
    }

}</pre>
<p>As can be seen, the configuration is similar to the <code class="literal">HttpRequestHandlingEndpointSupport</code> mentioned above, except that we use <code class="literal">@EnableWebFlux</code> to add the WebFlux infrastructure to our integration application.
Also, the <code class="literal">WebFluxInboundEndpoint</code> performs <code class="literal">sendAndReceive</code> operation to the downstream flow using back-pressure, on demand based capabilities, provided by the reactive HTTP server implementation.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The reply part is non-blocking as well and based on the internal <code class="literal">FutureReplyChannel</code> which is flat-mapped to a reply <code class="literal">Mono</code> for on demand resolution.</p>
</td></tr></table></div>
<p>The <code class="literal">WebFluxInboundEndpoint</code> can be configured with a custom <code class="literal">ServerCodecConfigurer</code>, <code class="literal">RequestedContentTypeResolver</code> and even a <code class="literal">ReactiveAdapterRegistry</code>.
The latter provides a mechanism where we can return a reply as any reactive type - Reactor <code class="literal">Flux</code>, RxJava <code class="literal">Observable</code>, <code class="literal">Flowable</code> etc.
This way, we can simply implement <a class="ulink" href="https://en.wikipedia.org/wiki/Server-sent_events" target="_top">Server Sent Events</a> scenarios with Spring Integration components:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow sseFlow() {
    <span class="hl-keyword">return</span> IntegrationFlows
            .from(WebFlux.inboundGateway(<span class="hl-string">"/sse"</span>)
                    .requestMapping(m -&gt; m.produces(MediaType.TEXT_EVENT_STREAM_VALUE)))
            .handle((p, h) -&gt; Flux.just(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>, <span class="hl-string">"baz"</span>))
            .get();
}</pre>
<p>Also see <a class="xref" href="http.html#http-request-mapping" title="18.4.3&nbsp;Request Mapping Support">Section&nbsp;18.4.3, &#8220;Request Mapping Support&#8221;</a> and <a class="xref" href="http.html#http-cors" title="18.4.4&nbsp;Cross-Origin Resource Sharing (CORS) Support">Section&nbsp;18.4.4, &#8220;Cross-Origin Resource Sharing (CORS) Support&#8221;</a> for more possible configuration options.</p>
<p>When the request body is empty, or <code class="literal">payloadExpression</code> returns <code class="literal">null</code>, the request params <code class="literal">MultiValueMap&lt;String, String&gt;</code> is used for a <code class="literal">payload</code> of the target message to process.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webflux-outbound" href="#webflux-outbound"></a>34.3&nbsp;WebFlux Outbound Components</h2></div></div></div>

<p>The <code class="literal">WebFluxRequestExecutingMessageHandler</code> (starting with <span class="emphasis"><em>version 5.0</em></span>) implementation is very similar to <code class="literal">HttpRequestExecutingMessageHandler</code>, using a <code class="literal">WebClient</code> from the Spring Framework WebFlux module.
To configure it, define a bean like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpReactiveOutbound"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.webflux.outbound.WebFluxRequestExecutingMessageHandler"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"http://localhost:8080/example"</span><span class="hl-tag"> /&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"outputChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"responseChannel"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>You can configure a <code class="literal">WebClient</code> instance to use:</p>
<pre class="programlisting"><span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"webClient"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.reactive.function.client.WebClient"</span>
				<span class="hl-attribute">factory-method</span>=<span class="hl-value">"create"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpReactiveOutbound"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.webflux.outbound.WebFluxRequestExecutingMessageHandler"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"http://localhost:8080/example"</span><span class="hl-tag"> /&gt;</span>
     <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">re</span>=<span class="hl-value">"webClient"</span><span class="hl-tag"> /&gt;</span>
     <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"outputChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"responseChannel"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>The <code class="literal">WebClient</code> <code class="literal">exchange()</code> operation returns a <code class="literal">Mono&lt;ClientResponse&gt;</code> which is mapped (using several <code class="literal">Mono.map()</code> steps) to an <code class="literal">AbstractIntegrationMessageBuilder</code> as the output from the <code class="literal">WebFluxRequestExecutingMessageHandler</code>.
Together with the <code class="literal">ReactiveChannel</code> as an <code class="literal">outputChannel</code>, the <code class="literal">Mono&lt;ClientResponse&gt;</code> evaluation is deferred until a downstream subscription is made.
Otherwise, it is treated as an <code class="literal">async</code> mode and the <code class="literal">Mono</code> response is adapted to an <code class="literal">SettableListenableFuture</code> for an asynchronous reply from the <code class="literal">WebFluxRequestExecutingMessageHandler</code>.
The target payload of the output message depends on the <code class="literal">WebFluxRequestExecutingMessageHandler</code> configuration.
The <code class="literal">setExpectedResponseType(Class&lt;?&gt;)</code> or <code class="literal">setExpectedResponseTypeExpression(Expression)</code> identifies the target type of the response body element conversion.
If the <code class="literal">replyPayloadToFlux</code> is set to <code class="literal">true</code>, the response body is converted to a <code class="literal">Flux</code> with the provided <code class="literal">expectedResponseType</code> for each element and this <code class="literal">Flux</code> is sent as the payload downstream.
A <a class="link" href="messaging-routing-chapter.html#splitter" title="6.3&nbsp;Splitter">splitter</a> afterwards can be used to iterate over this <code class="literal">Flux</code> in a reactive manner.</p>
<p>In addition a <code class="literal">BodyExtractor&lt;?, ClientHttpResponse&gt;</code> can be injected into the <code class="literal">WebFluxRequestExecutingMessageHandler</code> instead of <code class="literal">expectedResponseType</code> and <code class="literal">replyPayloadToFlux</code> properties.
It can be used for low-level access to the <code class="literal">ClientHttpResponse</code> and more control over body and HTTP headers conversion.
The <code class="literal">ClientHttpResponseBodyExtractor</code> is provided out-of-the-box as identity function to produce downstream the whole <code class="literal">ClientHttpResponse</code> and any other possible custom logic.</p>
<p>Also see <a class="xref" href="http.html#http-outbound" title="18.3&nbsp;Http Outbound Components">Section&nbsp;18.3, &#8220;Http Outbound Components&#8221;</a> for more possible configuration options.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webflux-namespace" href="#webflux-namespace"></a>34.4&nbsp;WebFlux Namespace Support</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_5" href="#_introduction_5"></a>34.4.1&nbsp;Introduction</h3></div></div></div>

<p>Spring Integration provides a <span class="emphasis"><em>webflux</em></span> namespace and the corresponding schema definition.
To include it in your configuration, simply provide the following namespace declaration in your application context configuration file:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
  <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
  <span class="hl-attribute">xmlns:int</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
  <span class="hl-attribute">xmlns:int-webflux</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/webflux"</span>
  <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    http://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/webflux
    http://www.springframework.org/schema/integration/webflux/spring-integration-webflux.xsd"</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/beans&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_2" href="#_inbound_2"></a>34.4.2&nbsp;Inbound</h3></div></div></div>

<p>To configure Spring Integration WebFlux via XML you may use appropriate components from the mentioned <code class="literal">int-webflux</code> namespace -  <code class="literal">inbound-channel-adapter</code> or <code class="literal">inbound-gateway</code> according request/response requirements respectively:</p>
<pre class="programlisting"><span class="hl-tag">&lt;inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reactiveFullConfig"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"requests"</span>
                         <span class="hl-attribute">path</span>=<span class="hl-value">"test1"</span>
                         <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span>
                         <span class="hl-attribute">phase</span>=<span class="hl-value">"101"</span>
                         <span class="hl-attribute">request-payload-type</span>=<span class="hl-value">"byte[]"</span>
                         <span class="hl-attribute">error-channel</span>=<span class="hl-value">"errorChannel"</span>
                         <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"payload"</span>
                         <span class="hl-attribute">supported-methods</span>=<span class="hl-value">"PUT"</span>
                         <span class="hl-attribute">status-code-expression</span>=<span class="hl-value">"'202'"</span>
                         <span class="hl-attribute">header-mapper</span>=<span class="hl-value">"headerMapper"</span>
                         <span class="hl-attribute">codec-configurer</span>=<span class="hl-value">"codecConfigurer"</span>
                         <span class="hl-attribute">reactive-adapter-registry</span>=<span class="hl-value">"reactiveAdapterRegistry"</span>
                         <span class="hl-attribute">requested-content-type-resolver</span>=<span class="hl-value">"requestedContentTypeResolver"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;request-mapping</span> <span class="hl-attribute">headers</span>=<span class="hl-value">"foo"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;cross-origin</span> <span class="hl-attribute">origin</span>=<span class="hl-value">"foo"</span>
                  <span class="hl-attribute">method</span>=<span class="hl-value">"PUT"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"'foo'"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reactiveFullConfig"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requests"</span>
                 <span class="hl-attribute">path</span>=<span class="hl-value">"test1"</span>
                 <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span>
                 <span class="hl-attribute">phase</span>=<span class="hl-value">"101"</span>
                 <span class="hl-attribute">request-payload-type</span>=<span class="hl-value">"byte[]"</span>
                 <span class="hl-attribute">error-channel</span>=<span class="hl-value">"errorChannel"</span>
                 <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"payload"</span>
                 <span class="hl-attribute">supported-methods</span>=<span class="hl-value">"PUT"</span>
                 <span class="hl-attribute">reply-timeout-status-code-expression</span>=<span class="hl-value">"'504'"</span>
                 <span class="hl-attribute">header-mapper</span>=<span class="hl-value">"headerMapper"</span>
                 <span class="hl-attribute">codec-configurer</span>=<span class="hl-value">"codecConfigurer"</span>
                 <span class="hl-attribute">reactive-adapter-registry</span>=<span class="hl-value">"reactiveAdapterRegistry"</span>
                 <span class="hl-attribute">requested-content-type-resolver</span>=<span class="hl-value">"requestedContentTypeResolver"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;request-mapping</span> <span class="hl-attribute">headers</span>=<span class="hl-value">"foo"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;cross-origin</span> <span class="hl-attribute">origin</span>=<span class="hl-value">"foo"</span>
                  <span class="hl-attribute">method</span>=<span class="hl-value">"PUT"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"'foo'"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/inbound-gateway&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_outbound_2" href="#_outbound_2"></a>34.4.3&nbsp;Outbound</h3></div></div></div>

<p>If you want to execute the http request in a reactive, non-blocking way, you can use the <code class="literal">outbound-gateway</code> or <code class="literal">outbound-channel-adapter</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-webflux:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reactiveExample1"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requests"</span>
    <span class="hl-attribute">url</span>=<span class="hl-value">"http://localhost/test"</span>
    <span class="hl-attribute">http-method-expression</span>=<span class="hl-value">"headers.httpMethod"</span>
    <span class="hl-attribute">extract-request-payload</span>=<span class="hl-value">"false"</span>
    <span class="hl-attribute">expected-response-type-expression</span>=<span class="hl-value">"payload"</span>
    <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>
    <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"replies"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-webflux:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"reactiveExample2"</span>
    <span class="hl-attribute">url</span>=<span class="hl-value">"http://localhost/example"</span>
    <span class="hl-attribute">http-method</span>=<span class="hl-value">"GET"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"requests"</span>
    <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>
    <span class="hl-attribute">extract-payload</span>=<span class="hl-value">"false"</span>
    <span class="hl-attribute">expected-response-type</span>=<span class="hl-value">"java.lang.String"</span>
    <span class="hl-attribute">order</span>=<span class="hl-value">"3"</span>
    <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webflux-java-config" href="#webflux-java-config"></a>34.5&nbsp;Configuring WebFlux Endpoints with Java</h2></div></div></div>

<p>
<b>Inbound Gateway Using Java Configuration.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> WebFluxInboundEndpoint jsonInboundEndpoint() {
    WebFluxInboundEndpoint endpoint = <span class="hl-keyword">new</span> WebFluxInboundEndpoint();
    RequestMapping requestMapping = <span class="hl-keyword">new</span> RequestMapping();
    requestMapping.setPathPatterns(<span class="hl-string">"/persons"</span>);
    endpoint.setRequestMapping(requestMapping);
    endpoint.setRequestChannel(fluxResultChannel());
    <span class="hl-keyword">return</span> endpoint;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> MessageChannel fluxResultChannel() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> FluxMessageChannel();
}

<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "fluxResultChannel")</span></em>
Flux&lt;Person&gt; getPersons() {
    <span class="hl-keyword">return</span> Flux.just(<span class="hl-keyword">new</span> Person(<span class="hl-string">"Jane"</span>), <span class="hl-keyword">new</span> Person(<span class="hl-string">"Jason"</span>), <span class="hl-keyword">new</span> Person(<span class="hl-string">"John"</span>));
}</pre><p>

</p>
<p>
<b>Inbound Gateway Using the Java DSL.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow inboundChannelAdapterFlow() {
    <span class="hl-keyword">return</span> IntegrationFlows
        .from(WebFlux.inboundChannelAdapter(<span class="hl-string">"/reactivePost"</span>)
            .requestMapping(m -&gt; m.methods(HttpMethod.POST))
            .requestPayloadType(ResolvableType.forClassWithGenerics(Flux.<span class="hl-keyword">class</span>, String.<span class="hl-keyword">class</span>))
            .statusCodeFunction(m -&gt; HttpStatus.ACCEPTED))
        .channel(c -&gt; c.queue(<span class="hl-string">"storeChannel"</span>))
        .get();
}</pre><p>

</p>
<p>
<b>Outbound Gateway Using Java Configuration.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "reactiveHttpOutRequest")</span></em>
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> WebFluxRequestExecutingMessageHandler reactiveOutbound(WebClient client) {
    WebFluxRequestExecutingMessageHandler handler =
        <span class="hl-keyword">new</span> WebFluxRequestExecutingMessageHandler(<span class="hl-string">"http://localhost:8080/foo"</span>, client);
    handler.setHttpMethod(HttpMethod.POST);
    handler.setExpectedResponseType(String.<span class="hl-keyword">class</span>);
    <span class="hl-keyword">return</span> handler;
}</pre><p>

</p>
<p>
<b>Outbound Gateway Using the Java DSL.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow outboundReactive() {
    <span class="hl-keyword">return</span> f -&gt; f
        .handle(WebFlux.&lt;MultiValueMap&lt;String, String&gt;&gt;outboundGateway(m -&gt;
                UriComponentsBuilder.fromUriString(<span class="hl-string">"http://localhost:8080/foo"</span>)
                        .queryParams(m.getPayload())
                        .build()
                        .toUri())
                .httpMethod(HttpMethod.GET)
                .expectedResponseType(String.<span class="hl-keyword">class</span>));
}</pre><p>

</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webflux-header-mapping" href="#webflux-header-mapping"></a>34.6&nbsp;WebFlux Header Mappings</h2></div></div></div>

<p>Since WebFlux components are fully based on the HTTP protocol there is no difference in the HTTP headers mapping.
See <a class="xref" href="http.html#http-header-mapping" title="18.8&nbsp;HTTP Header Mappings">Section&nbsp;18.8, &#8220;HTTP Header Mappings&#8221;</a> for more possible options and components to use for mapping headers.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="twitter.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="web-sockets.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">33.&nbsp;Twitter Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;35.&nbsp;WebSockets Support</td></tr></table></div></body></html>