<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Appendix&nbsp;B.&nbsp;Message Publishing</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-appendices.html" title="Part&nbsp;VI.&nbsp;Appendices"><link rel="prev" href="spel.html" title="Appendix&nbsp;A.&nbsp;Spring Expression Language (SpEL)"><link rel="next" href="transactions.html" title="Appendix&nbsp;C.&nbsp;Transaction Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix&nbsp;B.&nbsp;Message Publishing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="spel.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;VI.&nbsp;Appendices</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="transactions.html">Next</a></td></tr></table><hr></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="message-publishing" href="#message-publishing"></a>Appendix&nbsp;B.&nbsp;Message Publishing</h2></div></div></div>

<p>The AOP Message Publishing feature allows you to construct and send a message as a by-product of a method invocation.
For example, imagine you have a component and every time the state of this component changes you would like to be notified via a Message.
The easiest way to send such notifications would be to send a message to a dedicated channel, but how would you connect the method invocation that changes the state of the object to a message sending process, and how should the notification Message be structured?
The AOP Message Publishing feature handles these responsibilities with a configuration-driven approach.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-publishing-config" href="#message-publishing-config"></a>B.1&nbsp;Message Publishing Configuration</h2></div></div></div>

<p>Spring Integration provides two approaches: XML and Annotation-driven.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="publisher-annotation" href="#publisher-annotation"></a>B.1.1&nbsp;Annotation-driven approach via @Publisher annotation</h3></div></div></div>

<p>The annotation-driven approach allows you to annotate any method with the <code class="literal">@Publisher</code> annotation, specifying a <span class="emphasis"><em>channel</em></span> attribute.
The Message will be constructed from the return value of the method invocation and sent to a channel specified by the <span class="emphasis"><em>channel</em></span> attribute.
To further manage message structure, you can also use a combination of both <code class="literal">@Payload</code> and <code class="literal">@Header</code> annotations.</p>
<p>Internally this message publishing feature of Spring Integration uses both Spring AOP by defining <code class="literal">PublisherAnnotationAdvisor</code> and Spring 3.0&#8217;s Expression Language (SpEL) support, giving you considerable flexibility and control over the structure of the <span class="emphasis"><em>Message</em></span> it will publish.</p>
<p>The <code class="literal">PublisherAnnotationAdvisor</code> defines and binds the following variables:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>#return</em></span> - will bind to a return value allowing you to reference it or its attributes (e.g., <span class="emphasis"><em>#return.foo</em></span> where <span class="emphasis"><em>foo</em></span> is an attribute of the object bound to <span class="emphasis"><em>#return</em></span>)
</li><li class="listitem">
<span class="emphasis"><em>#exception</em></span> - will bind to an exception if one is thrown by the method invocation.
</li><li class="listitem">
<span class="emphasis"><em>#args</em></span> - will bind to method arguments, so individual arguments could be extracted by name (e.g., <span class="emphasis"><em>#args.fname</em></span> as in the above method)
</li></ul></div>
<p>Let&#8217;s look at a couple of examples:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Publisher</span></em>
<span class="hl-keyword">public</span> String defaultPayload(String fname, String lname) {
  <span class="hl-keyword">return</span> fname + <span class="hl-string">" "</span> + lname;
}</pre>
<p>In the above example the Message will be constructed with the following structure:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Message payload - will be the return type and value of the method.
This is the default.
</li><li class="listitem">
A newly constructed message will be sent to a default publisher channel configured with an annotation post processor (see the end of this section).
</li></ul></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Publisher(channel="testChannel")</span></em>
<span class="hl-keyword">public</span> String defaultPayload(String fname, <em><span class="hl-annotation" style="color: gray">@Header("last")</span></em> String lname) {
  <span class="hl-keyword">return</span> fname + <span class="hl-string">" "</span> + lname;
}</pre>
<p>In this example everything is the same as above, except that we are not using a default publishing channel.
Instead we are specifying the publishing channel via the <span class="emphasis"><em>channel</em></span> attribute of the <code class="literal">@Publisher</code> annotation.
We are also adding a <code class="literal">@Header</code> annotation which results in the Message header named <span class="emphasis"><em>last</em></span> having the same value as the <span class="emphasis"><em>lname</em></span> method parameter.
That header will be added to the newly constructed Message.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Publisher(channel="testChannel")</span></em>
<em><span class="hl-annotation" style="color: gray">@Payload</span></em>
<span class="hl-keyword">public</span> String defaultPayloadButExplicitAnnotation(String fname, <em><span class="hl-annotation" style="color: gray">@Header</span></em> String lname) {
  <span class="hl-keyword">return</span> fname + <span class="hl-string">" "</span> + lname;
}</pre>
<p>The above example is almost identical to the previous one.
The only difference here is that we are using a <code class="literal">@Payload</code> annotation on the method, thus explicitly specifying that the return value of the method should be used as the payload of the Message.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Publisher(channel="testChannel")</span></em>
<em><span class="hl-annotation" style="color: gray">@Payload("#return + #args.lname")</span></em>
<span class="hl-keyword">public</span> String setName(String fname, String lname, <em><span class="hl-annotation" style="color: gray">@Header("x")</span></em> <span class="hl-keyword">int</span> num) {
  <span class="hl-keyword">return</span> fname + <span class="hl-string">" "</span> + lname;
}</pre>
<p>Here we are expanding on the previous configuration by using the Spring Expression Language in the <code class="literal">@Payload</code> annotation to further instruct the framework how the message should be constructed.
In this particular case the message will be a concatenation of the return value of the method invocation and the <span class="emphasis"><em>lname</em></span> input argument.
The Message header named <span class="emphasis"><em>x</em></span> will have its value determined by the <span class="emphasis"><em>num</em></span> input argument.
That header will be added to the newly constructed Message.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Publisher(channel="testChannel")</span></em>
<span class="hl-keyword">public</span> String argumentAsPayload(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String fname, <em><span class="hl-annotation" style="color: gray">@Header</span></em> String lname) {
  <span class="hl-keyword">return</span> fname + <span class="hl-string">" "</span> + lname;
}</pre>
<p>In the above example you see another usage of the <code class="literal">@Payload</code> annotation.
Here we are annotating a method argument which will become the payload of the newly constructed message.</p>
<p>As with most other annotation-driven features in Spring, you will need to register a post-processor (<code class="literal">PublisherAnnotationBeanPostProcessor</code>).</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor"</span><span class="hl-tag">/&gt;</span></pre>
<p>You can instead use namespace support for a more concise configuration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:annotation-config</span> <span class="hl-attribute">default-publisher-channel</span>=<span class="hl-value">"defaultChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>Similar to other Spring annotations (@Component, @Scheduled, etc.), <code class="literal">@Publisher</code> can also be used as a meta-annotation.
That means you can define your own annotations that will be treated in the same way as the <code class="literal">@Publisher</code> itself.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Target({ElementType.METHOD, ElementType.TYPE})</span></em>
<em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@Publisher(channel="auditChannel")</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> Audit {
}</pre>
<p>Here we defined the <code class="literal">@Audit</code> annotation which itself is annotated with <code class="literal">@Publisher</code>.
Also note that you can define a <code class="literal">channel</code> attribute on the meta-annotation thus encapsulating the behavior of where messages will be sent inside of this annotation.
Now you can annotate any method:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Audit</span></em>
<span class="hl-keyword">public</span> String test() {
&nbsp;&nbsp; &nbsp;<span class="hl-keyword">return</span> <span class="hl-string">"foo"</span>;
}</pre>
<p>In the above example every invocation of the <code class="literal">test()</code> method will result in a Message with a payload created from its return value.
Each Message will be sent to&nbsp;the channel named <span class="emphasis"><em>auditChannel</em></span>.
One of the benefits of this technique is that you can avoid the duplication of the same channel name across multiple annotations.
You also can provide a level of indirection between your own, potentially domain-specific annotations and those provided by the framework.</p>
<p>You can also annotate the class which would mean that the properties of this annotation will be applied on every public method of that class.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Audit</span></em>
<span class="hl-keyword">static</span> <span class="hl-keyword">class</span> BankingOperationsImpl&nbsp;<span class="hl-keyword">implements</span>&nbsp;BankingOperations&nbsp;{

&nbsp;&nbsp;<span class="hl-keyword">public</span> String debit(String amount) {
&nbsp;&nbsp; &nbsp; . . .

&nbsp;&nbsp;}

&nbsp;&nbsp;<span class="hl-keyword">public</span>&nbsp;String credit(String amount) {
&nbsp;&nbsp; &nbsp; . . .
&nbsp;&nbsp;}

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="aop-based-interceptor" href="#aop-based-interceptor"></a>B.1.2&nbsp;XML-based approach via the &lt;publishing-interceptor&gt; element</h3></div></div></div>

<p>The XML-based approach allows you to configure the same AOP-based Message Publishing functionality with simple namespace-based configuration of a <code class="literal">MessagePublishingInterceptor</code>.
It certainly has some benefits over the annotation-driven approach since it allows you to use AOP pointcut expressions, thus possibly intercepting multiple methods at once or intercepting and publishing methods to which you don&#8217;t have the source code.</p>
<p>To configure Message Publishing via XML, you only need to do the following two things:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Provide configuration for <code class="literal">MessagePublishingInterceptor</code> via the <code class="literal">&lt;publishing-interceptor&gt;</code> XML element.
</li><li class="listitem">
Provide AOP configuration to apply the <code class="literal">MessagePublishingInterceptor</code> to managed objects.
</li></ul></div>
<pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>
  <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"interceptor"</span> <span class="hl-attribute">pointcut</span>=<span class="hl-value">"bean(testBean)"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span>
<span class="hl-tag">&lt;publishing-interceptor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"interceptor"</span> <span class="hl-attribute">default-channel</span>=<span class="hl-value">"defaultChannel"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;method</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">payload</span>=<span class="hl-value">"'Echoing: ' + #return"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"echoChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"bar"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/method&gt;</span>
  <span class="hl-tag">&lt;method</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"repl*"</span> <span class="hl-attribute">payload</span>=<span class="hl-value">"'Echoing: ' + #return"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"echoChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"'bar'.toUpperCase()"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/method&gt;</span>
  <span class="hl-tag">&lt;method</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"echoDef*"</span> <span class="hl-attribute">payload</span>=<span class="hl-value">"#return"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/publishing-interceptor&gt;</span></pre>
<p>As you can see the <code class="literal">&lt;publishing-interceptor&gt;</code> configuration looks rather similar to the Annotation-based approach, and it also utilizes the power of the Spring 3.0 Expression Language.</p>
<p>In the above example the execution of the <code class="literal">echo</code> method of a <code class="literal">testBean</code> will render a <span class="emphasis"><em>Message</em></span> with the following structure:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The Message payload will be of type String with the content "Echoing: [value]" where <code class="literal">value</code> is the value returned by an executed method.
</li><li class="listitem">
The Message will have a header with the name "foo" and value "bar".
</li><li class="listitem">
The Message will be sent to <code class="literal">echoChannel</code>.
</li></ul></div>
<p>The second method is very similar to the first.
Here every method that begins with <span class="emphasis"><em>repl</em></span> will render a Message with the following structure:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The Message payload will be the same as in the above sample
</li><li class="listitem">
The Message will have a header named "foo" whose value is the result of the SpEL expression <code class="literal">'bar'.toUpperCase()</code> .
</li><li class="listitem">
The Message will be sent to <code class="literal">echoChannel</code>.
</li></ul></div>
<p>The second method, mapping the execution of any method that begins with <code class="literal">echoDef</code> of <code class="literal">testBean</code>, will produce a Message with the following structure.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The Message payload will be the value returned by an executed method.
</li><li class="listitem">
Since the <code class="literal">channel</code> attribute is not provided explicitly, the Message will be sent to the <code class="literal">defaultChannel</code> defined by the <span class="emphasis"><em>publisher</em></span>.
</li></ul></div>
<p>For simple mapping rules you can rely on the <span class="emphasis"><em>publisher</em></span> defaults.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;publishing-interceptor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"anotherInterceptor"</span><span class="hl-tag">/&gt;</span></pre>
<p>This will map the return value of every method that matches the pointcut expression to a payload and will be sent to a <span class="emphasis"><em>default-channel</em></span>.
If the <span class="emphasis"><em>defaultChannel_is not specified (as above) the messages will be sent to the global _nullChannel</em></span>.</p>
<p><span class="emphasis"><em>Async Publishing</em></span></p>
<p>One important thing to understand is that publishing occurs in the same thread as your component&#8217;s execution.
So by default in is synchronous.
This means that the entire message flow would have to wait until the publisher&#8217;s flow completes.&nbsp; However, quite often you want the complete opposite and that is to use this Message publishing feature to initiate asynchronous sub-flows.
For example, you might host a service (HTTP, WS etc.) which receives a remote request.You may want to send this request internally into a process that might take a while.
However you may also want to reply to the user right away.
So, instead of sending inbound requests for processing via the output channel (the conventional way), you can simply use <span class="emphasis"><em>output-channel</em></span> or a <span class="emphasis"><em>replyChannel</em></span> header to send a simple&nbsp;acknowledgment-like reply back to the caller while using the Message publisher feature to initiate a complex flow.</p>
<p>EXAMPLE: Here is the simple service that receives a complex payload, which needs to be sent further for processing, but it also needs to reply to the caller with a simple acknowledgment.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> String echo(Object complexPayload) {
&nbsp;&nbsp; &nbsp;&nbsp;<span class="hl-keyword">return</span> <span class="hl-string">"ACK"</span>;&nbsp;
}</pre>
<p>So instead of hooking up the complex flow to the output channel we use the Message publishing feature instead.
We configure it to create a new Message using the input argument of the service method (above) and send that to the <span class="emphasis"><em>localProcessChannel</em></span>.
And to make sure this sub-flow is asynchronous all we need to do is send it to any type of asynchronous channel (ExecutorChannel in this example).</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">&nbsp;input-channel</span>=<span class="hl-value">"inputChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"outputChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sampleservice"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sampleservice"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"test.SampleService"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;aop:config&gt;</span>
  <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"interceptor"</span> <span class="hl-attribute">pointcut</span>=<span class="hl-value">"bean(sampleservice)"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;int:publishing-interceptor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"interceptor"</span><span class="hl-tag"> &gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">payload</span>=<span class="hl-value">"#args[0]"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"localProcessChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sample_header"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"'some sample value'"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
<span class="hl-tag">&lt;/int:publishing-interceptor&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"localProcessChannel"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:dispatcher</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"executor"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"executor"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"5"</span><span class="hl-tag">/&gt;</span></pre>
<p>Another way of handling this type of scenario is with a wire-tap.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="scheduled-producer" href="#scheduled-producer"></a>B.1.3&nbsp;Producing and publishing messages based on a scheduled trigger</h3></div></div></div>

<p>In the above sections we looked at the Message publishing feature of Spring Integration which constructs and publishes messages as by-products of Method invocations.
However in those cases, you are still responsible for invoking the method.
In Spring Integration 2.0 we&#8217;ve added another related useful feature: support for scheduled Message producers/publishers via the new "expression" attribute on the <span class="emphasis"><em>inbound-channel-adapter</em></span> element.
Scheduling could be based on several triggers, any one of which may be configured on the <span class="emphasis"><em>poller</em></span> sub-element.
Currently we support <code class="literal">cron</code>, <code class="literal">fixed-rate</code>, <code class="literal">fixed-delay</code> as well as any custom trigger implemented by you and referenced by the <span class="emphasis"><em>trigger</em></span> attribute value.</p>
<p>As mentioned above, support for scheduled producers/publishers is provided via the <span class="emphasis"><em>&lt;inbound-channel-adapter&gt;</em></span> xml element.
Let&#8217;s look at couple of examples:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fixedDelayProducer"</span>
       <span class="hl-attribute">expression</span>=<span class="hl-value">"'fixedDelayTest'"</span>
       <span class="hl-attribute">channel</span>=<span class="hl-value">"fixedDelayChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-delay</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span></pre>
<p>In the above example an inbound Channel Adapter will be created which will construct a Message with its payload being the result of the expression&nbsp; defined in the <code class="literal">expression</code> attribute.
Such messages will be created and sent every time the delay specified by the <code class="literal">fixed-delay</code> attribute occurs.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fixedRateProducer"</span>
       <span class="hl-attribute">expression</span>=<span class="hl-value">"'fixedRateTest'"</span>
       <span class="hl-attribute">channel</span>=<span class="hl-value">"fixedRateChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span></pre>
<p>This example is very similar to the previous one, except that we are using the <code class="literal">fixed-rate</code> attribute which will allow us to send messages at a fixed rate (measuring from the start time of each task).</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cronProducer"</span>
       <span class="hl-attribute">expression</span>=<span class="hl-value">"'cronTest'"</span>
       <span class="hl-attribute">channel</span>=<span class="hl-value">"cronChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">cron</span>=<span class="hl-value">"7 6 5 4 3 ?"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span></pre>
<p>This example demonstrates how you can apply a Cron trigger with a value specified in the <code class="literal">cron</code> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"headerExpressionsProducer"</span>
       <span class="hl-attribute">expression</span>=<span class="hl-value">"'headerExpressionsTest'"</span>
       <span class="hl-attribute">channel</span>=<span class="hl-value">"headerExpressionsChannel"</span>
       <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-delay</span>=<span class="hl-value">"5000"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"6 * 7"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"x"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span></pre>
<p>Here you can see that in a way very similar to the Message publishing feature we are enriching a newly constructed Message with extra Message headers which can take scalar values or the results of evaluating Spring expressions.</p>
<p>If you need to implement your own custom trigger you can use the <code class="literal">trigger</code> attribute to provide a reference to any spring configured bean which implements&nbsp;the <code class="literal">org.springframework.scheduling.Trigger</code> interface.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"triggerRefProducer"</span>
       <span class="hl-attribute">expression</span>=<span class="hl-value">"'triggerRefTest'"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"triggerRefChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">trigger</span>=<span class="hl-value">"customTrigger"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customTrigger"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.scheduling.support.PeriodicTrigger"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"9999"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans:bean&gt;</span></pre>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spel.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-appendices.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="transactions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Appendix&nbsp;A.&nbsp;Spring Expression Language (SpEL)&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Appendix&nbsp;C.&nbsp;Transaction Support</td></tr></table></div></body></html>