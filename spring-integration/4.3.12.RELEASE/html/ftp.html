<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>15.&nbsp;FTP/FTPS Adapters</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="files.html" title="14.&nbsp;File Support"><link rel="next" href="gemfire.html" title="16.&nbsp;GemFire Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">15.&nbsp;FTP/FTPS Adapters</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="files.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="gemfire.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="ftp" href="#ftp"></a>15.&nbsp;FTP/FTPS Adapters</h2></div></div></div>

<p>Spring Integration provides support for file transfer operations via FTP and FTPS.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-intro" href="#ftp-intro"></a>15.1&nbsp;Introduction</h2></div></div></div>

<p>The File Transfer Protocol (FTP) is a simple network protocol which allows you to transfer files between two computers on the Internet.</p>
<p>There are two actors when it comes to FTP communication: <span class="emphasis"><em>client</em></span> and <span class="emphasis"><em>server</em></span>.
To transfer files with FTP/FTPS, you use a <span class="emphasis"><em>client</em></span> which initiates a connection to a remote computer that is running an FTP <span class="emphasis"><em>server</em></span>.
After the connection is established, the <span class="emphasis"><em>client</em></span> can choose to send and/or receive copies of files.</p>
<p>Spring Integration supports sending and receiving files over FTP/FTPS by providing three <span class="emphasis"><em>client</em></span> side endpoints: <span class="emphasis"><em>Inbound Channel Adapter</em></span>, <span class="emphasis"><em>Outbound Channel Adapter</em></span>, and <span class="emphasis"><em>Outbound Gateway</em></span>.
It also provides convenient namespace-based configuration options for defining these <span class="emphasis"><em>client</em></span> components.</p>
<p>To use the <span class="emphasis"><em>FTP</em></span> namespace, add the following to the header of your XML file:</p>
<pre class="programlisting">xmlns:int-ftp="http://www.springframework.org/schema/integration/ftp"
xsi:schemaLocation="http://www.springframework.org/schema/integration/ftp
    http://www.springframework.org/schema/integration/ftp/spring-integration-ftp.xsd"</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-session-factory" href="#ftp-session-factory"></a>15.2&nbsp;FTP Session Factory</h2></div></div></div>

<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with version 3.0, sessions are no longer cached by default.
See <a class="xref" href="ftp.html#ftp-session-caching" title="15.8&nbsp;FTP Session Caching">Section&nbsp;15.8, &#8220;FTP Session Caching&#8221;</a>.</p>
</td></tr></table></div>
<p>Before configuring FTP adapters you must configure an <span class="emphasis"><em>FTP Session Factory</em></span>.
You can configure the <span class="emphasis"><em>FTP Session Factory</em></span> with a regular bean definition where the implementation class is <code class="literal">org.springframework.integration.ftp.session.DefaultFtpSessionFactory</code>: Below is a basic configuration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpClientFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.ftp.session.DefaultFtpSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"host"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"22"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"kermit"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"frog"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"clientMode"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"0"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fileType"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bufferSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>For FTPS connections all you need to do is use <code class="literal">org.springframework.integration.ftp.session.DefaultFtpsSessionFactory</code> instead.
Below is the complete configuration sample:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpClientFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.ftp.client.DefaultFtpsClientFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"host"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"22"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"oleg"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"password"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"clientMode"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fileType"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"useClientMode"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"cipherSuites"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"a,b.c"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"keyManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"keyManager"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"protocol"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SSL"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"trustManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"trustManager"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prot"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"P"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"needClientAuth"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authValue"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"oleg"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionCreation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"protocols"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SSL, TLS"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"implicit"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>Every time an adapter requests a session object from its <code class="literal">SessionFactory</code> the session is returned from a session pool maintained by a caching wrapper around the factory.
A Session in the session pool might go stale (if it has been disconnected by the server due to inactivity) so the <code class="literal">SessionFactory</code> will perform validation to make sure that it never returns a stale session to the adapter.
If a stale session was encountered, it will be removed from the pool, and a new one will be created.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you experience connectivity problems and would like to trace Session creation as well as see which Sessions are polled you may enable it by setting the logger to TRACE level (e.g., log4j.category.org.springframework.integration.file=TRACE)</p>
</td></tr></table></div>
<p>Now all you need to do is inject these session factories into your adapters.
Obviously the protocol (FTP or FTPS) that an adapter will use depends on the type of session factory that has been injected into the adapter.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>A more practical way to provide values for <span class="emphasis"><em>FTP/FTPS Session Factories</em></span> is by using Spring&#8217;s property placeholder support (See: <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-placeholderconfigurer" target="_top">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-placeholderconfigurer</a>).</p>
</td></tr></table></div>
<p><span class="strong"><strong>Advanced Configuration</strong></span></p>
<p><code class="literal">DefaultFtpSessionFactory</code> provides an abstraction over the underlying client API which, since <span class="emphasis"><em>Spring Integration 2.0</em></span>, is <a class="ulink" href="http://commons.apache.org/net/" target="_top">Apache Commons Net</a>.
This spares you from the low level configuration details of the <code class="literal">org.apache.commons.net.ftp.FTPClient</code>.
Several common properties are exposed on the session factory (since <span class="emphasis"><em>version 4.0</em></span>, this now includes <code class="literal">connectTimeout</code>, <code class="literal">defaultTimeout</code> and <code class="literal">dataTimeout</code>).
However there are times when access to lower level <code class="literal">FTPClient</code> configuration is necessary to achieve more advanced configuration (e.g., setting the port range for active mode etc.).
For that purpose, <code class="literal">AbstractFtpSessionFactory</code> (the base class for all FTP Session Factories) exposes hooks, in the form of the two post-processing methods below.</p>
<pre class="programlisting"><strong class="hl-tag" style="color: blue">/**
 * Will handle additional initialization after client.connect() method was invoked,
 * but before any action on the client has been taken
 */</strong>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> postProcessClientAfterConnect(T t) <span class="hl-keyword">throws</span> IOException {
    <span class="hl-comment">// NOOP</span>
}
<strong class="hl-tag" style="color: blue">/**
 * Will handle additional initialization before client.connect() method was invoked.
 */</strong>
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> postProcessClientBeforeConnect(T client) <span class="hl-keyword">throws</span> IOException {
    <span class="hl-comment">// NOOP</span>
}</pre>
<p>As you can see, there is no default implementation for these two methods.
However, by extending <code class="literal">DefaultFtpSessionFactory</code> you can override these methods to provide more advanced configuration of the <code class="literal">FTPClient</code>.
For example:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AdvancedFtpSessionFactory <span class="hl-keyword">extends</span> DefaultFtpSessionFactory {

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> postProcessClientBeforeConnect(FTPClient ftpClient) <span class="hl-keyword">throws</span> IOException {
       ftpClient.setActivePortRange(<span class="hl-number">4000</span>, <span class="hl-number">5000</span>);
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-dsf" href="#ftp-dsf"></a>15.3&nbsp;Delegating Session Factory</h2></div></div></div>

<p><span class="emphasis"><em>Version 4.2</em></span> introduced the <code class="literal">DelegatingSessionFactory</code> which allows the selection of the actual session factory at
runtime.
Prior to invoking the ftp endpoint, call <code class="literal">setThreadKey()</code> on the factory to associate a key with the current thread.
That key is then used to lookup the actual session factory to be used.
The key can be cleared by calling <code class="literal">clearThreadKey()</code> after use.</p>
<p>Convenience methods have been added so this can easily be done from a message flow:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dsf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.remote.session.DelegatingSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.file.remote.session.DefaultSessionFactoryLocator"</span><span class="hl-tag">&gt;</span>
            <span class="hl-comment">&lt;!-- delegate factories here --&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"c1"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"@dsf.setThreadKey(#root, headers['factoryToUse'])"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int-ftp:outbound-gateway</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"c1"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"c2"</span> <span class="hl-attribute">...</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"c2"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span>
        <span class="hl-attribute">expression</span>=<span class="hl-value">"@dsf.clearThreadKey(#root)"</span><span class="hl-tag"> /&gt;</span></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When using session caching (see <a class="xref" href="ftp.html#ftp-session-caching" title="15.8&nbsp;FTP Session Caching">Section&nbsp;15.8, &#8220;FTP Session Caching&#8221;</a>), each of the delegates should be cached; you
cannot cache the <code class="literal">DelegatingSessionFactory</code> itself.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-inbound" href="#ftp-inbound"></a>15.4&nbsp;FTP Inbound Channel Adapter</h2></div></div></div>

<p>The <span class="emphasis"><em>FTP Inbound Channel Adapter</em></span> is a special listener that will connect to the FTP server and will listen for the remote directory events (e.g., new file created) at which point it will initiate a file transfer.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpInbound"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"ftpChannel"</span>
    <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
    <span class="hl-attribute">auto-create-local-directory</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">delete-remote-files</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"*.txt"</span>
    <span class="hl-attribute">remote-directory</span>=<span class="hl-value">"some/remote/path"</span>
    <span class="hl-attribute">remote-file-separator</span>=<span class="hl-value">"/"</span>
    <span class="hl-attribute">preserve-timestamp</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">local-filename-generator-expression</span>=<span class="hl-value">"#this.toUpperCase() + '.a'"</span>
    <span class="hl-attribute">local-filter</span>=<span class="hl-value">"myFilter"</span>
    <span class="hl-attribute">temporary-file-suffix</span>=<span class="hl-value">".writing"</span>
    <span class="hl-attribute">local-directory</span>=<span class="hl-value">"."</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-ftp:inbound-channel-adapter&gt;</span></pre>
<p>As you can see from the configuration above you can configure an <span class="emphasis"><em>FTP Inbound Channel Adapter</em></span> via the <code class="literal">inbound-channel-adapter</code> element while also providing values for various attributes such as <code class="literal">local-directory</code>, <code class="literal">filename-pattern</code> (which is based on simple pattern matching, not regular expressions), and of course the reference to a <code class="literal">session-factory</code>.</p>
<p>By default the transferred file will carry the same name as the original file.
If you want to override this behavior you can set the <code class="literal">local-filename-generator-expression</code> attribute which allows you to provide a SpEL Expression to generate the name of the local file.
Unlike outbound gateways and adapters where the root object of the SpEL Evaluation Context is a <code class="literal">Message</code>, this inbound adapter does not yet have the Message at the time of evaluation since that&#8217;s what it ultimately generates with the transferred file as its payload.
So, the root object of the SpEL Evaluation Context is the original name of the remote file (String).</p>
<p>Starting with <span class="emphasis"><em>Spring Integration 3.0</em></span>, you can specify the <code class="literal">preserve-timestamp</code> attribute (default <code class="literal">false</code>); when <code class="literal">true</code>, the local file&#8217;s modified timestamp will be set to the value retrieved from the server; otherwise it will be set to the current time.</p>
<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, you can specify <code class="literal">remote-directory-expression</code> instead of <code class="literal">remote-directory</code>, allowing
you to dynamically determine the directory on each poll.
e.g <code class="literal">remote-directory-expression="@myBean.determineRemoteDir()"</code>.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, the <code class="literal">remote-directory</code>/<code class="literal">remote-directory-expression</code> attributes can be omitted assuming <code class="literal">null</code>.
In this case, according to the FTP protocol, the Client working directory is used as a default remote directory.</p>
<p>Sometimes file filtering based on the simple pattern specified via <code class="literal">filename-pattern</code> attribute might not be sufficient.
If this is the case, you can use the <code class="literal">filename-regex</code> attribute to specify a Regular Expression (e.g. <code class="literal">filename-regex=".*\.test$"</code>).
And of course if you need complete control you can use <code class="literal">filter</code> attribute and provide a reference to any custom implementation of the <code class="literal">org.springframework.integration.file.filters.FileListFilter</code>, a strategy interface for filtering a list of files.
This filter determines which remote files are retrieved.
You can also combine a pattern based filter with other filters, such as an <code class="literal">AcceptOnceFileListFilter</code> to avoid synchronizing files that have previously been fetched, by using a <code class="literal">CompositeFileListFilter</code>.</p>
<p>The <code class="literal">AcceptOnceFileListFilter</code> stores its state in memory.
If you wish the state to survive a system restart, consider using the <code class="literal">FtpPersistentAcceptOnceFileListFilter</code> instead.
This filter stores the accepted file names in an instance of the <code class="literal">MetadataStore</code> strategy (<a class="xref" href="system-management-chapter.html#metadata-store" title="9.5&nbsp;Metadata Store">Section&nbsp;9.5, &#8220;Metadata Store&#8221;</a>).
This filter matches on the filename and the remote modified time.</p>
<p>Since <span class="emphasis"><em>version 4.0</em></span>, this filter requires a <code class="literal">ConcurrentMetadataStore</code>.
When used with a shared data store (such as <code class="literal">Redis</code> with the <code class="literal">RedisMetadataStore</code>) this allows filter keys to be shared across multiple application or server instances.</p>
<p>The above discussion refers to filtering the files before retrieving them.
Once the files have been retrieved, an additional filter is applied to the files on the file system.
By default, this is an`AcceptOnceFileListFilter` which, as discussed, retains state in memory and does not consider the file&#8217;s modified time.
Unless your application removes files after processing, the adapter will re-process the files on disk by default after an application restart.</p>
<p>Also, if you configure the <code class="literal">filter</code> to use a <code class="literal">FtpPersistentAcceptOnceFileListFilter</code>, and the remote file timestamp changes (causing it to be re-fetched), the default local filter will not allow this new file to be processed.</p>
<p>Use the <code class="literal">local-filter</code> attribute to configure the behavior of the local file system filter.
Starting with <span class="emphasis"><em>verion 4.3.8</em></span>, a <code class="literal">FileSystemPersistentAcceptOnceFileListFilter</code> is configured by default.
This filter stores the accepted file names and modified timestamp in an instance of the <code class="literal">MetadataStore</code> strategy (<a class="xref" href="system-management-chapter.html#metadata-store" title="9.5&nbsp;Metadata Store">Section&nbsp;9.5, &#8220;Metadata Store&#8221;</a>), and will detect changes to the local file modified time.
The default <code class="literal">MetadataStore</code> is a <code class="literal">SimpleMetadataStore</code> which stores state in memory.</p>
<p>Since <span class="emphasis"><em>version 4.1.5</em></span>, these filters have a new property <code class="literal">flushOnUpdate</code> which will cause them to flush the
metadata store on every update (if the store implements <code class="literal">Flushable</code>).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Further, if you use a distributed <code class="literal">MetadataStore</code> (such as <a class="xref" href="redis.html#redis-metadata-store" title="24.5&nbsp;Redis Metadata Store">Section&nbsp;24.5, &#8220;Redis Metadata Store&#8221;</a> or <a class="xref" href="gemfire.html#gemfire-metadata-store" title="16.7&nbsp;Gemfire Metadata Store">Section&nbsp;16.7, &#8220;Gemfire Metadata Store&#8221;</a>) you can have multiple instances of the same adapter/application and be sure that one and only one will process a file.</p>
</td></tr></table></div>
<p>The actual local filter is a <code class="literal">CompositeFileListFilter</code> containing the supplied filter and a pattern filter that prevents processing files that are in the process of being downloaded (based on the <code class="literal">temporary-file-suffix</code>); files are downloaded with this suffix (default: <code class="literal">.writing</code>) and the file is renamed to its final name when the transfer is complete, making it <span class="emphasis"><em>visible</em></span> to the filter.</p>
<p>The <code class="literal">remote-file-separator</code> attribute allows you to configure a file separator character to use if the default <span class="emphasis"><em>/</em></span> is not applicable for your particular environment.</p>
<p>Please refer to the schema for more details on these attributes.</p>
<p>It is also important to understand that the <span class="emphasis"><em>FTP Inbound Channel Adapter</em></span> is a <span class="emphasis"><em>Polling Consumer</em></span> and therefore you must configure a poller (either via a global default or a local sub-element).
Once a file has been transferred, a Message with a <code class="literal">java.io.File</code> as its payload will be generated and sent to the channel identified by the <code class="literal">channel</code> attribute.</p>
<p><span class="emphasis"><em>More on File Filtering and Large Files</em></span></p>
<p>Sometimes the file that just appeared in the monitored (remote) directory is not complete.
Typically such a file will be written with temporary extension (e.g., foo.txt.writing) and then renamed after the writing process finished.
As a user in most cases you are only interested in files that are complete and would like to filter only files that are complete.
To handle these scenarios you can use the filtering support provided by the <code class="literal">filename-pattern</code>, <code class="literal">filename-regex</code> and <code class="literal">filter</code> attributes.
Here is an example that uses a custom Filter implementation.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:inbound-channel-adapter</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"ftpChannel"</span>
    <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
    <span class="hl-attribute">filter</span>=<span class="hl-value">"customFilter"</span>
    <span class="hl-attribute">local-directory</span>=<span class="hl-value">"file:/my_transfers"</span><span class="hl-tag">&gt;</span>
    remote-directory="some/remote/path"
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-ftp:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customFilter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.example.CustomFilter"</span><span class="hl-tag">/&gt;</span></pre>
<p><span class="emphasis"><em>Poller configuration notes for the inbound FTP adapter</em></span></p>
<p>The job of the inbound FTP adapter consists of two tasks:
<span class="emphasis"><em>1) Communicate with a remote server in order to transfer files from a remote directory to a local directory.</em></span>
<span class="emphasis"><em>2) For each transferred file, generate a Message with that file as a payload and send it to the channel identified by the <span class="emphasis"><em>channel</em></span> attribute.</em></span>
That is why they are called <span class="emphasis"><em>channel-adapters</em></span> rather than just <span class="emphasis"><em>adapters</em></span>.
The main job of such an adapter is to generate a Message to be sent to a Message Channel.
Essentially, the second task mentioned above takes precedence in such a way that <span class="strong"><strong>IF</strong></span> your local directory already has one or more files it will first generate Messages from those, and <span class="strong"><strong>ONLY</strong></span> when all local files have been processed, will it initiate the remote communication to retrieve more files.</p>
<p>Also, when configuring a trigger on the poller you should pay close attention to the <code class="literal">max-messages-per-poll</code> attribute.
Its default value is 1 for all <code class="literal">SourcePollingChannelAdapter</code> instances (including FTP).
This means that as soon as one file is processed, it will wait for the next execution time as determined by your trigger configuration.
If you happened to have one or more files sitting in the <code class="literal">local-directory</code>, it would process those files before it would initiate communication with the remote FTP server.
And, if the <code class="literal">max-messages-per-poll</code> were set to 1 (default), then it would be processing only one file at a time with intervals as defined by your trigger, essentially working as <span class="emphasis"><em>one-poll === one-file</em></span>.</p>
<p>For typical file-transfer use cases, you most likely want the opposite behavior: to process all the files you can for each poll and only then wait for the next poll.
If that is the case, set <code class="literal">max-messages-per-poll</code> to -1.
Then, on each poll, the adapter will attempt to generate as many Messages as it possibly can.
In other words, it will process everything in the local directory, and then it will connect to the remote directory to transfer everything that is available there to be processed locally.
Only then is the poll operation considered complete, and the poller will wait for the next execution time.</p>
<p>You can alternatively set the <span class="emphasis"><em>max-messages-per-poll</em></span> value to a positive value indicating the upward limit of Messages to be created from files with each poll.
For example, a value of 10 means that on each poll it will attempt to process no more than 10 files.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_recovering_from_failures" href="#_recovering_from_failures"></a>15.4.1&nbsp;Recovering from Failures</h3></div></div></div>

<p>It is important to understand the architecture of the adapter.
There is a file synchronizer which fetches the files, and a <code class="literal">FileReadingMessageSource</code> to emit a message for each
synchronized file.
As discussed above, there are two filters involved.
The <code class="literal">filter</code> attribute (and patterns) refers to the remote (FTP) file list - to avoid fetching files that have already
been fetched.
The <code class="literal">local-filter</code> is used by the <code class="literal">FileReadingMessageSource</code> to determine which files are to be sent as messages.</p>
<p>The synchronizer lists the remote files and consults its filter; the files are then transferred.
If an IO error occurs during file transfer, any files that have already been added to the filter are removed so they
are eligible to be re-fetched on the next poll.
This only applies if the filter implements <code class="literal">ReversibleFileListFilter</code> (such as the <code class="literal">AcceptOnceFileListFilter</code>).</p>
<p>If, after synchronizing the files, an error occurs on the downstream flow processing a file, there is <span class="emphasis"><em>no</em></span> automatic
rollback of the filter so the failed file will <span class="emphasis"><em>not</em></span> be reprocessed by default.</p>
<p>If you wish to reprocess such files after a failure, you can use configuration similar to the following to facilitate
the removal of the failed file from the filter.
This will work for any <code class="literal">ResettableFileListFilter</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpAdapter"</span>
        <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
        <span class="hl-attribute">channel</span>=<span class="hl-value">"requestChannel"</span>
        <span class="hl-attribute">remote-directory-expression</span>=<span class="hl-value">"'/sftpSource'"</span>
        <span class="hl-attribute">local-directory</span>=<span class="hl-value">"file:myLocalDir"</span>
        <span class="hl-attribute">auto-create-local-directory</span>=<span class="hl-value">"true"</span>
        <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"*.txt"</span>
        <span class="hl-attribute">local-filter</span>=<span class="hl-value">"acceptOnceFilter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">synchronization-factory</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int-ftp:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"acceptOnceFilter"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.filters.AcceptOnceFileListFilter"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:transaction-synchronization-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:after-rollback</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"@acceptOnceFilter.remove(payload)"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:transaction-synchronization-factory&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.transaction.PseudoTransactionManager"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_10" href="#_configuring_with_java_configuration_10"></a>15.4.2&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the inbound adapter using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = <span class="hl-keyword">new</span> DefaultFtpSessionFactory();
        sf.setHost(<span class="hl-string">"localhost"</span>);
        sf.setPort(port);
        sf.setUsername(<span class="hl-string">"foo"</span>);
        sf.setPassword(<span class="hl-string">"foo"</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> FtpInboundFileSynchronizer ftpInboundFileSynchronizer() {
        FtpInboundFileSynchronizer fileSynchronizer = <span class="hl-keyword">new</span> FtpInboundFileSynchronizer(ftpSessionFactory());
        fileSynchronizer.setDeleteRemoteFiles(false);
        fileSynchronizer.setRemoteDirectory(<span class="hl-string">"foo"</span>);
        fileSynchronizer.setFilter(<span class="hl-keyword">new</span> FtpSimplePatternFileListFilter(<span class="hl-string">"*.xml"</span>));
        <span class="hl-keyword">return</span> fileSynchronizer;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = "ftpChannel", poller = @Poller(fixedDelay = "5000"))</span></em>
    <span class="hl-keyword">public</span> MessageSource&lt;File&gt; ftpMessageSource() {
        FtpInboundFileSynchronizingMessageSource source =
                <span class="hl-keyword">new</span> FtpInboundFileSynchronizingMessageSource(ftpInboundFileSynchronizer());
        source.setLocalDirectory(<span class="hl-keyword">new</span> File(<span class="hl-string">"ftp-inbound"</span>));
        source.setAutoCreateLocalDirectory(true);
        source.setLocalFilter(<span class="hl-keyword">new</span> AcceptOnceFileListFilter&lt;File&gt;());
        <span class="hl-keyword">return</span> source;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "ftpChannel")</span></em>
    <span class="hl-keyword">public</span> MessageHandler handler() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> MessageHandler() {

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handleMessage(Message&lt;?&gt; message) <span class="hl-keyword">throws</span> MessagingException {
                System.out.println(message.getPayload());
            }

        };
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl_9" href="#_configuring_with_the_java_dsl_9"></a>15.4.3&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the inbound adapter using the Java DSL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow ftpInboundFlow() {
        <span class="hl-keyword">return</span> IntegrationFlows
            .from(s -&gt; s.ftp(<span class="hl-keyword">this</span>.ftpSessionFactory)
                    .preserveTimestamp(true)
                    .remoteDirectory(<span class="hl-string">"foo"</span>)
                    .regexFilter(<span class="hl-string">".*\\.txt$"</span>)
                    .localFilename(f -&gt; f.toUpperCase() + <span class="hl-string">".a"</span>)
                    .localDirectory(<span class="hl-keyword">new</span> File(<span class="hl-string">"d:\\ftp_files"</span>)),
                e -&gt; e.id(<span class="hl-string">"ftpInboundAdapter"</span>)
                    .autoStartup(true)
                    .poller(Pollers.fixedDelay(<span class="hl-number">5000</span>)))
            .handle(m -&gt; System.out.println(m.getPayload()))
            .get();
    }
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-streaming" href="#ftp-streaming"></a>15.5&nbsp;FTP Streaming Inbound Channel Adapter</h2></div></div></div>

<p>The streaming inbound channel adapter was introduced in <span class="emphasis"><em>version 4.3</em></span>.
This adapter produces message with payloads of type <code class="literal">InputStream</code>, allowing files to be fetched without writing to the
local file system.
Since the session remains open, the consuming application is responsible for closing the session when the file has been
consumed.
The session is provided in the <code class="literal">IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE</code> header.
Standard framework components, such as the <code class="literal">FileSplitter</code> and <code class="literal">StreamTransformer</code> will automatically close the session.
See <a class="xref" href="files.html#file-splitter" title="14.5&nbsp;File Splitter">Section&nbsp;14.5, &#8220;File Splitter&#8221;</a> and <a class="xref" href="messaging-transformation-chapter.html#stream-transformer" title="Stream Transformer">the section called &#8220;Stream Transformer&#8221;</a> for more information about these components.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:inbound-streaming-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpInbound"</span>
            <span class="hl-attribute">channel</span>=<span class="hl-value">"ftpChannel"</span>
            <span class="hl-attribute">session-factory</span>=<span class="hl-value">"sessionFactory"</span>
            <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"*.txt"</span>
            <span class="hl-attribute">filename-regex</span>=<span class="hl-value">".*\.txt"</span>
            <span class="hl-attribute">filter</span>=<span class="hl-value">"filter"</span>
            <span class="hl-attribute">remote-file-separator</span>=<span class="hl-value">"/"</span>
            <span class="hl-attribute">comparator</span>=<span class="hl-value">"comparator"</span>
            <span class="hl-attribute">remote-directory-expression</span>=<span class="hl-value">"'foo/bar'"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int-ftp:inbound-streaming-channel-adapter&gt;</span></pre>
<p>Only one of <code class="literal">filename-pattern</code>, <code class="literal">filename-regex</code> or <code class="literal">filter</code> is allowed.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Unlike the non-streaming inbound channel adapter, this adapter does not prevent duplicates by default.
If you do not delete the remote file (e.g. using an outbound gateway with an rm command) and you wish to prevent the
file being processed again, you can configure an <code class="literal">FtpPersistentFileListFilter</code> in the <code class="literal">filter</code> attribute.
If you don&#8217;t actually want to persist the state, an in-memory <code class="literal">SimpleMetadataStore</code> can be used with the filter.
If you wish to use a filename pattern (or regex) as well, use a <code class="literal">CompositeFileListFilter</code>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_11" href="#_configuring_with_java_configuration_11"></a>15.5.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the inbound adapter using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = "stream")</span></em>
    <span class="hl-keyword">public</span> MessageSource&lt;InputStream&gt; ftpMessageSource() {
        FtpStreamingMessageSource messageSource = <span class="hl-keyword">new</span> FtpStreamingMessageSource(template(), null);
        messageSource.setRemoteDirectory(<span class="hl-string">"ftpSource/"</span>);
        messageSource.setFilter(<span class="hl-keyword">new</span> FtpPersistentAcceptOnceFileListFilter(<span class="hl-keyword">new</span> SimpleMetadataStore(),
                           <span class="hl-string">"streaming"</span>));
        <span class="hl-keyword">return</span> messageSource;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = "stream", outputChannel = "data")</span></em>
    <span class="hl-keyword">public</span> org.springframework.integration.transformer.Transformer transformer() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> StreamTransformer();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> FtpRemoteFileTemplate template() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> FtpRemoteFileTemplate(ftpSessionFactory());
    }

}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-outbound" href="#ftp-outbound"></a>15.6&nbsp;FTP Outbound Channel Adapter</h2></div></div></div>

<p>The <span class="emphasis"><em>FTP Outbound Channel Adapter</em></span> relies upon a <code class="literal">MessageHandler</code> implementation that will connect to the FTP server and initiate an FTP transfer for every file it receives in the payload of incoming Messages.
It also supports several representations of the <span class="emphasis"><em>File</em></span> so you are not limited only to java.io.File typed payloads.
The <span class="emphasis"><em>FTP Outbound Channel Adapter</em></span> supports the following payloads: 1) <code class="literal">java.io.File</code> - the actual file object; 2) <code class="literal">byte[]</code> - a byte array that represents the file contents; and 3) <code class="literal">java.lang.String</code> - text that represents the file contents.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpOutbound"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"ftpChannel"</span>
    <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
    <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>
    <span class="hl-attribute">remote-file-separator</span>=<span class="hl-value">"/"</span>
    <span class="hl-attribute">auto-create-directory</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">remote-directory-expression</span>=<span class="hl-value">"headers.['remote_dir']"</span>
    <span class="hl-attribute">temporary-remote-directory-expression</span>=<span class="hl-value">"headers.['temp_remote_dir']"</span>
    <span class="hl-attribute">filename-generator</span>=<span class="hl-value">"fileNameGenerator"</span>
    <span class="hl-attribute">use-temporary-filename</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">mode</span>=<span class="hl-value">"REPLACE"</span><span class="hl-tag">/&gt;</span></pre>
<p>As you can see from the configuration above you can configure an <span class="emphasis"><em>FTP Outbound Channel Adapter</em></span> via the <code class="literal">outbound-channel-adapter</code> element while also providing values for various attributes such as <code class="literal">filename-generator</code> (an implementation of the <code class="literal">org.springframework.integration.file.FileNameGenerator</code> strategy interface), a reference to a <code class="literal">session-factory</code>, as well as other attributes.
You can also see some examples of <code class="literal">*expression</code> attributes which allow you to use SpEL to configure things like <code class="literal">remote-directory-expression</code>, <code class="literal">temporary-remote-directory-expression</code> and <code class="literal">remote-filename-generator-expression</code> (a SpEL alternative to <code class="literal">filename-generator</code> shown above).
As with any component that allows the usage of SpEL, access to Payload and Message Headers is available via <span class="emphasis"><em>payload</em></span> and <span class="emphasis"><em>headers</em></span> variables.
Please refer to the schema for more details on the available attributes.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>By default Spring Integration will use <code class="literal">o.s.i.file.DefaultFileNameGenerator</code> if none is specified.
<code class="literal">DefaultFileNameGenerator</code> will determine the file name based on the value of the <code class="literal">file_name</code> header (if it exists) in the MessageHeaders, or if the payload of the Message is already a <code class="literal">java.io.File</code>, then it will use the original name of that file.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Defining certain values (e.g., remote-directory) might be platform/ftp server dependent.
For example as it was reported on this forum <a class="ulink" href="http://forum.springsource.org/showthread.php?p=333478&amp;posted=1#post333478" target="_top">http://forum.springsource.org/showthread.php?p=333478&amp;posted=1#post333478</a> on some platforms you must add slash to the end of the directory definition (e.g., remote-directory="/foo/bar/" instead of remote-directory="/foo/bar")</p>
</td></tr></table></div>
<p>Starting with <span class="emphasis"><em>version 4.1</em></span>, you can specify the <code class="literal">mode</code> when transferring the file.
By default, an existing file will be overwritten; the modes are defined on <code class="literal">enum</code> <code class="literal">FileExistsMode</code>, having values <code class="literal">REPLACE</code> (default), <code class="literal">APPEND</code>, <code class="literal">IGNORE</code>, and <code class="literal">FAIL</code>.
With <code class="literal">IGNORE</code> and <code class="literal">FAIL</code>, the file is not transferred; <code class="literal">FAIL</code> causes an exception to be thrown whereas <code class="literal">IGNORE</code> silently ignores the transfer (although a <code class="literal">DEBUG</code> log entry is produced).</p>
<p><span class="emphasis"><em>Avoiding Partially Written Files</em></span></p>
<p>One of the common problems, when dealing with file transfers, is the possibility of processing a <span class="emphasis"><em>partial file</em></span> - a file might appear in the file system before its transfer is actually complete.</p>
<p>To deal with this issue, Spring Integration FTP adapters use a very common algorithm where files are transferred under a temporary name and then renamed once they are fully transferred.</p>
<p>By default, every file that is in the process of being transferred will appear in the file system with an additional suffix which, by default, is <code class="literal">.writing</code>; this can be changed using the <code class="literal">temporary-file-suffix</code> attribute.</p>
<p>However, there may be situations where you don&#8217;t want to use this technique (for example, if the server does not permit renaming files).
For situations like this, you can disable this feature by setting <code class="literal">use-temporary-file-name</code> to <code class="literal">false</code> (default is <code class="literal">true</code>).
When this attribute is <code class="literal">false</code>, the file is written with its final name and the consuming application will need some other mechanism to detect that the file is completely uploaded before accessing it.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_12" href="#_configuring_with_java_configuration_12"></a>15.6.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Adapter using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@IntegrationComponentScan</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context =
                    <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
                        .web(false)
                        .run(args);
        MyGateway gateway = context.getBean(MyGateway.<span class="hl-keyword">class</span>);
        gateway.sendToFtp(<span class="hl-keyword">new</span> File(<span class="hl-string">"/foo/bar.txt"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = <span class="hl-keyword">new</span> DefaultFtpSessionFactory();
        sf.setHost(<span class="hl-string">"localhost"</span>);
        sf.setPort(port);
        sf.setUsername(<span class="hl-string">"foo"</span>);
        sf.setPassword(<span class="hl-string">"foo"</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "ftpChannel")</span></em>
    <span class="hl-keyword">public</span> MessageHandler handler() {
        FtpMessageHandler handler = <span class="hl-keyword">new</span> FtpMessageHandler(ftpSessionFactory());
        handler.setRemoteDirectoryExpression(<span class="hl-keyword">new</span> LiteralExpression(<span class="hl-string">"remote-target-dir"</span>));
        handler.setFileNameGenerator(<span class="hl-keyword">new</span> FileNameGenerator() {

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span class="hl-keyword">public</span> String generateFileName(Message&lt;?&gt; message) {
                 <span class="hl-keyword">return</span> <span class="hl-string">"handlerContent.test"</span>;
            }

        });
        <span class="hl-keyword">return</span> handler;
    }

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

         <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "toFtpChannel")</span></em>
         <span class="hl-keyword">void</span> sendToFtp(File file);

    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl_10" href="#_configuring_with_the_java_dsl_10"></a>15.6.2&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Adapter using the Java DSL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@IntegrationComponentScan</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context =
            <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
                .web(false)
                .run(args);
        MyGateway gateway = context.getBean(MyGateway.<span class="hl-keyword">class</span>);
        gateway.sendToFtp(<span class="hl-keyword">new</span> File(<span class="hl-string">"/foo/bar.txt"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = <span class="hl-keyword">new</span> DefaultFtpSessionFactory();
        sf.setHost(<span class="hl-string">"localhost"</span>);
        sf.setPort(port);
        sf.setUsername(<span class="hl-string">"foo"</span>);
        sf.setPassword(<span class="hl-string">"foo"</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow ftpOutboundFlow() {
        <span class="hl-keyword">return</span> IntegrationFlows.from(<span class="hl-string">"toFtpChannel"</span>)
                .handle(Ftp.outboundAdapter(ftpSessionFactory(), FileExistsMode.FAIL)
                        .useTemporaryFileName(false)
                        .fileNameExpression(<span class="hl-string">"headers['"</span> + FileHeaders.FILENAME + <span class="hl-string">"']"</span>)
                        .remoteDirectory(<span class="hl-keyword">this</span>.ftpServer.getTargetFtpDirectory().getName())
                ).get();
    }

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

         <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "toFtpChannel")</span></em>
         <span class="hl-keyword">void</span> sendToFtp(File file);

    }

}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-outbound-gateway" href="#ftp-outbound-gateway"></a>15.7&nbsp;FTP Outbound Gateway</h2></div></div></div>

<p>The <span class="emphasis"><em>FTP Outbound Gateway</em></span> provides a limited set of commands to interact with a remote FTP/FTPS server.
Commands supported are:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
ls (list files)
</li><li class="listitem">
get (retrieve file)
</li><li class="listitem">
mget (retrieve file(s))
</li><li class="listitem">
rm (remove file(s))
</li><li class="listitem">
mv (move/rename file)
</li><li class="listitem">
put (send file)
</li><li class="listitem">
mput (send multiple files)
</li></ul></div>
<p><span class="strong"><strong>ls</strong></span></p>
<p>ls lists remote file(s) and supports the following options:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-1 - just retrieve a list of file names, default is to retrieve a list of <code class="literal">FileInfo</code> objects.
</li><li class="listitem">
-a - include all files (including those starting with <span class="emphasis"><em>.</em></span>)
</li><li class="listitem">
-f - do not sort the list
</li><li class="listitem">
-dirs - include directories (excluded by default)
</li><li class="listitem">
-links - include symbolic links (excluded by default)
</li><li class="listitem">
-R - list the remote directory recursively
</li></ul></div>
<p>In addition, filename filtering is provided, in the same manner as the <code class="literal">inbound-channel-adapter</code>.</p>
<p>The message payload resulting from an <span class="emphasis"><em>ls</em></span> operation is a list of file names, or a list of <code class="literal">FileInfo</code> objects.
These objects provide information such as modified time, permissions etc.</p>
<p>The remote directory that the <span class="emphasis"><em>ls</em></span> command acted on is provided in the <code class="literal">file_remoteDirectory</code> header.</p>
<p>When using the recursive option (<code class="literal">-R</code>), the <code class="literal">fileName</code> includes any subdirectory elements, representing a relative path to the file (relative to the remote directory).
If the <code class="literal">-dirs</code> option is included, each recursive directory is also returned as an element in the list.
In this case, it is recommended that the <code class="literal">-1</code> is not used because you would not be able to determine files Vs.
directories, which is achievable using the <code class="literal">FileInfo</code> objects.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, the <code class="literal">FtpSession</code> supports <code class="literal">null</code> for the <code class="literal">list()</code> and <code class="literal">listNames()</code> methods,
therefore the <code class="literal">expression</code> attribute can be omitted.
From Java perspective there are two new constructor without <code class="literal">expression</code> argument for convenience.
The <code class="literal">null</code> for <code class="literal">LS</code> command is treated as an Client working directory according to the FTP protocol.
The working directory can be set via the <code class="literal">FTPClient.changeWorkingDirectory()</code> function when you extend the <code class="literal">DefaultFtpSessionFactory</code> and implement <code class="literal">postProcessClientAfterConnect()</code> callback.</p>
<p><span class="strong"><strong>get</strong></span></p>
<p><span class="emphasis"><em>get</em></span> retrieves a remote file and supports the following option:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-P - preserve the timestamp of the remote file
</li><li class="listitem">
-stream - retrieve the remote file as a stream.
</li></ul></div>
<p>The remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the filename is provided in the <code class="literal">file_remoteFile</code> header.</p>
<p>The message payload resulting from a <span class="emphasis"><em>get</em></span> operation is a <code class="literal">File</code> object representing the retrieved file, or
an <code class="literal">InputStream</code> when the <code class="literal">-stream</code> option is provided.
This option allows retrieving the file as a stream.
For text files, a common use case is to combine this operation with a <a class="link" href="files.html#file-splitter" title="14.5&nbsp;File Splitter">File Splitter</a> or
<a class="link" href="messaging-transformation-chapter.html#stream-transformer" title="Stream Transformer">Stream Transformer</a>.
When consuming remote files as streams, the user is responsible for closing the <code class="literal">Session</code> after the stream is
consumed.
For convenience, the <code class="literal">Session</code> is provided in the <code class="literal">IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE</code> header, a convenience method is provided on the
<code class="literal">IntegrationMessageHeaderAccessor</code>:</p>
<pre class="programlisting">Closeable closeable = <span class="hl-keyword">new</span> IntegrationMessageHeaderAccessor(message).getCloseableResource();
<span class="hl-keyword">if</span> (closeable != null) {
    closeable.close();
}</pre>
<p>Note: In previous releases the session was in the <code class="literal">file_remoteSession</code> header, but this is deprecated - use
<code class="literal">IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE</code> instead.</p>
<p>Framework components such as the <a class="link" href="files.html#file-splitter" title="14.5&nbsp;File Splitter">File Splitter</a> and <a class="link" href="messaging-transformation-chapter.html#stream-transformer" title="Stream Transformer">Stream Transformer</a> will
automatically close the session after the data is transferred.</p>
<p>The following shows an example of consuming a file as a stream:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:outbound-gateway</span> <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
                            <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inboundGetStream"</span>
                            <span class="hl-attribute">command</span>=<span class="hl-value">"get"</span>
                            <span class="hl-attribute">command-options</span>=<span class="hl-value">"-stream"</span>
                            <span class="hl-attribute">expression</span>=<span class="hl-value">"payload"</span>
                            <span class="hl-attribute">remote-directory</span>=<span class="hl-value">"ftpTarget"</span>
                            <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"stream"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int-file:splitter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"stream"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"lines"</span><span class="hl-tag"> /&gt;</span></pre>
<p>Note: if you consume the input stream in a custom component, you <span class="strong"><strong>must</strong></span> close the <code class="literal">Session</code>.
You can either do that in your custom code, or route a copy of the message to a <code class="literal">service-activator</code> and use SpEL:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"closeSession"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"headers[T(org.springframework.integration.IntegrationMessageHeaderAccessor).CLOSEABLE_RESOURCE].close()"</span><span class="hl-tag"> /&gt;</span></pre>
<p><span class="strong"><strong>mget</strong></span></p>
<p><span class="emphasis"><em>mget</em></span> retrieves multiple remote files based on a pattern and supports the following option:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-P - preserve the timestamps of the remote files
</li><li class="listitem">
-x - Throw an exception if no files match the pattern (otherwise an empty list is returned)
</li></ul></div>
<p>The message payload resulting from an <span class="emphasis"><em>mget</em></span> operation is a <code class="literal">List&lt;File&gt;</code> object - a List of File objects, each representing a retrieved file.</p>
<p>The remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the pattern for the file names is provided in the <code class="literal">file_remoteFile</code> header.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Notes for when using recursion (-R)"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Notes for when using recursion (<code class="literal">-R</code>)</th></tr><tr><td align="left" valign="top">

<p>The pattern is ignored, and <code class="literal">*</code> is assumed.
By default, the entire remote tree is retrieved.
However, files in the tree can be filtered, by providing a`FileListFilter`; directories in the tree can also be filtered this way.
A <code class="literal">FileListFilter</code> can be provided by reference or by <code class="literal">filename-pattern</code> or <code class="literal">filename-regex</code> attributes.
For example, <code class="literal">filename-regex="(subDir|.*1.txt)"</code> will retrieve all files ending with <code class="literal">1.txt</code> in the remote directory and the subdirectory <code class="literal">subDir</code>.
If a subdirectory is filtered, no additional traversal of that subdirectory is performed.</p>
<p>The <code class="literal">-dirs</code> option is not allowed (the recursive mget uses the recursive <code class="literal">ls</code> to obtain the directory tree and the directories themselves cannot be included in the list).</p>
<p>Typically, you would use the <code class="literal">#remoteDirectory</code> variable in the <code class="literal">local-directory-expression</code> so that the remote directory structure is retained locally.</p>
</td></tr></table></div>
<p>See also <a class="xref" href="ftp.html#ftp-partial" title="15.7.3&nbsp;Outbound Gateway Partial Success (mget and mput)">Section&nbsp;15.7.3, &#8220;Outbound Gateway Partial Success (mget and mput)&#8221;</a>.</p>
<p><span class="strong"><strong>put</strong></span></p>
<p><span class="emphasis"><em>put</em></span> sends a file to the remote server; the payload of the message can be a <code class="literal">java.io.File</code>, a <code class="literal">byte[]</code> or a <code class="literal">String</code>.
A <code class="literal">remote-filename-generator</code> (or expression) is used to name the remote file.
Other available attributes include <code class="literal">remote-directory</code>, <code class="literal">temporary-remote-directory</code> (and their <code class="literal">*-expression</code>) equivalents, <code class="literal">use-temporary-file-name</code>, and <code class="literal">auto-create-directory</code>.
Refer to the schema documentation for more information.</p>
<p>The message payload resulting from a <span class="emphasis"><em>put</em></span> operation is a <code class="literal">String</code> representing the full path of the file on the server after transfer.</p>
<p><span class="strong"><strong>mput</strong></span></p>
<p><span class="emphasis"><em>mput</em></span> sends multiple files to the server and supports the following option:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
-R - Recursive - send all files (possibly filtered) in the directory and subdirectories
</li></ul></div>
<p>The message payload must be a <code class="literal">java.io.File</code> representing a local directory.</p>
<p>The same attributes as the <code class="literal">put</code> command are supported.
In addition, files in the local directory can be filtered with one of <code class="literal">mput-pattern</code>, <code class="literal">mput-regex</code> or <code class="literal">mput-filter</code>.
The filter works with recursion, as long as the subdirectories themselves pass the filter.
Subdirectories that do not pass the filter are not recursed.</p>
<p>The message payload resulting from an <span class="emphasis"><em>mget</em></span> operation is a <code class="literal">List&lt;String&gt;</code> object - a List of remote file paths resulting from the transfer.</p>
<p>See also <a class="xref" href="ftp.html#ftp-partial" title="15.7.3&nbsp;Outbound Gateway Partial Success (mget and mput)">Section&nbsp;15.7.3, &#8220;Outbound Gateway Partial Success (mget and mput)&#8221;</a>.</p>
<p><span class="strong"><strong>rm</strong></span></p>
<p>The <span class="emphasis"><em>rm</em></span> command has no options.</p>
<p>The message payload resulting from an <span class="emphasis"><em>rm</em></span> operation is Boolean.TRUE if the remove was successful, Boolean.FALSE otherwise.
The remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the filename is provided in the <code class="literal">file_remoteFile</code> header.</p>
<p><span class="strong"><strong>mv</strong></span></p>
<p>The <span class="emphasis"><em>mv</em></span> command has no options.</p>
<p>The <span class="emphasis"><em>expression</em></span> attribute defines the "from" path and the <span class="emphasis"><em>rename-expression</em></span> attribute defines the "to" path.
By default, the <span class="emphasis"><em>rename-expression</em></span> is <code class="literal">headers['file_renameTo']</code>.
This expression must not evaluate to null, or an empty <code class="literal">String</code>.
If necessary, any remote directories needed will be created.
The payload of the result message is <code class="literal">Boolean.TRUE</code>.
The original remote directory is provided in the <code class="literal">file_remoteDirectory</code> header, and the filename is provided in the <code class="literal">file_remoteFile</code> header.
The new path is in the <code class="literal">file_renameTo</code> header.</p>
<p><span class="strong"><strong>Additional Information</strong></span></p>
<p>The <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>mget</em></span> commands support the <span class="emphasis"><em>local-filename-generator-expression</em></span> attribute.
It defines a SpEL expression to generate the name of local file(s) during the transfer.
The root object of the evaluation context is the request Message but, in addition, the <code class="literal">remoteFileName</code> variable is also available, which is particularly useful for <span class="emphasis"><em>mget</em></span>, for example: <code class="literal">local-filename-generator-expression="#remoteFileName.toUpperCase() + headers.foo"</code>.</p>
<p>The <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>mget</em></span> commands support the <span class="emphasis"><em>local-directory-expression</em></span> attribute.
It defines a SpEL expression to generate the name of local directory(ies) during the transfer.
The root object of the evaluation context is the request Message but, in addition, the <code class="literal">remoteDirectory</code> variable is also available, which is particularly useful for <span class="emphasis"><em>mget</em></span>, for example: <code class="literal">local-directory-expression="'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.foo"</code>.
This attribute is mutually exclusive with <span class="emphasis"><em>local-directory</em></span> attribute.</p>
<p>For all commands, the PATH that the command acts on is provided by the <span class="emphasis"><em>expression</em></span> property of the gateway.
For the mget command, the expression might evaluate to <span class="emphasis"><em><span class="strong"><strong></strong></span>, meaning retrieve all files, or <span class="emphasis"><em>somedirectory/</em></span></em></span> etc.</p>
<p>Here is an example of a gateway configured for an ls command&#8230;&#8203;</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ftp:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gateway1"</span>
    <span class="hl-attribute">session-factory</span>=<span class="hl-value">"ftpSessionFactory"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inbound1"</span>
    <span class="hl-attribute">command</span>=<span class="hl-value">"ls"</span>
    <span class="hl-attribute">command-options</span>=<span class="hl-value">"-1"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"payload"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"toSplitter"</span><span class="hl-tag">/&gt;</span></pre>
<p>The payload of the message sent to the toSplitter channel is a list of String objects containing the filename of each
file.
If the <code class="literal">command-options</code> was omitted, it would be a list of <code class="literal">FileInfo</code> objects.
Options are provided space-delimited, e.g.
<code class="literal">command-options="-1 -dirs -links"</code>.</p>
<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, the <code class="literal">GET</code>, <code class="literal">MGET</code>, <code class="literal">PUT</code> and <code class="literal">MPUT</code> commands support a <code class="literal">FileExistsMode</code> property (<code class="literal">mode</code>
when using the namespace support). This affects the behavior when the local file exists (<code class="literal">GET</code> and <code class="literal">MGET</code>) or the remote
file exists (<code class="literal">PUT</code> and <code class="literal">MPUT</code>). Supported modes are <code class="literal">REPLACE</code>, <code class="literal">APPEND</code>, <code class="literal">FAIL</code> and <code class="literal">IGNORE</code>.
For backwards compatibility, the default mode for <code class="literal">PUT</code> and <code class="literal">MPUT</code> operations is <code class="literal">REPLACE</code> and for <code class="literal">GET</code> and <code class="literal">MGET</code>
operations, the default is <code class="literal">FAIL</code>.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration_13" href="#_configuring_with_java_configuration_13"></a>15.7.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Gateway using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = <span class="hl-keyword">new</span> DefaultFtpSessionFactory();
        sf.setHost(<span class="hl-string">"localhost"</span>);
        sf.setPort(port);
        sf.setUsername(<span class="hl-string">"foo"</span>);
        sf.setPassword(<span class="hl-string">"foo"</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "ftpChannel")</span></em>
    <span class="hl-keyword">public</span> MessageHandler handler() {
        FtpOutboundGateway ftpOutboundGateway = <span class="hl-keyword">new</span> FtpOutboundGateway(ftpSessionFactory(), <span class="hl-string">"ls"</span>);
        ftpOutboundGateway.setOutputChannelName(<span class="hl-string">"lsReplyChannel"</span>);
        <span class="hl-keyword">return</span> ftpOutboundGateway;
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl_11" href="#_configuring_with_the_java_dsl_11"></a>15.7.2&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the Outbound Gateway using the Java DSL:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FtpJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        <span class="hl-keyword">new</span> SpringApplicationBuilder(FtpJavaApplication.<span class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = <span class="hl-keyword">new</span> DefaultFtpSessionFactory();
        sf.setHost(<span class="hl-string">"localhost"</span>);
        sf.setPort(port);
        sf.setUsername(<span class="hl-string">"foo"</span>);
        sf.setPassword(<span class="hl-string">"foo"</span>);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> FtpOutboundGatewaySpec ftpOutboundGateway() {
        <span class="hl-keyword">return</span> Ftp.outboundGateway(ftpSessionFactory(),
            AbstractRemoteFileOutboundGateway.Command.MGET, <span class="hl-string">"payload"</span>)
            .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)
            .regexFileNameFilter(<span class="hl-string">"(subFtpSource|.*1.txt)"</span>)
            .localDirectoryExpression(<span class="hl-string">"'localDirectory/' + #remoteDirectory"</span>)
            .localFilenameExpression(<span class="hl-string">"#remoteFileName.replaceFirst('ftpSource', 'localTarget')"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow ftpMGetFlow(AbstractRemoteFileOutboundGateway&lt;FTPFile&gt; ftpOutboundGateway) {
        <span class="hl-keyword">return</span> f -&gt; f
            .handle(ftpOutboundGateway)
            .channel(c -&gt; c.queue(<span class="hl-string">"remoteFileOutputChannel"</span>));
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ftp-partial" href="#ftp-partial"></a>15.7.3&nbsp;Outbound Gateway Partial Success (mget and mput)</h3></div></div></div>

<p>When performing operations on multiple files (<code class="literal">mget</code> and <code class="literal">mput</code>) it is possible that an exception occurs some time after
one or more files have been transferred.
In this case (starting with <span class="emphasis"><em>version 4.2</em></span>), a <code class="literal">PartialSuccessException</code> is thrown.
As well as the usual <code class="literal">MessagingException</code> properties (<code class="literal">failedMessage</code> and <code class="literal">cause</code>), this exception has two additional
properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">partialResults</code> - the successful transfer results.
</li><li class="listitem">
<code class="literal">derivedInput</code> - the list of files generated from the request message (e.g. local files to transfer for an <code class="literal">mput</code>).
</li></ul></div>
<p>This will enable you to determine which files were successfully transferred, and which were not.</p>
<p>In the case of a recursive <code class="literal">mput</code>, the <code class="literal">PartialSuccessException</code> may have nested <code class="literal">PartialSuccessException</code> s.</p>
<p>Consider:</p>
<pre class="screen">root/
|- file1.txt
|- subdir/
   | - file2.txt
   | - file3.txt
|- zoo.txt</pre>
<p>If the exception occurs on <code class="literal">file3.txt</code>, the <code class="literal">PartialSuccessException</code> thrown by the gateway will have <code class="literal">derivedInput</code>
of <code class="literal">file1.txt</code>, <code class="literal">subdir</code>, <code class="literal">zoo.txt</code> and <code class="literal">partialResults</code> of <code class="literal">file1.txt</code>.
It&#8217;s <code class="literal">cause</code> will be another <code class="literal">PartialSuccessException</code> with <code class="literal">derivedInput</code> of <code class="literal">file2.txt</code>, <code class="literal">file3.txt</code> and
<code class="literal">partialResults</code> of <code class="literal">file2.txt</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-session-caching" href="#ftp-session-caching"></a>15.8&nbsp;FTP Session Caching</h2></div></div></div>

<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Starting with <span class="emphasis"><em>Spring Integration version 3.0</em></span>, sessions are no longer cached by default; the <code class="literal">cache-sessions</code> attribute is no longer supported on endpoints.
You must use a <code class="literal">CachingSessionFactory</code> (see below) if you wish to cache sessions.</p>
</td></tr></table></div>
<p>In versions prior to 3.0, the sessions were cached automatically by default.
A <code class="literal">cache-sessions</code> attribute was available for disabling the auto caching, but that solution did not provide a way to configure other session caching attributes.
For example, you could not limit on the number of sessions created.
To support that requirement and other configuration options, a <code class="literal">CachingSessionFactory</code> was provided.
It provides <code class="literal">sessionCacheSize</code> and <code class="literal">sessionWaitTimeout</code> properties.
As its name suggests, the <code class="literal">sessionCacheSize</code> property controls how many active sessions the factory will maintain in its cache (the DEFAULT is unbounded).
If the <code class="literal">sessionCacheSize</code> threshold has been reached, any attempt to acquire another session will block until either one of the cached sessions becomes available or until the wait time for a Session expires (the DEFAULT wait time is Integer.MAX_VALUE).
The <code class="literal">sessionWaitTimeout</code> property enables configuration of that value.</p>
<p>If you want your Sessions to be cached, simply configure your default Session Factory as described above and then wrap it in an instance of <code class="literal">CachingSessionFactory</code> where you may provide those additional properties.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ftpSessionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.ftp.session.DefaultFtpSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"host"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cachingSessionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.file.remote.session.CachingSessionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"ftpSessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionWaitTimeout"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>In the above example you see a <code class="literal">CachingSessionFactory</code> created with the <code class="literal">sessionCacheSize</code> set to 10 and the
<code class="literal">sessionWaitTimeout</code> set to 1 second (its value is in milliseconds).</p>
<p>Starting with <span class="emphasis"><em>Spring Integration version 3.0</em></span>, the <code class="literal">CachingConnectionFactory</code> provides a <code class="literal">resetCache()</code> method.
When invoked, all idle sessions are immediately closed and in-use sessions are closed when they are returned to the cache.
New requests for sessions will establish new sessions as necessary.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-rft" href="#ftp-rft"></a>15.9&nbsp;RemoteFileTemplate</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>Spring Integration version 3.0</em></span> a new abstraction is provided over the <code class="literal">FtpSession</code> object.
The template provides methods to send, retrieve (as an <code class="literal">InputStream</code>), remove, and rename files.
In addition an <code class="literal">execute</code> method is provided allowing the caller to execute multiple operations on the session.
In all cases, the template takes care of reliably closing the session.
For more information, refer to the
<a class="ulink" href="http://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html" target="_top">JavaDocs for <code class="literal">RemoteFileTemplate</code></a>.
There is a subclass for FTP: <code class="literal">FtpRemoteFileTemplate</code>.</p>
<p>Additional methods were added in <span class="emphasis"><em>version 4.1</em></span> including <code class="literal">getClientInstance()</code> which provides access to the underlying <code class="literal">FTPClient</code> enabling access to low-level APIs.</p>
<p>Not all FTP servers properly implement <code class="literal">STAT &lt;path&gt;</code> command, in that it can return a positive result for a non-existent path.
The <code class="literal">NLST</code> command reliably returns the name, when the path is a file and it exists.
However, this does not support checking that an empty directory exists since <code class="literal">NLST</code> always returns an empty list in this case, when the path is a directory.
Since the template doesn&#8217;t know if the path represents a directory or not, it has to perform additional checks when the path does not appear to exist, when using <code class="literal">NLST</code>.
This adds overhead, requiring several requests to the server.
Starting with <span class="emphasis"><em>version 4.1.9</em></span> the <code class="literal">FtpRemoteFileTemplate</code> provides <code class="literal">FtpRemoteFileTemplate.ExistsMode</code> property with the following options:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">STAT</code> - Perform the <code class="literal">STAT</code> FTP command (<code class="literal">FTPClient.getStatus(path)</code>) to check the path existence; this is the default and requires that your FTP server properly supports the <code class="literal">STAT</code> command (with a path).
</li><li class="listitem">
<code class="literal">NLST</code> - Perform the <code class="literal">NLST</code> FTP command - <code class="literal">FTPClient.listName(path)</code>; use this if you are testing for a path that is a full path to a file; it won&#8217;t work for empty directories.
</li><li class="listitem">
<code class="literal">NLST_AND_DIRS</code> -  Perform the <code class="literal">NLST</code> command first and if it returns no files, fall back to a technique which temporarily switches the working directory using <code class="literal">FTPClient.changeWorkingDirectory(path)</code>.
See <code class="literal">FtpSession.exists()</code> for more information.
</li></ul></div>
<p>Since we know that the <code class="literal">FileExistsMode.FAIL</code> case is always only looking for a file (and not a directory), we safely use <code class="literal">NLST</code> mode for the <code class="literal">FtpMessageHandler</code> and <code class="literal">FtpOutboundGateway</code> components.</p>
<p>For any other cases the <code class="literal">FtpRemoteFileTemplate</code> can be extended for implementing a custom logic in the overridden <code class="literal">exist()</code> method.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ftp-session-callback" href="#ftp-session-callback"></a>15.10&nbsp;MessageSessionCallback</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>Spring Integration version 4.2</em></span>, a <code class="literal">MessageSessionCallback&lt;F, T&gt;</code> implementation can be used with the
<code class="literal">&lt;int-ftp:outbound-gateway/&gt;</code> (<code class="literal">FtpOutboundGateway</code>) to perform any operation(s) on the <code class="literal">Session&lt;FTPFile&gt;</code> with
the <code class="literal">requestMessage</code> context.
It can be used for any non-standard or low-level FTP operation (or several); for example, allowing access
from an integration flow definition, and <span class="emphasis"><em>functional</em></span> interface (Lambda) implementation injection:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "ftpChannel")</span></em>
<span class="hl-keyword">public</span> MessageHandler ftpOutboundGateway(SessionFactory&lt;FTPFile&gt; sessionFactory) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> FtpOutboundGateway(sessionFactory,
         (session, requestMessage) -&gt; session.list(requestMessage.getPayload()));
}</pre>
<p>Another example might be to pre- or post- process the file data being sent/retrieved.</p>
<p>When using XML configuration, the <code class="literal">&lt;int-ftp:outbound-gateway/&gt;</code> provides a <code class="literal">session-callback</code> attribute to allow you to
specify the <code class="literal">MessageSessionCallback</code> bean name.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">session-callback</code> is mutually exclusive with the <code class="literal">command</code> and <code class="literal">expression</code> attributes.
When configuring with Java, different constructors are available in the <code class="literal">FtpOutboundGateway</code> class.</p>
</td></tr></table></div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="files.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="gemfire.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">14.&nbsp;File Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;16.&nbsp;GemFire Support</td></tr></table></div></body></html>