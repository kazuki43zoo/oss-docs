<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>8.&nbsp;Messaging Endpoints</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-core-messaging.html" title="Part&nbsp;IV.&nbsp;Core Messaging"><link rel="prev" href="messaging-transformation-chapter.html" title="7.&nbsp;Message Transformation"><link rel="next" href="system-management-chapter.html" title="9.&nbsp;System Management"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.&nbsp;Messaging Endpoints</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="messaging-transformation-chapter.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Core Messaging</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="system-management-chapter.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="messaging-endpoints-chapter" href="#messaging-endpoints-chapter"></a>8.&nbsp;Messaging Endpoints</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint" href="#endpoint"></a>8.1&nbsp;Message Endpoints</h2></div></div></div>

<p>The first part of this chapter covers some background theory and reveals quite a bit about the underlying API that drives Spring Integration&#8217;s various messaging components.
This information can be helpful if you want to really understand what&#8217;s going on behind the scenes.
However, if you want to get up and running with the simplified namespace-based configuration of the various elements, feel free to skip ahead to<a class="xref" href="messaging-endpoints-chapter.html#endpoint-namespace" title="8.1.4&nbsp;Namespace Support">Section&nbsp;8.1.4, &#8220;Namespace Support&#8221;</a> for now.</p>
<p>As mentioned in the overview, Message Endpoints are responsible for connecting the various messaging components to channels.
Over the next several chapters, you will see a number of different components that consume Messages.
Some of these are also capable of sending reply Messages.
Sending Messages is quite straightforward.
As shown above in <a class="xref" href="messaging-channels-section.html#channel" title="4.1&nbsp;Message Channels">Section&nbsp;4.1, &#8220;Message Channels&#8221;</a>, it&#8217;s easy to <span class="emphasis"><em>send</em></span> a Message to a Message Channel.
However, receiving is a bit more complicated.
The main reason is that there are two types of consumers: <a class="ulink" href="http://www.eaipatterns.com/PollingConsumer.html" target="_top">Polling Consumers</a> and <a class="ulink" href="http://www.eaipatterns.com/EventDrivenConsumer.html" target="_top">Event Driven Consumers</a>.</p>
<p>Of the two, Event Driven Consumers are much simpler.
Without any need to manage and schedule a separate poller thread, they are essentially just listeners with a callback method.
When connecting to one of Spring Integration&#8217;s subscribable Message Channels, this simple option works great.
However, when connecting to a buffering, pollable Message Channel, some component has to schedule and manage the polling thread(s).
Spring Integration provides two different endpoint implementations to accommodate these two types of consumers.
Therefore, the consumers themselves can simply implement the callback interface.
When polling is required, the endpoint acts as a <span class="emphasis"><em>container</em></span> for the consumer instance.
The benefit is similar to that of using a container for hosting Message Driven Beans, but since these consumers are simply Spring-managed Objects running within an ApplicationContext, it more closely resembles Spring&#8217;s own MessageListener containers.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-handler" href="#endpoint-handler"></a>8.1.1&nbsp;Message Handler</h3></div></div></div>

<p>Spring Integration&#8217;s <code class="literal">MessageHandler</code> interface is implemented by many of the components within the framework.
In other words, this is not part of the public API, and a developer would not typically implement <code class="literal">MessageHandler</code> directly.
Nevertheless, it is used by a Message Consumer for actually handling the consumed Messages, and so being aware of this strategy interface does help in terms of understanding the overall role of a consumer.
The interface is defined as follows:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageHandler {

    <span class="hl-keyword">void</span> handleMessage(Message&lt;?&gt; message);

}</pre>
<p>Despite its simplicity, this provides the foundation for most of the components that will be covered in the following chapters (Routers, Transformers, Splitters, Aggregators, Service Activators, etc).
Those components each perform very different functionality with the Messages they handle, but the requirements for actually receiving a Message are the same, and the choice between polling and event-driven behavior is also the same.
Spring Integration provides two endpoint implementations that <span class="emphasis"><em>host</em></span> these callback-based handlers and allow them to be connected to Message Channels.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-eventdrivenconsumer" href="#endpoint-eventdrivenconsumer"></a>8.1.2&nbsp;Event Driven Consumer</h3></div></div></div>

<p>Because it is the simpler of the two, we will cover the Event Driven Consumer endpoint first.
You may recall that the <code class="literal">SubscribableChannel</code> interface provides a <code class="literal">subscribe()</code> method and that the method accepts a <code class="literal">MessageHandler</code> parameter (as shown in <a class="xref" href="messaging-channels-section.html#channel-interfaces-subscribablechannel" title="SubscribableChannel">the section called &#8220;SubscribableChannel&#8221;</a>):</p>
<pre class="programlisting">subscribableChannel.subscribe(messageHandler);</pre>
<p>Since a handler that is subscribed to a channel does not have to actively poll that channel, this is an Event Driven Consumer, and the implementation provided by Spring Integration accepts a a <code class="literal">SubscribableChannel</code> and a <code class="literal">MessageHandler</code>:</p>
<pre class="programlisting">SubscribableChannel channel = context.getBean(<span class="hl-string">"subscribableChannel"</span>, SubscribableChannel.<span class="hl-keyword">class</span>);

EventDrivenConsumer consumer = <span class="hl-keyword">new</span> EventDrivenConsumer(channel, exampleHandler);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-pollingconsumer" href="#endpoint-pollingconsumer"></a>8.1.3&nbsp;Polling Consumer</h3></div></div></div>

<p>Spring Integration also provides a <code class="literal">PollingConsumer</code>, and it can be instantiated in the same way except that the channel must implement <code class="literal">PollableChannel</code>:</p>
<pre class="programlisting">PollableChannel channel = context.getBean(<span class="hl-string">"pollableChannel"</span>, PollableChannel.<span class="hl-keyword">class</span>);

PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, exampleHandler);</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For more information regarding Polling Consumers, please also read <a class="xref" href="messaging-channels-section.html#polling-consumer" title="4.2&nbsp;Poller">Section&nbsp;4.2, &#8220;Poller&#8221;</a> as well as <a class="xref" href="messaging-channels-section.html#channel-adapter" title="4.3&nbsp;Channel Adapter">Section&nbsp;4.3, &#8220;Channel Adapter&#8221;</a>.</p>
</td></tr></table></div>
<p>There are many other configuration options for the Polling Consumer.
For example, the trigger is a required property:</p>
<pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

consumer.setTrigger(<span class="hl-keyword">new</span> IntervalTrigger(<span class="hl-number">30</span>, TimeUnit.SECONDS));</pre>
<p>Spring Integration currently provides two implementations of the <code class="literal">Trigger</code> interface: <code class="literal">IntervalTrigger</code> and <code class="literal">CronTrigger</code>.
The <code class="literal">IntervalTrigger</code> is typically defined with a simple interval (in milliseconds), but also supports an <span class="emphasis"><em>initialDelay</em></span> property and a boolean <span class="emphasis"><em>fixedRate</em></span> property (the default is false, i.e.
fixed delay):</p>
<pre class="programlisting">IntervalTrigger trigger = <span class="hl-keyword">new</span> IntervalTrigger(<span class="hl-number">1000</span>);
trigger.setInitialDelay(<span class="hl-number">5000</span>);
trigger.setFixedRate(true);</pre>
<p>The <code class="literal">CronTrigger</code> simply requires a valid cron expression (see the Javadoc for details):</p>
<pre class="programlisting">CronTrigger trigger = <span class="hl-keyword">new</span> CronTrigger(<span class="hl-string">"*/10 * * * * MON-FRI"</span>);</pre>
<p>In addition to the trigger, several other polling-related configuration properties may be specified:</p>
<pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

consumer.setMaxMessagesPerPoll(<span class="hl-number">10</span>);
consumer.setReceiveTimeout(<span class="hl-number">5000</span>);</pre>
<p>The <span class="emphasis"><em>maxMessagesPerPoll</em></span> property specifies the maximum number of messages to receive within a given poll operation.
This means that the poller will continue calling receive() <span class="emphasis"><em>without waiting</em></span> until either <code class="literal">null</code> is returned or that max is reached.
For example, if a poller has a 10 second interval trigger and a <span class="emphasis"><em>maxMessagesPerPoll</em></span> setting of 25, and it is polling a channel that has 100 messages in its queue, all 100 messages can be retrieved within 40 seconds.
It grabs 25, waits 10 seconds, grabs the next 25, and so on.</p>
<p>The <span class="emphasis"><em>receiveTimeout</em></span> property specifies the amount of time the poller should wait if no messages are available when it invokes the receive operation.
For example, consider two options that seem similar on the surface but are actually quite different: the first has an interval trigger of 5 seconds and a receive timeout of 50 milliseconds while the second has an interval trigger of 50 milliseconds and a receive timeout of 5 seconds.
The first one may receive a message up to 4950 milliseconds later than it arrived on the channel (if that message arrived immediately after one of its poll calls returned).
On the other hand, the second configuration will never miss a message by more than 50 milliseconds.
The difference is that the second option requires a thread to wait, but as a result it is able to respond much more quickly to arriving messages.
This technique, known as <span class="emphasis"><em>long polling</em></span>, can be used to emulate event-driven behavior on a polled source.</p>
<p>A Polling Consumer may also delegate to a Spring <code class="literal">TaskExecutor</code>, as illustrated in the following example:</p>
<pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

TaskExecutor taskExecutor = context.getBean(<span class="hl-string">"exampleExecutor"</span>, TaskExecutor.<span class="hl-keyword">class</span>);
consumer.setTaskExecutor(taskExecutor);</pre>
<p>Furthermore, a <code class="literal">PollingConsumer</code> has a property called <span class="emphasis"><em>adviceChain</em></span>.
This property allows you to specify a <code class="literal">List</code> of AOP Advices for handling additional cross cutting concerns including transactions.
These advices are applied around the <code class="literal">doPoll()</code> method.
For more in-depth information, please see the sections <span class="emphasis"><em>AOP Advice chains</em></span> and <span class="emphasis"><em>Transaction Support</em></span> under <a class="xref" href="messaging-endpoints-chapter.html#endpoint-namespace" title="8.1.4&nbsp;Namespace Support">Section&nbsp;8.1.4, &#8220;Namespace Support&#8221;</a>.</p>
<p>The examples above show dependency lookups, but keep in mind that these consumers will most often be configured as Spring <span class="emphasis"><em>bean definitions</em></span>.
In fact, Spring Integration also provides a <code class="literal">FactoryBean</code> called <code class="literal">ConsumerEndpointFactoryBean</code> that creates the appropriate consumer type based on the type of channel, and there is full XML namespace support to even further hide those details.
The namespace-based configuration will be featured as each component type is introduced.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Many of the <code class="literal">MessageHandler</code> implementations are also capable of generating reply Messages.
As mentioned above, sending Messages is trivial when compared to the Message reception.
Nevertheless,<span class="emphasis"><em>when</em></span> and <span class="emphasis"><em>how many</em></span> reply Messages are sent depends on the handler type.
For example, an <span class="emphasis"><em>Aggregator</em></span> waits for a number of Messages to arrive and is often configured as a downstream consumer for a <span class="emphasis"><em>Splitter</em></span> which may generate multiple replies for each Message it handles.
When using the namespace configuration, you do not strictly need to know all of the details, but it still might be worth knowing that several of these components share a common base class, the <code class="literal">AbstractReplyProducingMessageHandler</code>, and it provides a <code class="literal">setOutputChannel(..)</code> method.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-namespace" href="#endpoint-namespace"></a>8.1.4&nbsp;Namespace Support</h3></div></div></div>

<p>Throughout the reference manual, you will see specific configuration examples for endpoint elements, such as router, transformer, service-activator, and so on.
Most of these will support an <span class="emphasis"><em>input-channel</em></span> attribute and many will support an <span class="emphasis"><em>output-channel</em></span> attribute.
After being parsed, these endpoint elements produce an instance of either the <code class="literal">PollingConsumer</code> or the <code class="literal">EventDrivenConsumer</code> depending on the type of the <span class="emphasis"><em>input-channel</em></span> that is referenced: <code class="literal">PollableChannel</code> or <code class="literal">SubscribableChannel</code> respectively.
When the channel is pollable, then the polling behavior is determined based on the endpoint element&#8217;s <span class="emphasis"><em>poller</em></span> sub-element and its attributes.</p>
<p><span class="emphasis"><em>Configuration_Below you find a _poller</em></span> with all available configuration options:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">cron</span>=<span class="hl-value">""</span>                                  <a name="CO11-1" href="#CO11-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
            default="false"                          <a name="CO11-2" href="#CO11-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
            error-channel=""                         <a name="CO11-3" href="#CO11-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
            fixed-delay=""                           <a name="CO11-4" href="#CO11-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
            fixed-rate=""                            <a name="CO11-5" href="#CO11-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
            id=""                                    <a name="CO11-6" href="#CO11-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
            max-messages-per-poll=""                 <a name="CO11-7" href="#CO11-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
            receive-timeout=""                       <a name="CO11-8" href="#CO11-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
            ref=""                                   <a name="CO11-9" href="#CO11-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
            task-executor=""                         <a name="CO11-10" href="#CO11-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span>
            time-unit="MILLISECONDS"                 <a name="CO11-11" href="#CO11-11"></a><span><img src="images/callouts/11.png" alt="11" border="0"></span>
            trigger=""&gt;                              <a name="CO11-12" href="#CO11-12"></a><span><img src="images/callouts/12.png" alt="12" border="0"></span>
            <span class="hl-tag">&lt;int:advice-chain /&gt;</span>                     <a name="CO11-13" href="#CO11-13"></a><span><img src="images/callouts/13.png" alt="13" border="0"></span>
            <span class="hl-tag">&lt;int:transactional /&gt;</span>                    <a name="CO11-14" href="#CO11-14"></a><span><img src="images/callouts/14.png" alt="14" border="0"></span>
<span class="hl-tag">&lt;/int:poller&gt;</span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Provides the ability to configure Pollers using Cron expressions.
The underlying implementation uses an <code class="literal">org.springframework.scheduling.support.CronTrigger</code>.
If this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-delay</code>, <code class="literal">trigger</code>, <code class="literal">fixed-rate</code>, <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>By setting this attribute to <span class="emphasis"><em>true</em></span>, it is possible to define exactly one (1) global default poller.
An exception is raised if more than one default poller is defined in the application context.
Any endpoints connected to a PollableChannel (PollingConsumer) or any SourcePollingChannelAdapter that does not have any explicitly configured poller will then use the global default Poller.
<span class="emphasis"><em>Optional</em></span>.
Defaults to <code class="literal">false</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Identifies the channel which error messages will be sent to if a failure occurs in this poller&#8217;s invocation.
To completely suppress Exceptions, provide a reference to the <code class="literal">nullChannel</code>.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The fixed delay trigger uses a <code class="literal">PeriodicTrigger</code> under the covers.
If the <code class="literal">time-unit</code> attribute is not used, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-rate</code>, <code class="literal">trigger</code>, <code class="literal">cron</code>, <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The fixed rate trigger uses a <code class="literal">PeriodicTrigger</code> under the covers.
If the <code class="literal">time-unit</code> attribute is not used the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-delay</code>, <code class="literal">trigger</code>, <code class="literal">cron</code>, <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The Id referring to the Poller&#8217;s underlying bean-definition, which is of type <code class="literal">org.springframework.integration.scheduling.PollerMetadata</code>.
The <span class="emphasis"><em>id</em></span> attribute is required for a top-level poller element unless it is the default poller (<code class="literal">default="true"</code>).</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Please see <a class="xref" href="messaging-channels-section.html#channel-adapter-namespace-inbound" title="4.3.1&nbsp;Configuring An Inbound Channel Adapter">Section&nbsp;4.3.1, &#8220;Configuring An Inbound Channel Adapter&#8221;</a> for more information.
<span class="emphasis"><em>Optional</em></span>.
If not specified the default values used depends on the context.
If a <code class="literal">PollingConsumer</code> is used, this atribute will default to <span class="emphasis"><em>-1</em></span>.
However, if a <code class="literal">SourcePollingChannelAdapter</code> is used, then the <code class="literal">max-messages-per-poll</code> attribute defaults to <span class="emphasis"><em>1</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Value is set on the underlying class `PollerMetadata`<span class="emphasis"><em>Optional</em></span>.
If not specified it defaults to 1000 (milliseconds).</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Bean reference to another top-level poller.
The <code class="literal">ref</code> attribute must not be present on the top-level <code class="literal">poller</code> element.
However, if this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-rate</code>, <code class="literal">trigger</code>, <code class="literal">cron</code>, <code class="literal">fixed-delay</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Provides the ability to reference a custom <span class="emphasis"><em>task executor</em></span>.
Please see the section below titled <span class="emphasis"><em>TaskExecutor Support</em></span> for further information.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-11"><span><img src="images/callouts/11.png" alt="11" border="0"></span></a> </p></td><td valign="top" align="left">
<p>This attribute specifies the <code class="literal">java.util.concurrent.TimeUnit</code> enum value on the underlying <code class="literal">org.springframework.scheduling.support.PeriodicTrigger</code>.
Therefore, this attribute can <span class="emphasis"><em>ONLY</em></span> be used in combination with the <code class="literal">fixed-delay</code> or <code class="literal">fixed-rate</code> attributes.
If combined with either <code class="literal">cron</code> or a <code class="literal">trigger</code> reference attribute, it will cause a failure.
The minimal supported granularity for a <code class="literal">PeriodicTrigger</code> is MILLISECONDS.
Therefore, the only available options are MILLISECONDS and SECONDS.
If this value is not provided, then any <code class="literal">fixed-delay</code> or <code class="literal">fixed-rate</code> value will be interpreted as MILLISECONDS by default.
Basically this enum provides a convenience for SECONDS-based interval trigger values.
For hourly, daily, and monthly settings, consider using a <code class="literal">cron</code> trigger instead.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-12"><span><img src="images/callouts/12.png" alt="12" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Reference to any spring configured bean which implements the <code class="literal">org.springframework.scheduling.Trigger</code> interface.
<span class="emphasis"><em>Optional</em></span>.
However, if this attribute is set, none of the following attributes must be specified:<code class="literal">fixed-delay</code>, <code class="literal">fixed-rate</code>, <code class="literal">cron</code>, <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-13"><span><img src="images/callouts/13.png" alt="13" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Allows to specify extra AOP Advices to handle additional cross cutting concerns.
Please see the section below titled <span class="emphasis"><em>Transaction Support</em></span> for further information.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO11-14"><span><img src="images/callouts/14.png" alt="14" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Pollers can be made transactional.
Please see the section below titled <span class="emphasis"><em>AOP Advice chains</em></span> for further information.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr></table></div>
<p><span class="emphasis"><em>Examples</em></span></p>
<p>For example, a simple interval-based poller with a 1-second interval would be configured like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
    <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transformer&gt;</span></pre>
<p>As an alternative to <span class="emphasis"><em>fixed-rate</em></span> you can also use the <span class="emphasis"><em>fixed-delay</em></span> attribute.</p>
<p>For a poller based on a Cron expression, use the <span class="emphasis"><em>cron</em></span> attribute instead:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
    <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">cron</span>=<span class="hl-value">"*/10 * * * * MON-FRI"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transformer&gt;</span></pre>
<p>If the input channel is a <code class="literal">PollableChannel</code>, then the poller configuration is required.
Specifically, as mentioned above, the <span class="emphasis"><em>trigger</em></span> is a required property of the PollingConsumer class.
Therefore, if you omit the <span class="emphasis"><em>poller</em></span> sub-element for a Polling Consumer endpoint&#8217;s configuration, an Exception may be thrown.
The exception will also be thrown if you attempt to configure a poller on the element that is connected to a non-pollable channel.</p>
<p>It is also possible to create top-level pollers in which case only a <span class="emphasis"><em>ref</em></span> is required:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"weekdayPoller"</span> <span class="hl-attribute">cron</span>=<span class="hl-value">"*/10 * * * * MON-FRI"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
    <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"weekdayPoller"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transformer&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <span class="emphasis"><em>ref</em></span> attribute is only allowed on the inner-poller definitions.
Defining this attribute on a top-level poller will result in a configuration exception thrown during initialization of the Application Context.</p>
</td></tr></table></div>
<p><span class="emphasis"><em>Global Default Pollers</em></span></p>
<p>In fact, to simplify the configuration even further, you can define a global default poller.
A single top-level poller within an ApplicationContext may have the <code class="literal">default</code> attribute with a value of <span class="emphasis"><em>true</em></span>.
In that case, any endpoint with a PollableChannel for its input-channel that is defined within the same ApplicationContext and has no explicitly configured <span class="emphasis"><em>poller</em></span> sub-element will use that default.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"defaultPoller"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"5"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"3000"</span><span class="hl-tag">/&gt;</span>

<span class="hl-comment">&lt;!-- No &lt;poller/&gt; sub-element is necessary since there is a default --&gt;</span>
<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
                 <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
                 <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">/&gt;</span></pre>
<p><span class="emphasis"><em>Transaction Support</em></span></p>
<p>Spring Integration also provides transaction support for the pollers so that each receive-and-forward operation can be performed as an atomic unit-of-work.
To configure transactions for a poller, simply add the_&lt;transactional/&gt;_ sub-element.
The attributes for this element should be familiar to anyone who has experience with Spring&#8217;s Transaction management:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-delay</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span>
                       <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span>
                       <span class="hl-attribute">isolation</span>=<span class="hl-value">"REPEATABLE_READ"</span>
                       <span class="hl-attribute">timeout</span>=<span class="hl-value">"10000"</span>
                       <span class="hl-attribute">read-only</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:poller&gt;</span></pre>
<p>For more information please refer to <a class="xref" href="transactions.html#transaction-poller" title="C.1.1&nbsp;Poller Transaction Support">Section&nbsp;C.1.1, &#8220;Poller Transaction Support&#8221;</a>.</p>
<p><span class="emphasis"><em>AOP Advice chains</em></span></p>
<p>Since Spring transaction support depends on the Proxy mechanism &nbsp;with <code class="literal">TransactionInterceptor</code> (AOP Advice) handling transactional behavior of the message flow initiated by the poller, some times there is a need to provide extra Advice(s) to handle other cross cutting behavior associated with the poller.
For that poller defines an <span class="emphasis"><em>advice-chain</em></span>&nbsp;element allowing you to add more advices - class that &nbsp;implements <code class="literal">MethodInterceptor</code> interface&#8230;&#8203;</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"advicedSa"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"goodInputWithAdvice"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"testBean"</span>
		<span class="hl-attribute">method</span>=<span class="hl-value">"good"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"10000"</span><span class="hl-tag">&gt;</span>
		 <span class="hl-tag">&lt;int:advice-chain&gt;</span>
			<span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"adviceA"</span><span class="hl-tag"> /&gt;</span>
			<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.bar.SampleAdvice"</span><span class="hl-tag"> /&gt;</span>
			<span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"txAdvice"</span><span class="hl-tag"> /&gt;</span>
		<span class="hl-tag">&lt;/int:advice-chain&gt;</span>
	<span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
<p>For more information on how to implement MethodInterceptor please refer to AOP sections of Spring reference manual (section 8 and 9).
Advice chain can also be applied on the poller that does not have any transaction configuration essentially allowing you to enhance the behavior of the message flow initiated by the poller.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When using an advice chain, the <code class="literal">&lt;transactional/&gt;</code> child element cannot be specified; instead, declare a <code class="literal">&lt;tx:advice/&gt;</code> bean and add it to the <code class="literal">&lt;advice-chain/&gt;</code>.
See <a class="xref" href="transactions.html#transaction-poller" title="C.1.1&nbsp;Poller Transaction Support">Section&nbsp;C.1.1, &#8220;Poller Transaction Support&#8221;</a> for complete configuration.</p>
</td></tr></table></div>
<p><span class="emphasis"><em>TaskExecutor Support</em></span></p>
<p>The polling threads may be executed by any instance of Spring&#8217;s <code class="literal">TaskExecutor</code> abstraction.
This enables concurrency for an endpoint or group of endpoints.
As of Spring 3.0, there is a <span class="emphasis"><em>task</em></span> namespace in the core Spring Framework, and its &lt;executor/&gt; element supports the creation of a simple thread pool executor.
That element accepts attributes for common concurrency settings such as pool-size and queue-capacity.
Configuring a thread-pooling executor can make a substantial difference in how the endpoint performs under load.
These settings are available per-endpoint since the performance of an endpoint is one of the major factors to consider (the other major factor being the expected volume on the channel to which the endpoint subscribes).
To enable concurrency for a polling endpoint that is configured with the XML namespace support, provide the <span class="emphasis"><em>task-executor</em></span> reference on its &lt;poller/&gt; element and then provide one or more of the properties shown below:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"pool"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pool"</span>
               <span class="hl-attribute">pool-size</span>=<span class="hl-value">"5-25"</span>
               <span class="hl-attribute">queue-capacity</span>=<span class="hl-value">"20"</span>
               <span class="hl-attribute">keep-alive</span>=<span class="hl-value">"120"</span><span class="hl-tag">/&gt;</span></pre>
<p>If no <span class="emphasis"><em>task-executor</em></span> is provided, the consumer&#8217;s handler will be invoked in the caller&#8217;s thread.
Note that the <span class="emphasis"><em>caller</em></span> is usually the default <code class="literal">TaskScheduler</code> (see <a class="xref" href="configuration.html#namespace-taskscheduler" title="F.3&nbsp;Configuring the Task Scheduler">Section&nbsp;F.3, &#8220;Configuring the Task Scheduler&#8221;</a>).
Also, keep in mind that the <span class="emphasis"><em>task-executor</em></span> attribute can provide a reference to any implementation of Spring&#8217;s <code class="literal">TaskExecutor</code> interface by specifying the bean name.
The <span class="emphasis"><em>executor</em></span> element above is simply provided for convenience.</p>
<p>As mentioned in the background section for Polling Consumers above, you can also configure a Polling Consumer in such a way as to emulate event-driven behavior.
With a long receive-timeout and a short interval-trigger, you can ensure a very timely reaction to arriving messages even on a polled message source.
Note that this will only apply to sources that have a blocking wait call with a timeout.
For example, the File poller does not block, each receive() call returns immediately and either contains new files or not.
Therefore, even if a poller contains a long receive-timeout, that value would never be usable in such a scenario.
On the other hand when using Spring Integration&#8217;s own queue-based channels, the timeout value does have a chance to participate.
The following example demonstrates how a Polling Consumer will receive Messages nearly instantaneously.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"someQueueChannel"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">receive-timeout</span>=<span class="hl-value">"30000"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
<p>Using this approach does not carry much overhead since internally it is nothing more then a timed-wait thread which does not require nearly as much CPU resource usage as a thrashing, infinite while loop for example.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="polling-consumer-change-polling-rate" href="#polling-consumer-change-polling-rate"></a>8.1.5&nbsp;Change Polling Rate at Runtime</h3></div></div></div>

<p>When configuring Pollers with a <code class="literal">fixed-delay</code> or <code class="literal">fixed-rate</code> attribute, the default implementation will use a <code class="literal">PeriodicTrigger</code> instance.
The <code class="literal">PeriodicTrigger</code> is part of the Core Spring Framework and it accepts the <span class="emphasis"><em>interval</em></span> as a constructor argument, only.
Therefore it cannot be changed at runtime.</p>
<p>However, you can define your own implementation of the <code class="literal">org.springframework.scheduling.Trigger</code> interface.
You could even use the PeriodicTrigger as a starting point.
Then, you can add a setter for the interval (period), or you could even embed your own throttling logic within the trigger itself if desired.
The <span class="emphasis"><em>period</em></span> property will be used with each call to <span class="emphasis"><em>nextExecutionTime</em></span> to schedule the next poll.
To use this custom trigger within pollers, declare the bean definition of the custom Trigger in your application context and inject the dependency into your Poller configuration using the <code class="literal">trigger</code> attribute, which references the custom Trigger bean instance.
You can now obtain a reference to the Trigger bean and the polling interval can be changed between polls.</p>
<p>For an example, please see the Spring Integration Samples project.
It contains a sample called <span class="emphasis"><em>dynamic-poller</em></span>, which uses a custom Trigger and demonstrates the ability to change the polling interval at runtime.</p>
<p><a class="ulink" href="https://github.com/SpringSource/spring-integration-samples/tree/master/intermediate" target="_top">https://github.com/SpringSource/spring-integration-samples/tree/master/intermediate</a></p>
<p>The sample provides a custom Trigger which implements the <span class="emphasis"><em><a class="ulink" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/Trigger.html" target="_top">org.springframework.scheduling.Trigger</a></em></span> interface.
The sample&#8217;s Trigger is based on Spring&#8217;s <a class="ulink" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/support/PeriodicTrigger.html" target="_top">PeriodicTrigger</a> implementation.
However, the fields of the custom trigger are not final and the properties have explicit getters and setters, allowing to dynamically change the polling period at runtime.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It is important to note, though, that because the Trigger method is <span class="emphasis"><em>nextExecutionTime()</em></span>, any changes to a dynamic trigger will not take effect until the next poll, based on the existing configuration.
It is not possible to force a trigger to fire before it&#8217;s currently configured next execution time.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="payload-type-conversion" href="#payload-type-conversion"></a>8.1.6&nbsp;Payload Type Conversion</h3></div></div></div>

<p>Throughout the reference manual, you will also see specific configuration and implementation examples of various endpoints which can accept a Message or&nbsp;any arbitrary Object as an input parameter.
In the case of an Object, such a parameter will be mapped to&nbsp;a Message payload or part of the payload or header (when using the Spring Expression Language).
However there are times when the type of input parameter of the endpoint method does not match the type of the payload or its part.
In this scenario we need to perform type conversion.
Spring Integration provides a convenient way for registering type converters (using the Spring 3.x ConversionService) within its own instance of a conversion service bean named <span class="emphasis"><em>integrationConversionService</em></span>.
That bean is automatically created as soon as the first converter is defined using the Spring Integration infrastructure.
To register a Converter all you need is to implement <code class="literal">org.springframework.core.convert.converter.Converter</code>, <code class="literal">org.springframework.core.convert.converter.GenericConverter</code> or <code class="literal">org.springframework.core.convert.converter.ConverterFactory</code>.</p>
<p>The <code class="literal">Converter</code> implementation is the simplest and converts from a single type to another.
For more sophistication, such as converting to a class hierarchy, you would implement a <code class="literal">GenericConverter</code> and possibly a <code class="literal">ConditionalConverter</code>.
These give you complete access to the <span class="emphasis"><em>from</em></span> and <span class="emphasis"><em>to</em></span> type descriptors enabling complex conversions.
For example, if you have an abstract class <code class="literal">Foo</code> that is the target of your conversion (parameter type, channel data type etc) and you have two concrete implementations <code class="literal">Bar</code> and <code class="literal">Baz</code> and you wish to convert to one or the other based on the input type, the <code class="literal">GenericConverter</code> would be a good fit.
Refer to the JavaDocs for these interfaces for more information.</p>
<p>When you have implemented your converter, you can register it with convenient namespace support:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:converter</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sampleConverter"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sampleConverter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.TestConverter"</span><span class="hl-tag">/&gt;</span></pre>
<p>or as an inner bean:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:converter&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.config.xml.ConverterParserTests$TestConverter3"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:converter&gt;</span></pre>
<p>Starting with <span class="emphasis"><em>Spring Integration 4.0</em></span>, the above configuration is available using annotations:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<em><span class="hl-annotation" style="color: gray">@IntegrationConverter</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TestConverter <span class="hl-keyword">implements</span> Converter&lt;Boolean, Number&gt; {

	<span class="hl-keyword">public</span> Number convert(Boolean source) {
		<span class="hl-keyword">return</span> source ? <span class="hl-number">1</span> : <span class="hl-number">0</span>;
	}

}</pre>
<p>or as a <code class="literal">@Configuration</code> part:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableIntegration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@IntegrationConverter</span></em>
	<span class="hl-keyword">public</span> SerializingConverter serializingConverter() {
		<span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SerializingConverter();
	}

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When configuring an <span class="emphasis"><em>Application Context</em></span>, the Spring Framework allows you to add a <span class="emphasis"><em>conversionService</em></span> bean (see <a class="ulink" href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/validation.html#core-convert-Spring-config" target="_top">Configuring a ConversionService</a> chapter).
This service is used, when needed, to perform appropriate conversions during bean creation and configuration.</p>
<p>In contrast, the <span class="emphasis"><em>integrationConversionService</em></span> is used for runtime conversions.
These uses are quite different; converters that are intended for use when wiring bean constructor-args and properties may produce unintended results if used at runtime for Spring Integration expression evaluation against Messages within Datatype Channels, Payload Type transformers etc.</p>
<p>However, if you do want to use the Spring <span class="emphasis"><em>conversionService</em></span> as the Spring Integration <span class="emphasis"><em>integrationConversionService</em></span>, you can configure an <span class="emphasis"><em>alias</em></span> in the Application Context:</p>
<pre class="programlisting"><span class="hl-tag">&lt;alias</span> <span class="hl-attribute">name</span>=<span class="hl-value">"conversionService"</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"integrationConversionService"</span><span class="hl-tag">/&gt;</span></pre>
<p>In this case the <span class="emphasis"><em>conversionService</em></span>'s Converters will be available for Spring Integration runtime conversion.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="async-polling" href="#async-polling"></a>8.1.7&nbsp;Asynchronous polling</h3></div></div></div>

<p>If you want the polling to be asynchronous, a Poller can optionally specify a <span class="emphasis"><em>task-executor</em></span> attribute pointing to an existing instance of any <code class="literal">TaskExecutor</code> bean (Spring 3.0 provides a convenient namespace configuration via the <code class="literal">task</code> namespace).
However, there are certain things you must understand when configuring a Poller with a TaskExecutor.&nbsp;</p>
<p>The problem is that there are two configurations in place.
The <span class="emphasis"><em>Poller</em></span> and the <span class="emphasis"><em>TaskExecutor</em></span>, and they both have to be in tune&nbsp;with each other otherwise you might end up creating an artificial memory leak.</p>
<p>Let&#8217;s look at the following configuration provided by one of the users on the
<a class="ulink" href="http://forum.spring.io/forum/spring-projects/integration/87155-spring-integration-poller-configuration" target="_top">Spring Integration Forum</a>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"publishChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:queue /&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span>

<span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"publishChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myService"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">receive-timeout</span>=<span class="hl-value">"5000"</span><span class="hl-attribute">&nbsp;task-executor</span>=<span class="hl-value">"taskExecutor"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"50"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"taskExecutor"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"20"</span><span class="hl-tag"> /&gt;</span></pre>
<p>The above configuration demonstrates one of those out of tune configurations.</p>
<p>By default, the task executor has an unbounded task queue.
The poller keeps scheduling new tasks even though all the threads are blocked waiting for either a new message to arrive, or the timeout to expire.
Given that there are 20 threads executing tasks with a 5 second timeout, they will be executed at a rate of 4 per second (5000/20 = 250ms).
But, new tasks are being scheduled at a rate of 20 per second, so the internal queue in the task executor will grow at a rate of 16 per second (while the process is idle), so we essentially have a memory leak.</p>
<p>One of the ways to handle this is to set the <code class="literal">queue-capacity</code> attribute of the Task Executor; and even 0 is a reasonable
value.
You can also manage it by specifying what to do with messages that can not be queued by setting the <code class="literal">rejection-policy</code> attribute of the Task Executor (e.g., DISCARD).
In other words, there are certain details you must understand with regard to configuring the TaskExecutor.
Please refer to <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html" target="_top">Task Execution and Scheduling</a> of the Spring reference manual for more detail on the subject.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-inner" href="#endpoint-inner"></a>8.1.8&nbsp;Endpoint Inner Beans</h3></div></div></div>

<p>Many endpoints are composite beans; this includes all consumers and all polled inbound channel adapters.
Consumers (polled or event- driven) delegate to a <code class="literal">MessageHandler</code>; polled adapters obtain messages by delegating to a <code class="literal">MessageSource</code>.
Often, it is useful to obtain a reference to the delegate bean, perhaps to change configuration at runtime, or for testing.
These beans can be obtained from the <code class="literal">ApplicationContext</code> with well-known names.
<code class="literal">MessageHandler</code> s are registered with the application context with a bean id <code class="literal">someConsumer.handler</code> (where <span class="emphasis"><em>consumer</em></span> is the endpoint&#8217;s <code class="literal">id</code> attribute).
<code class="literal">MessageSource</code> s are registered with a bean id <code class="literal">somePolledAdapter.source</code>, again where <span class="emphasis"><em>somePolledAdapter</em></span> is the id of the adapter.</p>
<p>The above only applies to the framework component itself.
If you use an inner bean definition such as this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleServiceActivator"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span>
            <span class="hl-attribute">output-channel</span> = <span class="hl-value">"outChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"foo"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.ExampleServiceActivator"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
<p>the bean is treated like any inner bean declared that way and is not registered with the application context.
If you wish to access this bean in some other manner, declare it at the top level with an <code class="literal">id</code> and use the <code class="literal">ref</code> attribute instead.
See the <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/beans.html#beans-inner-beans" target="_top">Spring Documentation</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-roles" href="#endpoint-roles"></a>8.2&nbsp;Endpoint Roles</h2></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, endpoints can be assigned to roles.
Roles allow endpoints to be started and stopped as a group; this is particularly useful when using leadership election
where a set of endpoints can be started or stopped when leadership is granted or revoked respectively.</p>
<p>You can assign endpoints to roles using XML, Java configuration, or programmatically:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ica"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"someChannel"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"'foo'"</span> <span class="hl-attribute">role</span>=<span class="hl-value">"cluster"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span></pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "sendAsyncChannel")</span></em>
<em><span class="hl-annotation" style="color: gray">@Role("cluster")</span></em>
<span class="hl-keyword">public</span> MessageHandler sendAsyncHandler() {
    <span class="hl-keyword">return</span> <span class="hl-comment">// some MessageHandler</span>
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Payload("#args[0].toLowerCase()")</span></em>
<em><span class="hl-annotation" style="color: gray">@Role("cluster")</span></em>
<span class="hl-keyword">public</span> String handle(String payload) {
    <span class="hl-keyword">return</span> payload.toUpperCase();
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span class="hl-keyword">private</span> SmartLifecycleRoleController roleController;

...

    <span class="hl-keyword">this</span>.roleController.addSmartLifeCycleToRole(<span class="hl-string">"cluster"</span>, someEndpoint);
...</pre>
<p>Each of these adds the endpoint to the role <code class="literal">cluster</code>.</p>
<p>Invoking <code class="literal">roleController.startLifecyclesInRole("cluster")</code> (and the corresponding <code class="literal">stop...</code> method) will start/stop
the endpoints.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Any object implementing <code class="literal">SmartLifecycle</code> can be programmatically added, not just endpoints.</p>
</td></tr></table></div>
<p>The <code class="literal">SmartLifecycleRoleController</code> implements <code class="literal">ApplicationListener&lt;AbstractLeaderEvent&gt;</code> and it will automatically
start/stop its configured <code class="literal">SmartLifecycle</code> objects when leadership is granted/revoked (when some bean publishes
<code class="literal">OnGrantedEvent</code> or <code class="literal">OnRevokedEvent</code> respectively).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When using leadership election to start/stop components, it is important to set the <code class="literal">auto-startup</code> XML attribute (<code class="literal">autoStartup</code> bean property) to <code class="literal">false</code> so the application context does not start the components during context intialization.</p>
</td></tr></table></div>
<p>Starting with _version 4.3.8, the <code class="literal">SmartLifecycleRoleController</code> provides several status methods:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> Collection&lt;String&gt; getRoles() <a name="CO12-1" href="#CO12-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> allEndpointsRunning(String role) <a name="CO12-2" href="#CO12-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> noEndpointsRunning(String role) <a name="CO12-3" href="#CO12-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>

<span class="hl-keyword">public</span> Map&lt;String, Boolean&gt; getEndpointsRunningStatus(String role) <a name="CO12-4" href="#CO12-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns a list of the roles being managed.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns true if all endpoints in the role are running.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns true if none of the endpoints in the role are running.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns a map of <code class="literal">component name : running status</code> - the component name is usually the bean name.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="leadership-event-handling" href="#leadership-event-handling"></a>8.3&nbsp;Leadership Event Handling</h2></div></div></div>

<p>Groups of endpoints can be started/stopped based on leadership being granted or revoked respectively.
This is useful in clustered scenarios where shared resources must only be consumed by a single instance.
An example of this is a file inbound channel adapter that is polling a shared directory.
(See <a class="xref" href="files.html#file-reading" title="14.2&nbsp;Reading Files">Section&nbsp;14.2, &#8220;Reading Files&#8221;</a>).</p>
<p>To participate in a leader election and be notified when elected leader or when leadership is revoked, an application creates a component in the application context called a "leader initiator". Normally a leader initiator is a <code class="literal">SmartLifecycle</code> so it starts up (optionally) automatically when the context starts, and then publishes notifications when leadership changes. By convention the user provides a <code class="literal">Candidate</code> that receives the callbacks and also can revoke the leadership through a <code class="literal">Context</code> object provided by the framework. User code can also listen for <code class="literal">AbstractLeaderEvents</code>, and respond accordingly, for instance using a <code class="literal">SmartLifecycleRoleController</code>.</p>
<p>There is a basic implementation of a leader initiator based on the <code class="literal">LockRegistry</code> abstraction. To use it you just need to create an instance as a bean, for example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> LockRegistryLeaderInitiator leaderInitiator(LockRegistry locks) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> LockRegistryLeaderInitiator(locks);
}</pre>
<p>If the lock registry is implemented correctly, there will only ever be at most one leader. If the lock registry also provides locks which throw exceptions (ideally <code class="literal">InterruptedException</code>) when they expire or are broken, then the duration of the leaderless periods can be as short as is allowed by the inherent latency in the lock implementation. By default there is a <code class="literal">busyWaitMillis</code> property that adds some additional latency to prevent CPU starvation in the (more usual) case that the locks are imperfect and you only know they expired by trying to obtain one again.</p>
<p>See <a class="xref" href="zookeeper.html#zk-leadership" title="37.4&nbsp;Zookeeper Leadership Event Handling">Section&nbsp;37.4, &#8220;Zookeeper Leadership Event Handling&#8221;</a> for more information about leadership election and events using Zookeeper.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gateway" href="#gateway"></a>8.4&nbsp;Messaging Gateways</h2></div></div></div>

<p>The primary purpose of a Gateway is to hide the messaging API provided by Spring Integration.
It allows your application&#8217;s business logic to be completely unaware of the Spring Integration API and using a generic Gateway, your code interacts instead with a simple interface, only.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-proxy" href="#gateway-proxy"></a>8.4.1&nbsp;Enter the GatewayProxyFactoryBean</h3></div></div></div>

<p>As mentioned above, it would be great to have no dependency on the Spring Integration API at all - including the gateway class.
For that reason, Spring Integration provides the <code class="literal">GatewayProxyFactoryBean</code> that generates a proxy for any interface and internally invokes the gateway methods shown below.
Using dependency injection you can then expose the interface to your business methods.</p>
<p>Here is an example of an interface that can be used to interact with Spring Integration:</p>
<pre class="programlisting"><span class="hl-keyword">package</span> org.cafeteria;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Cafe {

    <span class="hl-keyword">void</span> placeOrder(Order order);

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-namespace" href="#gateway-namespace"></a>8.4.2&nbsp;Gateway XML Namespace Support</h3></div></div></div>

<p>Namespace support is also provided which allows you to configure such an interface as a service as demonstrated by the following example.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cafeService"</span>
         <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.cafeteria.Cafe"</span>
         <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"requestChannel"</span>
         <span class="hl-attribute">default-reply-timeout</span>=<span class="hl-value">"10000"</span>
         <span class="hl-attribute">default-reply-channel</span>=<span class="hl-value">"replyChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>With this configuration defined, the "cafeService" can now be injected into other beans, and the code that invokes the methods on that proxied instance of the Cafe interface has no awareness of the Spring Integration API.
The general approach is similar to that of Spring Remoting (RMI, HttpInvoker, etc.).
See the "Samples" Appendix for an example that uses this "gateway" element (in the Cafe demo).</p>
<p>The defaults in the configuration above are applied to all methods on the gateway interface; if a reply timeout is not
specified, the calling thread will wait indefinitely for a reply.
See <a class="xref" href="messaging-endpoints-chapter.html#gateway-no-response" title="8.4.10&nbsp;Gateway behavior when no response arrives">Section&nbsp;8.4.10, &#8220;Gateway behavior when no response arrives&#8221;</a>.</p>
<p>The defaults can be overridden for individual methods; see <a class="xref" href="messaging-endpoints-chapter.html#gateway-configuration-annotations" title="8.4.4&nbsp;Gateway Configuration with Annotations and/or XML">Section&nbsp;8.4.4, &#8220;Gateway Configuration with Annotations and/or XML&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-default-reply-channel" href="#gateway-default-reply-channel"></a>8.4.3&nbsp;Setting the Default Reply Channel</h3></div></div></div>

<p>Typically you don&#8217;t have to specify the <code class="literal">default-reply-channel</code>, since a Gateway will auto-create a temporary, anonymous reply channel, where it will listen for the reply.
However, there are some cases which may prompt you to define a <code class="literal">default-reply-channel</code> (or <code class="literal">reply-channel</code> with adapter gateways such as HTTP, JMS, etc.).</p>
<p>For some background, we&#8217;ll quickly discuss some of the inner-workings of the Gateway.
A Gateway will create a temporary point-to-point reply channel which is anonymous and is added to the Message Headers with the name <code class="literal">replyChannel</code>.
When providing an explicit <code class="literal">default-reply-channel</code> (<code class="literal">reply-channel</code> with remote adapter gateways), you have the option to point to a publish-subscribe channel, which is so named because you can add more than one subscriber to it.
Internally Spring Integration will create a Bridge between the temporary <code class="literal">replyChannel</code> and the explicitly defined <code class="literal">default-reply-channel</code>.</p>
<p>So let&#8217;s say you want your reply to go not only to the gateway, but also to some other consumer.
In this case you would want two things: <span class="emphasis"><em>a) a named channel you can subscribe to and b) that channel is a publish-subscribe-channel.</em></span> The default strategy used by the gateway will not satisfy those needs, because the reply channel added to the header is anonymous and point-to-point.
This means that no other subscriber can get a handle to it and even if it could, the channel has point-to-point behavior such that only one subscriber would get the Message.
So by defining a <code class="literal">default-reply-channel</code> you can point to a channel of your choosing, which in this case would be a <code class="literal">publish-subscribe-channel</code>.
The Gateway would create a bridge from it to the temporary, anonymous reply channel that is stored in the header.</p>
<p>Another case where you might want to provide a reply channel explicitly is for monitoring or auditing via an interceptor (e.g., wiretap).
You need a named channel in order to configure a Channel Interceptor.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-configuration-annotations" href="#gateway-configuration-annotations"></a>8.4.4&nbsp;Gateway Configuration with Annotations and/or XML</h3></div></div></div>

<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Cafe {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel="orders")</span></em>
    <span class="hl-keyword">void</span> placeOrder(Order order);

}</pre>
<p>You may alternatively provide such content in <code class="literal">method</code> sub-elements if you prefer XML configuration (see the next paragraph).</p>
<p>It is also possible to pass values to be interpreted as Message headers on the Message that is created and sent to the
request channel by using the <code class="literal">@Header</code> annotation:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FileWriter {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel="filesOut")</span></em>
    <span class="hl-keyword">void</span> write(<span class="hl-keyword">byte</span>[] content, <em><span class="hl-annotation" style="color: gray">@Header(FileHeaders.FILENAME)</span></em> String filename);

}</pre>
<p>If you prefer the XML approach of configuring Gateway methods, you can provide <span class="emphasis"><em>method</em></span> sub-elements to the gateway configuration.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myGateway"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.foo.bar.TestGateway"</span>
      <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"inputC"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:default-header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"calledMethod"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"#gatewayMethod.name"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputA"</span> <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"2"</span> <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"200"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoUpperCase"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputB"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoViaDefault"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
<p>You can also provide individual headers per method invocation via XML.
This could be very useful if the headers you want to set are static in nature and you don&#8217;t want to embed them in the gateway&#8217;s method signature via <code class="literal">@Header</code> annotations.
For example, in the Loan Broker example we want to influence how aggregation of the Loan quotes will be done based on what type of request was initiated (single quote or all quotes).
Determining the type of the request by evaluating what gateway method was invoked, although possible, would violate the separation of concerns paradigm (the method is a java artifact), &nbsp;but expressing your intention (meta information) via Message headers is natural in a Messaging architecture.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"loanBrokerGateway"</span>
         <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.springframework.integration.loanbroker.LoanBrokerGateway"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"getLoanQuote"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"loanBrokerPreProcessingChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"RESPONSE_TYPE"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"BEST"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"getAllLoanQuotes"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"loanBrokerPreProcessingChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"RESPONSE_TYPE"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"ALL"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
<p>In the above case you can clearly see how a different value will be set for the <span class="emphasis"><em>RESPONSE_TYPE</em></span> header based on the gateway&#8217;s method.</p>
<p><span class="strong"><strong>Expressions and "Global" Headers</strong></span></p>
<p>The <code class="literal">&lt;header/&gt;</code> element supports <code class="literal">expression</code> as an alternative to <code class="literal">value</code>.
The SpEL expression is evaluated to determine the value of the header.
There is no <code class="literal">#root</code> object but the following variables are available:</p>
<p>#args - an <code class="literal">Object[]</code> containing the method arguments</p>
<p>#gatewayMethod - the <code class="literal">java.reflect.Method</code> object representing the method in the <code class="literal">service-interface</code> that was invoked.
A header containing this variable can be used later in the flow, for example, for routing.
For example, if you wish to route on the simple method name, you might add a header, with expression <code class="literal">#gatewayMethod.name</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">java.reflect.Method</code> is not serializable; a header with expression <code class="literal">#gatewayMethod</code> will be lost if you later serialize the message.
So, you may wish to use <code class="literal">#gatewayMethod.name</code> or <code class="literal">#gatewayMethod.toString()</code> in those cases; the <code class="literal">toString()</code> method provides a String representation of the method, including parameter and return types.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Prior to 3.0, the <code class="literal">#method</code> variable was available, representing the method name only.
This is still available, but deprecated; use <code class="literal">#gatewayMethod.name</code> instead.</p>
</td></tr></table></div>
<p>Since 3.0, <code class="literal">&lt;default-header/&gt;</code> s can be defined to add headers to all messages produced by the gateway, regardless of the method invoked.
Specific headers defined for a method take precedence over default headers.
Specific headers defined for a method here will override any <code class="literal">@Header</code> annotations in the service interface.
However, default headers will NOT override any <code class="literal">@Header</code> annotations in the service interface.</p>
<p>The gateway now also supports a <code class="literal">default-payload-expression</code> which will be applied for all methods (unless overridden).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-mapping" href="#gateway-mapping"></a>8.4.5&nbsp;Mapping Method Arguments to a Message</h3></div></div></div>

<p>Using the configuration techniques in the previous section allows control of how method arguments are mapped to message elements (payload and header(s)).
When no explicit configuration is used, certain conventions are used to perform the mapping.
In some cases, these conventions cannot determine which argument is the payload and which should be mapped to headers.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> String send1(Object foo, Map bar);

<span class="hl-keyword">public</span> String send2(Map foo, Map bar);</pre>
<p>In the first case, the convention will map the first argument to the payload (as long as it is not a <code class="literal">Map</code>) and the contents of the second become headers.</p>
<p>In the second case (or the first when the argument for parameter <code class="literal">foo</code> is a <code class="literal">Map</code>), the framework cannot determine which argument should be the payload; mapping will fail.
This can generally be resolved using a <code class="literal">payload-expression</code>, a <code class="literal">@Payload</code> annotation and/or a <code class="literal">@Headers</code> annotation.</p>
<p>Alternatively, and whenever the conventions break down, you can take the entire responsibility for mapping the method calls to messages.
To do this, implement an`MethodArgsMessageMapper` and provide it to the <code class="literal">&lt;gateway/&gt;</code> using the <code class="literal">mapper</code> attribute.
The mapper maps a <code class="literal">MethodArgsHolder</code>, which is a simple class wrapping the <code class="literal">java.reflect.Method</code> instance and an <code class="literal">Object[]</code> containing the arguments.
When providing a custom mapper, the <code class="literal">default-payload-expression</code> attribute and <code class="literal">&lt;default-header/&gt;</code> elements are not allowed on the gateway; similarly, the <code class="literal">payload-expression</code> attribute and <code class="literal">&lt;header/&gt;</code> elements are not allowed on any <code class="literal">&lt;method/&gt;</code> elements.</p>
<p><span class="strong"><strong>Mapping Method Arguments</strong></span></p>
<p>Here are examples showing how method arguments can be mapped to the message (and some examples of invalid configuration):</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

    <span class="hl-keyword">void</span> payloadAndHeaderMapWithoutAnnotations(String s, Map&lt;String, Object&gt; map);

    <span class="hl-keyword">void</span> payloadAndHeaderMapWithAnnotations(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s, <em><span class="hl-annotation" style="color: gray">@Headers</span></em> Map&lt;String, Object&gt; map);

    <span class="hl-keyword">void</span> headerValuesAndPayloadWithAnnotations(<em><span class="hl-annotation" style="color: gray">@Header("k1")</span></em> String x, <em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s, <em><span class="hl-annotation" style="color: gray">@Header("k2")</span></em> String y);

    <span class="hl-keyword">void</span> mapOnly(Map&lt;String, Object&gt; map); <span class="hl-comment">// the payload is the map and no custom headers are added</span>

    <span class="hl-keyword">void</span> twoMapsAndOneAnnotatedWithPayload(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> Map&lt;String, Object&gt; payload, Map&lt;String, Object&gt; headers);

    <em><span class="hl-annotation" style="color: gray">@Payload("#args[0] + #args[1] + '!'")</span></em>
    <span class="hl-keyword">void</span> payloadAnnotationAtMethodLevel(String a, String b);

    <em><span class="hl-annotation" style="color: gray">@Payload("@someBean.exclaim(#args[0])")</span></em>
    <span class="hl-keyword">void</span> payloadAnnotationAtMethodLevelUsingBeanResolver(String s);

    <span class="hl-keyword">void</span> payloadAnnotationWithExpression(<em><span class="hl-annotation" style="color: gray">@Payload("toUpperCase()")</span></em> String s);

    <span class="hl-keyword">void</span> payloadAnnotationWithExpressionUsingBeanResolver(<em><span class="hl-annotation" style="color: gray">@Payload("@someBean.sum(#this)")</span></em> String s); <span class="hl-comment">//  </span><a name="CO13-1" href="#CO13-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> twoMapsWithoutAnnotations(Map&lt;String, Object&gt; m1, Map&lt;String, Object&gt; m2);

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> twoPayloads(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s1, <em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s2);

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> payloadAndHeaderAnnotationsOnSameParameter(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> <em><span class="hl-annotation" style="color: gray">@Header("x")</span></em> String s);

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> payloadAndHeadersAnnotationsOnSameParameter(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> <em><span class="hl-annotation" style="color: gray">@Headers</span></em> Map&lt;String, Object&gt; map);

}</pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO13-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Note that in this example, the SpEL variable <code class="literal">#this</code> refers to the argument - in this case, the value of <code class="literal">'s'</code>.</p>
</td></tr></table></div>
<p>The XML equivalent looks a little different, since there is no <code class="literal">#this</code> context for the method argument, but expressions can refer to method arguments using the <code class="literal">#args</code> variable:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myGateway"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.foo.bar.MyGateway"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send1"</span> <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"#args[0] + 'bar'"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send2"</span> <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"@someBean.sum(#args[0])"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send3"</span> <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"#method"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send4"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"#args[2].toUpperCase()"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="messaging-gateway-annotation" href="#messaging-gateway-annotation"></a>8.4.6&nbsp;@MessagingGateway Annotation</h3></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.0</em></span>, gateway service interfaces can be marked with a <code class="literal">@MessagingGateway</code> annotation instead of requiring the definition of a <code class="literal">&lt;gateway /&gt;</code> xml element for configuration.
The following compares the two approaches for configuring the same gateway:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myGateway"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.foo.bar.TestGateway"</span>
      <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"inputC"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:default-header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"calledMethod"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"#gatewayMethod.name"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputA"</span> <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"2"</span> <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"200"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoUpperCase"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputB"</span><span class="hl-tag">&gt;</span>
  		<span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"bar"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoViaDefault"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway(name = "myGateway", defaultRequestChannel = "inputC",
		  defaultHeaders = @GatewayHeader(name = "calledMethod",
		                           expression="#gatewayMethod.name"))</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TestGateway {

   <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "inputA", replyTimeout = 2, requestTimeout = 200)</span></em>
   String echo(String payload);

   <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "inputB", headers = @GatewayHeader(name = "foo", value="bar"))</span></em>
   String echoUpperCase(String payload);

   String echoViaDefault(String payload);

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>As with the XML version, Spring Integration creates the <code class="literal">proxy</code> implementation with its messaging infrastructure, when discovering these annotations during a component scan.
To perform this scan and register the <code class="literal">BeanDefinition</code> in the application context, add the <code class="literal">@IntegrationComponentScan</code> annotation to a <code class="literal">@Configuration</code> class.
The standard <code class="literal">@ComponentScan</code> infrastructure doesn&#8217;t deal with interfaces, therefore the custom <code class="literal">@IntegrationComponentScan</code> logic has been introduced
to determine <code class="literal">@MessagingGateway</code> annotation on the interfaces and register <code class="literal">GatewayProxyFactoryBean</code> s for them.
See also <a class="xref" href="configuration.html#annotations" title="F.6&nbsp;Annotation Support">Section&nbsp;F.6, &#8220;Annotation Support&#8221;</a></p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you have no XML configuration, the <code class="literal">@EnableIntegration</code> annotation is required on at least one <code class="literal">@Configuration</code>
class.
See <a class="xref" href="overview.html#configuration-enable-integration" title="3.5&nbsp;Configuration and @EnableIntegration">Section&nbsp;3.5, &#8220;Configuration and @EnableIntegration&#8221;</a> for more information.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-calling-no-argument-methods" href="#gateway-calling-no-argument-methods"></a>8.4.7&nbsp;Invoking No-Argument Methods</h3></div></div></div>

<p>When invoking methods on a Gateway interface that do not have any arguments, the default behavior is to <span class="emphasis"><em>receive</em></span> a <code class="literal">Message</code> from a <code class="literal">PollableChannel</code>.</p>
<p>At times however, you may want to trigger no-argument methods so that you can in fact interact with other components downstream that do not require user-provided parameters, e.g.
triggering no-argument SQL calls or Stored Procedures.</p>
<p>In order to achieve <span class="emphasis"><em>send-and-receive</em></span> semantics, you must provide a payload.
In order to generate a payload, method parameters on the interface are not necessary.
You can either use the <code class="literal">@Payload</code> annotation or the <code class="literal">payload-expression</code> attribute in XML on the <code class="literal">method</code> sub-element.
Below please find a few examples of what the payloads could be:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
a literal string
</li><li class="listitem">
#gatewayMethod.name
</li><li class="listitem">
new java.util.Date()
</li><li class="listitem">
@someBean.someMethod()'s return value
</li></ul></div>
<p>Here is an example using the <code class="literal">@Payload</code> annotation:</p>
<pre class="programlisting">public interface Cafe {

    @Payload("new java.util.Date()")
    List<span class="hl-tag">&lt;Order&gt;</span> retrieveOpenOrders();

}</pre>
<p>If a method has no argument and no return value, but does contain a payload expression, it will be treated as a <span class="emphasis"><em>send-only</em></span> operation.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-error-handling" href="#gateway-error-handling"></a>8.4.8&nbsp;Error Handling</h3></div></div></div>

<p>Of course, the Gateway invocation might result in errors.
By default any error that has occurred downstream will be re-thrown as a <code class="literal">MessagingException</code> (<code class="literal">RuntimeException</code>) upon the Gateway&#8217;s method invocation.
However there are times when you may want to simply log the error rather than propagating it, or you may want to treat an Exception as a valid reply, by mapping it to a Message that will conform to some "error message" contract that the caller understands.
To accomplish this, the Gateway provides support for a Message Channel dedicated to the errors via the <span class="emphasis"><em>error-channel</em></span> attribute.
In the example below, you can see that a <span class="emphasis"><em>transformer</em></span> is used to create a reply Message from the Exception.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sampleGateway"</span>
    <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"gatewayChannel"</span>
    <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.bar.SimpleGateway"</span>
    <span class="hl-attribute">error-channel</span>=<span class="hl-value">"exceptionTransformationChannel"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exceptionTransformationChannel"</span>
        <span class="hl-attribute">ref</span>=<span class="hl-value">"exceptionTransformer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"createErrorResponse"</span><span class="hl-tag">/&gt;</span></pre>
<p>The <span class="emphasis"><em>exceptionTransformer</em></span> could be a simple POJO that knows how to create the expected error response objects.
That would then be the payload that is sent back to the caller.
Obviously, you could do many more elaborate things in such an "error flow" if necessary.
It might involve routers (including Spring Integration&#8217;s <code class="literal">ErrorMessageExceptionTypeRouter</code>), filters, and so on.
Most of the time, a simple <span class="emphasis"><em>transformer</em></span> should be sufficient, however.</p>
<p>Alternatively, you might want to only log the Exception (or send it somewhere asynchronously).
If you provide a one-way flow, then nothing would be sent back to the caller.
In the case that you want to completely suppress Exceptions, you can provide a reference to the global "nullChannel" (essentially a /dev/null approach).
Finally, as mentioned above, if no "error-channel" is defined at all, then the Exceptions will propagate as usual.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Exposing the messaging system via simple POJI Gateways obviously provides benefits, but "hiding" the reality of the underlying messaging system does come at a price so there are certain things you should consider.
We want our Java method to return as quickly as possible and not hang for an indefinite amount of time while the caller is waiting on it to return (void, return value, or a thrown Exception).
When regular methods are used as a proxies in front of the Messaging system, we have to take into account the potentially asynchronous nature of the underlying messaging.
This means that there might be a chance that a Message that was initiated by a Gateway could be dropped by a Filter, thus never reaching a component that is responsible for producing a reply.
Some Service Activator method might result in an Exception, thus providing no reply (as we don&#8217;t generate Null messages).
So as you can see there are multiple scenarios where a reply message might not be coming.
That is perfectly natural in messaging systems.
However think about the implication on the gateway method.&nbsp;The Gateway&#8217;s method input arguments &nbsp;were incorporated into a Message and sent downstream.
The reply Message would be converted to a return value of the Gateway&#8217;s method.
So you might want to ensure that for each Gateway call there will always be a reply Message.
Otherwise, your Gateway method might never return and will hang indefinitely.
One of the ways of handling this situation is via an Asynchronous Gateway (explained later in this section).
Another way of handling it is to explicitly set the reply-timeout attribute.
That way, the gateway will not hang any longer than the time specified by the reply-timeout and will return <span class="emphasis"><em>null</em></span> if that timeout does elapse.
Finally, you might want to consider setting downstream flags such as <span class="emphasis"><em>requires-reply</em></span> on a service-activator or <span class="emphasis"><em>throw-exceptions-on-rejection</em></span> on a filter.&nbsp;These options will be discussed in more detail in the final section of this chapter.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If the downstream flow returns an <code class="literal">ErrorMessage</code>, its <code class="literal">payload</code> (a <code class="literal">Throwable</code>) is treated as a regular downstream
error: if there is an <code class="literal">error-channel</code> configured, it will be sent there, to the error flow; otherwise the payload is
thrown to the caller of gateway.
Similarly, if the error flow on the <code class="literal">error-channel</code> returns an <code class="literal">ErrorMessage</code> its payload is thrown to the caller.
The same applies to any message with a <code class="literal">Throwable</code> payload.
This can be useful in async situations when when there is a need propagate an <code class="literal">Exception</code> directly to the caller.
To achieve this you can either return an <code class="literal">Exception</code> as the <code class="literal">reply</code> from some service, or simply throw it.
Generally, even with an async flow, the framework will take care of propagating an exception thrown by the
downstream flow back to the gateway.
The <a class="ulink" href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/tcp-client-server-multiplex" target="_top">TCP Client-Server Multiplex</a>
sample demonstrates both techniques to return the exception to the caller.
It emulates a Socket IO error to the waiting thread using an <code class="literal">aggregator</code> with <code class="literal">group-timeout</code> (see <a class="xref" href="messaging-routing-chapter.html#agg-and-group-to" title="Aggregator and Group Timeout">the section called &#8220;Aggregator and Group Timeout&#8221;</a>)
and <code class="literal">MessagingTimeoutException</code> reply on the discard flow.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="async-gateway" href="#async-gateway"></a>8.4.9&nbsp;Asynchronous Gateway</h3></div></div></div>

<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_3" href="#_introduction_3"></a>Introduction</h4></div></div></div>

<p>As a pattern, the Messaging Gateway is a very nice way to hide messaging-specific code while still exposing the full capabilities of the messaging system.
As you&#8217;ve seen, the <code class="literal">GatewayProxyFactoryBean</code> provides a convenient way to expose a Proxy over a service-interface thus giving you POJO-based access to a messaging system (based on objects in your own domain, or primitives/Strings, etc).
&nbsp;But when a gateway is exposed via simple POJO methods which return values it does imply that for each Request message (generated when the method is invoked) there must be a Reply message (generated when the method has returned).
Since Messaging systems naturally are asynchronous you may not always be able to guarantee the contract where <span class="emphasis"><em>"for each request there will always be be a reply"</em></span>.&nbsp; With Spring Integration 2.0 we introduced support for an <span class="emphasis"><em>Asynchronous Gateway</em></span> which is a convenient way to initiate flows where you may not know if a reply is expected or how long will it take for replies to arrive.</p>
<p>A natural way to handle these types of scenarios in Java would be relying upon <span class="emphasis"><em>java.util.concurrent.Future</em></span> instances, and that is exactly what Spring Integration uses to support an <span class="emphasis"><em>Asynchronous Gateway</em></span>.</p>
<p>From the XML configuration, there is nothing different and you still define <span class="emphasis"><em>Asynchronous Gateway</em></span> the same way as a regular Gateway.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mathService"</span><span class="hl-attribute">&nbsp;</span>
     <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.springframework.integration.sample.gateway.futures.MathServiceGateway"</span>
     <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"requestChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>However the Gateway Interface (service-interface) is a little different:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MathServiceGateway {

  Future&lt;Integer&gt; multiplyByTwo(<span class="hl-keyword">int</span> i);

}</pre>
<p>As you can see from the example above, the return type for the gateway method is a <code class="literal">Future</code>.
When <code class="literal">GatewayProxyFactoryBean</code> sees that the return type of the gateway method is a <code class="literal">Future</code>, it immediately switches to the async mode by utilizing an <code class="literal">AsyncTaskExecutor</code>.
That is all.
The call to such a method always returns immediately with a <code class="literal">Future</code> instance.
Then, you can interact with the <code class="literal">Future</code> at your own pace to get the result, cancel, etc.
And, as with any other use of Future instances, calling get() may reveal a timeout, an execution exception, and so on.</p>
<pre class="programlisting">MathServiceGateway mathService = ac.getBean(<span class="hl-string">"mathService"</span>, MathServiceGateway.<span class="hl-keyword">class</span>);
Future&lt;Integer&gt; result = mathService.multiplyByTwo(number);
<span class="hl-comment">// do something else here since the reply might take a moment</span>
<span class="hl-keyword">int</span> finalResult =&nbsp; result.get(<span class="hl-number">1000</span>, TimeUnit.SECONDS);</pre>
<p>For a more detailed example, please refer to the <a class="ulink" href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/async-gateway" target="_top"><span class="emphasis"><em>async-gateway</em></span></a> sample distributed within the Spring Integration samples.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_listenablefuture" href="#_listenablefuture"></a>ListenableFuture</h4></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.1</em></span>, async gateway methods can also return <code class="literal">ListenableFuture</code> (introduced in Spring Framework 4.0).
These return types allow you to provide a callback which is invoked when the result is available (or an exception occurs).
When the gateway detects this return type, and the task executor (see below) is an <code class="literal">AsyncListenableTaskExecutor</code>, the executor&#8217;s <code class="literal">submitListenable()</code> method is invoked.</p>
<pre class="programlisting">ListenableFuture&lt;String&gt; result = <span class="hl-keyword">this</span>.asyncGateway.async(<span class="hl-string">"foo"</span>);
result.addCallback(<span class="hl-keyword">new</span> ListenableFutureCallback&lt;String&gt;() {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onSuccess(String result) {
        ...
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onFailure(Throwable t) {
        ...
    }
});</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_asynctaskexecutor" href="#_asynctaskexecutor"></a>AsyncTaskExecutor</h4></div></div></div>

<p>By default, the <code class="literal">GatewayProxyFactoryBean</code> uses <code class="literal">org.springframework.core.task.SimpleAsyncTaskExecutor</code> when submitting internal <code class="literal">AsyncInvocationTask</code> instances for any gateway method whose return type is <code class="literal">Future</code>.
However the <code class="literal">async-executor</code> attribute in the <code class="literal">&lt;gateway/&gt;</code> element&#8217;s configuration allows you to provide a reference to any implementation of <code class="literal">java.util.concurrent.Executor</code> available within the Spring application context.</p>
<p>The (default) <code class="literal">SimpleAsyncTaskExecutor</code> supports both <code class="literal">Future</code> and <code class="literal">ListenableFuture</code> return types, returning <code class="literal">FutureTask</code> or <code class="literal">ListenableFutureTask</code> respectively. Also see <a class="xref" href="messaging-endpoints-chapter.html#gw-completable-future" title="CompletableFuture">the section called &#8220;CompletableFuture&#8221;</a> below.
Even though there is a default executor, it is often useful to provide an external one so that you can identify its threads in logs (when using XML, the thread name is based on the executor&#8217;s bean name):</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> AsyncTaskExecutor exec() {
    SimpleAsyncTaskExecutor simpleAsyncTaskExecutor = <span class="hl-keyword">new</span> SimpleAsyncTaskExecutor();
    simpleAsyncTaskExecutor.setThreadNamePrefix(<span class="hl-string">"exec-"</span>);
    <span class="hl-keyword">return</span> simpleAsyncTaskExecutor;
}

<em><span class="hl-annotation" style="color: gray">@MessagingGateway(asyncExecutor = "exec")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ExecGateway {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "gatewayChannel")</span></em>
    Future&lt;?&gt; doAsync(String foo);

}</pre>
<p>If you wish to return a different <code class="literal">Future</code> implementation, you can provide a custom executor, or disable the executor altogether and return the <code class="literal">Future</code> in the reply message payload from the downstream flow.
To disable the executor, simply set it to <code class="literal">null</code> in the <code class="literal">GatewayProxyFactoryBean</code> (<code class="literal">setAsyncTaskExecutor(null)</code>).
When configuring the gateway with XML, use <code class="literal">async-executor=""</code>; when configuring using the <code class="literal">@MessagingGateway</code> annotation, use:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway(asyncExecutor = AnnotationConstants.NULL)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> NoExecGateway {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "gatewayChannel")</span></em>
    Future&lt;?&gt; doAsync(String foo);

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>If the return type is a specific concrete <code class="literal">Future</code> implementation or some other subinterface that is not supported by the configured executor, the flow will run on the caller&#8217;s thread and the flow must return the required type in the reply message payload.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gw-completable-future" href="#gw-completable-future"></a>CompletableFuture</h4></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, gateway methods can now return <code class="literal">CompletableFuture&lt;?&gt;</code>.
There are several modes of operation when returning this type:</p>
<p>When an async executor is provided <span class="strong"><strong>and</strong></span> the return type is exactly <code class="literal">CompletableFuture</code> (not a subclass), the framework
will run the task on the executor and immediately return a <code class="literal">CompletableFuture</code> to the caller.
<code class="literal">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code> is used to create the future.</p>
<p>When the async executor is explicitly set to <code class="literal">null</code> and the return type is <code class="literal">CompletableFuture</code> <span class="strong"><strong>or</strong></span> the return type
is a subclass of <code class="literal">CompletableFuture</code>, the flow is invoked on the caller&#8217;s thread.
In this scenario, it is expected that the downstream flow will return a <code class="literal">CompletableFuture</code> of the appropriate type.</p>
<p><span class="strong"><strong>Usage Scenarios</strong></span></p>
<pre class="programlisting">CompletableFuture&lt;Invoice&gt; order(Order order);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.Service"</span> <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"orders"</span><span class="hl-tag"> /&gt;</span></pre>
<p>In this scenario, the caller thread returns immediately with a <code class="literal">CompletableFuture&lt;Invoice&gt;</code> which will be completed
when the downstream flow replies to the gateway (with an <code class="literal">Invoice</code> object).</p>
<pre class="programlisting">CompletableFuture&lt;Invoice&gt; order(Order order);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.Service"</span> <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"orders"</span>
    <span class="hl-attribute">async-executor</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span></pre>
<p>In this scenario, the caller thread will return with a CompletableFuture&lt;Invoice&gt; when the downstream flow provides
it as the payload of the reply to the gateway.
Some other process must complete the future when the invoice is ready.</p>
<pre class="programlisting">MyCompletableFuture&lt;Invoice&gt; order(Order order);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.Service"</span> <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"orders"</span><span class="hl-tag"> /&gt;</span></pre>
<p>In this scenario, the caller thread will return with a CompletableFuture&lt;Invoice&gt; when the downstream flow provides
it as the payload of the reply to the gateway.
Some other process must complete the future when the invoice is ready.
If <code class="literal">DEBUG</code> logging is enabled, a log is emitted indicating that the async executor cannot be used for this scenario.</p>
<p><code class="literal">CompletableFuture</code> s can be used to perform additional manipulation on the reply, such as:</p>
<pre class="programlisting">CompletableFuture&lt;String&gt; process(String data);

...

CompletableFuture result = process(<span class="hl-string">"foo"</span>)
    .thenApply(t -&gt; t.toUpperCase());

...

String out = result.get(<span class="hl-number">10</span>, TimeUnit.SECONDS);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_reactor_promise" href="#_reactor_promise"></a>Reactor Promise</h4></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.1</em></span>, the <code class="literal">GatewayProxyFactoryBean</code> allows the use of a <code class="literal">Reactor</code> with gateway interface methods, utilizing a <a class="ulink" href="https://github.com/reactor/reactor/wiki/Promises" target="_top"><code class="literal">Promise&lt;?&gt;</code></a> return type.
The internal <code class="literal">AsyncInvocationTask</code> is wrapped in a <code class="literal">reactor.function.Supplier</code>, using a default <code class="literal">RingBufferDispatcher</code> for the <code class="literal">Promise</code> consumption.
Only methods with the <code class="literal">Promise&lt;?&gt;</code> return type are run on the reactor&#8217;s dispatcher.</p>
<p>A <code class="literal">Promise</code> can be used to retrieve the result later (similar to a <code class="literal">Future&lt;?&gt;</code>) or you can consume from it with the dispatcher invoking your <code class="literal">Consumer</code> when the result is returned to the gateway.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">Promise</code> isn&#8217;t <span class="emphasis"><em>flushed</em></span> immediately by the framework.
Hence the underlying message flow won&#8217;t be started before the gateway method returns (as it is with <code class="literal">Future&lt;?&gt;</code> <code class="literal">Executor</code> task).
The flow will be started when the <code class="literal">Promise</code> is <span class="emphasis"><em>flushed</em></span> or via <code class="literal">Promise.await()</code>.
Alternatively, the <code class="literal">Promise</code> (being a <code class="literal">Composable</code>) might be a part of Reactor <code class="literal">Stream&lt;?&gt;</code>, when the <code class="literal">flush()</code> is related to the entire <code class="literal">Stream</code>.
For example:</p>
</td></tr></table></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">interface</span> TestGateway {

	<em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "promiseChannel")</span></em>
	Promise&lt;Integer&gt; multiply(Integer value);

	}

	    ...

	<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "promiseChannel")</span></em>
	<span class="hl-keyword">public</span> Integer multiply(Integer value) {
			<span class="hl-keyword">return</span> value * <span class="hl-number">2</span>;
	}

		...

	Streams.defer(Arrays.asList(<span class="hl-string">"1"</span>, <span class="hl-string">"2"</span>, <span class="hl-string">"3"</span>, <span class="hl-string">"4"</span>, <span class="hl-string">"5"</span>))
			.get()
			.map(Integer::parseInt)
			.mapMany(integer -&gt; testGateway.multiply(integer))
			.collect()
			.consume(integers -&gt; ...)
			.flush();</pre>
<p>Another example is a simple callback scenario:</p>
<pre class="programlisting">Promise&lt;Invoice&gt; promise = service.process(myOrder);

promise.consume(<span class="hl-keyword">new</span> Consumer&lt;Invoice&gt;() {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> accept(Invoice invoice) {
		handleInvoice(invoice);
	}
})
.flush();</pre>
<p>The calling thread continues, with <code class="literal">handleInvoice()</code> being called when the flow completes.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-no-response" href="#gateway-no-response"></a>8.4.10&nbsp;Gateway behavior when no response arrives</h3></div></div></div>

<p>As it was explained earlier, the Gateway provides a convenient way of interacting with a Messaging system via POJO method invocations, but realizing that a typical method invocation, which is generally expected to always return (even with an Exception), might not always map one-to-one to message exchanges (e.g., a reply message might not arrive - which is equivalent to a method not returning).
It is important to go over several scenarios especially in the Sync Gateway case and understand the default behavior of the Gateway and how to deal with these scenarios to make the Sync Gateway behavior more predictable regardless of the outcome of the message flow that was initialed from such Gateway.</p>
<p>There are certain attributes that could be configured to make Sync Gateway behavior more predictable, but some of them might not always work as you might have expected.
One of them is <span class="emphasis"><em>reply-timeout</em></span> (at the method level or <span class="emphasis"><em>default-reply-timeout</em></span> at the gateway level).
So, lets look at the <span class="emphasis"><em>reply-timeout</em></span> attribute and see how it can/can&#8217;t influence the behavior of the Sync Gateway in various scenarios.
We will look at single-threaded scenario (all components downstream are connected via Direct Channel) and multi-threaded scenarios (e.g.,&nbsp;somewhere downstream you may have Pollable or Executor Channel which breaks single-thread boundary)</p>
<p><span class="emphasis"><em>Long running process downstream</em></span></p>
<p><span class="emphasis"><em>Sync Gateway - single-threaded</em></span>.
If a component downstream is still running (e.g., infinite loop or a very slow service), then setting a <span class="emphasis"><em>reply-timeout</em></span> has no effect and the Gateway method call will not return until such downstream service exits (via return or exception).
<span class="emphasis"><em>Sync&nbsp;Gateway - multi-threaded</em></span>.
If a component downstream is still running (e.g., infinite loop or a very slow service), in a multi-threaded message flow setting the <span class="emphasis"><em>reply-timeout</em></span> will have an effect by allowing gateway method invocation to return once the timeout has been reached, since the <code class="literal">GatewayProxyFactoryBean</code> &nbsp;will simply poll on the reply channel waiting for a message until the timeout expires.
However it could result in a <span class="emphasis"><em>null</em></span> return from the Gateway method if the timeout has been reached before the actual reply was produced.&nbsp;It is also important to understand that the reply message (if produced) will be sent to a reply channel after the Gateway method invocation might have returned, so you must be aware of that and design your flow with this in mind.</p>
<p><span class="emphasis"><em>Downstream component returns 'null'</em></span></p>
<p><span class="emphasis"><em>Sync Gateway - single-threaded</em></span>.
If a component downstream returns <span class="emphasis"><em>null</em></span> and no <span class="emphasis"><em>reply-timeout</em></span> has been configured, the Gateway method call will hang indefinitely unless: a) a <span class="emphasis"><em>reply-timeout</em></span> has been configured or b) the <span class="emphasis"><em>requires-reply</em></span> attribute has been set on the downstream component (e.g., service-activator) that might return <span class="emphasis"><em>null</em></span>.
In this case, an Exception would be thrown and propagated to the Gateway.<span class="emphasis"><em>Sync Gateway - multi-threaded</em></span>.
Behavior is the same as above.</p>
<p><span class="emphasis"><em>Downstream component return signature is <span class="emphasis"><em>void</em></span> while Gateway method signature is non-void</em></span></p>
<p><span class="emphasis"><em>Sync Gateway - single-threaded</em></span>.
If a component downstream returns <span class="emphasis"><em>void</em></span> and no <span class="emphasis"><em>reply-timeout</em></span> has been configured, the Gateway method call will hang indefinitely unless a <span class="emphasis"><em>reply-timeout</em></span> has been configured&nbsp; <span class="emphasis"><em>Sync Gateway - multi-threaded</em></span> Behavior is the same as above.</p>
<p><span class="emphasis"><em>Downstream component results in Runtime Exception (regardless of the method signature)</em></span></p>
<p><span class="emphasis"><em>Sync Gateway - single-threaded</em></span>.
If a component downstream throws a Runtime Exception, such exception will be propagated via an Error Message back to the gateway and re-thrown.
<span class="emphasis"><em>Sync Gateway - multi-threaded</em></span> Behavior is the same as above.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>It is also important to understand that by default <span class="emphasis"><em>reply-timeout</em></span> is unbounded* which means that if not explicitly set there are several scenarios (described above) where your Gateway method invocation might hang indefinitely.
So, make sure you analyze your flow and if there is even a remote possibility of one of these scenarios to occur, set the <span class="emphasis"><em>reply-timeout</em></span> attribute to a <span class="emphasis"><em>safe</em></span> value or, even better, set the <span class="emphasis"><em>requires-reply</em></span> attribute of the downstream component to <span class="emphasis"><em>true</em></span> to ensure a timely response as produced by the throwing of an Exception as soon as that downstream component does return null internally.
But also, realize that there are some scenarios (see the very first one) where <span class="emphasis"><em>reply-timeout</em></span> will not help.
That means it is also important to analyze your message flow and decide when to use a Sync Gateway vs an Async Gateway.
As you&#8217;ve seen the latter case is simply a matter of defining Gateway methods that return Future instances.
Then, you are guaranteed to receive that return value, and you will have more granular control over the results of the invocation.Also, when dealing with a Router you should remember that setting the <span class="emphasis"><em>resolution-required</em></span> attribute to <span class="emphasis"><em>true</em></span> will result in an Exception thrown by the router if it can not resolve a particular channel.
Likewise, when dealing with a Filter, you can set the <span class="emphasis"><em>throw-exception-on-rejection</em></span> attribute.
In both of these cases, the resulting flow will behave like that containing a service-activator with the <span class="emphasis"><em>requires-reply</em></span> attribute.
In other words, it will help to ensure a timely response from the Gateway method invocation.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>* <span class="emphasis"><em>reply-timeout</em></span> is unbounded for <span class="emphasis"><em>&lt;gateway/&gt;</em></span> elements (created by the GatewayProxyFactoryBean).
Inbound gateways for external integration (ws, http, etc.) share many characteristics and attributes with these gateways.
However, for those inbound gateways, the default <span class="emphasis"><em>reply-timeout</em></span> is 1000 milliseconds (1 second).
If a downstream async handoff is made to another thread, you may need to increase this attribute to allow enough time for the flow to complete before the gateway times out.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>It is important to understand that the timer starts when the thread returns to the gateway, i.e. when the
flow completes or a message is handed off to another thread.
At that time, the calling thread starts waiting for the reply.
If the flow was completely synchronous, the reply will be immediately available; for asynchronous flows, the thread
will wait for up to this time.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-activator" href="#service-activator"></a>8.5&nbsp;Service Activator</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="service-activator-introduction" href="#service-activator-introduction"></a>8.5.1&nbsp;Introduction</h3></div></div></div>

<p>The Service Activator is the endpoint type for connecting any Spring-managed Object to an input channel so that it may play the role of a service.
If the service produces output, it may also be connected to an output channel.
Alternatively, an output producing service may be located at the end of a processing pipeline or message flow in which case, the inbound Message&#8217;s "replyChannel" header can be used.
This is the default behavior if no output channel is defined and, as with most of the configuration options you&#8217;ll see here, the same behavior actually applies for most of the other components we have seen.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="service-activator-namespace" href="#service-activator-namespace"></a>8.5.2&nbsp;Configuring Service Activator</h3></div></div></div>

<p>To create a Service Activator, use the <span class="emphasis"><em>service-activator</em></span> element with the <span class="emphasis"><em>input-channel</em></span> and <span class="emphasis"><em>ref</em></span> attributes:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"exampleHandler"</span><span class="hl-tag">/&gt;</span></pre>
<p>The configuration above assumes that "exampleHandler" either contains a single method annotated with the @ServiceActivator annotation or that it contains only one public method at all.
To delegate to an explicitly defined method of any object, simply add the "method" attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span><span class="hl-tag">/&gt;</span></pre>
<p>In either case, when the service method returns a non-null value, the endpoint will attempt to send the reply message to an appropriate reply channel.
To determine the reply channel, it will first check if an "output-channel" was provided in the endpoint configuration:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"replyChannel"</span>
                       <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span><span class="hl-tag">/&gt;</span></pre>
<p>If the method returns a result and no "output-channel" is defined, the framework will then check the Message&#8217;s <code class="literal">replyChannel</code> header value.
If that value is available, it will then check its type.
If it is a`MessageChannel`, the reply message will be sent to that channel.
If it is a <code class="literal">String</code>, then the endpoint will attempt to resolve the channel name to a channel instance.
If the channel cannot be resolved, then a <code class="literal">DestinationResolutionException</code> will be thrown.
It it can be resolved, the Message will be sent there.
This is the technique used for Request Reply messaging in Spring Integration, and it is also an example of the Return Address pattern.</p>
<p>If your method returns a result, and you want to discard it and end the flow, you should configure the <code class="literal">output-channel</code> to send to a <code class="literal">NullChannel</code>.
For convenience, the framework registers one with the name <code class="literal">nullChannel</code>.
See <a class="xref" href="messaging-channels-section.html#channel-special-channels" title="4.1.6&nbsp;Special Channels">Section&nbsp;4.1.6, &#8220;Special Channels&#8221;</a> for more information.</p>
<p>The Service Activator is one of those components that is not required to produce a reply message.
If your method returns <code class="literal">null</code> or has a <code class="literal">void</code> return type, the Service Activator exits after the method invocation, without any signals.
This behavior can be controlled by the <code class="literal">AbstractReplyProducingMessageHandler.requiresReply</code> option, also exposed as <code class="literal">requires-reply</code> when configuring with the XML namespace.
If the flag is set to <code class="literal">true</code> and the method returns null, a <code class="literal">ReplyRequiredException</code> is thrown.</p>
<p>The argument in the service method could be either a Message or an arbitrary type.
If the latter, then it will be assumed that it is a Message payload, which will be extracted from the message and injected into such service method.
This is generally the recommended approach as it follows and promotes a POJO model when working with Spring Integration.
Arguments may also have @Header or @Headers annotations as described in <a class="xref" href="configuration.html#annotations" title="F.6&nbsp;Annotation Support">Section&nbsp;F.6, &#8220;Annotation Support&#8221;</a></p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The service method is not required to have any arguments at all, which means you can implement event-style Service Activators, where all you care about is an invocation of the service method, not worrying about the contents of the message.
Think of it as a NULL JMS message.
An example use-case for such an implementation could be a simple counter/monitor of messages deposited on the input channel.</p>
</td></tr></table></div>
<p>Starting with <span class="emphasis"><em>version 4.1</em></span> the framework correct converts Message properties (<code class="literal">payload</code> and <code class="literal">headers</code>) to the Java 8 <code class="literal">Optional</code> POJO method parameters:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyBean {
    <span class="hl-keyword">public</span> String computeValue(Optional&lt;String&gt; payload,
               <em><span class="hl-annotation" style="color: gray">@Header(value="foo", required=false)</span></em> String foo1,
               <em><span class="hl-annotation" style="color: gray">@Header(value="foo")</span></em> Optional&lt;String&gt; foo2) {
        <span class="hl-keyword">if</span> (payload.isPresent()) {
            String value = payload.get();
            ...
        }
        <span class="hl-keyword">else</span> {
           ...
       }
    }

}</pre>
<p>Using a <code class="literal">ref</code> attribute is generally recommended if the custom Service Activator handler implementation can be reused in other <code class="literal">&lt;service-activator&gt;</code> definitions.
However if the custom Service Activator handler implementation is only used within a single definition of the <code class="literal">&lt;service-activator&gt;</code>, you can provide an inner bean definition:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleServiceActivator"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span>
            <span class="hl-attribute">output-channel</span> = <span class="hl-value">"outChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"foo"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.ExampleServiceActivator"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Using both the "ref" attribute and an inner handler definition in the same <code class="literal">&lt;service-activator&gt;</code> configuration is not allowed, as it creates an ambiguous condition and will result in an Exception being thrown.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>If the "ref" attribute references a bean that extends <code class="literal">AbstractMessageProducingHandler</code> (such as handlers provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.
In this case, each "ref" must be to a separate bean instance (or a <code class="literal">prototype</code>-scoped bean), or use the inner <code class="literal">&lt;bean/&gt;</code> configuration type.
If you inadvertently reference the same message handler from multiple beans, you will get a configuration exception.</p>
</td></tr></table></div>
<p><span class="emphasis"><em>Service Activators and the Spring Expression Language (SpEL)</em></span></p>
<p>Since Spring Integration 2.0, Service Activators can also benefit from SpEL (<a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html" target="_top">http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html</a>).</p>
<p>For example, you may now invoke any bean method without pointing to the bean via a <code class="literal">ref</code> attribute or including it as an inner bean definition.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span>
	<span class="hl-attribute">expression</span>=<span class="hl-value">"@accountService.processAccount(payload, headers.accountId)"</span><span class="hl-tag">/&gt;</span>

	<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.Account"</span><span class="hl-tag">/&gt;</span></pre>
<p>In the above configuration instead of injecting <span class="emphasis"><em>accountService</em></span> using a <code class="literal">ref</code> or as an inner bean, we are simply using SpEL&#8217;s <code class="literal">@beanId</code> notation and invoking a method which takes a type compatible with Message payload.
We are also passing a header value.
As you can see, any valid SpEL expression can be evaluated against any content in the Message.
For simple scenarios your <span class="emphasis"><em>Service Activators</em></span> do not even have to reference a bean if all logic can be encapsulated by such an expression.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload * 2"</span><span class="hl-tag">/&gt;</span></pre>
<p>In the above configuration our service logic is to simply multiply the payload value by 2, and SpEL lets us handle it relatively easy.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="async-service-activator" href="#async-service-activator"></a>8.5.3&nbsp;Asynchronous Service Activator</h3></div></div></div>

<p>The service activator is invoked by the calling thread; this would be some upstream thread if the input channel is a
<code class="literal">SubscribableChannel</code>, or a poller thread for a <code class="literal">PollableChannel</code>.
If the service returns a <code class="literal">ListenableFuture&lt;?&gt;</code> the default action is to send that as the payload of the message sent
to the output (or reply) channel.
Starting with <span class="emphasis"><em>version 4.3</em></span>, you can now set the <code class="literal">async</code> attribute to true (<code class="literal">setAsync(true)</code> when using
Java configuration).
If the service returns a <code class="literal">ListenableFuture&lt;?&gt;</code> when this is true, the calling thread is released immediately, and the
reply message is sent on the thread (from within your service) that completes the future.
This is particularly advantageous for long-running services using a <code class="literal">PollableChannel</code> because the poller thread is
freed up to perform other services within the framework.</p>
<p>If the service completes the future with an <code class="literal">Exception</code>, normal error processing will occur - an <code class="literal">ErrorMessage</code> is
sent to the <code class="literal">errorChannel</code> message header, if present or otherwise to the default <code class="literal">errorChannel</code> (if available).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="delayer" href="#delayer"></a>8.6&nbsp;Delayer</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayer-introduction" href="#delayer-introduction"></a>8.6.1&nbsp;Introduction</h3></div></div></div>

<p>A Delayer is a simple endpoint that allows a Message flow to be delayed by a certain interval.
When a Message is delayed, the original sender will not block.
Instead, the delayed Messages will be scheduled with an instance of <code class="literal">org.springframework.scheduling.TaskScheduler</code> to be sent to the output channel after the delay has passed.
This approach is scalable even for rather long delays, since it does not result in a large number of blocked sender Threads.
On the contrary, in the typical case a thread pool will be used for the actual execution of releasing the Messages.
Below you will find several examples of configuring a Delayer.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayer-namespace" href="#delayer-namespace"></a>8.6.2&nbsp;Configuring Delayer</h3></div></div></div>

<p>The <code class="literal">&lt;delayer&gt;</code> element is used to delay the Message flow between two Message Channels.
As with the other endpoints, you can provide the <span class="emphasis"><em>input-channel</em></span> and <span class="emphasis"><em>output-channel</em></span> attributes, but the delayer also has <span class="emphasis"><em>default-delay</em></span> and <span class="emphasis"><em>expression</em></span> attributes (and <span class="emphasis"><em>expression</em></span> sub-element) that are used to determine the number of milliseconds that each Message should be delayed.
The following delays all messages by 3 seconds:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span>
             <span class="hl-attribute">default-delay</span>=<span class="hl-value">"3000"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">/&gt;</span></pre>
<p>If you need per-Message determination of the delay, then you can also provide the SpEL expression using the <span class="emphasis"><em>expression</em></span> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
             <span class="hl-attribute">default-delay</span>=<span class="hl-value">"3000"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"headers['delay']"</span><span class="hl-tag">/&gt;</span></pre>
<p>In the example above, the 3 second delay would only apply when the expression evaluates to <span class="emphasis"><em>null</em></span> for a given inbound Message.
If you only want to apply a delay to Messages that have a valid result of the expression evaluation, then you can use a <span class="emphasis"><em>default-delay</em></span> of 0 (the default).
For any Message that has a delay of 0 (or less), the Message will be sent immediately, on the calling Thread.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>The delay handler supports expression evaluation results that represent an interval in milliseconds (any Object whose <code class="literal">toString()</code> method produces a value that can be parsed into a Long) as well as <code class="literal">java.util.Date</code> instances representing an absolute time.
In the first case, the milliseconds will be counted from the current time (e.g.
a value of 5000 would delay the Message for at least 5 seconds from the time it is received by the Delayer).
With a Date instance, the Message will not be released until the time represented by that Date object.
In either case, a value that equates to a non-positive delay, or a Date in the past, will not result in any delay.
Instead, it will be sent directly to the output channel on the original sender&#8217;s Thread.
If the expression evaluation result is not a Date, and can not be parsed as a Long, the default delay (if any) will be applied.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The expression evaluation may throw an evaluation Exception for various reasons, including an invalid expression, or other conditions.
By default, such exceptions are ignored (logged at DEBUG level) and the delayer falls back to the default delay (if any).
You can modify this behavior by setting the <code class="literal">ignore-expression-failures</code> attribute.
By default this attribute is set to <code class="literal">true</code> and the Delayer behavior is as described above.
However, if you wish to not ignore expression evaluation exceptions, and throw them to the delayer&#8217;s caller, set the <code class="literal">ignore-expression-failures</code> attribute to <code class="literal">false</code>.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Notice in the example above that the delay expression is specified as <code class="literal">headers['delay']</code>.
This is the SpEL <code class="literal">Indexer</code> syntax to access a <code class="literal">Map</code> element (<code class="literal">MessageHeaders</code> implements <code class="literal">Map</code>), it invokes: <code class="literal">headers.get("delay")</code>.
For simple map element names (that do not contain <span class="emphasis"><em>.</em></span>) you can also use the SpEL <span class="emphasis"><em>dot accessor</em></span> syntax, where the above header expression can be specified as <code class="literal">headers.delay</code>.
But, different results are achieved if the header is missing.
In the first case, the expression will evaluate to <code class="literal">null</code>; the second will result in something like:</p>
<pre class="programlisting"> org.springframework.expression.spel.SpelEvaluationException: EL1<span class="hl-number">008E</span>:(pos <span class="hl-number">8</span>):
		   Field or property <span class="hl-string">'delay'</span> cannot be found on object of type <span class="hl-string">'org.springframework.messaging.MessageHeaders'</span></pre>
<p>So, if there is a possibility of the header being omitted, and you want to fall back to the default delay, it is generally more efficient (and recommended) to use the <span class="emphasis"><em>Indexer</em></span> syntax instead of <span class="emphasis"><em>dot property accessor</em></span> syntax, because detecting the null is faster than catching an exception.</p>
</td></tr></table></div>
<p>The delayer delegates to an instance of Spring&#8217;s <code class="literal">TaskScheduler</code> abstraction.
The default scheduler used by the delayer is the <code class="literal">ThreadPoolTaskScheduler</code> instance provided by Spring Integration on startup: <a class="xref" href="configuration.html#namespace-taskscheduler" title="F.3&nbsp;Configuring the Task Scheduler">Section&nbsp;F.3, &#8220;Configuring the Task Scheduler&#8221;</a>.
If you want to delegate to a different scheduler, you can provide a reference through the delayer element&#8217;s <span class="emphasis"><em>scheduler</em></span> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"headers.delay"</span>
    <span class="hl-attribute">scheduler</span>=<span class="hl-value">"exampleTaskScheduler"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;task:scheduler</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleTaskScheduler"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span></pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>If you configure an external <code class="literal">ThreadPoolTaskScheduler</code> you can set on this scheduler property <code class="literal">waitForTasksToCompleteOnShutdown = true</code>.
It allows successful completion of <span class="emphasis"><em>delay</em></span> tasks, which already in the execution state (releasing the Message), when the application is shutdown.
Before Spring Integration 2.2 this property was available on the <code class="literal">&lt;delayer&gt;</code> element, because <code class="literal">DelayHandler</code> could create its own scheduler on the background.
Since 2.2 delayer requires an external scheduler instance and <code class="literal">waitForTasksToCompleteOnShutdown</code> was deleted; you should use the scheduler&#8217;s own configuration.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Also keep in mind <code class="literal">ThreadPoolTaskScheduler</code> has a property <code class="literal">errorHandler</code> which can be injected with some implementation of <code class="literal">org.springframework.util.ErrorHandler</code>.
This handler allows to process an <code class="literal">Exception</code> from the thread of the scheduled task sending the delayed message.
By default it uses an <code class="literal">org.springframework.scheduling.support.TaskUtils$LoggingErrorHandler</code> and you will see a stack trace in the logs.
You might want to consider using an <code class="literal">org.springframework.integration.channel.MessagePublishingErrorHandler</code>, which sends an <code class="literal">ErrorMessage</code> into an <code class="literal">error-channel</code>, either from the failed Message&#8217;s header or into the default <code class="literal">error-channel</code>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayer-message-store" href="#delayer-message-store"></a>8.6.3&nbsp;Delayer and Message Store</h3></div></div></div>

<p>The <code class="literal">DelayHandler</code> persists delayed Messages into the Message Group in the provided <code class="literal">MessageStore</code>.
(The <span class="emphasis"><em>groupId</em></span> is based on required <span class="emphasis"><em>id</em></span> attribute of <code class="literal">&lt;delayer&gt;</code> element.) A delayed message is removed from the <code class="literal">MessageStore</code> by the scheduled task just before the <code class="literal">DelayHandler</code> sends the Message to the <code class="literal">output-channel</code>.
If the provided <code class="literal">MessageStore</code> is persistent (e.g.
<code class="literal">JdbcMessageStore</code>) it provides the ability to not lose Messages on the application shutdown.
After application startup, the <code class="literal">DelayHandler</code> reads Messages from its Message Group in the <code class="literal">MessageStore</code> and reschedules them with a delay based on the original arrival time of the Message (if the delay is numeric).
For messages where the delay header was a <code class="literal">Date</code>, that is used when rescheduling.
If a delayed Message remained in the <code class="literal">MessageStore</code> more than its <span class="emphasis"><em>delay</em></span>, it will be sent immediately after startup.</p>
<p>The <code class="literal">&lt;delayer&gt;</code> can be enriched with mutually exclusive sub-elements <code class="literal">&lt;transactional&gt;</code> or <code class="literal">&lt;advice-chain&gt;</code>.
The List of these AOP Advices is applied to the proxied internal <code class="literal">DelayHandler.ReleaseMessageHandler</code>, which has the responsibility to release the Message, after the delay, on a <code class="literal">Thread</code> of the scheduled task.
It might be used, for example, when the downstream message flow throws an Exception and the <code class="literal">ReleaseMessageHandler</code>'s transaction will be rolled back.
In this case the delayed Message will remain in the persistent <code class="literal">MessageStore</code>.
You can use any custom <code class="literal">org.aopalliance.aop.Advice</code> implementation within the <code class="literal">&lt;advice-chain&gt;</code>.
A sample configuration of the <code class="literal">&lt;delayer&gt;</code> may look like this:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"headers.delay"</span>
    <span class="hl-attribute">message-store</span>=<span class="hl-value">"jdbcMessageStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:advice-chain&gt;</span>
        <span class="hl-tag">&lt;beans:ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"customAdviceBean"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;tx:advice&gt;</span>
            <span class="hl-tag">&lt;tx:attributes&gt;</span>
                <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/tx:attributes&gt;</span>
        <span class="hl-tag">&lt;/tx:advice&gt;</span>
    <span class="hl-tag">&lt;/int:advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:delayer&gt;</span></pre>
<p>The <code class="literal">DelayHandler</code> can be exported as a JMX <code class="literal">MBean</code> with managed operations <code class="literal">getDelayedMessageCount</code> and <code class="literal">reschedulePersistedMessages</code>, which allows the rescheduling of delayed persisted Messages at runtime, for example, if the <code class="literal">TaskScheduler</code> has previously been stopped.
These operations can be invoked via a <code class="literal">Control Bus</code> command:</p>
<pre class="programlisting">Message&lt;String&gt; delayerReschedulingMessage =
    MessageBuilder.withPayload(<span class="hl-string">"@'delayer.handler'.reschedulePersistedMessages()"</span>).build();
    controlBusChannel.send(delayerReschedulingMessage);</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For more information regarding the Message Store, JMX and the Control Bus, please read <a class="xref" href="system-management-chapter.html" title="9.&nbsp;System Management">Chapter&nbsp;9, <i>System Management</i></a>.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scripting" href="#scripting"></a>8.7&nbsp;Scripting support</h2></div></div></div>

<p>With Spring Integration 2.1 we&#8217;ve added support for the <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/pr/jsr223/" target="_top">JSR223 Scripting for Java specification</a>, introduced in Java version 6.
This allows you to use scripts written in any supported language including Ruby/JRuby, Javascript and Groovy to provide the logic for various integration components similar to the way the Spring Expression Language (SpEL) is used in Spring Integration.
For more information about JSR223 please refer to the <a class="ulink" href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/" target="_top">documentation</a></p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Note that this feature requires Java 6 or higher.
Sun developed a JSR223 reference implementation which works with Java 5 but it is not officially supported and we have not tested it with Spring Integration.</p>
</td></tr></table></div>
<p>In order to use a JVM scripting language, a JSR223 implementation for that language must be included in your class path.
Java 6 natively supports Javascript.
The <a class="ulink" href="http://www.groovy-lang.org/" target="_top">Groovy</a> and <a class="ulink" href="http://jruby.org/" target="_top">JRuby</a> projects provide JSR233 support in their standard distribution.
Other language implementations may be available or under development.
Please refer to the appropriate project website for more information.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Various JSR223 language implementations have been developed by third parties.
A particular implementation&#8217;s compatibility with Spring Integration depends on how well it conforms to the specification and/or the implementer&#8217;s interpretation of the specification.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>If you plan to use Groovy as your scripting language, we recommended you use <a class="link" href="messaging-endpoints-chapter.html#groovy" title="8.8&nbsp;Groovy support">Spring-Integration&#8217;s Groovy Support</a> as it offers additional features specific to Groovy.
<span class="emphasis"><em>However you will find this section relevant as well</em></span>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="scripting-config" href="#scripting-config"></a>8.7.1&nbsp;Script configuration</h3></div></div></div>

<p>Depending on the complexity of your integration requirements scripts may be provided inline as CDATA in XML configuration&nbsp;or as a reference to a Spring resource containing the script.
To enable scripting support Spring Integration defines a <code class="literal">ScriptExecutingMessageProcessor</code>&nbsp;which will bind the Message Payload to a variable named <code class="literal">payload</code> and the Message Headers to a <code class="literal">headers</code> variable, both accessible within the script execution context.
All that is left for you to do is write a script that uses these variables.
Below are a couple of sample configurations:</p>
<p><span class="emphasis"><em>Filter</em></span></p>
<pre class="programlisting"><span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"referencedScriptInput"</span><span class="hl-tag">&gt;</span>
   <span class="hl-tag">&lt;int-script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"ruby"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"some/path/to/ruby/script/RubyFilterTests.rb"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span>

<span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inlineScriptInput"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;int-script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"groovy"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;![CDATA[</span>
     return payload == 'good'
   <span class="hl-tag">]]&gt;</span>
  <span class="hl-tag">&lt;/int-script:script&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span></pre>
<p>Here, you see that the script can be included inline or can reference a resource location via the <code class="literal">location</code> attribute.
Additionally the <code class="literal">lang</code> attribute corresponds to the language name (or JSR223 alias)</p>
<p>Other Spring Integration endpoint elements which support scripting include <span class="emphasis"><em>router</em></span>, <span class="emphasis"><em>service-activator</em></span>, <span class="emphasis"><em>transformer</em></span>, and <span class="emphasis"><em>splitter</em></span>.
The scripting configuration in each case would be identical to the above (besides the endpoint element).</p>
<p>Another useful feature of Scripting support is the ability to update (reload) scripts without having to restart the Application Context.
To accomplish this, specify the <code class="literal">refresh-check-delay</code> attribute on the <span class="emphasis"><em>script</em></span> element:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script&nbsp;location="..."</span> <span class="hl-attribute">refresh-check-delay</span>=<span class="hl-value">"5000"</span><span class="hl-tag">/&gt;</span></pre>
<p>In the above example, the script location will be checked for updates every 5 seconds.
If the script is updated, any invocation that occurs later than 5 seconds since the update will result in execution of the new script.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script&nbsp;location="..."</span> <span class="hl-attribute">refresh-check-delay</span>=<span class="hl-value">"0"</span><span class="hl-tag">/&gt;</span></pre>
<p>In the above example the context will be updated with any script modifications as soon as such modification occurs, providing a simple mechanism for <span class="emphasis"><em>real-time</em></span> configuration.
Any negative number value means the script will not be reloaded after initialization of the application context.
This is the default behavior.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Inline scripts can not be reloaded.</p>
</td></tr></table></div>
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script&nbsp;location="..."</span> <span class="hl-attribute">refresh-check-delay</span>=<span class="hl-value">"-1"</span><span class="hl-tag">/&gt;</span></pre>
<p><span class="emphasis"><em>Script variable bindings</em></span></p>
<p>Variable bindings are required to enable the script to reference variables externally provided to the script&#8217;s execution context.
As we have seen, <code class="literal">payload</code> and <code class="literal">headers</code> are used as binding variables by default.
You can bind additional variables to a script via <code class="literal">&lt;variable&gt;</code> sub-elements:</p>
<pre class="programlisting"><span class="hl-tag">&lt;script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"js"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"foo/bar/MyScript.js"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"foo"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"bar"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"date"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/script:script&gt;</span></pre>
<p>As shown in the above example, you can bind a script variable either to a scalar value or a Spring bean reference.
Note that <code class="literal">payload</code> and <code class="literal">headers</code> will still be included as binding variables.</p>
<p>With <span class="emphasis"><em>Spring Integration 3.0</em></span>, in addition to the <code class="literal">variable</code> sub-element, the <code class="literal">variables</code> attribute has been introduced.
This attribute and <code class="literal">variable</code> sub-elements aren&#8217;t mutually exclusive and you can combine them within one <code class="literal">script</code> component.
However variables must be unique, regardless of where they are defined.
Also, since <span class="emphasis"><em>Spring Integration 3.0</em></span>, variable bindings are allowed for inline scripts too:</p>
<pre class="programlisting"><span class="hl-tag">&lt;service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"ruby"</span> <span class="hl-attribute">variables</span>=<span class="hl-value">"foo=FOO, date-ref=dateBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"barBean"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"baz"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"bar"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;![CDATA[</span>
            payload.foo = foo
            payload.date = date
            payload.bar = bar
            payload.baz = baz
            payload
        <span class="hl-tag">]]&gt;</span>
    <span class="hl-tag">&lt;/script:script&gt;</span>
<span class="hl-tag">&lt;/service-activator&gt;</span></pre>
<p>The example above shows a combination of an inline script, a <code class="literal">variable</code> sub-element and a <code class="literal">variables</code> attribute.
The <code class="literal">variables</code> attribute is a comma-separated value, where each segment contains an <span class="emphasis"><em>=</em></span> separated pair of the variable and its value.
The variable name can be suffixed with <code class="literal">-ref</code>, as in the <code class="literal">date-ref</code> variable above.
That means that the binding variable will have the name <code class="literal">date</code>, but the value will be a reference to the <code class="literal">dateBean</code> bean from the application context.
This may be useful when using <span class="emphasis"><em>Property Placeholder Configuration</em></span> or command line arguments.</p>
<p>If you need more control over how variables are generated, you can implement your own Java class using the <code class="literal">ScriptVariableGenerator</code> strategy:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ScriptVariableGenerator {

    Map&lt;String, Object&gt; generateScriptVariables(Message&lt;?&gt; message);

}</pre>
<p>This interface requires you to implement the method <code class="literal">generateScriptVariables(Message)</code>.
The Message argument allows you to access any data available in the Message payload and headers and the return value is the Map of bound variables.
This method will be called every time the script is executed for a Message.
All you need to do is provide an implementation of <code class="literal">ScriptVariableGenerator</code> and reference it with the <code class="literal">script-variable-generator</code> attribute:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">"foo/bar/MyScript.groovy"</span>
        <span class="hl-attribute">script-variable-generator</span>=<span class="hl-value">"variableGenerator"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"variableGenerator"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.MyScriptVariableGenerator"</span><span class="hl-tag">/&gt;</span></pre>
<p>If a <code class="literal">script-variable-generator</code> is not provided, script components use <code class="literal">DefaultScriptVariableGenerator</code>, which merges any provided <code class="literal">&lt;variable&gt;</code> s with <span class="emphasis"><em>payload</em></span> and <span class="emphasis"><em>headers</em></span> variables from the <code class="literal">Message</code> in its <code class="literal">generateScriptVariables(Message)</code> method.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>You cannot provide both the <code class="literal">script-variable-generator</code> attribute and <code class="literal">&lt;variable&gt;</code> sub-element(s) as they are mutually exclusive.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="groovy" href="#groovy"></a>8.8&nbsp;Groovy support</h2></div></div></div>

<p>In Spring Integration 2.0 we added Groovy support allowing you to use the Groovy scripting language to provide the logic for various integration components similar to the way the Spring Expression Language (SpEL) is supported for routing, transformation and other integration concerns.
For more information about Groovy please refer to the Groovy documentation which you can find on the <a class="ulink" href="http://www.groovy-lang.org/" target="_top">project website</a>.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="groovy-config" href="#groovy-config"></a>8.8.1&nbsp;Groovy configuration</h3></div></div></div>

<p>With Spring Integration 2.1, Groovy Support&#8217;s configuration namespace is an extension of Spring Integration&#8217;s Scripting Support and shares the core configuration and behavior described in detail in the <a class="link" href="messaging-endpoints-chapter.html#scripting" title="8.7&nbsp;Scripting support">Scripting Support</a> section.
Even though Groovy scripts are well supported by generic Scripting Support, Groovy Support provides the <span class="emphasis"><em>Groovy</em></span> configuration namespace which is backed by the Spring Framework&#8217;s <code class="literal">org.springframework.scripting.groovy.GroovyScriptFactory</code> and related components, offering extended capabilities for using Groovy.
Below are a couple of sample configurations:</p>
<p><span class="emphasis"><em>Filter</em></span></p>
<pre class="programlisting"><span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"referencedScriptInput"</span><span class="hl-tag">&gt;</span>
   <span class="hl-tag">&lt;int-groovy:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">"some/path/to/groovy/file/GroovyFilterTests.groovy"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span>

<span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inlineScriptInput"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;int-groovy:script&gt;</span><span class="hl-tag">&lt;![CDATA[</span>
     return payload == 'good'
   <span class="hl-tag">]]&gt;</span><span class="hl-tag">&lt;/int-groovy:script&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span></pre>
<p>As the above examples show, the configuration looks identical to the general Scripting Support configuration.
The only difference is the use of the Groovy namespace as indicated in the examples by the <span class="emphasis"><em>int-groovy</em></span> namespace prefix.
Also note that the <code class="literal">lang</code> attribute on the <code class="literal">&lt;script&gt;</code> tag is not valid in this namespace.</p>
<p><span class="emphasis"><em>Groovy object customization</em></span></p>
<p>If you need to customize the Groovy object itself, beyond setting variables, you can reference a bean that implements <code class="literal">GroovyObjectCustomizer</code> via the <code class="literal">customizer</code> attribute.
For example, this might be useful if you want to implement a domain-specific language (DSL) by modifying the <code class="literal">MetaClass</code> and registering functions to be available within the script:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"groovyChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int-groovy:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">"foo/SomeScript.groovy"</span> <span class="hl-attribute">customizer</span>=<span class="hl-value">"groovyCustomizer"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"groovyCustomizer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.MyGroovyObjectCustomizer"</span><span class="hl-tag">/&gt;</span></pre>
<p>Setting a custom <code class="literal">GroovyObjectCustomizer</code> is not mutually exclusive with <code class="literal">&lt;variable&gt;</code> sub-elements or the <code class="literal">script-variable-generator</code> attribute.
It can also be provided when defining an inline script.</p>
<p>With <span class="emphasis"><em>Spring Integration 3.0</em></span>, in addition to the <code class="literal">variable</code> sub-element, the <code class="literal">variables</code> attribute has been introduced.
Also, groovy scripts have the ability to resolve a variable to a bean in the <code class="literal">BeanFactory</code>, if a binding variable was not provided with the name:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-groovy:script&gt;</span>
    <span class="hl-tag">&lt;![CDATA[</span>
        entityManager.persist(payload)
        payload
    <span class="hl-tag">]]&gt;</span>
<span class="hl-tag">&lt;/int-groovy:script&gt;</span></pre>
<p>where variable <code class="literal">entityManager</code> is an appropriate bean in the application context.</p>
<p>For more information regarding <code class="literal">&lt;variable&gt;</code>, <code class="literal">variables</code>, and <code class="literal">script-variable-generator</code>, see the paragraph <span class="emphasis"><em><span class="emphasis"><em>Script variable bindings</em></span></em></span> of <a class="xref" href="messaging-endpoints-chapter.html#scripting-config" title="8.7.1&nbsp;Script configuration">Section&nbsp;8.7.1, &#8220;Script configuration&#8221;</a>.</p>
<p><span class="emphasis"><em>Groovy Script Compiler Customization</em></span></p>
<p>The <code class="literal">@CompileStatic</code> hint is the most popular Groovy compiler customization option,
which can be used on the class or method level.
See more information in the Groovy
<a class="ulink" href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_static_compilation" target="_top">Reference Manual</a> and,
specifically, <a class="ulink" href="http://docs.groovy-lang.org/latest/html/documentation/index.html#compilestatic-annotation" target="_top">@CompileStatic</a>.
To utilize this feature for short scripts (in integration scenarios), we are forced to change a simple script like this
(a <code class="literal">&lt;filter&gt;</code> script):</p>
<pre class="programlisting">headers.type == <span class="hl-string">'good'</span></pre>
<p>to more Java-like code:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@groovy.transform.CompileStatic</span></em>
String filter(Map headers) {
	headers.type == <span class="hl-string">'good'</span>
}

filter(headers)</pre>
<p>With that, the <code class="literal">filter()</code> method will be transformed and compiled to static Java code, bypassing the Groovy
dynamic phases of invocation, like <code class="literal">getProperty()</code> factories and <code class="literal">CallSite</code> proxies.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, Spring Integration Groovy components can be configured with the <code class="literal">compile-static</code> <code class="literal">boolean</code>
option, specifying that <code class="literal">ASTTransformationCustomizer</code> for <code class="literal">@CompileStatic</code> should be added to the internal
<code class="literal">CompilerConfiguration</code>.
With that in place, we can omit the method declaration with <code class="literal">@CompileStatic</code> in our script code and still get compiled
plain Java code.
In this case our script can still be short but still needs to be a little more verbose than interpreted script:</p>
<pre class="programlisting">binding.variables.headers.type == <span class="hl-string">'good'</span></pre>
<p>Where we can access the <code class="literal">headers</code> and <code class="literal">payload</code> (or any other) variables only through the <code class="literal">groovy.lang.Script</code>
<code class="literal">binding</code> property since, with <code class="literal">@CompileStatic</code>, we don&#8217;t have the  dynamic <code class="literal">GroovyObject.getProperty()</code> capability.</p>
<p>In addition, the <code class="literal">compiler-configuration</code> bean reference has been introduced.
With this attribute, you can provide any other required Groovy compiler customizations, e.g. <code class="literal">ImportCustomizer</code>.
For more information about this feature, please, refer to the Groovy Documentation:
<a class="ulink" href="http://groovy.jmiguel.eu/groovy.codehaus.org/Advanced+compiler+configuration.html" target="_top">Advanced compiler configuration</a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Using <code class="literal">compilerConfiguration</code> does not automatically add a <code class="literal">ASTTransformationCustomizer</code> for <code class="literal">@CompileStatic</code>
and overrides the <code class="literal">compileStatic</code> option.
If <code class="literal">CompileStatic</code> is still requirement, a <code class="literal">new ASTTransformationCustomizer(CompileStatic.class)</code> should be manually
added into the <code class="literal">CompilationCustomizers</code> of that custom <code class="literal">compilerConfiguration</code>.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The Groovy compiler customization does not have any effect to the <code class="literal">refresh-check-delay</code> option
and reloadable scripts can be statically compiled, too.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="groovy-control-bus" href="#groovy-control-bus"></a>8.8.2&nbsp;Control Bus</h3></div></div></div>

<p>As described in (<a class="ulink" href="http://www.eaipatterns.com/ControlBus.html" target="_top">EIP</a>), the idea behind the Control Bus is that the same messaging system can be used for monitoring and managing the components within the framework as is used for "application-level" messaging.
In Spring Integration we build upon the adapters described above so that it&#8217;s possible to send Messages as a means of invoking exposed operations.
One option for those operations is Groovy scripts.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-groovy:control-bus</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"operationChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>The Control Bus has an input channel that can be accessed for invoking operations on the beans in the application context.</p>
<p>The Groovy Control Bus executes messages on the input channel as Groovy scripts.
It takes a message, compiles the body to a Script, customizes it with a <code class="literal">GroovyObjectCustomizer</code>, and then executes it.
The Control Bus' <code class="literal">MessageProcessor</code> exposes all beans in the application context that are annotated with <code class="literal">@ManagedResource</code>, implement Spring&#8217;s <code class="literal">Lifecycle</code> interface or extend Spring&#8217;s <code class="literal">CustomizableThreadCreator</code> base class (e.g.
several of the <code class="literal">TaskExecutor</code> and <code class="literal">TaskScheduler</code> implementations).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Be careful about using managed beans with custom scopes (e.g.
<span class="emphasis"><em>request</em></span>) in the Control Bus' command scripts, especially inside an <span class="emphasis"><em>async</em></span> message flow.
If The Control Bus' <code class="literal">MessageProcessor</code> can&#8217;t expose a bean from the application context, you may end up with some <code class="literal">BeansException</code> during <span class="emphasis"><em>command script&#8217;s</em></span> executing.
For example, if a custom scope&#8217;s context is not established, the attempt to get a bean within that scope will trigger a <code class="literal">BeanCreationException</code>.</p>
</td></tr></table></div>
<p>If you need to further customize the Groovy objects, you can also provide a reference to a bean that implements <code class="literal">GroovyObjectCustomizer</code> via the <code class="literal">customizer</code> attribute.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-groovy:control-bus</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span>
        <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
        <span class="hl-attribute">customizer</span>=<span class="hl-value">"groovyCustomizer"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"groovyCustomizer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.MyGroovyObjectCustomizer"</span><span class="hl-tag">/&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-handler-advice-chain" href="#message-handler-advice-chain"></a>8.9&nbsp;Adding Behavior to Endpoints</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mhac-intro" href="#mhac-intro"></a>8.9.1&nbsp;Introduction</h3></div></div></div>

<p>Prior to Spring Integration <span class="emphasis"><em>2.2</em></span>, you could add behavior to an entire Integration flow by adding an AOP Advice to a poller&#8217;s <code class="literal">&lt;advice-chain/&gt;</code> element.
However, let&#8217;s say you want to retry, say, just a REST Web Service call, and not any downstream endpoints.</p>
<p>For example, consider the following flow:</p>
<p><span class="emphasis"><em>inbound-adapter&#8594;poller&#8594;http-gateway1&#8594;http-gateway2&#8594;jdbc-outbound-adapter</em></span></p>
<p>If you configure some retry-logic into an advice chain on the poller, and, the call to <span class="emphasis"><em>http-gateway2</em></span> failed because of a network glitch, the retry would cause both <span class="emphasis"><em>http-gateway1</em></span> and <span class="emphasis"><em>http-gateway2</em></span> to be called a second time.
Similarly, after a transient failure in the <span class="emphasis"><em>jdbc-outbound-adapter</em></span>, both http-gateways would be called a second time before again calling the <span class="emphasis"><em>jdbc-outbound-adapter</em></span>.</p>
<p>Spring Integration 2.2 adds the ability to add behavior to individual endpoints.
This is achieved by the addition of the <code class="literal">&lt;request-handler-advice-chain/&gt;</code> element to many endpoints.
For example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-http:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"withAdvice"</span>
    <span class="hl-attribute">url-expression</span>=<span class="hl-value">"'http://localhost/test1'"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requests"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"nextChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"myRetryAdvice"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int-http:outbound-gateway&gt;</span></pre>
<p>In this case, <span class="emphasis"><em>myRetryAdvice</em></span> will only be applied locally to this gateway and will not apply to further actions taken downstream after the reply is sent to the <span class="emphasis"><em>nextChannel</em></span>.
The scope of the advice is limited to the endpoint itself.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>At this time, you cannot advise an entire <code class="literal">&lt;chain/&gt;</code> of endpoints.
The schema does not allow a <code class="literal">&lt;request-handler-advice-chain/&gt;</code> as a child element of the chain itself.</p>
<p>However, a <code class="literal">&lt;request-handler-advice-chain/&gt;</code> can be added to individual reply-producing endpoints <span class="emphasis"><em>within</em></span> a <code class="literal">&lt;chain/&gt;</code> element.
An exception is that, in a chain that produces no reply, because the last element in the chain is an <span class="emphasis"><em>outbound-channel-adapter</em></span>, that <span class="emphasis"><em>last</em></span> element cannot be advised.
If you need to advise such an element, it must be moved outside of the chain (with the <span class="emphasis"><em>output-channel</em></span> of the chain being the <span class="emphasis"><em>input-channel</em></span> of the adapter.
The adapter can then be advised as normal.
For chains that produce a reply, every child element can be advised.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advice-classes" href="#advice-classes"></a>8.9.2&nbsp;Provided Advice Classes</h3></div></div></div>

<p>In addition to providing the general mechanism to apply AOP Advice classes in this way, three standard Advices are provided:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">RequestHandlerRetryAdvice</code>
</li><li class="listitem">
<code class="literal">RequestHandlerCircuitBreakerAdvice</code>
</li><li class="listitem">
<code class="literal">ExpressionEvaluatingRequestHandlerAdvice</code>
</li></ul></div>
<p>These are each described in detail in the following sections.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="retry-advice" href="#retry-advice"></a>Retry Advice</h4></div></div></div>

<p>The retry advice (<code class="literal">o.s.i.handler.advice.RequestHandlerRetryAdvice</code>) leverages the rich retry mechanisms provided by the <a class="ulink" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a> project.
The core component of <code class="literal">spring-retry</code> is the <code class="literal">RetryTemplate</code>, which allows configuration of sophisticated retry scenarios, including <code class="literal">RetryPolicy</code> and <code class="literal">BackoffPolicy</code> strategies, with a number of implementations, as well as a <code class="literal">RecoveryCallback</code> strategy to determine the action to take when retries are exhausted.</p>
<p><span class="strong"><strong>Stateless Retry</strong></span></p>
<p>Stateless retry is the case where the retry activity is handled entirely within the advice, where the thread pauses (if so configured) and retries the action.</p>
<p><span class="strong"><strong>Stateful Retry</strong></span></p>
<p>Stateful retry is the case where the retry state is managed within the advice, but where an exception is thrown and the caller resubmits the request.
An example for stateful retry is when we want the message originator (e.g.
JMS) to be responsible for resubmitting, rather than performing it on the current thread.
Stateful retry needs some mechanism to detect a retried submission.</p>
<p><span class="strong"><strong>Further Information</strong></span></p>
<p>For more information on <code class="literal">spring-retry</code>, refer to the project&#8217;s javadocs, as well as the reference documentation for <a class="ulink" href="http://docs.spring.io/spring-batch/reference/html/retry.html" target="_top">Spring Batch</a>, where <code class="literal">spring-retry</code> originated.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
<p>The default back off behavior is no back off - retries are attempted immediately.
Using a back off policy that causes threads to pause between attempts may cause performance issues, including excessive memory use and thread starvation.
In high volume environments, back off policies should be used with caution.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="retry-config" href="#retry-config"></a>Configuring the Retry Advice</h5></div></div></div>

<p>The following examples use a simple <code class="literal">&lt;service-activator/&gt;</code> that always throws an exception:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FailingService {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> service(String message) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(<span class="hl-string">"foo"</span>);
    }
}</pre>
<p><span class="strong"><strong>Simple Stateless Retry</strong></span></p>
<p>This example uses the default <code class="literal">RetryTemplate</code> which has a <code class="literal">SimpleRetryPolicy</code> which tries 3 times.
There is no <code class="literal">BackOffPolicy</code> so the 3 attempts are made back-to-back-to-back with no delay between attempts.
There is no <code class="literal">RecoveryCallback</code> so, the result is to throw the exception to the caller after the final failed retry occurs.
In a <span class="emphasis"><em>Spring Integration</em></span> environment, this final exception might be handled using an <code class="literal">error-channel</code> on the inbound endpoint.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
DEBUG [task-scheduler-2]Retry: count=0
DEBUG [task-scheduler-2]Checking for rethrow: count=1
DEBUG [task-scheduler-2]Retry: count=1
DEBUG [task-scheduler-2]Checking for rethrow: count=2
DEBUG [task-scheduler-2]Retry: count=2
DEBUG [task-scheduler-2]Checking for rethrow: count=3
DEBUG [task-scheduler-2]Retry failed last attempt: count=3</pre>
<p><span class="strong"><strong>Simple Stateless Retry with Recovery</strong></span></p>
<p>This example adds a <code class="literal">RecoveryCallback</code> to the above example; it uses a <code class="literal">ErrorMessageSendingRecoverer</code> to send an <code class="literal">ErrorMessage</code> to a channel.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"recoveryCallback"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.ErrorMessageSendingRecoverer"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:int:service-activator&gt;</span>

DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
DEBUG [task-scheduler-2]Retry: count=0
DEBUG [task-scheduler-2]Checking for rethrow: count=1
DEBUG [task-scheduler-2]Retry: count=1
DEBUG [task-scheduler-2]Checking for rethrow: count=2
DEBUG [task-scheduler-2]Retry: count=2
DEBUG [task-scheduler-2]Checking for rethrow: count=3
DEBUG [task-scheduler-2]Retry failed last attempt: count=3
DEBUG [task-scheduler-2]Sending ErrorMessage :failedMessage:[Payload=...]</pre>
<p><span class="strong"><strong>Stateless Retry with Customized Policies, and Recovery</strong></span></p>
<p>For more sophistication, we can provide the advice with a customized <code class="literal">RetryTemplate</code>.
This example continues to use the <code class="literal">SimpleRetryPolicy</code> but it increases the attempts to 4.
It also adds an <code class="literal">ExponentialBackoffPolicy</code> where the first retry waits 1 second, the second waits 5 seconds and the third waits 25 (for 4 attempts in all).</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"recoveryCallback"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.ErrorMessageSendingRecoverer"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"retryTemplate"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"retryTemplate"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retryTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.support.RetryTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"retryPolicy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.policy.SimpleRetryPolicy"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxAttempts"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"4"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"backOffPolicy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.backoff.ExponentialBackOffPolicy"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"initialInterval"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"multiplier"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5.0"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxInterval"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

27.058 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]
27.071 DEBUG [task-scheduler-1]Retry: count=0
27.080 DEBUG [task-scheduler-1]Sleeping for 1000
28.081 DEBUG [task-scheduler-1]Checking for rethrow: count=1
28.081 DEBUG [task-scheduler-1]Retry: count=1
28.081 DEBUG [task-scheduler-1]Sleeping for 5000
33.082 DEBUG [task-scheduler-1]Checking for rethrow: count=2
33.082 DEBUG [task-scheduler-1]Retry: count=2
33.083 DEBUG [task-scheduler-1]Sleeping for 25000
58.083 DEBUG [task-scheduler-1]Checking for rethrow: count=3
58.083 DEBUG [task-scheduler-1]Retry: count=3
58.084 DEBUG [task-scheduler-1]Checking for rethrow: count=4
58.084 DEBUG [task-scheduler-1]Retry failed last attempt: count=4
58.086 DEBUG [task-scheduler-1]Sending ErrorMessage :failedMessage:[Payload=...]</pre>
<p><span class="strong"><strong>Namespace Support for Stateless Retry</strong></span></p>
<p>Starting with <span class="emphasis"><em>version 4.0</em></span>, the above configuration can be greatly simplified with the namespace support for the retry advice:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"retrier"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;int:handler-retry-advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retrier"</span> <span class="hl-attribute">max-attempts</span>=<span class="hl-value">"4"</span> <span class="hl-attribute">recovery-channel</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:exponential-back-off</span> <span class="hl-attribute">initial</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">multiplier</span>=<span class="hl-value">"5.0"</span> <span class="hl-attribute">maximum</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:handler-retry-advice&gt;</span></pre>
<p>In this example, the advice is defined as a top level bean so it can be used in multiple <code class="literal">request-handler-advice-chain</code> s.
You can also define the advice directly within the chain:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;int:retry-advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retrier"</span> <span class="hl-attribute">max-attempts</span>=<span class="hl-value">"4"</span> <span class="hl-attribute">recovery-channel</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;int:exponential-back-off</span> <span class="hl-attribute">initial</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">multiplier</span>=<span class="hl-value">"5.0"</span> <span class="hl-attribute">maximum</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/int:retry-advice&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
<p>A <code class="literal">&lt;handler-retry-advice/&gt;</code> with no child element uses no back off; it can have a <code class="literal">fixed-back-off</code> or <code class="literal">exponential-back-off</code> child element.
If there is no <code class="literal">recovery-channel</code>, the exception is thrown when retries are exhausted.
The namespace can only be used with stateless retry.</p>
<p>For more complex environments (custom policies etc), use normal <code class="literal">&lt;bean/&gt;</code> definitions.</p>
<p><span class="strong"><strong>Simple Stateful Retry with Recovery</strong></span></p>
<p>To make retry stateful, we need to provide the Advice with a RetryStateGenerator implementation.
This class is used to identify a message as being a resubmission so that the <code class="literal">RetryTemplate</code> can determine the current state of retry for this message.
The framework provides a <code class="literal">SpelExpressionRetryStateGenerator</code> which determines the message identifier using a SpEL expression.
This is shown below; this example again uses the default policies (3 attempts with no back off); of course, as with stateless retry, these policies can be customized.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"retryStateGenerator"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.SpelExpressionRetryStateGenerator"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"headers['jms_messageId']"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"recoveryCallback"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.ErrorMessageSendingRecoverer"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/int:request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

24.351 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
24.368 DEBUG [Container#0-1]Retry: count=0
24.387 DEBUG [Container#0-1]Checking for rethrow: count=1
24.387 DEBUG [Container#0-1]Rethrow in retry for policy: count=1
24.387 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
24.391 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
25.412 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
25.412 DEBUG [Container#0-1]Retry: count=1
25.413 DEBUG [Container#0-1]Checking for rethrow: count=2
25.413 DEBUG [Container#0-1]Rethrow in retry for policy: count=2
25.413 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
25.414 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
26.418 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
26.418 DEBUG [Container#0-1]Retry: count=2
26.419 DEBUG [Container#0-1]Checking for rethrow: count=3
26.419 DEBUG [Container#0-1]Rethrow in retry for policy: count=3
26.419 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
26.420 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
27.425 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
27.426 DEBUG [Container#0-1]Retry failed last attempt: count=3
27.426 DEBUG [Container#0-1]Sending ErrorMessage :failedMessage:[Payload=...]</pre>
<p>Comparing with the stateless examples, you can see that with stateful retry, the exception is thrown to the caller on each failure.</p>
<p><span class="strong"><strong>Exception Classification for Retry</strong></span></p>
<p>Spring Retry has a great deal of flexibility for determining which exceptions can invoke retry.
The default configuration will retry for all exceptions and the exception classifier just looks at the top level exception.
If you configure it to, say, only retry on <code class="literal">BarException</code> and your application throws a <code class="literal">FooException</code> where the cause is a <code class="literal">BarException</code>, retry will not occur.</p>
<p>Since <span class="emphasis"><em>Spring Retry 1.0.3</em></span>, the <code class="literal">BinaryExceptionClassifier</code> has a property <code class="literal">traverseCauses</code> (default <code class="literal">false</code>).
When <code class="literal">true</code> it will traverse exception causes until it finds a match or there is no cause.</p>
<p>To use this classifier for retry, use a <code class="literal">SimpleRetryPolicy</code> created with the constructor that takes the max attempts, the <code class="literal">Map</code> of <code class="literal">Exception</code> s and the boolean (traverseCauses), and inject this policy into the <code class="literal">RetryTemplate</code>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="circuit-breaker-advice" href="#circuit-breaker-advice"></a>Circuit Breaker Advice</h4></div></div></div>

<p>The general idea of the Circuit Breaker Pattern is that, if a service is not currently available, then don&#8217;t waste time (and resources) trying to use it.
The <code class="literal">o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice</code> implements this pattern.
When the circuit breaker is in the <span class="emphasis"><em>closed</em></span> state, the endpoint will attempt to invoke the service.
The circuit breaker goes to the <span class="emphasis"><em>open</em></span> state if a certain number of consecutive attempts fail; when it is in the <span class="emphasis"><em>open</em></span> state, new requests will "fail fast" and no attempt will be made to invoke the service until some time has expired.</p>
<p>When that time has expired, the circuit breaker is set to the <span class="emphasis"><em>half-open</em></span> state.
When in this state, if even a single attempt fails, the breaker will immediately go to the <span class="emphasis"><em>open</em></span> state; if the attempt succeeds, the breaker will go to the <span class="emphasis"><em>closed</em></span> state, in which case, it won&#8217;t go to the <span class="emphasis"><em>open</em></span> state again until the configured number of consecutive failures again occur.
Any successful attempt resets the state to zero failures for the purpose of determining when the breaker might go to the <span class="emphasis"><em>open</em></span> state again.</p>
<p>Typically, this Advice might be used for external services, where it might take some time to fail (such as a timeout attempting to make a network connection).</p>
<p>The <code class="literal">RequestHandlerCircuitBreakerAdvice</code> has two properties: <code class="literal">threshold</code> and <code class="literal">halfOpenAfter</code>.
The <span class="emphasis"><em>threshold</em></span> property represents the number of consecutive failures that need to occur before the breaker goes <span class="emphasis"><em>open</em></span>.
It defaults to 5.
The <span class="emphasis"><em>halfOpenAfter</em></span> property represents the time after the last failure that the breaker will wait before attempting another request.
Default is 1000 milliseconds.</p>
<p>Example:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"threshold"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"halfOpenAfter"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"12000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/int:request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

05.617 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]
05.638 ERROR [task-scheduler-1]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
10.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
10.600 ERROR [task-scheduler-2]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
15.598 DEBUG [task-scheduler-3]preSend on channel 'input', message: [Payload=...]
15.599 ERROR [task-scheduler-3]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator
...
20.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
20.598 ERROR [task-scheduler-2]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator
...
25.598 DEBUG [task-scheduler-5]preSend on channel 'input', message: [Payload=...]
25.601 ERROR [task-scheduler-5]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
30.598 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=foo...]
30.599 ERROR [task-scheduler-1]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator</pre>
<p>In the above example, the threshold is set to 2 and halfOpenAfter is set to 12 seconds; a new request arrives every 5 seconds.
You can see that the first two attempts invoked the service; the third and fourth failed with an exception indicating the circuit breaker is open.
The fifth request was attempted because the request was 15 seconds after the last failure; the sixth attempt fails immediately because the breaker immediately went to <span class="emphasis"><em>open</em></span>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="expression-advice" href="#expression-advice"></a>Expression Evaluating Advice</h4></div></div></div>

<p>The final supplied advice class is the <code class="literal">o.s.i.handler.advice.ExpressionEvaluatingRequestHandlerAdvice</code>.
This advice is more general than the other two advices.
It provides a mechanism to evaluate an expression on the original inbound message sent to the endpoint.
Separate expressions are available to be evaluated, either after success, or failure.
Optionally, a message containing the evaluation result, together with the input message, can be sent to a message channel.</p>
<p>A typical use case for this advice might be with an <code class="literal">&lt;ftp:outbound-channel-adapter/&gt;</code>, perhaps to move the file to one directory if the transfer was successful, or to another directory if it fails:</p>
<p>The Advice has properties to set an expression when successful, an expression for failures, and corresponding channels for each.
For the successful case, the message sent to the <span class="emphasis"><em>successChannel</em></span> is an <code class="literal">AdviceMessage</code>, with the payload being the result of the expression evaluation, and an additional property <code class="literal">inputMessage</code> which contains the original message sent to the handler.
A message sent to the <span class="emphasis"><em>failureChannel</em></span> (when the handler throws an exception) is an <code class="literal">ErrorMessage</code> with a payload of <code class="literal">MessageHandlingExpressionEvaluatingAdviceException</code>.
Like all <code class="literal">MessagingException</code> s, this payload has <code class="literal">failedMessage</code> and <code class="literal">cause</code> properties, as well as an additional property <code class="literal">evaluationResult</code>, containing the result of the expression evaluation.</p>
<p>When an exception is thrown in the scope of the advice, by default, that exception is thrown to caller after any
<code class="literal">failureExpression</code> is evaluated.
If you wish to suppress throwing the exception, set the <code class="literal">trapException</code> property to <code class="literal">true</code>.</p>
<p>
<b>Example - Configuring the Advice with Java DSL.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> EerhaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(EerhaApplication.<span class="hl-keyword">class</span>, args);
        MessageChannel in = context.getBean(<span class="hl-string">"advised.input"</span>, MessageChannel.<span class="hl-keyword">class</span>);
        in.send(<span class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span class="hl-string">"good"</span>));
        in.send(<span class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span class="hl-string">"bad"</span>));
        context.close();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow advised() {
        <span class="hl-keyword">return</span> f -&gt; f.handle((GenericHandler&lt;String&gt;) (payload, headers) -&gt; {
            <span class="hl-keyword">if</span> (payload.equals(<span class="hl-string">"good"</span>)) {
                <span class="hl-keyword">return</span> null;
            }
            <span class="hl-keyword">else</span> {
                <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(<span class="hl-string">"some failure"</span>);
            }
        }, c -&gt; c.advice(expressionAdvice()));
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Advice expressionAdvice() {
        ExpressionEvaluatingRequestHandlerAdvice advice = <span class="hl-keyword">new</span> ExpressionEvaluatingRequestHandlerAdvice();
        advice.setSuccessChannelName(<span class="hl-string">"success.input"</span>);
        advice.setOnSuccessExpressionString(<span class="hl-string">"payload + ' was successful'"</span>);
        advice.setFailureChannelName(<span class="hl-string">"failure.input"</span>);
        advice.setOnFailureExpressionString(
                <span class="hl-string">"payload + ' was bad, with reason: ' + #exception.cause.message"</span>);
        advice.setTrapException(true);
        <span class="hl-keyword">return</span> advice;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow success() {
        <span class="hl-keyword">return</span> f -&gt; f.handle(System.out::println);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow failure() {
        <span class="hl-keyword">return</span> f -&gt; f.handle(System.out::println);
    }

}</pre><p>

</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-advice" href="#custom-advice"></a>8.9.3&nbsp;Custom Advice Classes</h3></div></div></div>

<p>In addition to the provided Advice classes above, you can implement your own Advice classes.
While you can provide any implementation of <code class="literal">org.aopalliance.aop.Advice</code> (usually <code class="literal">org.aopalliance.intercept.MethodInterceptor</code>), it is generally recommended that you subclass <code class="literal">o.s.i.handler.advice.AbstractRequestHandlerAdvice</code>.
This has the benefit of avoiding writing low-level <span class="emphasis"><em>Aspect Oriented Programming</em></span> code as well as providing a starting point that is specifically tailored for use in this environment.</p>
<p>Subclasses need to implement the <code class="literal">doInvoke()`</code> method:</p>
<pre class="programlisting"><strong class="hl-tag" style="color: blue">/**
 * Subclasses implement this method to apply behavior to the {@link MessageHandler} callback.execute()
 * invokes the handler method and returns its result, or null).
 * @param callback Subclasses invoke the execute() method on this interface to invoke the handler method.
 * @param target The target handler.
 * @param message The message that will be sent to the handler.
 * @return the result after invoking the {@link MessageHandler}.
 * @throws Exception
 */</strong>
<span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object doInvoke(ExecutionCallback callback, Object target, Message&lt;?&gt; message) <span class="hl-keyword">throws</span> Exception;</pre>
<p>The <span class="emphasis"><em>callback</em></span> parameter is simply a convenience to avoid subclasses dealing with AOP directly; invoking the <code class="literal">callback.execute()</code> method invokes the message handler.</p>
<p>The <span class="emphasis"><em>target</em></span> parameter is provided for those subclasses that need to maintain state for a specific handler, perhaps by maintaining that state in a <code class="literal">Map</code>, keyed by the target.
This allows the same advice to be applied to multiple handlers.
The <code class="literal">RequestHandlerCircuitBreakerAdvice</code> uses this to keep circuit breaker state for each handler.</p>
<p>The <span class="emphasis"><em>message</em></span> parameter is the message that will be sent to the handler.
While the advice cannot modify the message before invoking the handler, it can modify the payload (if it has mutable properties).
Typically, an advice would use the message for logging and/or to send a copy of the message somewhere before or after invoking the handler.</p>
<p>The return value would normally be the value returned by <code class="literal">callback.execute()</code>; but the advice does have the ability to modify the return value.
Note that only <code class="literal">AbstractReplyProducingMessageHandler</code> s return a value.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyAdvice <span class="hl-keyword">extends</span> AbstractRequestHandlerAdvice {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> Object doInvoke(ExecutionCallback callback, Object target, Message&lt;?&gt; message) <span class="hl-keyword">throws</span> Exception {
        <span class="hl-comment">// add code before the invocation</span>
        Object result = callback.execute();
        <span class="hl-comment">// add code after the invocation</span>
        <span class="hl-keyword">return</span> result;
    }
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>In addition to the <code class="literal">execute()</code> method, the <code class="literal">ExecutionCallback</code> provides an additional method <code class="literal">cloneAndExecute()</code>.
This method must be used in cases where the invocation might be called multiple times within a single execution of <code class="literal">doInvoke()</code>, such as in the <code class="literal">RequestHandlerRetryAdvice</code>.
This is required because the Spring AOP <code class="literal">org.springframework.aop.framework.ReflectiveMethodInvocation</code> object maintains state of which advice in a chain was last invoked; this state must be reset for each call.</p>
<p>For more information, see the <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/framework/ReflectiveMethodInvocation.html" target="_top">ReflectiveMethodInvocation</a> JavaDocs.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other-advice" href="#other-advice"></a>8.9.4&nbsp;Other Advice Chain Elements</h3></div></div></div>

<p>While the abstract class mentioned above is provided as a convenience, you can add any <code class="literal">Advice</code> to the chain, including a transaction advice.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="handle-message-advice" href="#handle-message-advice"></a>8.9.5&nbsp;Handle Message Advice</h3></div></div></div>

<p>As discussed in <a class="link" href="messaging-endpoints-chapter.html#mhac-intro" title="8.9.1&nbsp;Introduction">the introduction to this section</a>, advice objects in a request handler advice chain are applied to just the current endpoint, not the downstream flow (if any).
For <code class="literal">MessageHandler</code> s that produce a reply (<code class="literal">AbstractReplyProducingMessageHandler</code>), the advice is applied to an internal method
<code class="literal">handleRequestMessage()</code> (called from <code class="literal">MessageHandler.handleMessage()</code>).
For other message handlers, the advice is applied to <code class="literal">MessageHandler.handleMessage()</code>.</p>
<p>There are some circumstances where, even if a message handler is an <code class="literal">AbstractReplyProducingMessageHandler</code>, the advice must be applied to the <code class="literal">handleMessage</code> method - for example, the <a class="link" href="messaging-endpoints-chapter.html#idempotent-receiver" title="8.9.10&nbsp;Idempotent Receiver Enterprise Integration Pattern">Idempotent Receiver</a> might return <code class="literal">null</code> and this would cause an exception if the handler&#8217;s <code class="literal">replyRequired</code> property is true.</p>
<p>Starting with <span class="emphasis"><em>version 4.3.1</em></span>, a new <code class="literal">HandleMessageAdvice</code> and the <code class="literal">AbstractHandleMessageAdvice</code> base implementation have been introduced.
<code class="literal">Advice</code> s that implement <code class="literal">HandleMessageAdvice</code> will always be applied to the <code class="literal">handleMessage()</code> method, regardless of the handler type.</p>
<p>It is important to understand that <code class="literal">HandleMessageAdvice</code> implementations (such as <a class="link" href="messaging-endpoints-chapter.html#idempotent-receiver" title="8.9.10&nbsp;Idempotent Receiver Enterprise Integration Pattern">Idempotent Receiver</a>), when applied to a handler that returns a response, are dissociated from the <code class="literal">adviceChain</code> and properly applied to the <code class="literal">MessageHandler.handleMessage()</code> method.
Bear in mind, however, that this means the advice chain order is not complied with; and, with configuration such as:</p>
<pre class="programlisting"><span class="hl-tag">&lt;some-reply-producing-endpoint</span> <span class="hl-attribute">...</span><span class="hl-tag"> &gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">...</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myHandleMessageAdvice"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/some-reply-producing-endpoint&gt;</span></pre>
<p>The <code class="literal">&lt;tx:advice&gt;</code> is applied to the <code class="literal">AbstractReplyProducingMessageHandler.handleRequestMessage()</code>, but <code class="literal">myHandleMessageAdvice</code> is applied for to <code class="literal">MessageHandler.handleMessage()</code> and, therefore, invoked <span class="strong"><strong>before</strong></span> the <code class="literal">&lt;tx:advice&gt;</code>.
To retain the order, you should follow with standard <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html" target="_top">Spring AOP</a> configuration approach and use endpoint <code class="literal">id</code> together with the <code class="literal">.handler</code> suffix to obtain the target <code class="literal">MessageHandler</code> bean.
Note, however, that in that case, the entire downstream flow would be within the transaction scope.</p>
<p>In the case of a <code class="literal">MessageHandler</code> that does <span class="strong"><strong>not</strong></span> return a response, the advice chain order is retained.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advising-filters" href="#advising-filters"></a>8.9.6&nbsp;Advising Filters</h3></div></div></div>

<p>There is an additional consideration when advising <code class="literal">Filter</code> s.
By default, any discard actions (when the filter returns false) are performed <span class="emphasis"><em>within</em></span> the scope of the advice chain.
This could include all the flow downstream of the <span class="emphasis"><em>discard channel</em></span>.
So, for example if an element downstream of the <span class="emphasis"><em>discard-channel</em></span> throws an exception, and there is a retry advice, the process will be retried.
This is also the case if <span class="emphasis"><em>throwExceptionOnRejection</em></span> is set to true (the exception is thrown within the scope of the advice).</p>
<p>Setting <span class="emphasis"><em>discard-within-advice</em></span> to "false" modifies this behavior and the discard (or exception) occurs after the advice chain is called.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advising-with-annotations" href="#advising-with-annotations"></a>8.9.7&nbsp;Advising Endpoints Using Annotations</h3></div></div></div>

<p>When configuring certain endpoints using annotations (<code class="literal">@Filter</code>, <code class="literal">@ServiceActivator</code>, <code class="literal">@Splitter</code>, and <code class="literal">@Transformer</code>), you can supply a bean name for the advice chain in the <code class="literal">adviceChain</code> attribute.
In addition, the <code class="literal">@Filter</code> annotation also has the <code class="literal">discardWithinAdvice</code> attribute, which can be used to configure the discard behavior as discussed in <a class="xref" href="messaging-endpoints-chapter.html#advising-filters" title="8.9.6&nbsp;Advising Filters">Section&nbsp;8.9.6, &#8220;Advising Filters&#8221;</a>.
An example with the discard being performed after the advice is shown below.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessageEndpoint</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyAdvisedFilter {

    <em><span class="hl-annotation" style="color: gray">@Filter(inputChannel="input", outputChannel="output",
            adviceChain="adviceChain", discardWithinAdvice="false")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> filter(String s) {
        <span class="hl-keyword">return</span> s.contains(<span class="hl-string">"good"</span>);
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advice-order" href="#advice-order"></a>8.9.8&nbsp;Ordering Advices within an Advice Chain</h3></div></div></div>

<p>Advice classes are "around" advices and are applied in a nested fashion.
The first advice is the outermost, the last advice the innermost (closest to the handler being advised).
It is important to put the advice classes in the correct order to achieve the functionality you desire.</p>
<p>For example, let&#8217;s say you want to add a retry advice and a transaction advice.
You may want to place the retry advice advice first, followed by the transaction advice.
Then, each retry will be performed in a new transaction.
On the other hand, if you want all the attempts, and any recovery operations (in the retry <code class="literal">RecoveryCallback</code>), to be scoped within the transaction, you would put the transaction advice first.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advised-handler-properties" href="#advised-handler-properties"></a>8.9.9&nbsp;Advised Handler Properties</h3></div></div></div>

<p>Sometimes, it is useful to access handler properties from within the advice.
For example, most handlers implement <code class="literal">NamedComponent</code> and you can access the component name.</p>
<p>The target object can be accessed via the <code class="literal">target</code> argument when subclassing <code class="literal">AbstractRequestHandlerAdvice</code> or
<code class="literal">invocation.getThis()</code> when implementing <code class="literal">org.aopalliance.intercept.MethodInterceptor</code>.</p>
<p>When the entire handler is advised (such as when the handler does not produce replies, or the advice implements <code class="literal">HandleMessageAdvice</code>), you can simply cast the target object to the desired implemented interface, such as <code class="literal">NamedComponent</code>.</p>
<pre class="programlisting">String componentName = ((NamedComponent) target).getComponentName();</pre>
<p>or</p>
<pre class="programlisting">String componentName = ((NamedComponent) invocation.getThis()).getComponentName();</pre>
<p>when implementing <code class="literal">MethodInterceptor</code> directly.</p>
<p>When only the <code class="literal">handleRequestMessage()</code> method is advised (in a reply-producing handler), you need to access the
full handler, which is an <code class="literal">AbstractReplyProducingMessageHandler</code>&#8230;&#8203;</p>
<pre class="programlisting">AbstractReplyProducingMessageHandler handler =
    ((AbstractReplyProducingMessageHandler.RequestHandler) target).getAdvisedHandler();

String componentName = handler.getComponentName();</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idempotent-receiver" href="#idempotent-receiver"></a>8.9.10&nbsp;Idempotent Receiver Enterprise Integration Pattern</h3></div></div></div>

<p>Starting with <span class="emphasis"><em>version 4.1</em></span>, Spring Integration provides an implementation of the <a class="ulink" href="http://www.eaipatterns.com/IdempotentReceiver.html" target="_top">Idempotent Receiver</a> Enterprise Integration Pattern.
It is a <span class="emphasis"><em>functional</em></span> pattern and the whole <span class="emphasis"><em>idempotency</em></span> logic should be implemented in the application, however to simplify the decision-making, the <code class="literal">IdempotentReceiverInterceptor</code> component is provided.
This is an AOP <code class="literal">Advice</code>, which is applied to the <code class="literal">MessageHandler.handleMessage()</code> method and can <code class="literal">filter</code> a request message or mark it as a <code class="literal">duplicate</code>, according to its configuration.</p>
<p>Previously, users could have implemented this pattern, by using a custom MessageSelector in a <code class="literal">&lt;filter/&gt;</code> (<a class="xref" href="messaging-routing-chapter.html#filter" title="6.2&nbsp;Filter">Section&nbsp;6.2, &#8220;Filter&#8221;</a>), for example.
However, since this pattern is really behavior of an endpoint rather than being an endpoint itself, the Idempotent Receiver implementation doesn&#8217;t provide an <span class="emphasis"><em>endpoint</em></span> component; rather, it is applied to endpoints declared in the application.</p>
<p>The logic of the <code class="literal">IdempotentReceiverInterceptor</code> is based on the provided <code class="literal">MessageSelector</code> and, if the message isn&#8217;t accepted by that selector, it will be enriched with the <code class="literal">duplicateMessage</code> header set to <code class="literal">true</code>.
The target <code class="literal">MessageHandler</code> (or downstream flow) can consult this header to implement the correct <span class="emphasis"><em>idempotency</em></span> logic.
If the <code class="literal">IdempotentReceiverInterceptor</code> is configured with a <code class="literal">discardChannel</code> and/or <code class="literal">throwExceptionOnRejection = true</code>, the <span class="emphasis"><em>duplicate</em></span> Message won&#8217;t be sent to the target <code class="literal">MessageHandler.handleMessage()</code>, but discarded.
If you simply want to discard (do nothing with) the <span class="emphasis"><em>duplicate</em></span> Message, the <code class="literal">discardChannel</code> should be configured with a <code class="literal">NullChannel</code>, such as the default <code class="literal">nullChannel</code> bean.</p>
<p>To maintain <span class="emphasis"><em>state</em></span> between messages and provide the ability to compare messages for the idempotency, the <code class="literal">MetadataStoreSelector</code> is provided.
It accepts a <code class="literal">MessageProcessor</code> implementation (which creates a lookup key based on the <code class="literal">Message</code>) and an optional <code class="literal">ConcurrentMetadataStore</code> (<a class="xref" href="system-management-chapter.html#metadata-store" title="9.5&nbsp;Metadata Store">Section&nbsp;9.5, &#8220;Metadata Store&#8221;</a>).
See the <code class="literal">MetadataStoreSelector</code> JavaDocs for more information.
The <code class="literal">value</code> for <code class="literal">ConcurrentMetadataStore</code> also can be customized using additional <code class="literal">MessageProcessor</code>.
By default <code class="literal">MetadataStoreSelector</code> uses <code class="literal">timestamp</code> message header.</p>
<p>For convenience, the <code class="literal">MetadataStoreSelector</code> options are configurable directly on the <code class="literal">&lt;idempotent-receiver&gt;</code> component:</p>
<pre class="programlisting"><span class="hl-tag">&lt;idempotent-receiver</span>
        <span class="hl-attribute">id</span>=<span class="hl-value">""</span>  <a name="CO14-1" href="#CO14-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
        endpoint=""  <a name="CO14-2" href="#CO14-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
        selector=""  <a name="CO14-3" href="#CO14-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
        discard-channel=""  <a name="CO14-4" href="#CO14-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
        metadata-store=""  <a name="CO14-5" href="#CO14-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
        key-strategy=""  <a name="CO14-6" href="#CO14-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
        key-expression=""  <a name="CO14-7" href="#CO14-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
        value-strategy=""  <a name="CO14-8" href="#CO14-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
        value-expression=""  <a name="CO14-9" href="#CO14-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
        throw-exception-on-rejection="" /&gt;  <a name="CO14-10" href="#CO14-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The id of the <code class="literal">IdempotentReceiverInterceptor</code> bean.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Consumer Endpoint name(s) or pattern(s) to which this interceptor will be applied.
Separate names (patterns) with commas (<code class="literal">,</code>) e.g.
<code class="literal">endpoint="aaa, bbb*, *ccc, *ddd*, eee*fff"</code>.
Endpoint bean names matching these patterns are then used to retrieve the target endpoint&#8217;s <code class="literal">MessageHandler</code> bean (using its <code class="literal">.handler</code> suffix), and the <code class="literal">IdempotentReceiverInterceptor</code> will be applied to those beans.
<span class="emphasis"><em>Required</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">MessageSelector</code> bean reference.
Mutually exclusive with <code class="literal">metadata-store</code> and <code class="literal">key-strategy (key-expression)</code>.
When <code class="literal">selector</code> is not provided, one of <code class="literal">key-strategy</code> or <code class="literal">key-strategy-expression</code> is required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Identifies the channel to which to send a message when the <code class="literal">IdempotentReceiverInterceptor</code> doesn&#8217;t accept it.
When omitted, duplicate messages are forwarded to the handler with a <code class="literal">duplicateMessage</code> header.
<span class="emphasis"><em>Optional</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">ConcurrentMetadataStore</code> reference.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Mutually exclusive with <code class="literal">selector</code>.
<span class="emphasis"><em>Optional</em></span>.
The default <code class="literal">MetadataStoreSelector</code> uses an internal <code class="literal">SimpleMetadataStore</code> which does not maintain state across application executions.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">MessageProcessor</code> reference.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates an <code class="literal">idempotentKey</code> from the request Message.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">key-expression</code>.
When a <code class="literal">selector</code> is not provided, one of <code class="literal">key-strategy</code> or <code class="literal">key-strategy-expression</code> is required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL expression to populate an <code class="literal">ExpressionEvaluatingMessageProcessor</code>.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates an <code class="literal">idempotentKey</code> using the request Message as the evaluation context root object.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">key-strategy</code>.
When a <code class="literal">selector</code> is not provided, one of <code class="literal">key-strategy</code> or <code class="literal">key-strategy-expression</code> is required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">MessageProcessor</code> reference.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates a <code class="literal">value</code> for the <code class="literal">idempotentKey</code> from the request Message.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">value-expression</code>.
By default, the <span class="emphasis"><em>MetadataStoreSelector</em></span> uses the <span class="emphasis"><em>timestamp</em></span> message header as the Metadata <span class="emphasis"><em>value</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL expression to populate an <code class="literal">ExpressionEvaluatingMessageProcessor</code>.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates a <code class="literal">value</code> for the <code class="literal">idempotentKey</code> using the request Message as the evaluation context root object.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">value-strategy</code>.
By default, the <span class="emphasis"><em>MetadataStoreSelector</em></span> uses the <span class="emphasis"><em>timestamp</em></span> message header as the Metadata <span class="emphasis"><em>value</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Throw an exception if the <code class="literal">IdempotentReceiverInterceptor</code> rejects the message defaults to <code class="literal">false</code>.
It is applied regardless of whether or not a <code class="literal">discard-channel</code> is provided.</p>
</td></tr></table></div>
<p>For Java configuration, the method level <code class="literal">IdempotentReceiver</code> annotation is provided.
It is used to mark a <code class="literal">method</code> that has a Messaging annotation (<code class="literal">@ServiceActivator</code>, <code class="literal">@Router</code> etc.) to specify which <code class="literal">IdempotentReceiverInterceptor</code> s will be applied to this endpoint:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IdempotentReceiverInterceptor idempotentReceiverInterceptor() {
   <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> IdempotentReceiverInterceptor(<span class="hl-keyword">new</span> MetadataStoreSelector(m -&gt;
                                                    m.getHeaders().get(INVOICE_NBR_HEADER)));
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "input", outputChannel = "output")</span></em>
<em><span class="hl-annotation" style="color: gray">@IdempotentReceiver("idempotentReceiverInterceptor")</span></em>
<span class="hl-keyword">public</span> MessageHandler myService() {
    ....
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">IdempotentReceiverInterceptor</code> is designed only for the <code class="literal">MessageHandler.handleMessage(Message&lt;?&gt;)</code> method and starting with <span class="emphasis"><em>version 4.3.1</em></span> it implements <code class="literal">HandleMessageAdvice</code>, with the <code class="literal">AbstractHandleMessageAdvice</code> as a base class, for better dissociation.
See <a class="xref" href="messaging-endpoints-chapter.html#handle-message-advice" title="8.9.5&nbsp;Handle Message Advice">Section&nbsp;8.9.5, &#8220;Handle Message Advice&#8221;</a> for more information.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="logging-channel-adapter" href="#logging-channel-adapter"></a>8.10&nbsp;Logging Channel Adapter</h2></div></div></div>

<p>The <code class="literal">&lt;logging-channel-adapter/&gt;</code> is often used in conjunction with a Wire Tap, as discussed in <a class="xref" href="messaging-channels-section.html#channel-wiretap" title="Wire Tap">the section called &#8220;Wire Tap&#8221;</a>.
However, it can also be used as the ultimate consumer of any flow.
For example, consider a flow that ends with a <code class="literal">&lt;service-activator/&gt;</code> that returns a result, but you wish to discard that result.
To do that, you could send the result to <code class="literal">NullChannel</code>.
Alternatively, you can route it to an <code class="literal">INFO</code> level <code class="literal">&lt;logging-channel-adapter/&gt;</code>; that way, you can see the discarded message when logging at <code class="literal">INFO</code> level, but not see it when logging at, say, <code class="literal">WARN</code> level.
With a <code class="literal">NullChannel</code>, you would only see the discarded message when logging at <code class="literal">DEBUG</code> level.</p>
<pre class="screen">&lt;int:logging-channel-adapter
    channel="" <a name="CO15-1" href="#CO15-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
    level="INFO" <a name="CO15-2" href="#CO15-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    expression="" <a name="CO15-3" href="#CO15-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    log-full-message="false" <a name="CO15-4" href="#CO15-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
    logger-name="" /&gt; <a name="CO15-5" href="#CO15-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The channel connecting the logging adapter to an upstream component.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The logging level at which messages sent to this adapter will be logged.
Default: <code class="literal">INFO</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL expression representing exactly what part(s) of the message will be logged.
Default: <code class="literal">payload</code> - just the payload will be logged.
This attribute cannot be specified if <code class="literal">log-full-message</code> is specified.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>When <code class="literal">true</code>, the entire message will be logged (including headers).
Default: <code class="literal">false</code> - just the payload will be logged.
This attribute cannot be specified if <code class="literal">expression</code> is specified.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies the <span class="emphasis"><em>name</em></span> of the logger (known as <code class="literal">category</code> in <code class="literal">log4j</code>) used for log messages created by this adapter.
This enables setting the log name (in the logging subsystem) for individual adapters.
By default, all adapters will log under the name <code class="literal">org.springframework.integration.handler.LoggingHandler</code>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_java_configuration" href="#_configuring_with_java_configuration"></a>8.10.1&nbsp;Configuring with Java Configuration</h3></div></div></div>

<p>The following Spring Boot application provides an example of configuring the <code class="literal">LoggingHandler</code> using Java configuration:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> LoggingJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context =
             <span class="hl-keyword">new</span> SpringApplicationBuilder(LoggingJavaApplication.<span class="hl-keyword">class</span>)
                    .web(false)
                    .run(args);
         MyGateway gateway = context.getBean(MyGateway.<span class="hl-keyword">class</span>);
         gateway.sendToLogger(<span class="hl-string">"foo"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> MessageChannel logInputChannel() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DirectChannel();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "logChannel")</span></em>
    <span class="hl-keyword">public</span> LoggingHandler logging() {
        LoggingHandler adapter = <span class="hl-keyword">new</span> LoggingHandler(LoggingHandler.Level.DEBUG);
        adapter.setLoggerName(<span class="hl-string">"TEST_LOGGER"</span>);
        adapter.setLogExpressionString(<span class="hl-string">"headers.id + ': ' + payload"</span>);
        <span class="hl-keyword">return</span> adapter;
    }

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway(defaultRequestChannel = "logChannel")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

        <span class="hl-keyword">void</span> sendToLogger(String data);

    }

}</pre>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="messaging-transformation-chapter.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-core-messaging.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="system-management-chapter.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.&nbsp;Message Transformation&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;9.&nbsp;System Management</td></tr></table></div></body></html>