<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>31.&nbsp;TCP and UDP Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="syslog.html" title="30.&nbsp;Syslog Support"><link rel="next" href="twitter.html" title="32.&nbsp;Twitter Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">31.&nbsp;TCP and UDP Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="syslog.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="twitter.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="ip" href="#ip"></a>31.&nbsp;TCP and UDP Support</h2></div></div></div>

<p>Spring Integration provides Channel Adapters for receiving and sending messages over internet protocols.
Both UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided.
Each adapter provides for one-way communication over the underlying protocol.
In addition, simple inbound and outbound tcp gateways are provided.
These are used when two-way communication is needed.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ip-intro" href="#ip-intro"></a>31.1&nbsp;Introduction</h2></div></div></div>

<p>Two flavors each of UDP inbound and outbound channel adapters are provided <code class="literal">UnicastSendingMessageHandler</code> sends a datagram packet to a single destination.
<code class="literal">UnicastReceivingChannelAdapter</code> receives incoming datagram packets.
<code class="literal">MulticastSendingMessageHandler</code> sends (broadcasts) datagram packets to a multicast address.
<code class="literal">MulticastReceivingChannelAdapter</code> receives incoming datagram packets by joining to a multicast address.</p>
<p>TCP inbound and outbound channel adapters are provided <code class="literal">TcpSendingMessageHandler</code> sends messages over TCP.
<code class="literal">TcpReceivingChannelAdapter</code> receives messages over TCP.</p>
<p>An inbound TCP gateway is provided; this allows for simple request/response processing.
While the gateway can support any number of connections, each connection can only process serially.
The thread that reads from the socket waits for, and sends, the response before reading again.
If the connection factory is configured for single use connections, the connection is closed after the socket times out.</p>
<p>An outbound TCP gateway is provided; this allows for simple request/response processing.
If the associated connection factory is configured for single use connections, a new connection is immediately created for each new request.
Otherwise, if the connection is in use, the calling thread blocks on the connection until either a response is received or a timeout or I/O error occurs.</p>
<p>The TCP and UDP inbound channel adapters, and the TCP inbound gateway, support the "error-channel" attribute.
This provides the same basic functionality as described in <a class="xref" href="messaging-endpoints-chapter.html#gateway-proxy" title="8.4.1&nbsp;Enter the GatewayProxyFactoryBean">Section&nbsp;8.4.1, &#8220;Enter the GatewayProxyFactoryBean&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="udp-adapters" href="#udp-adapters"></a>31.2&nbsp;UDP Adapters</h2></div></div></div>

<pre class="programlisting"><span class="hl-tag">&lt;int-ip:udp-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"udpOut"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"somehost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"11111"</span>
    <span class="hl-attribute">multicast</span>=<span class="hl-value">"false"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>A simple UDP outbound channel adapter.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>When setting multicast to true, provide the multicast address in the host attribute.</p>
</td></tr></table></div>
<p>UDP is an efficient, but unreliable protocol.
Two attributes are added to improve reliability.
When check-length is set to true, the adapter precedes the message data with a length field (4 bytes in network byte order).
This enables the receiving side to verify the length of the packet received.
If a receiving system uses a buffer that is too short the contain the packet, the packet can be truncated.
The length header provides a mechanism to detect this.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, the <code class="literal">port</code> can be set to <code class="literal">0</code>, in which case the Operating System chooses the port; the
chosen port can be discovered by invoking <code class="literal">getPort()</code> after the adapter is started and <code class="literal">isListening()</code> returns <code class="literal">true</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:udp-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"udpOut"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"somehost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"11111"</span>
    <span class="hl-attribute">multicast</span>=<span class="hl-value">"false"</span>
    <span class="hl-attribute">check-length</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>An outbound channel adapter that adds length checking to the datagram packets.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>The recipient of the packet must also be configured to expect a length to precede the actual data.
For a Spring Integration UDP inbound channel adapter, set its <code class="literal">check-length</code> attribute.</p>
</td></tr></table></div>
<p>The second reliability improvement allows an application-level acknowledgment protocol to be used.
The receiver must send an acknowledgment to the sender within a specified time.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:udp-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"udpOut"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"somehost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"11111"</span>
    <span class="hl-attribute">multicast</span>=<span class="hl-value">"false"</span>
    <span class="hl-attribute">check-length</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">acknowledge</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">ack-host</span>=<span class="hl-value">"thishost"</span>
    <span class="hl-attribute">ack-port</span>=<span class="hl-value">"22222"</span>
    <span class="hl-attribute">ack-timeout</span>=<span class="hl-value">"10000"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>An outbound channel adapter that adds length checking to the datagram packets and waits for an acknowledgment.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Setting acknowledge to true implies the recipient of the packet can interpret the header added to the packet containing acknowledgment data (host and port).
Most likely, the recipient will be a Spring Integration inbound channel adapter.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>When multicast is true, an additional attribute min-acks-for-success specifies how many acknowledgments must be received within the ack-timeout.</p>
</td></tr></table></div>
<p>For even more reliable networking, TCP can be used.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, the <code class="literal">ackPort</code> can be set to <code class="literal">0</code>, in which case the Operating System chooses the port.</p>
<p>Also starting with <span class="emphasis"><em>version 4.3</em></span>, the <code class="literal">destination-expression</code> and <code class="literal">socket-expression</code> options are available
for the <code class="literal">&lt;int-ip:udp-outbound-channel-adapter&gt;</code> (<code class="literal">UnicastSendingMessageHandler</code>).</p>
<p>The <code class="literal">destination-expression</code> can be used as a runtime alternative to the hardcoded <code class="literal">host</code>/<code class="literal">port</code> pair to determine
the destination address for the outgoing datagram packet against <code class="literal">requestMessage</code> as a root object for evaluation context.
The expression must evaluate to <code class="literal">URI</code>, or <code class="literal">String</code> in the URI style (see <a class="ulink" href="http://www.ietf.org/rfc/rfc2396.txt" target="_top">RFC-2396</a>)
or <code class="literal">SocketAddress</code>.
The new <code class="literal">IpHeaders.PACKET_ADDRESS</code> header can be used for this expression as well.
In the Framework this header is populated by the <code class="literal">DatagramPacketMessageMapper</code>, when we receive datagrams in the
<code class="literal">UnicastReceivingChannelAdapter</code> and convert them to messages.
The header value is exactly the result of <code class="literal">DatagramPacket.getSocketAddress()</code> of incoming datagram.</p>
<p>With the <code class="literal">socket-expression</code> help the Outbound Channel Adapter can use e.g. Inbound Channel Adapter socket
to send datagrams through same port which they were received.
It&#8217;s useful in a scenario when our application works as a UDP server and clients operate behind the NAT.
This expression must evaluate to the <code class="literal">DatagramSocket</code>.
The <code class="literal">requestMessage</code> is used as a root object for evaluation context.
The <code class="literal">socket-expression</code> parameter cannot be used with parameters like <code class="literal">multicast</code> and <code class="literal">acknowledge</code>.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:udp-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inbound"</span> <span class="hl-attribute">port</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"in"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"in"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"new String(payload).toUpperCase()"</span>
                       <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"out"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int-ip:udp-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outbound"</span>
                        <span class="hl-attribute">socket-expression</span>=<span class="hl-value">"@inbound.socket"</span>
                        <span class="hl-attribute">destination-expression</span>=<span class="hl-value">"headers['ip_packetAddress']"</span>
                        <span class="hl-attribute">channel</span>=<span class="hl-value">"out"</span><span class="hl-tag"> /&gt;</span></pre>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:udp-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"udpReceiver"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"udpOutChannel"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"11111"</span>
    <span class="hl-attribute">receive-buffer-size</span>=<span class="hl-value">"500"</span>
    <span class="hl-attribute">multicast</span>=<span class="hl-value">"false"</span>
    <span class="hl-attribute">check-length</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>
<p>A basic unicast inbound udp channel adapter.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:udp-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"udpReceiver"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"udpOutChannel"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"11111"</span>
    <span class="hl-attribute">receive-buffer-size</span>=<span class="hl-value">"500"</span>
    <span class="hl-attribute">multicast</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">multicast-address</span>=<span class="hl-value">"225.6.7.8"</span>
    <span class="hl-attribute">check-length</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>
<p>A basic multicast inbound udp channel adapter.</p>
<p>By default, reverse DNS lookups are done on inbound packets to convert IP addresses to hostnames for use in message headers.
In environments where DNS is not configured, this can cause delays.
This default behavior can be overridden by setting the <code class="literal">lookup-host</code> attribute to "false".</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connection-factories" href="#connection-factories"></a>31.3&nbsp;TCP Connection Factories</h2></div></div></div>

<p>For TCP, the configuration of the underlying connection is provided using a Connection Factory.
Two types of connection factory are provided; a client connection factory and a server connection factory.
Client connection factories are used to establish outgoing connections; Server connection factories listen for incoming connections.</p>
<p>A client connection factory is used by an outbound channel adapter but a reference to a client connection factory can also be provided to an inbound channel adapter and that adapter will receive any incoming messages received on connections created by the outbound adapter.</p>
<p>A server connection factory is used by an inbound channel adapter or gateway (in fact the connection factory will not function without one).
A reference to a server connection factory can also be provided to an outbound adapter; that adapter can then be used to send replies to incoming messages to the same connection.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Reply messages will only be routed to the connection if the reply contains the header <code class="literal">ip_connectionId</code> that was inserted into the original message by the connection factory.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>This is the extent of message correlation performed when sharing connection factories between inbound and outbound adapters.
Such sharing allows for asynchronous two-way communication over TCP.
By default, only payload information is transferred using TCP; therefore any message correlation must be performed by downstream components such as aggregators or other endpoints.
Support for transferring selected headers was introduced in version 3.0.
For more information refer to <a class="xref" href="ip.html#ip-correlation" title="31.8&nbsp;TCP Message Correlation">Section&nbsp;31.8, &#8220;TCP Message Correlation&#8221;</a>.</p>
</td></tr></table></div>
<p>A maximum of one adapter of each type may be given a reference to a connection factory.</p>
<p>Connection factories using <code class="literal">java.net.Socket</code> and <code class="literal">java.nio.channel.SocketChannel</code> are provided.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span><span class="hl-tag">/&gt;</span></pre>
<p>A simple server connection factory that uses <code class="literal">java.net.Socket</code> connections.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">using-nio</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span></pre>
<p>A simple server connection factory that uses <code class="literal">java.nio.channel.SocketChannel</code> connections.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Starting with Spring Integration <span class="emphasis"><em>version 4.2</em></span>, if the server is configured to listen on a random port (0),
the actual port chosen by the OS can be obtained using <code class="literal">getPort()</code>.
Also, <code class="literal">getServerSocketAddress()</code> is available to get the complete <code class="literal">SocketAddress</code>.
See the javadocs for the <code class="literal">TcpServerConnectionFactory</code> interface for more information.</p>
</td></tr></table></div>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">single-use</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">so-timeout</span>=<span class="hl-value">"10000"</span><span class="hl-tag">/&gt;</span></pre>
<p>A client connection factory that uses <code class="literal">java.net.Socket</code> connections and creates a new connection for each message.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">single-use</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">so-timeout</span>=<span class="hl-value">"10000"</span>
    <span class="hl-attribute">using-nio</span>=<span class="hl-value">true</span><span class="hl-tag">/&gt;</span></pre>
<p>A client connection factory that uses <code class="literal">java.nio.channel.Socket</code> connections and creates a new connection for each message.</p>
<p>TCP is a streaming protocol; this means that some structure has to be provided to data transported over TCP, so the receiver can demarcate the data into discrete messages.
Connection factories are configured to use (de)serializers to convert between the message payload and the bits that are sent over TCP.
This is accomplished by providing a deserializer and serializer for inbound and outbound messages respectively.
A number of standard (de)serializers are provided.</p>
<p>The <code class="literal">ByteArrayCrlfSerializer</code><sup>*</sup>, converts a byte array to a stream of bytes followed by carriage return and linefeed characters (\r\n).
This is the default (de)serializer and can be used with telnet as a client, for example.</p>
<p>The <code class="literal">ByteArraySingleTerminatorSerializer</code><sup>*</sup>, converts a byte array to a stream of bytes followed by a single termination character (default 0x00).</p>
<p>The <code class="literal">ByteArrayLfSerializer</code><sup>*</sup>, converts a byte array to a stream of bytes followed by a single linefeed character (0x0a).</p>
<p>The <code class="literal">ByteArrayStxEtxSerializer</code><sup>*</sup>, converts a byte array to a stream of bytes preceded by an STX (0x02) and followed by an ETX (0x03).</p>
<p>The <code class="literal">ByteArrayLengthHeaderSerializer</code>, converts a byte array to a stream of bytes preceded by a binary length in network byte order (big endian).
This a very efficient deserializer because it does not have to parse every byte looking for a termination character sequence.
It can also be used for payloads containing binary data; the above serializers only support text in the payload.
The default size of the length header is 4 bytes (Integer), allowing for messages up to (2^31 - 1) bytes.
However, the length header can be a single byte (unsigned) for messages up to 255 bytes, or an unsigned short (2 bytes) for messages up to (2^16 - 1) bytes.
If you need any other format for the header, you can subclass this class and provide implementations for the readHeader and writeHeader methods.
The absolute maximum data size supported is (2^31 - 1) bytes.</p>
<p>The <code class="literal">ByteArrayRawSerializer</code><sup>*</sup>, converts a byte array to a stream of bytes and adds no additional message demarcation data; with this (de)serializer, the end of a message is indicated by the client closing the socket in an orderly fashion.
When using this serializer, message reception will hang until the client closes the socket, or a timeout occurs; a timeout will NOT result in a message.
When this serializer is being used, and the client is a Spring Integration application, the client must use a connection factory that is configured with single-use=true - this causes the adapter to close the socket after sending the message; the serializer will not, itself, close the connection.
This serializer should only be used with connection factories used by channel adapters (not gateways), and the connection factories should be used by either an inbound or outbound adapter, and not both.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Before version 4.2.2, when using NIO, this serializer treated a timeout (during read) as an end of file and the
data read so far was emitted as a message.
This is unreliable and should not be used to delimit messages; it now treats such conditions as an exception.
In the unlikely event you are using it this way, the previous behavior can be restored by setting the
<code class="literal">treatTimeoutAsEndOfMessage</code> constructor argument to <code class="literal">true</code>.</p>
</td></tr></table></div>
<p>Each of these is a subclass of <code class="literal">AbstractByteArraySerializer</code> which implements both <code class="literal">org.springframework.core.serializer.Serializer</code> and <code class="literal">org.springframework.core.serializer.Deserializer</code>.
For backwards compatibility, connections using any subclass of <code class="literal">AbstractByteArraySerializer</code> for serialization will also accept a String which will be converted to a byte array first.
Each of these (de)serializers converts an input stream containing the corresponding format to a byte array payload.</p>
<p>To avoid memory exhaustion due to a badly behaved client (one that does not adhere to the protocol of the configured serializer), these serializers impose a maximum message size.
If the size is exceeded by an incoming message, an exception will be thrown.
The default maximum message size is 2048 bytes, and can be increased by setting the <code class="literal">maxMessageSize</code> property.
If you are using the default (de)serializer and wish to increase the maximum message size, you must declare it as an explicit bean with the property set and configure the connection factory to use that bean.</p>
<p>The classes marked with <sup>*</sup> above use an intermediate buffer and copy the decoded data to a final buffer of the correct
size.
Starting with <span class="emphasis"><em>version 4.3</em></span>, these can be configured with a <code class="literal">poolSize</code> property to allow these raw buffers to be reused
instead of being allocated and discarded for each message, which is the default behavior.
Setting the property to a negative value will create a pool that has no bounds.
If the pool is bounded, you can also set the <code class="literal">poolWaitTimeout</code> property (milliseconds) after which an exception is
thrown if no buffer becomes available; it defaults to infinity.
Such an exception will cause the socket to be closed.</p>
<p>If you wish to use the same mechanism in custom deserializers, subclass <code class="literal">AbstractPooledBufferByteArraySerializer</code>
instead of its super class <code class="literal">AbstractByteArraySerializer</code>, and implement <code class="literal">doDeserialize()</code> instead of <code class="literal">deserialize()</code>.
The buffer will be returned to the pool automatically.
<code class="literal">AbstractPooledBufferByteArraySerializer</code> also provides a convenient utility method <code class="literal">copyToSizedArray()</code>.</p>
<p>The <code class="literal">MapJsonSerializer</code> uses a Jackson <code class="literal">ObjectMapper</code> to convert between a <code class="literal">Map</code> and JSON.
This can be used in conjunction with a <code class="literal">MessageConvertingTcpMessageMapper</code> and a <code class="literal">MapMessageConverter</code> to transfer selected headers and the payload in a JSON format.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The Jackson <code class="literal">ObjectMapper</code> cannot demarcate messages in the stream.
Therefore, the <code class="literal">MapJsonSerializer</code> needs to delegate to another (de)serializer to handle message demarcation.
By default, a <code class="literal">ByteArrayLfSerializer</code> is used, resulting in messages with the format <code class="literal">&lt;json&gt;&lt;LF&gt;</code> on the wire, but you can configure it to use others instead.</p>
</td></tr></table></div>
<p>The final standard serializer is <code class="literal">org.springframework.core.serializer.DefaultSerializer</code> which can be used to convert Serializable objects using java serialization.<code class="literal">org.springframework.core.serializer.DefaultDeserializer</code> is provided for inbound deserialization of streams containing Serializable objects.</p>
<p>To implement a custom (de)serializer pair, implement the <code class="literal">org.springframework.core.serializer.Deserializer</code> and <code class="literal">org.springframework.core.serializer.Serializer</code> interfaces.</p>
<p>If you do not wish to use the default (de)serializer (<code class="literal">ByteArrayCrLfSerializer</code>), you must supply <code class="literal">serializer</code> and <code class="literal">deserializer</code> attributes on the connection factory (example below).</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"javaSerializer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.core.serializer.DefaultSerializer"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"javaDeserializer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.core.serializer.DefaultDeserializer"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">deserializer</span>=<span class="hl-value">"javaDeserializer"</span>
    <span class="hl-attribute">serializer</span>=<span class="hl-value">"javaSerializer"</span><span class="hl-tag">/&gt;</span></pre>
<p>A server connection factory that uses <code class="literal">java.net.Socket</code> connections and uses Java serialization on the wire.</p>
<p>For full details of the attributes available on connection factories, see the reference at the end of this section.</p>
<p>By default, reverse DNS lookups are done on inbound packets to convert IP addresses to hostnames for use in message headers.
In environments where DNS is not configured, this can cause connection delays.
This default behavior can be overridden by setting the <code class="literal">lookup-host</code> attribute to "false".</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It is possible to modify the creation of and/or attributes of sockets - see <a class="xref" href="ip.html#ssl-tls" title="31.10&nbsp;SSL/TLS Support">Section&nbsp;31.10, &#8220;SSL/TLS Support&#8221;</a>.
As is noted there, such modifications are possible whether or not SSL is being used.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="caching-cf" href="#caching-cf"></a>31.3.1&nbsp;TCP Caching Client Connection Factory</h3></div></div></div>

<p>As noted above, TCP sockets can be <span class="emphasis"><em>single-use</em></span> (one request/response) or shared.
Shared sockets do not perform well with outbound gateways, in high-volume environments, because the socket can only process one request/response at a time.</p>
<p>To improve performance, users could use collaborating channel adapters instead of gateways, but that requires application-level message correlation.
See <a class="xref" href="ip.html#ip-correlation" title="31.8&nbsp;TCP Message Correlation">Section&nbsp;31.8, &#8220;TCP Message Correlation&#8221;</a> for more information.</p>
<p>Spring Integration 2.2 introduced a caching client connection factory, where a pool of shared sockets is used, allowing a gateway to process multiple concurrent requests with a pool of shared connections.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="failover-cf" href="#failover-cf"></a>31.3.2&nbsp;TCP Failover Client Connection Factory</h3></div></div></div>

<p>It is now possible to configure a TCP connection factory that supports failover to one or more other servers.
When sending a message, the factory will iterate over all its configured factories until either the message can be sent, or no connection can be found.
Initially, the first factory in the configured list is used; if a connection subsequently fails the next factory will become the current factory.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"failCF"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.ip.tcp.connection.FailoverClientConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"clientFactory1"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"clientFactory2"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>When using the failover connection factory, the singleUse property must be consistent between the factory itself and the list of factories it is configured to use.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ip-interceptors" href="#ip-interceptors"></a>31.4&nbsp;TCP Connection Interceptors</h2></div></div></div>

<p>Connection factories can be configured with a reference to a <code class="literal">TcpConnectionInterceptorFactoryChain</code>.
Interceptors can be used to add behavior to connections, such as negotiation, security, and other setup.
No interceptors are currently provided by the framework but, for an example, see the <code class="literal">InterceptedSharedConnectionTests</code> in the source repository.</p>
<p>The <code class="literal">HelloWorldInterceptor</code> used in the test case works as follows:</p>
<p>When configured with a client connection factory, when the first message is sent over a connection that is intercepted, the interceptor sends <span class="emphasis"><em>Hello</em></span> over the connection, and expects to receive <span class="emphasis"><em>world!</em></span>.
When that occurs, the negotiation is complete and the original message is sent; further messages that use the same connection are sent without any additional negotiation.</p>
<p>When configured with a server connection factory, the interceptor requires the first message to be <span class="emphasis"><em>Hello</em></span> and, if it is, returns <span class="emphasis"><em>world!</em></span>.
Otherwise it throws an exception causing the connection to be closed.</p>
<p>All <code class="literal">TcpConnection</code> methods are intercepted.
Interceptor instances are created for each connection by an interceptor factory.
If an interceptor is stateful, the factory should create a new instance for each connection; if there is no state, the same interceptor can wrap each connection.
Interceptor factories are added to the configuration of an interceptor factory chain, which is provided to a connection factory using the <code class="literal">interceptor-factory</code> attribute.
Interceptors must extend <code class="literal">TcpConnectionInterceptorSupport</code>; factories must implement the <code class="literal">TcpConnectionInterceptorFactory</code> interface.
<code class="literal">TcpConnectionInterceptorSupport</code> is provided with passthrough methods; by extending this class, you only need to implement those methods you wish to intercept.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"helloWorldInterceptorFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.ip.tcp.connection.TcpConnectionInterceptorFactoryChain"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"interceptors"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;array&gt;</span>
            <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.ip.tcp.connection.HelloWorldInterceptorFactory"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/array&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"12345"</span>
    <span class="hl-attribute">using-nio</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">single-use</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">interceptor-factory-chain</span>=<span class="hl-value">"helloWorldInterceptorFactory"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"12345"</span>
    <span class="hl-attribute">single-use</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">so-timeout</span>=<span class="hl-value">"100000"</span>
    <span class="hl-attribute">using-nio</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">interceptor-factory-chain</span>=<span class="hl-value">"helloWorldInterceptorFactory"</span><span class="hl-tag">/&gt;</span></pre>
<p>Configuring a connection interceptor factory chain.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tcp-events" href="#tcp-events"></a>31.5&nbsp;TCP Connection Events</h2></div></div></div>

<p>Beginning with version 3.0, changes to <code class="literal">TcpConnection</code> s are reported by <code class="literal">TcpConnectionEvent</code> s.
<code class="literal">TcpConnectionEvent</code> is a subclass of <code class="literal">ApplicationEvent</code> and thus can be received by any <code class="literal">ApplicationListener</code> defined in the <code class="literal">ApplicationContext</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The following is deprecated as of <span class="emphasis"><em>version 4.2</em></span>; use the generic Event Inbound Channel Adapter instead.
See <a class="xref" href="applicationevent.html#appevent-inbound" title="12.1&nbsp;Receiving Spring Application Events">Section&nbsp;12.1, &#8220;Receiving Spring Application Events&#8221;</a>.</p>
<p>For convenience, a <code class="literal">&lt;int-ip:tcp-connection-event-inbound-channel-adapter/&gt;</code> is provided.
This adapter will receive all <code class="literal">TcpConnectionEvent</code> s (by default), and send them to its <code class="literal">channel</code>.
The adapter accepts an <code class="literal">event-type</code> attribute, which is a list of class names for events that should be sent.
This can be used if an application subclasses <code class="literal">TcpConnectionEvent</code> for some reason, and wishes to only receive those events.
Omitting this attribute will mean that all <code class="literal">TcpConnectionEvent</code> s will be sent.
You can also use this to limit which <code class="literal">TcpConnectionEvent</code> s you are interested in ( <code class="literal">TcpConnectionOpenEvent</code>, <code class="literal">TcpConnectionCloseEvent</code>, or <code class="literal">TcpConnectionExceptionEvent</code>).</p>
</td></tr></table></div>
<p><code class="literal">TcpConnectionEvents</code> have the following properties:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">connectionId</code> - the connection identifier which can be used in a message header to send data to the connection
</li><li class="listitem">
<code class="literal">connectionFactoryName</code> - the bean name of the connection factory the connection belongs to
</li><li class="listitem">
<code class="literal">throwable</code> - the <code class="literal">Throwable</code> (for <code class="literal">TcpConnectionExceptionEvent</code> events only)
</li><li class="listitem">
<code class="literal">source</code> - the <code class="literal">TcpConnection</code>; this can be used, for example, to determine the remote IP Address with <code class="literal">getHostAddress()</code> (cast required)
</li></ul></div>
<p>In addition, since <span class="emphasis"><em>version 4.0</em></span> the standard deserializers discussed in <a class="xref" href="ip.html#connection-factories" title="31.3&nbsp;TCP Connection Factories">Section&nbsp;31.3, &#8220;TCP Connection Factories&#8221;</a> now emit <code class="literal">TcpDeserializationExceptionEvent</code> s when problems are encountered decoding the data stream.
These events contain the exception, the buffer that was in the process of being built, and an offset into the buffer (if available) at the point the exception occurred.
Applications can use a normal <code class="literal">ApplicationListener</code>, or see <a class="xref" href="applicationevent.html#appevent-inbound" title="12.1&nbsp;Receiving Spring Application Events">Section&nbsp;12.1, &#8220;Receiving Spring Application Events&#8221;</a>, to capture these events, allowing analysis of the problem.</p>
<p>Starting with <span class="emphasis"><em>versions 4.0.7, 4.1.3</em></span>, <code class="literal">TcpConnectionServerExceptionEvent</code> s are published whenever an unexpected exception occurs on a server socket (such as a <code class="literal">BindException</code> when the server socket is in use).
These events have a reference to the connection factory and the cause.</p>
<p>Starting with <span class="emphasis"><em>version 4.2</em></span>, <code class="literal">TcpConnectionFailedCorrelationEvent</code> s are published whenever an endpoint (inbound gateway or
collaborating outbound channel adapter) receives a message that cannot be routed to a connection because the
<code class="literal">ip_connectionId</code> header is invalid.
Outbound gateways also publish this event when a late reply is received (the sender thread has timed out).
The event contains the connection id as well as an exception in the <code class="literal">cause</code> property that contains the failed message.</p>
<p>Starting with <span class="emphasis"><em>version 4.3</em></span>, a <code class="literal">TcpConnectionServerListeningEvent</code> is emitted when a server connection factory is started.
This is useful when the factory is configured to listen on port 0, meaning that the operating system chooses the port.
It can also be used instead of polling <code class="literal">isListening()</code>, if you need to wait before starting some other process that will
connect to the socket.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>To avoid delaying the listening thread from accepting connections, the event is published on a separate
thread.</p>
</td></tr></table></div>
<p>Starting with <span class="emphasis"><em>version 4.3.2</em></span>, a <code class="literal">TcpConnectionFailedEvent</code> is emitted whenever a client connection can&#8217;t be created.
The source of the event is the connection factory which can be used to determine the host and port to which the connection could not be established.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tcp-adapters" href="#tcp-adapters"></a>31.6&nbsp;TCP Adapters</h2></div></div></div>

<p>TCP inbound and outbound channel adapters that utilize the above connection factories are provided.
These adapters have attributes <code class="literal">connection-factory</code> and <code class="literal">channel</code>.
The channel attribute specifies the channel on which messages arrive at an outbound adapter and on which messages are placed by an inbound adapter.
The connection-factory attribute indicates which connection factory is to be used to manage connections for the adapter.
While both inbound and outbound adapters can share a connection factory, server connection factories are always <span class="emphasis"><em>owned</em></span> by an inbound adapter; client connection factories are always <span class="emphasis"><em>owned</em></span> by an outbound adapter.
One, and only one, adapter of each type may get a reference to a connection factory.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"javaSerializer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.core.serializer.DefaultSerializer"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"javaDeserializer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.core.serializer.DefaultDeserializer"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"server"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">deserializer</span>=<span class="hl-value">"javaDeserializer"</span>
    <span class="hl-attribute">serializer</span>=<span class="hl-value">"javaSerializer"</span>
    <span class="hl-attribute">using-nio</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">single-use</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"#{server.port}"</span>
    <span class="hl-attribute">single-use</span>=<span class="hl-value">"true"</span>
    <span class="hl-attribute">so-timeout</span>=<span class="hl-value">"10000"</span>
    <span class="hl-attribute">deserializer</span>=<span class="hl-value">"javaDeserializer"</span>
    <span class="hl-attribute">serializer</span>=<span class="hl-value">"javaSerializer"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"input"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"replies"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:queue/&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundClient"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"input"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"client"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inboundClient"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"replies"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"client"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inboundServer"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"loop"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"server"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int-ip:tcp-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundServer"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"loop"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"server"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"loop"</span><span class="hl-tag">/&gt;</span></pre>
<p>In this configuration, messages arriving in channel <span class="emphasis"><em>input</em></span> are serialized over connections created by <span class="emphasis"><em>client</em></span> received at the server and placed on channel <span class="emphasis"><em>loop</em></span>.
Since <span class="emphasis"><em>loop</em></span> is the input channel for <span class="emphasis"><em>outboundServer</em></span> the message is simply looped back over the same connection and received by <span class="emphasis"><em>inboundClient</em></span> and deposited in channel <span class="emphasis"><em>replies</em></span>.
Java serialization is used on the wire.</p>
<p>Normally, inbound adapters use a type="server" connection factory, which listens for incoming connection requests.
In some cases, it is desirable to establish the connection in reverse, whereby the inbound adapter connects to an external server and then waits for inbound messages on that connection.</p>
<p>This topology is supported by using <span class="emphasis"><em>client-mode="true"</em></span> on the inbound adapter.
In this case, the connection factory must be of type <span class="emphasis"><em>client</em></span> and must have <span class="emphasis"><em>single-use</em></span> set to false.</p>
<p>Two additional attributes are used to support this mechanism: <span class="emphasis"><em>retry-interval</em></span> specifies (in milliseconds) how often the framework will attempt to reconnect after a connection failure.
<span class="emphasis"><em>scheduler</em></span> is used to supply a <code class="literal">TaskScheduler</code> used to schedule the connection attempts, and to test that the connection is still active.</p>
<p>For an outbound adapter, the connection is normally established when the first message is sent.
<span class="emphasis"><em>client-mode="true"</em></span> on an outbound adapter will cause the connection to be established when the adapter is started.
Adapters are automatically started by default.
Again, the connection factory must be of type client and have <span class="emphasis"><em>single-use</em></span> set to false and <span class="emphasis"><em>retry-interval</em></span> and <span class="emphasis"><em>scheduler</em></span> are also supported.
If a connection fails, it will be re-established either by the scheduler or when the next message is sent.</p>
<p>For both inbound and outbound, if the adapter is started, you may force the adapter to establish a connection by sending a &lt;control-bus /&gt; command: <code class="literal">@adapter_id.retryConnection()</code> and examine the current state with <code class="literal">@adapter_id.isClientModeConnected()</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tcp-gateways" href="#tcp-gateways"></a>31.7&nbsp;TCP Gateways</h2></div></div></div>

<p>The inbound TCP gateway <code class="literal">TcpInboundGateway</code> and outbound TCP gateway <code class="literal">TcpOutboundGateway</code> use a server and client connection factory respectively.
Each connection can process a single request/response at a time.</p>
<p>The inbound gateway, after constructing a message with the incoming payload and sending it to the requestChannel, waits for a response and sends the payload from the response message by writing it to the connection.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For the inbound gateway, care must be taken to retain, or populate, the <span class="emphasis"><em>ip_connectionId</em></span> header because it is used to correlate the message to a connection.
Messages that originate at the gateway will automatically have the header set.
If the reply is constructed as a new message, you will need to set the header.
The header value can be captured from the incoming message.</p>
</td></tr></table></div>
<p>As with inbound adapters, inbound gateways normally use a type="server" connection factory, which listens for incoming connection requests.
In some cases, it is desirable to establish the connection in reverse, whereby the inbound gateway connects to an external server and then waits for, and replies to, inbound messages on that connection.</p>
<p>This topology is supported by using <span class="emphasis"><em>client-mode="true"</em></span> on the inbound gateway.
In this case, the connection factory must be of type <span class="emphasis"><em>client</em></span> and must have <span class="emphasis"><em>single-use</em></span> set to false.</p>
<p>Two additional attributes are used to support this mechanism: <span class="emphasis"><em>retry-interval</em></span> specifies (in milliseconds) how often the framework will attempt to reconnect after a connection failure.
<span class="emphasis"><em>scheduler</em></span> is used to supply a <code class="literal">TaskScheduler</code> used to schedule the connection attempts, and to test that the connection is still active.</p>
<p>If the gateway is started, you may force the gateway to establish a connection by sending a &lt;control-bus /&gt; command: <code class="literal">@adapter_id.retryConnection()</code> and examine the current state with <code class="literal">@adapter_id.isClientModeConnected()</code>.</p>
<p>The outbound gateway, after sending a message over the connection, waits for a response and constructs a response message and puts in on the reply channel.
Communications over the connections are single-threaded.
Users should be aware that only one message can be handled at a time and, if another thread attempts to send a message before the current response has been received, it will block until any previous requests are complete (or time out).
If, however, the client connection factory is configured for single-use connections each new request gets its own connection and is processed immediately.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inGateway"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"tcpChannel"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"replyChannel"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"cfServer"</span>
    <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"10000"</span><span class="hl-tag">/&gt;</span></pre>
<p>A simple inbound TCP gateway; if a connection factory configured with the default (de)serializer is used, messages will be \r\n delimited data and the gateway can be used by a simple client such as telnet.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outGateway"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"tcpChannel"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"replyChannel"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"cfClient"</span>
    <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"10000"</span>
    <span class="hl-attribute">remote-timeout</span>=<span class="hl-value">"10000"</span><span class="hl-tag">/&gt;</span> <span class="hl-comment">&lt;!-- or e.g.
remote-timeout-expression="headers['timeout']" --&gt;</span></pre>
<p>A simple outbound TCP gateway.</p>
<p><code class="literal">client-mode</code> is not currently available with the outbound gateway.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ip-correlation" href="#ip-correlation"></a>31.8&nbsp;TCP Message Correlation</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview" href="#_overview"></a>31.8.1&nbsp;Overview</h3></div></div></div>

<p>One goal of the IP Endpoints is to provide communication with systems other than another Spring Integration application.
For this reason, only message payloads are sent and received, by default.
Since 3.0, headers can be transferred, using JSON, Java serialization, or with custom <code class="literal">Serializer</code> s and <code class="literal">Deserializer</code> s; see <a class="xref" href="ip.html#ip-headers" title="31.8.4&nbsp;Transferring Headers">Section&nbsp;31.8.4, &#8220;Transferring Headers&#8221;</a> for more information.
No message correlation is provided by the framework, except when using the gateways, or collaborating channel adapters on the server side.
In the paragraphs below we discuss the various correlation techniques available to applications.
In most cases, this requires specific application-level correlation of messages, even when message payloads contain some natural correlation data (such as an order number).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gateways" href="#_gateways"></a>31.8.2&nbsp;Gateways</h3></div></div></div>

<p>The gateways will automatically correlate messages.
However, an outbound gateway should only be used for relatively low-volume use.
When the connection factory is configured for a single shared connection to be used for all message pairs (<span class="emphasis"><em>single-use="false"</em></span>), only one message can be processed at a time.
A new message will have to wait until the reply to the previous message has been received.
When a connection factory is configured for each new message to use a new connection (<span class="emphasis"><em>single-use="true"</em></span>), the above restriction does not apply.
While this may give higher throughput than a shared connection environment, it comes with the overhead of opening and closing a new connection for each message pair.</p>
<p>Therefore, for high-volume messages, consider using a collaborating pair of channel adapters.
However, you will need to provide collaboration logic.</p>
<p>Another solution, introduced in Spring Integration 2.2, is to use a <code class="literal">CachingClientConnectionFactory</code>, which allows the use of a pool of shared connections.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_collaborating_outbound_and_inbound_channel_adapters" href="#_collaborating_outbound_and_inbound_channel_adapters"></a>31.8.3&nbsp;Collaborating Outbound and Inbound Channel Adapters</h3></div></div></div>

<p>To achieve high-volume throughput (avoiding the pitfalls of using gateways as mentioned above) you may consider configuring a pair of collaborating outbound and inbound channel adapters.
Collaborating adapters can also be used (server-side or client-side) for totally asynchronous communication (rather than with request/reply semantics).
On the server side, message correlation is automatically handled by the adapters because the inbound adapter adds a header allowing the outbound adapter to determine which connection to use to send the reply message.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>On the server side, care must be taken to populate the <span class="emphasis"><em>ip_connectionId</em></span> header because it is used to correlate the message to a connection.
Messages that originate at the inbound adapter will automatically have the header set.
If you wish to construct other messages to send, you will need to set the header.
The header value can be captured from an incoming message.</p>
</td></tr></table></div>
<p>On the client side, the application will have to provide its own correlation logic, if needed.
This can be done in a number of ways.</p>
<p>If the message payload has some natural correlation data, such as a transaction id or an order number, AND there is no need to retain any information (such as a reply channel header) from the original outbound message, the correlation is simple and would done at the application level in any case.</p>
<p>If the message payload has some natural correlation data, such as a transaction id or an order number, but there is a need to retain some information (such as a reply channel header) from the original outbound message, you may need to retain a copy of the original outbound message (perhaps by using a publish-subscribe channel) and use an aggregator to recombine the necessary data.</p>
<p>For either of the previous two paragraphs, if the payload has no natural correlation data, you may need to provide a transformer upstream of the outbound channel adapter to enhance the payload with such data.
Such a transformer may transform the original payload to a new object containing both the original payload and some subset of the message headers.
Of course, live objects (such as reply channels) from the headers can not be included in the transformed payload.</p>
<p>If such a strategy is chosen you will need to ensure the connection factory has an appropriate serializer/deserializer pair to handle such a payload, such as the <code class="literal">DefaultSerializer/Deserializer</code> which use java serialization, or a custom serializer and deserializer.
The <code class="literal">ByteArray*Serializer</code> options mentioned in <a class="xref" href="ip.html#connection-factories" title="31.3&nbsp;TCP Connection Factories">Section&nbsp;31.3, &#8220;TCP Connection Factories&#8221;</a>, including the default <code class="literal">ByteArrayCrLfSerializer</code>, do not support such payloads, unless the transformed payload is a <code class="literal">String</code> or <code class="literal">byte[]</code>,</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Before the 2.2 release, when a <span class="emphasis"><em>client</em></span> connection factory was used by collaborating channel adapters, the <span class="emphasis"><em>so-timeout</em></span> attribute defaulted to the default reply timeout (10 seconds).
This meant that if no data were received by the inbound adapter for this period of time, the socket was closed.</p>
<p>This default behavior was not appropriate in a truly asynchronous environment, so it now defaults to an infinite timeout.
You can reinstate the previous default behavior by setting the <span class="emphasis"><em>so-timeout</em></span> attribute on the client connection factory to 10000 milliseconds.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ip-headers" href="#ip-headers"></a>31.8.4&nbsp;Transferring Headers</h3></div></div></div>

<p>TCP is a streaming protocol; <code class="literal">Serializers</code> and <code class="literal">Deserializers</code> are used to demarcate messages within the stream.
Prior to 3.0, only message payloads (String or byte[]) could be transferred over TCP.
Beginning with 3.0, you can now transfer selected headers as well as the payload.
It is important to understand, though, that "live" objects, such as the <code class="literal">replyChannel</code> header cannot be serialized.</p>
<p>Sending header information over TCP requires some additional configuration.</p>
<p>The first step is to provide the <code class="literal">ConnectionFactory</code> with a <code class="literal">MessageConvertingTcpMessageMapper</code> using the <code class="literal">mapper</code> attribute.
This mapper delegates to any <code class="literal">MessageConverter</code> implementation to convert the message to/from some object that can be (de)serialized by the configured <code class="literal">serializer</code> and <code class="literal">deserializer</code>.</p>
<p>A <code class="literal">MapMessageConverter</code> is provided, which allows the specification of a list of headers that will be added to a <code class="literal">Map</code> object, along with the payload.
The generated Map has two entries: <code class="literal">payload</code> and <code class="literal">headers</code>.
The <code class="literal">headers</code> entry is itself a <code class="literal">Map</code> containing the selected headers.</p>
<p>The second step is to provide a (de)serializer that can convert between a <code class="literal">Map</code> and some wire format.
This can be a custom <code class="literal">(de)Serializer</code>, which would typically be needed if the peer system is not a Spring Integration application.</p>
<p>A <code class="literal">MapJsonSerializer</code> is provided that will convert a Map to/from JSON.
This uses a Spring Integration <code class="literal">JsonObjectMapper</code> to perform this function.
You can provide a custom <code class="literal">JsonObjectMapper</code> if needed.
By default, the serializer inserts a linefeed`0x0a` character between objects.
See the JavaDocs for more information.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>At the time of writing, the <code class="literal">JsonObjectMapper</code> uses whichever version of <code class="literal">Jackson</code> is on the classpath.</p>
</td></tr></table></div>
<p>You can also use standard Java serialization of the Map, using the <code class="literal">DefaultSerializer</code> and <code class="literal">DefaultDeserializer</code>.</p>
<p>The following example shows the configuration of a connection factory that transfers the <code class="literal">correlationId</code>, <code class="literal">sequenceNumber</code>, and <code class="literal">sequenceSize</code> headers using JSON.</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"12345"</span>
    <span class="hl-attribute">mapper</span>=<span class="hl-value">"mapper"</span>
    <span class="hl-attribute">serializer</span>=<span class="hl-value">"jsonSerializer"</span>
    <span class="hl-attribute">deserializer</span>=<span class="hl-value">"jsonSerializer"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mapper"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"o.sf.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageConverter"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.sf.integration.support.converter.MapMessageConverter"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"headerNames"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;list&gt;</span>
                    <span class="hl-tag">&lt;value&gt;</span>correlationId<span class="hl-tag">&lt;/value&gt;</span>
                    <span class="hl-tag">&lt;value&gt;</span>sequenceNumber<span class="hl-tag">&lt;/value&gt;</span>
                    <span class="hl-tag">&lt;value&gt;</span>sequenceSize<span class="hl-tag">&lt;/value&gt;</span>
                <span class="hl-tag">&lt;/list&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jsonSerializer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.sf.integration.ip.tcp.serializer.MapJsonSerializer"</span><span class="hl-tag"> /&gt;</span></pre>
<p>A message sent with the above configuration, with payload <span class="emphasis"><em>foo</em></span> would appear on the wire like so:</p>
<pre class="programlisting">{"headers":{"correlationId":"bar","sequenceSize":5,"sequenceNumber":1},"payload":"foo"}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="note_nio" href="#note_nio"></a>31.9&nbsp;A Note About NIO</h2></div></div></div>

<p>Using NIO (see <code class="literal">using-nio</code> in <a class="xref" href="ip.html#ip-endpoint-reference" title="31.12&nbsp;IP Configuration Attributes">Section&nbsp;31.12, &#8220;IP Configuration Attributes&#8221;</a>) avoids dedicating a thread to read from each socket.
For a small number of sockets, you will likely find that <span class="emphasis"><em>not</em></span> using NIO, together with an async handoff (e.g.
to a <code class="literal">QueueChannel</code>), will perform as well as, or better than, using NIO.</p>
<p>Consider using NIO when handling a large number of connections.
However, the use of NIO has some other ramifications.
A pool of threads (in the task executor) is shared across all the sockets; each incoming message is assembled and sent to the configured channel as a separate unit of work on a thread selected from that pool.
Two sequential messages arriving on the <span class="emphasis"><em>same</em></span> socket <span class="emphasis"><em>might</em></span> be processed by different threads.
This means that the order in which the messages are sent to the channel is indeterminate; the strict ordering of the messages arriving on the socket is not maintained.</p>
<p>For some applications, this is not an issue; for others it is.
If strict ordering is required, consider setting <code class="literal">using-nio</code> to false and using async handoff.</p>
<p>Alternatively, you may choose to insert a resequencer downstream of the inbound endpoint to return the messages to their proper sequence.
Set <span class="emphasis"><em>apply-sequence</em></span> to true on the connection factory, and messages arriving on a TCP connection will have <span class="emphasis"><em>sequenceNumber</em></span> and <span class="emphasis"><em>correlationId</em></span> headers set.
The resequencer uses these headers to return the messages to their proper sequence.</p>
<p><span class="emphasis"><em>Pool Size</em></span></p>
<p>The pool size attribute is no longer used; previously, it specified the size of the default thread pool when a task-executor was not specified.
It was also used to set the connection backlog on server sockets.
The first function is no longer needed (see below); the second function is replaced by the <span class="emphasis"><em>backlog</em></span> attribute.</p>
<p>Previously, when using a fixed thread pool task executor (which was the default), with NIO, it was possible to get a deadlock and processing would stop.
The problem occurred when a buffer was full, a thread reading from the socket was trying to add more data to the buffer, and there were no threads available to make space in the buffer.
This only occurred with a very small pool size, but it could be possible under extreme conditions.
Since 2.2, two changes have eliminated this problem.
First, the default task executor is a cached thread pool executor.
Second, deadlock detection logic has been added such that if thread starvation occurs, instead of deadlocking, an exception is thrown, thus releasing the deadlocked resources.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Now that the default task executor is unbounded, it is possible that an out of memory condition might occur with high rates of incoming messages, if message processing takes extended time.
If your application exhibits this type of behavior, you are advised to use a pooled task executor with an appropriate pool size, but see the next section.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_thread_pool_task_executor_with_caller_runs_policy" href="#_thread_pool_task_executor_with_caller_runs_policy"></a>31.9.1&nbsp;Thread Pool Task Executor with CALLER_RUNS Policy</h3></div></div></div>

<p>There are some important considerations when using a fixed thread pool with the <code class="literal">CallerRunsPolicy</code> (<code class="literal">CALLER_RUNS</code> when using the <code class="literal">&lt;task/&gt;</code> namespace) and the queue capacity is small.</p>
<p>The following does not apply if you are not using a fixed thread pool.</p>
<p>With NIO connections there are 3 distinct task types; the IO Selector processing is performed on one dedicated thread - detecting events, accepting new connections, and dispatching the IO read operations to other threads, using the task executor.
When an IO reader thread (to which the read operation is dispatched) reads data, it hands off to another thread to assemble the incoming message; large messages may take several reads to complete.
These "assembler" threads can block waiting for data.
When a new read event occurs, the reader determines if this socket already has an assembler and runs a new one if not.
When the assembly process is complete, the assembler thread is returned to the pool.</p>
<p>This can cause a deadlock when the pool is exhausted and the CALLER_RUNS rejection policy is in use, and the task queue is full.
When the pool is empty and there is no room in the queue, the IO selector thread receives an <code class="literal">OP_READ</code> event and dispatches the read using the executor; the queue is full, so the selector thread itself starts the read process; now, it detects that there is not an assembler for this socket and, before it does the read, fires off an assembler; again, the queue is full, and the selector thread becomes the assembler.
The assembler is now blocked awaiting the data to be read, which will never happen.
The connection factory is now deadlocked because the selector thread can&#8217;t handle new events.</p>
<p>We must avoid the selector (or reader) threads performing the assembly task to avoid this deadlock.
It is desirable to use seperate pools for the IO and assembly operations.</p>
<p>The framework provides a <code class="literal">CompositeExecutor</code>, which allows the configuration of two distinct executors; one for performing IO operations, and one for message assembly.
In this environment, an IO thread can never become an assembler thread, and the deadlock cannot occur.</p>
<p>In addition, the task executors should be configured to use a <code class="literal">AbortPolicy</code> (ABORT when using <code class="literal">&lt;task&gt;</code>).
When an IO cannot be completed, it is deferred for a short time and retried continually until it can be completed and an assembler allocated.
By default, the delay is 100ms but it can be changed using the <code class="literal">readDelay</code> property on the connection factory (<code class="literal">read-delay</code> when configuring with the XML namespace).</p>
<p>Example configuration of the composite executor is shown below.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">private</span> CompositeExecutor compositeExecutor() {
    ThreadPoolTaskExecutor ioExec = <span class="hl-keyword">new</span> ThreadPoolTaskExecutor();
    ioExec.setCorePoolSize(<span class="hl-number">4</span>);
    ioExec.setMaxPoolSize(<span class="hl-number">10</span>);
    ioExec.setQueueCapacity(<span class="hl-number">0</span>);
    ioExec.setThreadNamePrefix(<span class="hl-string">"io-"</span>);
    ioExec.setRejectedExecutionHandler(<span class="hl-keyword">new</span> AbortPolicy());
    ioExec.initialize();
    ThreadPoolTaskExecutor assemblerExec = <span class="hl-keyword">new</span> ThreadPoolTaskExecutor();
    assemblerExec.setCorePoolSize(<span class="hl-number">4</span>);
    assemblerExec.setMaxPoolSize(<span class="hl-number">10</span>);
    assemblerExec.setQueueCapacity(<span class="hl-number">0</span>);
    assemblerExec.setThreadNamePrefix(<span class="hl-string">"assembler-"</span>);
    assemblerExec.setRejectedExecutionHandler(<span class="hl-keyword">new</span> AbortPolicy());
    assemblerExec.initialize();
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CompositeExecutor(ioExec, assemblerExec);
}</pre>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTaskExecutor"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.util.CompositeExecutor"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"io"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"assembler"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"io"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"4-10"</span> <span class="hl-attribute">queue-capacity</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">rejection-policy</span>=<span class="hl-value">"ABORT"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"assembler"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"4-10"</span> <span class="hl-attribute">queue-capacity</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">rejection-policy</span>=<span class="hl-value">"ABORT"</span><span class="hl-tag"> /&gt;</span></pre>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTaskExecutor"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.util.CompositeExecutor"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"threadNamePrefix"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"io-"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"corePoolSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"4"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxPoolSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"8"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"queueCapacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"0"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"rejectedExecutionHandler"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"java.util.concurrent.ThreadPoolExecutor.AbortPolicy"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"threadNamePrefix"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"assembler-"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"corePoolSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"4"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxPoolSize"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"queueCapacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"0"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"rejectedExecutionHandler"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"java.util.concurrent.ThreadPoolExecutor.AbortPolicy"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssl-tls" href="#ssl-tls"></a>31.10&nbsp;SSL/TLS Support</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overview_2" href="#_overview_2"></a>31.10.1&nbsp;Overview</h3></div></div></div>

<p>Secure Sockets Layer/Transport Layer Security is supported.
When using NIO, the JDK 5+ <code class="literal">SSLEngine</code> feature is used to handle handshaking after the connection is established.
When not using NIO, standard <code class="literal">SSLSocketFactory</code> and <code class="literal">SSLServerSocketFactory</code> objects are used to create connections.
A number of strategy interfaces are provided to allow significant customization; default implementations of these interfaces provide for the simplest way to get started with secure communications.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_getting_started" href="#_getting_started"></a>31.10.2&nbsp;Getting Started</h3></div></div></div>

<p>Regardless of whether NIO is being used, you need to configure the <code class="literal">ssl-context-support</code> attribute on the connection factory.
This attribute references a &lt;bean/&gt; definition that describes the location and passwords for the required key stores.</p>
<p>SSL/TLS peers require two keystores each; a keystore containing private/public key pairs identifying the peer; a truststore, containing the public keys for peers that are trusted.
See the documentation for the <code class="literal">keytool</code> utility provided with the JDK.
The essential steps are</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Create a new key pair and store in a keystore.
</li><li class="listitem">
Export the public key.
</li><li class="listitem">
Import the public key into the peer&#8217;s truststore.
</li></ol></div>
<p>Repeat for the other peer.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It is common in test cases to use the same key stores on both peers, but this should be avoided for production.</p>
</td></tr></table></div>
<p>After establishing the key stores, the next step is to indicate their locations to the <code class="literal">TcpSSLContextSupport</code> bean, and provide a reference to that bean to the connection factory.</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sslContextSupport"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"o.sf.integration.ip.tcp.connection.support.DefaultTcpSSLContextSupport"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"client.ks"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"client.truststore.ks"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;ip:tcp-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"clientFactory"</span>
    <span class="hl-attribute">type</span>=<span class="hl-value">"client"</span>
    <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">port</span>=<span class="hl-value">"1234"</span>
    <span class="hl-attribute">ssl-context-support</span>=<span class="hl-value">"sslContextSupport"</span><span class="hl-tag"> /&gt;</span></pre>
<p>The <code class="literal">DefaulTcpSSLContextSupport</code> class also has an optional <code class="literal">protocol</code> property, which can be <code class="literal">SSL</code> or <code class="literal">TLS</code> (default).</p>
<p>The keystore file names (first two constructor arguments) use the Spring <code class="literal">Resource</code> abstraction; by default the files will be located on the classpath, but this can be overridden by using the <code class="literal">file:</code> prefix, to find the files on the filesystem instead.</p>
<p>Starting with <span class="emphasis"><em>version 4.3.6</em></span>, when using NIO, you can specify an <code class="literal">ssl-handshake-timeout</code> (seconds) on the connection factory.
This timeout (default 30) is used during SSL handshake when waiting for data; if the timeout is exceeded, the process is aborted and the socket closed.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-techniques" href="#advanced-techniques"></a>31.11&nbsp;Advanced Techniques</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_strategy_interfaces" href="#_strategy_interfaces"></a>31.11.1&nbsp;Strategy Interfaces</h3></div></div></div>

<p>In many cases, the configuration described above is all that is needed to enable secure communication over TCP/IP.
However, a number of strategy interfaces are provided to allow customization and modification of socket factories and sockets.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">TcpSSLContextSupport</code>
</li><li class="listitem">
<code class="literal">TcpSocketFactorySupport</code>
</li><li class="listitem">
<code class="literal">TcpSocketSupport</code>
</li><li class="listitem">
<code class="literal">TcpNioConnectionSupport</code>
</li></ul></div>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TcpSSLContextSupport {

    SSLContext getSSLContext() <span class="hl-keyword">throws</span> Exception;

}</pre>
<p>Implementations of this interface are responsible for creating an SSLContext.
The implementation provided by the framework is the <code class="literal">DefaultTcpSSLContextSupport</code> described above.
If you require different behavior, implement this interface and provide the connection factory with a reference to a bean of your class' implementation.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TcpSocketFactorySupport {

    ServerSocketFactory getServerSocketFactory();

    SocketFactory getSocketFactory();

}</pre>
<p>Implementations of this interface are responsible for obtaining references to <code class="literal">ServerSocketFactory</code> and <code class="literal">SocketFactory</code>.
Two implementations are provided; the first is <code class="literal">DefaultTcpNetSocketFactorySupport</code> for non-SSL sockets (when no <code class="literal">ssl-context-support</code> attribute is defined); this simply uses the JDK&#8217;s default factories.
The second implementation is <code class="literal">DefaultTcpNetSSLSocketFactorySupport</code>; this is used, by default, when an <code class="literal">ssl-context-support</code> attribute is defined; it uses the <code class="literal">SSLContext</code> created by that bean to create the socket factories.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This interface only applies if <code class="literal">using-nio</code> is "false"; socket factories are not used by NIO.</p>
</td></tr></table></div>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TcpSocketSupport {

    <span class="hl-keyword">void</span> postProcessServerSocket(ServerSocket serverSocket);

    <span class="hl-keyword">void</span> postProcessSocket(Socket socket);

}</pre>
<p>Implementations of this interface can modify sockets after they are created, and after all configured attributes have been applied, but before the sockets are used.
This applies whether or not NIO is being used.
For example, you could use an implementation of this interface to modify the supported cipher suites on an SSL socket, or you could add a listener that gets notified after SSL handshaking is complete.
The sole implementation provided by the framework is the <code class="literal">DefaultTcpSocketSupport</code> which does not modify the sockets in any way</p>
<p>To supply your own implementation of <code class="literal">TcpSocketFactorySupport</code> or <code class="literal">TcpSocketSupport</code>, provide the connection factory with references to beans of your custom type using the <code class="literal">socket-factory-support</code> and <code class="literal">socket-support</code> attributes, respectively.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TcpNioConnectionSupport {

    TcpNioConnection createNewConnection(SocketChannel socketChannel,
            <span class="hl-keyword">boolean</span> server, <span class="hl-keyword">boolean</span> lookupHost,
            ApplicationEventPublisher applicationEventPublisher,
            String connectionFactoryName) <span class="hl-keyword">throws</span> Exception;

}</pre>
<p>This interface is invoked to create <code class="literal">TcpNioConnection</code> objects (or subclasses).
Two implementations are provided <code class="literal">DefaultTcpNioSSLConnectionSupport</code> and <code class="literal">DefaultTcpNioConnectionSupport</code> which are used depending on whether SSL is in use or not.
A common use case would be to subclass <code class="literal">DefaultTcpNioSSLConnectionSupport</code> and override <code class="literal">postProcessSSLEngine</code>; see the example below.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_example_enabling_ssl_client_authentication" href="#_example_enabling_ssl_client_authentication"></a>31.11.2&nbsp;Example: Enabling SSL Client Authentication</h3></div></div></div>

<p>To enable client certificate authentication when using SSL, the technique depends on whether NIO is in use or not.
When NIO is not being used, provide a custom <code class="literal">TcpSocketSupport</code> implementation to post-process the server socket:</p>
<pre class="programlisting">serverFactory.setTcpSocketSupport(<span class="hl-keyword">new</span> DefaultTcpSocketSupport() {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> postProcessServerSocket(ServerSocket serverSocket) {
        ((SSLServerSocket) serverSocket).setNeedClientAuth(true);
    }

});</pre>
<p>(When using XML configuration, provide a reference to your bean using the <code class="literal">socket-support</code> attribute).</p>
<p>When using NIO, provide a custom <code class="literal">TcpNioSslConnectionSupport</code> implementation to post-process the <code class="literal">SSLEngine</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DefaultTcpNioSSLConnectionSupport tcpNioConnectionSupport() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DefaultTcpNioSSLConnectionSupport(serverSslContextSupport) {

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> postProcessSSLEngine(SSLEngine sslEngine) {
                sslEngine.setNeedClientAuth(true);
            }

    }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> TcpNioServerConnectionFactory server() {
    ...
    serverFactory.setTcpNioConnectionSupport(tcpNioConnectionSupport());
    ...
}</pre>
<p>(When using XML configuration, since <span class="emphasis"><em>version 4.3.7</em></span>, provide a reference to your bean using the <code class="literal">nio-connection-support</code> attribute).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ip-endpoint-reference" href="#ip-endpoint-reference"></a>31.12&nbsp;IP Configuration Attributes</h2></div></div></div>

<div class="table"><a name="d5e17567" href="#d5e17567"></a><p class="title"><b>Table&nbsp;31.1.&nbsp;Connection Factory Attributes</b></p><div class="table-contents">

<table summary="Connection Factory Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Client?</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Server?</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>client, server</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Determines whether the connection factory is a client or server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>host</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The host name or ip address of the destination.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>port</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The port.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>serializer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>An implementation of <code class="literal">Serializer</code> used to serialize the payload.
Defaults to <code class="literal">ByteArrayCrLfSerializer</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>deserializer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>An implementation of <code class="literal">Deserializer</code> used to deserialize the payload.
Defaults to <code class="literal">ByteArrayCrLfSerializer</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>using-nio</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not connection uses NIO.
Refer to the java.nio package for more information.
See <a class="xref" href="ip.html#note_nio" title="31.9&nbsp;A Note About NIO">Section&nbsp;31.9, &#8220;A Note About NIO&#8221;</a>.
Default false.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>using-direct-buffers</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When using NIO, whether or not the connection uses direct buffers.
Refer to <code class="literal">java.nio.ByteBuffer</code> documentation for more information.
Must be false if using-nio is false.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>apply-sequence</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When using NIO, it may be necessary to resequence messages.
When this attribute is set to true, <span class="emphasis"><em>correlationId</em></span> and <span class="emphasis"><em>sequenceNumber</em></span> headers will be added to received messages.
See <a class="xref" href="ip.html#note_nio" title="31.9&nbsp;A Note About NIO">Section&nbsp;31.9, &#8220;A Note About NIO&#8221;</a>.
Default false.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Defaults to 0 (infinity), except for server connection factories with single-use="true".
In that case, it defaults to the default reply timeout (10 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-send-buffer-size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.Socket.
setSendBufferSize()</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-receive-buffer- size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.Socket.
setReceiveBufferSize()</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-keep-alive</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.Socket.
setKeepAlive()</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-linger</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Sets linger to true with supplied value.
See <code class="literal">java.net.Socket.
setSoLinger()</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-tcp-no-delay</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.Socket.
setTcpNoDelay()</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-traffic-class</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.Socket.
setTrafficClass()</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>local-address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>On a multi-homed system, specifies an IP address for the interface to which the socket will be bound.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>task-executor</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies a specific Executor to be used for socket handling.
If not supplied, an internal cached thread executor will be used.
Needed on some platforms that require the use of specific task executors such as a WorkManagerTaskExecutor.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>single-use</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies whether a connection can be used for multiple messages.
If true, a new connection will be used for each message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>pool-size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>This attribute is no longer used.
For backward compatibility, it sets the backlog but users should use backlog to specify the connection backlog in server factories</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>backlog</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Sets the connection backlog for server factories.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>lookup-host</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies whether reverse lookups are done on IP addresses to convert to host names for use in message headers.
If false, the IP address is used instead.
Defaults to true.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>interceptor-factory-chain</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <a class="xref" href="ip.html#ip-interceptors" title="31.4&nbsp;TCP Connection Interceptors">Section&nbsp;31.4, &#8220;TCP Connection Interceptors&#8221;</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ssl-context-support</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <a class="xref" href="ip.html#ssl-tls" title="31.10&nbsp;SSL/TLS Support">Section&nbsp;31.10, &#8220;SSL/TLS Support&#8221;</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>socket-factory-support</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <a class="xref" href="ip.html#ssl-tls" title="31.10&nbsp;SSL/TLS Support">Section&nbsp;31.10, &#8220;SSL/TLS Support&#8221;</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>socket-support</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <a class="xref" href="ip.html#ssl-tls" title="31.10&nbsp;SSL/TLS Support">Section&nbsp;31.10, &#8220;SSL/TLS Support&#8221;</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>nio-connection-support</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <a class="xref" href="ip.html#advanced-techniques" title="31.11&nbsp;Advanced Techniques">Section&nbsp;31.11, &#8220;Advanced Techniques&#8221;</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>read-delay</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>Y</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>long &gt; 0</p></td><td style="" align="left" valign="top"><p>The delay (in milliseconds) before retrying a read after the previous attempt failed due to insufficient threads.
Default 100.
Only applies if <code class="literal">using-nio</code> is <code class="literal">true</code>.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="ip-udp-ib-atts" href="#ip-udp-ib-atts"></a><p class="title"><b>Table&nbsp;31.2.&nbsp;UDP Inbound Channel Adapter Attributes</b></p><div class="table-contents">

<table summary="UDP Inbound Channel Adapter Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>port</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The port on which the adapter listens.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>multicast</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not the udp adapter uses multicast.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>multicast-address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When multicast is true, the multicast address to which the adapter joins.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>pool-size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies the concurrency.
Specifies how many packets can be handled concurrently.
It only applies if task-executor is not configured.
Defaults to 5.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>task-executor</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies a specific Executor to be used for socket handling.
If not supplied, an internal pooled executor will be used.
Needed on some platforms that require the use of specific task executors such as a WorkManagerTaskExecutor.
See pool-size for thread requirements.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>receive-buffer-size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The size of the buffer used to receive DatagramPackets.
Usually set to the MTU size.
If a smaller buffer is used than the size of the sent packet, truncation can occur.
This can be detected by means of the check-length attribute..</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>check-length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not a udp adapter expects a data length field in the packet received.
Used to detect packet truncation.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.DatagramSocket</code> setSoTimeout() methods for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-send-buffer-size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Used for udp acknowledgment packets.
See <code class="literal">java.net.DatagramSocket</code> setSendBufferSize() methods for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-receive-buffer- size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.DatagramSocket</code> setReceiveBufferSize() for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>local-address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>On a multi-homed system, specifies an IP address for the interface to which the socket will be bound.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>error-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If an Exception is thrown by a downstream component, the MessagingException message containing the exception and failed message is sent to this channel.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>lookup-host</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="" align="left" valign="top"><p>Specifies whether reverse lookups are done on IP addresses to convert to host names for use in message headers.
If false, the IP address is used instead.
Defaults to true.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="d5e17980" href="#d5e17980"></a><p class="title"><b>Table&nbsp;31.3.&nbsp;UDP Outbound Channel Adapter Attributes</b></p><div class="table-contents">

<table summary="UDP Outbound Channel Adapter Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>host</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The host name or ip address of the destination.
For multicast udp adapters, the multicast address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>port</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The port on the destination.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>multicast</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not the udp adapter uses multicast.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>acknowledge</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not a udp adapter requires an acknowledgment from the destination.
when enabled, requires setting the following 4 attributes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ack-host</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When acknowledge is true, indicates the host or ip address to which the acknowledgment should be sent.
Usually the current host, but may be different, for example when Network Address Transaction (NAT) is being used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ack-port</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When acknowledge is true, indicates the port to which the acknowledgment should be sent.
The adapter listens on this port for acknowledgments.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ack-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When acknowledge is true, indicates the time in milliseconds that the adapter will wait for an acknowledgment.
If an acknowledgment is not received in time, the adapter will throw an exception.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>min-acks-for- success</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Defaults to 1.
For multicast adapters, you can set this to a larger value, requiring acknowledgments from multiple destinations.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>check-length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Whether or not a udp adapter includes a data length field in the packet sent to the destination.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>time-to-live</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>For multicast adapters, specifies the time to live attribute for the <code class="literal">MulticastSocket</code>; controls the scope of the multicasts.
Refer to the Java API documentation for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.DatagramSocket</code> setSoTimeout() methods for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-send-buffer-size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>See <code class="literal">java.net.DatagramSocket</code> setSendBufferSize() methods for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>so-receive-buffer- size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Used for udp acknowledgment packets.
See <code class="literal">java.net.DatagramSocket</code> setReceiveBufferSize() methods for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>local-address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>On a multi-homed system, for the UDP adapter, specifies an IP address for the interface to which the socket will be bound for reply messages.
For a multicast adapter it is also used to determine which interface the multicast packets will be sent over.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>task-executor</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specifies a specific Executor to be used for acknowledgment handling.
If not supplied, an internal single threaded executor will be used.
Needed on some platforms that require the use of specific task executors such as a WorkManagerTaskExecutor.
One thread will be dedicated to handling acknowledgments (if the acknowledge option is true).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>destination-expression</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>SpEL expression</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A SpEL expression to be evaluated to determine which <code class="literal">SocketAddress</code> to use as a destination address for the
outgoing UDP packets.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>socket-expression</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>SpEL expression</p></td><td style="" align="left" valign="top"><p>A SpEL expression to be evaluated to determine which datagram socket use for sending outgoing UDP packets.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="d5e18104" href="#d5e18104"></a><p class="title"><b>Table&nbsp;31.4.&nbsp;TCP Inbound Channel Adapter Attributes</b></p><div class="table-contents">

<table summary="TCP Inbound Channel Adapter Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The channel to which inbound messages will be sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>connection-factory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If the connection factory has a type <span class="emphasis"><em>server</em></span>, the factory is <span class="emphasis"><em>owned</em></span> by this adapter.
If it has a type <span class="emphasis"><em>client</em></span>, it is <span class="emphasis"><em>owned</em></span> by an outbound channel adapter and this adapter will receive any incoming messages on the connection created by the outbound adapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>error-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If an Exception is thrown by a downstream component, the MessagingException message containing the exception and failed message is sent to this channel.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>client-mode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When true, the inbound adapter will act as a client, with respect to establishing the connection and then receive incoming messages on that connection.
Default = false.
Also see <span class="emphasis"><em>retry-interval</em></span> and <span class="emphasis"><em>scheduler</em></span>.
The connection factory must be of type <span class="emphasis"><em>client</em></span> and have <span class="emphasis"><em>single-use</em></span> set to false.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>retry-interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When in <span class="emphasis"><em>client-mode</em></span>, specifies the number of milliseconds to wait between connection attempts, or after a connection failure.
Default 60,000 (60 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>scheduler</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="" align="left" valign="top"><p>Specifies a <code class="literal">TaskScheduler</code> to use for managing the <span class="emphasis"><em>client-mode</em></span> connection.
Defaults to a <code class="literal">ThreadPoolTaskScheduler</code> with a pool size of `.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="d5e18166" href="#d5e18166"></a><p class="title"><b>Table&nbsp;31.5.&nbsp;TCP Outbound Channel Adapter Attributes</b></p><div class="table-contents">

<table summary="TCP Outbound Channel Adapter Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The channel on which outbound messages arrive.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>connection-factory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If the connection factory has a type <span class="emphasis"><em>client</em></span>, the factory is <span class="emphasis"><em>owned</em></span> by this adapter.
If it has a type <span class="emphasis"><em>server</em></span>, it is <span class="emphasis"><em>owned</em></span> by an inbound channel adapter and this adapter will attempt to correlate messages to the connection on which an original inbound message was received.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>client-mode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When true, the outbound adapter will attempt to establish the connection as soon as it is started.
When false, the connection is established when the first message is sent.
Default = false.
Also see <span class="emphasis"><em>retry-interval</em></span> and <span class="emphasis"><em>scheduler</em></span>.
The connection factory must be of type <span class="emphasis"><em>client</em></span> and have <span class="emphasis"><em>single-use</em></span> set to false.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>retry-interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When in <span class="emphasis"><em>client-mode</em></span>, specifies the number of milliseconds to wait between connection attempts, or after a connection failure.
Default 60,000 (60 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>scheduler</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="" align="left" valign="top"><p>Specifies a <code class="literal">TaskScheduler</code> to use for managing the <span class="emphasis"><em>client-mode</em></span> connection.
Defaults to a <code class="literal">ThreadPoolTaskScheduler</code> with a pool size of `.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="d5e18222" href="#d5e18222"></a><p class="title"><b>Table&nbsp;31.6.&nbsp;TCP Inbound Gateway Attributes</b></p><div class="table-contents">

<table summary="TCP Inbound Gateway Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>connection-factory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The connection factory must be of type server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>request-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The channel to which incoming messages will be sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>reply-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The channel on which reply messages may arrive.
Usually replies will arrive on a temporary reply channel added to the inbound message header</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>reply-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The time in milliseconds for which the gateway will wait for a reply.
Default 1000 (1 second).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>error-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If an Exception is thrown by a downstream component, the MessagingException message containing the exception and failed message is sent to this channel; any reply from that flow will then be returned as a response by the gateway.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>client-mode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When true, the inbound gateway will act as a client, with respect to establishing the connection and then receive (and reply to) incoming messages on that connection.
Default = false.
Also see <span class="emphasis"><em>retry-interval</em></span> and <span class="emphasis"><em>scheduler</em></span>.
The connection factory must be of type <span class="emphasis"><em>client</em></span> and have <span class="emphasis"><em>single-use</em></span> set to false.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>retry-interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>When in <span class="emphasis"><em>client-mode</em></span>, specifies the number of milliseconds to wait between connection attempts, or after a connection failure.
Default 60,000 (60 seconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>scheduler</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top"><p>true, false</p></td><td style="" align="left" valign="top"><p>Specifies a <code class="literal">TaskScheduler</code> to use for managing the <span class="emphasis"><em>client-mode</em></span> connection.
Defaults to a <code class="literal">ThreadPoolTaskScheduler</code> with a pool size of `.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="table"><a name="tcp-ob-gateway-attributes" href="#tcp-ob-gateway-attributes"></a><p class="title"><b>Table&nbsp;31.7.&nbsp;TCP Outbound Gateway Attributes</b></p><div class="table-contents">

<table summary="TCP Outbound Gateway Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">Allowed Values</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>connection-factory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The connection factory must be of type client.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>request-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The channel on which outgoing messages will arrive.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>reply-channel</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional.
The channel to which reply messages may be sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>remote-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The time in milliseconds for which the gateway will wait for a reply from the remote system.
Mutually exclusive with <code class="literal">remote-timeout-expression</code>.
Default: 10000 (10 seconds).
Note: in versions prior to <span class="emphasis"><em>4.2</em></span> this value defaulted to <code class="literal">reply-timeout</code> (if set).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>remote-timeout-expression</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A SpEL expression, evaluated against the message to determine the time in milliseconds for which the gateway will wait for a reply from the remote system.
Mutually exclusive with <code class="literal">remote-timeout</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>request-timeout</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>If a single-use connection factory is not being used, The time in milliseconds for which the gateway will wait to get access to the shared connection.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>reply-timeout</p></td><td style="border-right: 0.5pt solid ; " align="center" valign="top">&nbsp;</td><td style="" align="left" valign="top"><p>The time in milliseconds for which the gateway will wait when sending the reply to the reply-channel.
Only applies if the reply-channel might block, such as a bounded QueueChannel that is currently full.</p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ip-msg-headers" href="#ip-msg-headers"></a>31.13&nbsp;IP Message Headers</h2></div></div></div>

<p>
<b>IP Message Headers.&nbsp;</b>
The following <code class="literal">MessageHeader</code> s are used by this module:
</p>
<div class="informaltable">
<table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Header Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">IpHeaders Constant</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_hostname</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>HOSTNAME</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The host name from which a TCP message or UDP packet was received.
If <code class="literal">lookupHost</code> is <code class="literal">false</code>, this will contain the ip address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>IP_ADDRESS</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The ip address from which a TCP message or UDP packet was received.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_port</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>PORT</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The remote port for a UDP packet.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_localInetAddress</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>IP_LOCAL_ADDRESS</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The local <code class="literal">InetAddress</code> to which the socket is connected (since <span class="emphasis"><em>version 4.2.5</em></span>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_ackTo</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ACKADDRESS</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The remote ip address to which UDP application-level acks will be sent.
The framework includes acknowledgment information in the data packet.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_ackId</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ACK_ID</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A correlation id for UDP application-level acks.
The framework includes acknowledgment information in the data packet.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_tcp_remotePort</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>REMOTE_PORT</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The remote port for a TCP connection.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_connectionId</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>CONNECTION_ID</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>A unique identifier for a TCP connection; set by the framework for inbound messages; when sending to a server-side inbound channel adapter, or replying to an inbound gateway, this header is required so the endpoint can determine which connection to send the message to.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ip_actualConnectionId</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>ACTUAL_ CONNECTION_ID</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>For information only - when using a cached or failover client connection factory, contains the actual underlying connection id.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>contentType</p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>MessageHeaders. CONTENT_TYPE</p></td><td style="" align="left" valign="top"><p>An optional content type for inbound messages; see below.
Note that, unlike the other header constants, this constant is in the class <code class="literal">MessageHeaders</code> not <code class="literal">IpHeaders</code>.</p></td></tr></tbody></table>
</div>
<p>For inbound messages, <code class="literal">ip_hostname</code>, <code class="literal">ip_address</code>, <code class="literal">ip_tcp_remotePort</code> and <code class="literal">ip_connectionId</code> are mapped by the default
<code class="literal">TcpHeaderMapper</code>.
Set the mapper&#8217;s <code class="literal">addContentTypeHeader</code> property to <code class="literal">true</code> and the mapper will set the <code class="literal">contentType</code> header (<code class="literal">application/octet-stream;charset="UTF-8"</code>) by default.
You can change the default by setting the <code class="literal">contentType</code> property.
Users can add additional headers by subclassing <code class="literal">TcpHeaderMapper</code> and overriding the method <code class="literal">supplyCustomHeaders</code>.
For example, when using SSL, properties of the <code class="literal">SSLSession</code> can be added by obtaining the session object from the
<code class="literal">TcpConnection</code> object which is provided as an argument to the <code class="literal">supplyCustomHeaders</code> method.</p>
<p>For outbound messages, <code class="literal">String</code> payloads are converted to <code class="literal">byte[]</code> using the default (<code class="literal">UTF-8</code>) charset.
Set the <code class="literal">charset</code> property to change the default.</p>
<p>When customizing the mapper properties, or subclassing, declare the mapper as a bean and provide an instance to the connection factory using the <code class="literal">mapper</code> property</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ip-annotation" href="#ip-annotation"></a>31.14&nbsp;Annotation-Based Configuration</h2></div></div></div>

<p>The following example from the samples repository is used to illustrate some of the configuration options when using
annotations instead of XML.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableIntegration</span></em> <a name="CO49-1" href="#CO49-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
<em><span class="hl-annotation" style="color: gray">@IntegrationComponentScan</span></em> <a name="CO49-2" href="#CO49-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> Config {

    <em><span class="hl-annotation" style="color: gray">@Value(${some.port})</span></em>
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> port;

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway(defaultRequestChannel="toTcp")</span></em> <a name="CO49-3" href="#CO49-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Gateway {

        String viaTcp(String in);

    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel="toTcp")</span></em> <a name="CO49-4" href="#CO49-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
    <span class="hl-keyword">public</span> MessageHandler tcpOutGate(AbstractClientConnectionFactory connectionFactory) {
        TcpOutboundGateway gate = <span class="hl-keyword">new</span> TcpOutboundGateway();
        gate.setConnectionFactory(connectionFactory);
        gate.setOutputChannelName(<span class="hl-string">"resultToString"</span>);
        <span class="hl-keyword">return</span> gate;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em> <a name="CO49-5" href="#CO49-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
    <span class="hl-keyword">public</span> TcpInboundGateway tcpInGate(AbstractServerConnectionFactory connectionFactory)  {
        TcpInboundGateway inGate = <span class="hl-keyword">new</span> TcpInboundGateway();
        inGate.setConnectionFactory(connectionFactory);
        inGate.setRequestChannel(fromTcp());
        <span class="hl-keyword">return</span> inGate;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> MessageChannel fromTcp() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DirectChannel();
    }

    <em><span class="hl-annotation" style="color: gray">@MessageEndpoint</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> Echo { <a name="CO49-6" href="#CO49-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>

        <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel="fromTcp", outputChannel="toEcho")</span></em>
        <span class="hl-keyword">public</span> String convert(<span class="hl-keyword">byte</span>[] bytes) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> String(bytes);
        }

        <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel="toEcho")</span></em>
        <span class="hl-keyword">public</span> String upCase(String in) {
            <span class="hl-keyword">return</span> in.toUpperCase();
        }

        <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel="resultToString")</span></em>
        <span class="hl-keyword">public</span> String convertResult(<span class="hl-keyword">byte</span>[] bytes) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> String(bytes);
        }

    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> AbstractClientConnectionFactory clientCF() { <a name="CO49-7" href="#CO49-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> TcpNetClientConnectionFactory(<span class="hl-string">"localhost"</span>, <span class="hl-keyword">this</span>.port);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> AbstractServerConnectionFactory serverCF() { <a name="CO49-8" href="#CO49-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> TcpNetServerConnectionFactory(<span class="hl-keyword">this</span>.port);
    }

}</pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Standard Spring Integration annotation enabling the infrastructure for an integration application.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Searches for <code class="literal">@MessagingGateway</code> interfaces.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The entry point to the client-side of the flow. The calling application can <code class="literal">@Autowired</code> this <code class="literal">Gateway</code> bean
and invoke its method.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Outbound endpoints consist of a <code class="literal">MessageHandler</code> and a consumer that wraps it. In this scenario, the
<code class="literal">@ServiceActivator</code> configures the endpoint according to the channel type.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Inbound endpoints (in the TCP/UDP module) are all message-driven so just need to be declared as simple <code class="literal">@Bean</code> s.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>This class provides a number of POJO methods for use in this sample flow (a <code class="literal">@Transformer</code> and <code class="literal">@ServiceActivator</code>
on the server side, and a <code class="literal">@Transformer</code> on the client side).</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The client-side connection factory.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO49-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The server-side connection factory.</p>
</td></tr></table></div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="syslog.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="twitter.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">30.&nbsp;Syslog Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;32.&nbsp;Twitter Support</td></tr></table></div></body></html>