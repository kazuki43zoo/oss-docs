<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>10.&nbsp;Messaging Endpoints</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-core-messaging.html" title="Part&nbsp;IV.&nbsp;Core Messaging"><link rel="prev" href="messaging-transformation-chapter.html" title="9.&nbsp;Message Transformation"><link rel="next" href="java-dsl.html" title="11.&nbsp;Java DSL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.&nbsp;Messaging Endpoints</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="messaging-transformation-chapter.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Core Messaging</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="java-dsl.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="messaging-endpoints-chapter" href="#messaging-endpoints-chapter"></a>10.&nbsp;Messaging Endpoints</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint" href="#endpoint"></a>10.1&nbsp;Message Endpoints</h2></div></div></div>

<p>The first part of this chapter covers some background theory and reveals quite a bit about the underlying API that drives Spring Integration&#8217;s various messaging components.
This information can be helpful if you want to really understand what goes on behind the scenes.
However, if you want to get up and running with the simplified namespace-based configuration of the various elements, feel free to skip ahead to <a class="xref" href="messaging-endpoints-chapter.html#endpoint-namespace" title="10.1.4&nbsp;Endpoint Namespace Support">Section&nbsp;10.1.4, &#8220;Endpoint Namespace Support&#8221;</a> for now.</p>
<p>As mentioned in the overview, message endpoints are responsible for connecting the various messaging components to channels.
Over the next several chapters, we cover a number of different components that consume messages.
Some of these are also capable of sending reply messages.
Sending messages is quite straightforward.
As shown earlier in <a class="xref" href="messaging-channels-section.html#channel" title="6.1&nbsp;Message Channels">Section&nbsp;6.1, &#8220;Message Channels&#8221;</a>, you can send a message to a message channel.
However, receiving is a bit more complicated.
The main reason is that there are two types of consumers: <a class="ulink" href="http://www.eaipatterns.com/PollingConsumer.html" target="_top">polling consumers</a> and <a class="ulink" href="http://www.eaipatterns.com/EventDrivenConsumer.html" target="_top">event-driven consumers</a>.</p>
<p>Of the two, event-driven consumers are much simpler.
Without any need to manage and schedule a separate poller thread, they are essentially listeners with a callback method.
When connecting to one of Spring Integration&#8217;s subscribable message channels, this simple option works great.
However, when connecting to a buffering, pollable message channel, some component has to schedule and manage the polling threads.
Spring Integration provides two different endpoint implementations to accommodate these two types of consumers.
Therefore, the consumers themselves need only implement the callback interface.
When polling is required, the endpoint acts as a container for the consumer instance.
The benefit is similar to that of using a container for hosting message-driven beans, but, since these consumers are Spring-managed objects running within an <code class="literal">ApplicationContext</code>, it more closely resembles Spring&#8217;s own <code class="literal">MessageListener</code> containers.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-handler" href="#endpoint-handler"></a>10.1.1&nbsp;Message Handler</h3></div></div></div>

<p>Spring Integration&#8217;s <code class="literal">MessageHandler</code> interface is implemented by many of the components within the framework.
In other words, this is not part of the public API, and you would not typically implement <code class="literal">MessageHandler</code> directly.
Nevertheless, it is used by a message consumer for actually handling the consumed messages, so being aware of this strategy interface does help in terms of understanding the overall role of a consumer.
The interface is defined as follows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageHandler {

    <span class="hl-keyword">void</span> handleMessage(Message&lt;?&gt; message);

}</pre>
</div>
<p>Despite its simplicity, this interface provides the foundation for most of the components (routers, transformers, splitters, aggregators, service activators, and others) covered in the following chapters.
Those components each perform very different functionality with the messages they handle, but the requirements for actually receiving a message are the same, and the choice between polling and event-driven behavior is also the same.
Spring Integration provides two endpoint implementations that host these callback-based handlers and let them be connected to message channels.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-eventdrivenconsumer" href="#endpoint-eventdrivenconsumer"></a>10.1.2&nbsp;Event-driven Consumer</h3></div></div></div>

<p>Because it is the simpler of the two, we cover the event-driven consumer endpoint first.
You may recall that the <code class="literal">SubscribableChannel</code> interface provides a <code class="literal">subscribe()</code> method and that the method accepts a <code class="literal">MessageHandler</code> parameter (as shown in <a class="xref" href="messaging-channels-section.html#channel-interfaces-subscribablechannel" title="SubscribableChannel">the section called &#8220;<code class="literal">SubscribableChannel</code>&#8221;</a>).
The following listing shows the definition of the <code class="literal">subscribe</code> method:</p>
<div class="informalexample">
<pre class="programlisting">subscribableChannel.subscribe(messageHandler);</pre>
</div>
<p>Since a handler that is subscribed to a channel does not have to actively poll that channel, this is an event-driven consumer, and the implementation provided by Spring Integration accepts a <code class="literal">SubscribableChannel</code> and a <code class="literal">MessageHandler</code>, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">SubscribableChannel channel = context.getBean(<span class="hl-string">"subscribableChannel"</span>, SubscribableChannel.<span class="hl-keyword">class</span>);

EventDrivenConsumer consumer = <span class="hl-keyword">new</span> EventDrivenConsumer(channel, exampleHandler);</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-pollingconsumer" href="#endpoint-pollingconsumer"></a>10.1.3&nbsp;Polling Consumer</h3></div></div></div>

<p>Spring Integration also provides a <code class="literal">PollingConsumer</code>, and it can be instantiated in the same way except that the channel must implement <code class="literal">PollableChannel</code>, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">PollableChannel channel = context.getBean(<span class="hl-string">"pollableChannel"</span>, PollableChannel.<span class="hl-keyword">class</span>);

PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, exampleHandler);</pre>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For more information regarding polling consumers, see <a class="xref" href="messaging-channels-section.html#polling-consumer" title="6.2&nbsp;Poller">Section&nbsp;6.2, &#8220;Poller&#8221;</a> and <a class="xref" href="messaging-channels-section.html#channel-adapter" title="6.3&nbsp;Channel Adapter">Section&nbsp;6.3, &#8220;Channel Adapter&#8221;</a>.</p>
</td></tr></table></div>
<p>There are many other configuration options for the polling consumer.
For example, the trigger is a required property.
The following example shows how to set the trigger:</p>
<div class="informalexample">
<pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

consumer.setTrigger(<span class="hl-keyword">new</span> IntervalTrigger(<span class="hl-number">30</span>, TimeUnit.SECONDS));</pre>
</div>
<p>Spring Integration currently provides two implementations of the <code class="literal">Trigger</code> interface: <code class="literal">IntervalTrigger</code> and <code class="literal">CronTrigger</code>.
The <code class="literal">IntervalTrigger</code> is typically defined with a simple interval (in milliseconds) but also supports an <code class="literal">initialDelay</code> property and a boolean <code class="literal">fixedRate</code> property (the default is <code class="literal">false</code>&#8201;&#8212;&#8201;that is, no fixed delay).
The following example sets both properties:</p>
<div class="informalexample">
<pre class="programlisting">IntervalTrigger trigger = <span class="hl-keyword">new</span> IntervalTrigger(<span class="hl-number">1000</span>);
trigger.setInitialDelay(<span class="hl-number">5000</span>);
trigger.setFixedRate(true);</pre>
</div>
<p>The result of the three settings in the preceding example is a trigger that waits five seconds and then triggers every second.</p>
<p>The <code class="literal">CronTrigger</code> requires a valid cron expression.
See the <a class="ulink" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/support/CronTrigger.html" target="_top">Javadoc</a> for details.
The following example sets a new <code class="literal">CronTrigger</code>:</p>
<div class="informalexample">
<pre class="programlisting">CronTrigger trigger = <span class="hl-keyword">new</span> CronTrigger(<span class="hl-string">"*/10 * * * * MON-FRI"</span>);</pre>
</div>
<p>The result of the trigger defined in the previous example is a trigger that triggers every ten seconds, Monday through Friday.</p>
<p>In addition to the trigger, you can specify two other polling-related configuration properties: <code class="literal">maxMessagesPerPoll</code> and <code class="literal">receiveTimeout</code>.
The following example shows how to set these two properties:</p>
<div class="informalexample">
<pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

consumer.setMaxMessagesPerPoll(<span class="hl-number">10</span>);
consumer.setReceiveTimeout(<span class="hl-number">5000</span>);</pre>
</div>
<p>The <code class="literal">maxMessagesPerPoll</code> property specifies the maximum number of messages to receive within a given poll operation.
This means that the poller continues calling receive() without waiting, until either <code class="literal">null</code> is returned or the maximum value is reached.
For example, if a poller has a ten-second interval trigger and a <code class="literal">maxMessagesPerPoll</code> setting of <code class="literal">25</code>, and it is polling a channel that has 100 messages in its queue, all 100 messages can be retrieved within 40 seconds.
It grabs 25, waits ten seconds, grabs the next 25, and so on.</p>
<p>The <code class="literal">receiveTimeout</code> property specifies the amount of time the poller should wait if no messages are available when it invokes the receive operation.
For example, consider two options that seem similar on the surface but are actually quite different: The first has an interval trigger of 5 seconds and a receive timeout of 50 milliseconds, while the second has an interval trigger of 50 milliseconds and a receive timeout of 5 seconds.
The first one may receive a message up to 4950 milliseconds later than it arrived on the channel (if that message arrived immediately after one of its poll calls returned).
On the other hand, the second configuration never misses a message by more than 50 milliseconds.
The difference is that the second option requires a thread to wait. However, as a result, it can respond much more quickly to arriving messages.
This technique, known as "<code class="literal">long polling</code>", can be used to emulate event-driven behavior on a polled source.</p>
<p>A polling consumer can also delegate to a Spring <code class="literal">TaskExecutor</code>, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

TaskExecutor taskExecutor = context.getBean(<span class="hl-string">"exampleExecutor"</span>, TaskExecutor.<span class="hl-keyword">class</span>);
consumer.setTaskExecutor(taskExecutor);</pre>
</div>
<p>Furthermore, a <code class="literal">PollingConsumer</code> has a property called <code class="literal">adviceChain</code>.
This property lets you to specify a <code class="literal">List</code> of AOP advices for handling additional cross cutting concerns including transactions.
These advices are applied around the <code class="literal">doPoll()</code> method.
For more in-depth information, see the sections on AOP advice chains and transaction support under <a class="xref" href="messaging-endpoints-chapter.html#endpoint-namespace" title="10.1.4&nbsp;Endpoint Namespace Support">Section&nbsp;10.1.4, &#8220;Endpoint Namespace Support&#8221;</a>.</p>
<p>The earlier examples show dependency lookups.
However, keep in mind that these consumers are most often configured as Spring bean definitions.
In fact, Spring Integration also provides a <code class="literal">FactoryBean</code> called <code class="literal">ConsumerEndpointFactoryBean</code> that creates the appropriate consumer type based on the type of channel.
Also, Spring Integration has full XML namespace support to even further hide those details.
The namespace-based configuration is in this guide featured as each component type is introduced.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Many of the <code class="literal">MessageHandler</code> implementations can generate reply messages.
As mentioned earlier, sending messages is trivial when compared to receiving messages.
Nevertheless, when and how many reply messages are sent depends on the handler type.
For example, an aggregator waits for a number of messages to arrive and is often configured as a downstream consumer for a splitter, which can generate multiple replies for each message it handles.
When using the namespace configuration, you do not strictly need to know all of the details.
However, it still might be worth knowing that several of these components share a common base class, the <code class="literal">AbstractReplyProducingMessageHandler</code>, and that it provides a <code class="literal">setOutputChannel(..)</code> method.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-namespace" href="#endpoint-namespace"></a>10.1.4&nbsp;Endpoint Namespace Support</h3></div></div></div>

<p>Throughout this reference manual, you can find specific configuration examples for endpoint elements, such as router, transformer, service-activator, and so on.
Most of these support an <code class="literal">input-channel</code> attribute and many support an <code class="literal">output-channel</code> attribute.
After being parsed, these endpoint elements produce an instance of either the <code class="literal">PollingConsumer</code> or the <code class="literal">EventDrivenConsumer</code>, depending on the type of the <code class="literal">input-channel</code> that is referenced: <code class="literal">PollableChannel</code> or <code class="literal">SubscribableChannel</code>, respectively.
When the channel is pollable, the polling behavior is based on the endpoint element&#8217;s <code class="literal">poller</code> sub-element and its attributes.</p>
<p>The following listing lists all of the available configuration options for a <code class="literal">poller</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">cron</span>=<span class="hl-value">""</span>                                  <a name="CO12-1" href="#CO12-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
            default="false"                          <a name="CO12-2" href="#CO12-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
            error-channel=""                         <a name="CO12-3" href="#CO12-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
            fixed-delay=""                           <a name="CO12-4" href="#CO12-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
            fixed-rate=""                            <a name="CO12-5" href="#CO12-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
            id=""                                    <a name="CO12-6" href="#CO12-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
            max-messages-per-poll=""                 <a name="CO12-7" href="#CO12-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
            receive-timeout=""                       <a name="CO12-8" href="#CO12-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
            ref=""                                   <a name="CO12-9" href="#CO12-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
            task-executor=""                         <a name="CO12-10" href="#CO12-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span>
            time-unit="MILLISECONDS"                 <a name="CO12-11" href="#CO12-11"></a><span><img src="images/callouts/11.png" alt="11" border="0"></span>
            trigger=""&gt;                              <a name="CO12-12" href="#CO12-12"></a><span><img src="images/callouts/12.png" alt="12" border="0"></span>
            <span class="hl-tag">&lt;int:advice-chain /&gt;</span>                     <a name="CO12-13" href="#CO12-13"></a><span><img src="images/callouts/13.png" alt="13" border="0"></span>
            <span class="hl-tag">&lt;int:transactional /&gt;</span>                    <a name="CO12-14" href="#CO12-14"></a><span><img src="images/callouts/14.png" alt="14" border="0"></span>
<span class="hl-tag">&lt;/int:poller&gt;</span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Provides the ability to configure pollers by using Cron expressions.
The underlying implementation uses an <code class="literal">org.springframework.scheduling.support.CronTrigger</code>.
If this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-delay</code>, <code class="literal">trigger</code>, <code class="literal">fixed-rate</code>, and <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>By setting this attribute to <code class="literal">true</code>, you can define exactly one global default poller.
An exception is raised if more than one default poller is defined in the application context.
Any endpoints connected to a <code class="literal">PollableChannel</code> (<code class="literal">PollingConsumer</code>) or any <code class="literal">SourcePollingChannelAdapter</code> that does not have an explicitly configured poller then uses the global default poller.
It defaults to <code class="literal">false</code>.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Identifies the channel to which error messages are sent if a failure occurs in this poller&#8217;s invocation.
To completely suppress exceptions, you can provide a reference to the <code class="literal">nullChannel</code>.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The fixed delay trigger uses a <code class="literal">PeriodicTrigger</code> under the covers.
If you do not use the <code class="literal">time-unit</code> attribute, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-rate</code>, <code class="literal">trigger</code>, <code class="literal">cron</code>, and <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The fixed rate trigger uses a <code class="literal">PeriodicTrigger</code> under the covers.
If you do not use the <code class="literal">time-unit</code> attribute, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-delay</code>, <code class="literal">trigger</code>, <code class="literal">cron</code>, and <code class="literal">ref</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The ID referring to the poller&#8217;s underlying bean-definition, which is of type <code class="literal">org.springframework.integration.scheduling.PollerMetadata</code>.
The <code class="literal">id</code> attribute is required for a top-level poller element, unless it is the default poller (<code class="literal">default="true"</code>).</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>See <a class="xref" href="messaging-channels-section.html#channel-adapter-namespace-inbound" title="6.3.1&nbsp;Configuring An Inbound Channel Adapter">Section&nbsp;6.3.1, &#8220;Configuring An Inbound Channel Adapter&#8221;</a> for more information.
If not specified, the default value depends on the context.
If you use a <code class="literal">PollingConsumer</code>, this attribute defaults to <code class="literal">-1</code>.
However, if you use a <code class="literal">SourcePollingChannelAdapter</code>, the <code class="literal">max-messages-per-poll</code> attribute defaults to <code class="literal">1</code>.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Value is set on the underlying class <code class="literal">PollerMetadata</code>.
If not specified, it defaults to 1000 (milliseconds).
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Bean reference to another top-level poller.
The <code class="literal">ref</code> attribute must not be present on the top-level <code class="literal">poller</code> element.
However, if this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-rate</code>, <code class="literal">trigger</code>, <code class="literal">cron</code>, and <code class="literal">fixed-delay</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Provides the ability to reference a custom task executor.
See <a class="xref" href="messaging-endpoints-chapter.html#taskexecutor-support" title="TaskExecutor Support">the section called &#8220;TaskExecutor Support&#8221;</a> for further information.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-11"><span><img src="images/callouts/11.png" alt="11" border="0"></span></a> </p></td><td valign="top" align="left">
<p>This attribute specifies the <code class="literal">java.util.concurrent.TimeUnit</code> enum value on the underlying <code class="literal">org.springframework.scheduling.support.PeriodicTrigger</code>.
Therefore, this attribute can be used only in combination with the <code class="literal">fixed-delay</code> or <code class="literal">fixed-rate</code> attributes.
If combined with either <code class="literal">cron</code> or a <code class="literal">trigger</code> reference attribute, it causes a failure.
The minimal supported granularity for a <code class="literal">PeriodicTrigger</code> is milliseconds.
Therefore, the only available options are milliseconds and seconds.
If this value is not provided, any <code class="literal">fixed-delay</code> or <code class="literal">fixed-rate</code> value is interpreted as milliseconds.
Basically, this enum provides a convenience for seconds-based interval trigger values.
For hourly, daily, and monthly settings, we recommend using a <code class="literal">cron</code> trigger instead.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-12"><span><img src="images/callouts/12.png" alt="12" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Reference to any Spring-configured bean that implements the <code class="literal">org.springframework.scheduling.Trigger</code> interface.
However, if this attribute is set, none of the following attributes must be specified: <code class="literal">fixed-delay</code>, <code class="literal">fixed-rate</code>, <code class="literal">cron</code>, and <code class="literal">ref</code>.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-13"><span><img src="images/callouts/13.png" alt="13" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Allows specifying extra AOP advices to handle additional cross-cutting concerns.
See <a class="xref" href="messaging-endpoints-chapter.html#transaction-support" title="Transaction Support">the section called &#8220;Transaction Support&#8221;</a> for further information.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO12-14"><span><img src="images/callouts/14.png" alt="14" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Pollers can be made transactional.
See <a class="xref" href="messaging-endpoints-chapter.html#aop-advice-chains" title="AOP Advice chains">the section called &#8220;AOP Advice chains&#8221;</a> for further information.
Optional.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_examples" href="#_examples"></a>Examples</h4></div></div></div>

<p>A simple interval-based poller with a 1-second interval can be configured as follows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
    <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transformer&gt;</span></pre>
</div>
<p>As an alternative to using the <code class="literal">fixed-rate</code> attribute, you can also use the <code class="literal">fixed-delay</code> attribute.</p>
<p>For a poller based on a Cron expression, use the <code class="literal">cron</code> attribute instead, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
    <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">cron</span>=<span class="hl-value">"*/10 * * * * MON-FRI"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transformer&gt;</span></pre>
</div>
<p>If the input channel is a <code class="literal">PollableChannel</code>, the poller configuration is required.
Specifically, as mentioned earlier, the <code class="literal">trigger</code> is a required property of the <code class="literal">PollingConsumer</code> class.
Therefore, if you omit the <code class="literal">poller</code> sub-element for a polling consumer endpoint&#8217;s configuration, an exception may be thrown.
The exception may also be thrown if you attempt to configure a poller on the element that is connected to a non-pollable channel.</p>
<p>It is also possible to create top-level pollers, in which case only a <code class="literal">ref</code> attribute is required, as the following example shows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"weekdayPoller"</span> <span class="hl-attribute">cron</span>=<span class="hl-value">"*/10 * * * * MON-FRI"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
    <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"weekdayPoller"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transformer&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">ref</code> attribute is allowed only on the inner poller definitions.
Defining this attribute on a top-level poller results in a configuration exception being thrown during initialization of the application context.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_global_default_pollers" href="#_global_default_pollers"></a>Global Default Pollers</h5></div></div></div>

<p>To simplify the configuration even further, you can define a global default poller.
A single top-level poller within an <code class="literal">ApplicationContext</code> may have the <code class="literal">default</code> attribute set to <code class="literal">true</code>.
In that case, any endpoint with a <code class="literal">PollableChannel</code> for its input channel, that is defined within the same <code class="literal">ApplicationContext</code>, and has no explicitly configured <code class="literal">poller</code> sub-element uses that default.
The following example shows such a poller and a transformer that uses it:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"defaultPoller"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"5"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"3000"</span><span class="hl-tag">/&gt;</span>

<span class="hl-comment">&lt;!-- No &lt;poller/&gt; sub-element is necessary, because there is a default --&gt;</span>
<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
                 <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
                 <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="transaction-support" href="#transaction-support"></a>Transaction Support</h5></div></div></div>

<p>Spring Integration also provides transaction support for the pollers so that each receive-and-forward operation can be performed as an atomic unit of work.
To configure transactions for a poller, add the <code class="literal">&lt;transactional/&gt;</code> sub-element.
The following example shows the available attributes:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-delay</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span>
                       <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span>
                       <span class="hl-attribute">isolation</span>=<span class="hl-value">"REPEATABLE_READ"</span>
                       <span class="hl-attribute">timeout</span>=<span class="hl-value">"10000"</span>
                       <span class="hl-attribute">read-only</span>=<span class="hl-value">"false"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:poller&gt;</span></pre>
<p>For more information, see <a class="xref" href="transactions.html#transaction-poller" title="C.1.1&nbsp;Poller Transaction Support">Section&nbsp;C.1.1, &#8220;Poller Transaction Support&#8221;</a>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-chains" href="#aop-advice-chains"></a>AOP Advice chains</h4></div></div></div>

<p>Since Spring transaction support depends on the proxy mechanism with <code class="literal">TransactionInterceptor</code> (AOP Advice) handling transactional behavior of the message flow initiated by the poller, you must sometimes provide extra advices to handle other cross cutting behavior associated with the poller.
For that, the <code class="literal">poller</code> defines an <code class="literal">advice-chain</code>&nbsp;element that lets you add more advices in a class that&nbsp;implements the <code class="literal">MethodInterceptor</code> interface.
The following example shows how to define an <code class="literal">advice-chain</code> for a <code class="literal">poller</code>:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"advicedSa"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"goodInputWithAdvice"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"testBean"</span>
		<span class="hl-attribute">method</span>=<span class="hl-value">"good"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"10000"</span><span class="hl-tag">&gt;</span>
		 <span class="hl-tag">&lt;int:advice-chain&gt;</span>
			<span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"adviceA"</span><span class="hl-tag"> /&gt;</span>
			<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.something.SampleAdvice"</span><span class="hl-tag"> /&gt;</span>
			<span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"txAdvice"</span><span class="hl-tag"> /&gt;</span>
		<span class="hl-tag">&lt;/int:advice-chain&gt;</span>
	<span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
</div>
<p>For more information on how to implement the <code class="literal">MethodInterceptor</code> interface, see the <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api" target="_top">AOP sections of the Spring Framework Reference Guide</a>.
An advice chain can also be applied on a poller that does not have any transaction configuration, letting you enhance the behavior of the message flow initiated by the poller.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When using an advice chain, the <code class="literal">&lt;transactional/&gt;</code> child element cannot be specified.
Instead, declare a <code class="literal">&lt;tx:advice/&gt;</code> bean and add it to the <code class="literal">&lt;advice-chain/&gt;</code>.
See <a class="xref" href="transactions.html#transaction-poller" title="C.1.1&nbsp;Poller Transaction Support">Section&nbsp;C.1.1, &#8220;Poller Transaction Support&#8221;</a> for complete configuration details.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="taskexecutor-support" href="#taskexecutor-support"></a>TaskExecutor Support</h5></div></div></div>

<p>The polling threads may be executed by any instance of Spring&#8217;s <code class="literal">TaskExecutor</code> abstraction.
This enables concurrency for an endpoint or group of endpoints.
As of Spring 3.0, the core Spring Framework has a <code class="literal">task</code> namespace, and its <code class="literal">&lt;executor/&gt;</code> element supports the creation of a simple thread pool executor.
That element accepts attributes for common concurrency settings, such as pool-size and queue-capacity.
Configuring a thread-pooling executor can make a substantial difference in how the endpoint performs under load.
These settings are available for each endpoint, since the performance of an endpoint is one of the major factors to consider (the other major factor being the expected volume on the channel to which the endpoint subscribes).
To enable concurrency for a polling endpoint that is configured with the XML namespace support, provide the <code class="literal">task-executor</code> reference on its <code class="literal">&lt;poller/&gt;</code> element and then provide one or more of the properties shown in the following example:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"pool"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pool"</span>
               <span class="hl-attribute">pool-size</span>=<span class="hl-value">"5-25"</span>
               <span class="hl-attribute">queue-capacity</span>=<span class="hl-value">"20"</span>
               <span class="hl-attribute">keep-alive</span>=<span class="hl-value">"120"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>If you do not provide a task-executor, the consumer&#8217;s handler is invoked in the caller&#8217;s thread.
Note that the caller is usually the default <code class="literal">TaskScheduler</code> (see <a class="xref" href="configuration.html#namespace-taskscheduler" title="E.2&nbsp;Configuring the Task Scheduler">Section&nbsp;E.2, &#8220;Configuring the Task Scheduler&#8221;</a>).
You should also keep in mind that the <code class="literal">task-executor</code> attribute can provide a reference to any implementation of Spring&#8217;s <code class="literal">TaskExecutor</code> interface by specifying the bean name.
The <code class="literal">executor</code> element shown earlier is provided for convenience.</p>
<p>As mentioned earlier in the <a class="link" href="messaging-endpoints-chapter.html#endpoint-pollingconsumer" title="10.1.3&nbsp;Polling Consumer">background section for polling consumers</a>, you can also configure a polling consumer in such a way as to emulate event-driven behavior.
With a long <code class="literal">receive-timeout</code> and a short <code class="literal">interval-trigger</code>, you can ensure a very timely reaction to arriving messages even on a polled message source.
Note that this applies only  to sources that have a blocking wait call with a timeout.
For example, the file poller does not block.
Each receive() call returns immediately and either contains new files or not.
Therefore, even if a poller contains a long <code class="literal">receive-timeout</code>, that value would never be used in such a scenario.
On the other hand, when using Spring Integration&#8217;s own queue-based channels, the timeout value does have a chance to participate.
The following example shows how a polling consumer can receive messages nearly instantaneously:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"someQueueChannel"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">receive-timeout</span>=<span class="hl-value">"30000"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
</div>
<p>Using this approach does not carry much overhead, since, internally, it is nothing more then a timed-wait thread, which does not require nearly as much CPU resource usage as (for example) a thrashing, infinite while loop.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="polling-consumer-change-polling-rate" href="#polling-consumer-change-polling-rate"></a>10.1.5&nbsp;Changing Polling Rate at Runtime</h3></div></div></div>

<p>When configuring a poller with a <code class="literal">fixed-delay</code> or a <code class="literal">fixed-rate</code> attribute, the default implementation uses a <code class="literal">PeriodicTrigger</code> instance.
The <code class="literal">PeriodicTrigger</code> is part of the core Spring Framework.
It accepts the interval only as a constructor argument.
Therefore, it cannot be changed at runtime.</p>
<p>However, you can define your own implementation of the <code class="literal">org.springframework.scheduling.Trigger</code> interface.
You could even use the <code class="literal">PeriodicTrigger</code> as a starting point.
Then you can add a setter for the interval (period), or you can even embed your own throttling logic within the trigger itself.
The <code class="literal">period</code> property is used with each call to <code class="literal">nextExecutionTime</code> to schedule the next poll.
To use this custom trigger within pollers, declare the bean definition of the custom trigger in your application context and inject the dependency into your poller configuration by using the <code class="literal">trigger</code> attribute, which references the custom trigger bean instance.
You can now obtain a reference to the trigger bean and change the polling interval between polls.</p>
<p>For an example, see the <a class="ulink" href="https://github.com/SpringSource/spring-integration-samples/tree/master/intermediate" target="_top">Spring Integration Samples</a> project.
It contains a sample called <code class="literal">dynamic-poller</code>, which uses a custom trigger and demonstrates the ability to change the polling interval at runtime.</p>
<p>The sample provides a custom trigger that implements the <a class="ulink" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/Trigger.html" target="_top"><code class="literal">org.springframework.scheduling.Trigger</code></a> interface.
The sample&#8217;s trigger is based on Spring&#8217;s <a class="ulink" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/support/PeriodicTrigger.html" target="_top"><code class="literal">PeriodicTrigger</code></a> implementation.
However, the fields of the custom trigger are not final, and the properties have explicit getters and setters, letting you dynamically change the polling period at runtime.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>It is important to note, though, that because the Trigger method is <code class="literal">nextExecutionTime()</code>, any changes to a dynamic trigger do not take effect until the next poll, based on the existing configuration.
It is not possible to force a trigger to fire before its currently configured next execution time.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="payload-type-conversion" href="#payload-type-conversion"></a>10.1.6&nbsp;Payload Type Conversion</h3></div></div></div>

<p>Throughout this reference manual, you can also see specific configuration and implementation examples of various endpoints that accept a message or&nbsp;any arbitrary <code class="literal">Object</code> as an input parameter.
In the case of an <code class="literal">Object</code>, such a parameter is mapped to&nbsp;a message payload or part of the payload or header (when using the Spring Expression Language).
However, the type of input parameter of the endpoint method sometimes does not match the type of the payload or its part.
In this scenario, we need to perform type conversion.
Spring Integration provides a convenient way for registering type converters (by using the Spring <code class="literal">ConversionService</code>) within its own instance of a conversion service bean named <code class="literal">integrationConversionService</code>.
That bean is automatically created as soon as the first converter is defined by using the Spring Integration infrastructure.
To register a converter, you can implement <code class="literal">org.springframework.core.convert.converter.Converter</code>, <code class="literal">org.springframework.core.convert.converter.GenericConverter</code>, or <code class="literal">org.springframework.core.convert.converter.ConverterFactory</code>.</p>
<p>The <code class="literal">Converter</code> implementation is the simplest and converts from a single type to another.
For more sophistication, such as converting to a class hierarchy, you can implement a <code class="literal">GenericConverter</code> and possibly a <code class="literal">ConditionalConverter</code>.
These give you complete access to the <code class="literal">from</code> and <code class="literal">to</code> type descriptors, enabling complex conversions.
For example, if you have an abstract class called <code class="literal">Something</code> that is the target of your conversion (parameter type, channel data type, and so on), you have two concrete implementations called <code class="literal">Thing1</code> and <code class="literal">Thing</code>, and you wish to convert to one or the other based on the input type, the <code class="literal">GenericConverter</code> would be a good fit.
For more information, see the Javadoc for these interfaces:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html" target="_top">org.springframework.core.convert.converter.Converter</a>
</li><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/package-summary.html" target="_top">org.springframework.core.convert.converter.GenericConverter</a>
</li><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/ConverterFactory.html" target="_top">org.springframework.core.convert.converter.ConverterFactory</a>
</li></ul></div>
<p>When you have implemented your converter, you can register it with convenient namespace support, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:converter</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sampleConverter"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sampleConverter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.TestConverter"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>Alternately, you can use an inner bean, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:converter&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.config.xml.ConverterParserTests$TestConverter3"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:converter&gt;</span></pre>
</div>
<p>Starting with Spring Integration 4.0, you can use annotations to create the preceding configuration, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<em><span class="hl-annotation" style="color: gray">@IntegrationConverter</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TestConverter <span class="hl-keyword">implements</span> Converter&lt;Boolean, Number&gt; {

	<span class="hl-keyword">public</span> Number convert(Boolean source) {
		<span class="hl-keyword">return</span> source ? <span class="hl-number">1</span> : <span class="hl-number">0</span>;
	}

}</pre>
</div>
<p>Alternately, you can use the <code class="literal">@Configuration</code> annotation, as the following example shows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableIntegration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@IntegrationConverter</span></em>
	<span class="hl-keyword">public</span> SerializingConverter serializingConverter() {
		<span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SerializingConverter();
	}

}</pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When configuring an application context, the Spring Framework lets you add a <code class="literal">conversionService</code> bean (see <a class="ulink" href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/validation.html#core-convert-Spring-config" target="_top">Configuring a ConversionService</a> chapter).
This service is used, when needed, to perform appropriate conversions during bean creation and configuration.</p>
<p>In contrast, the <code class="literal">integrationConversionService</code> is used for runtime conversions.
These uses are quite different.
Converters that are intended for use when wiring bean constructor arguments and properties may produce unintended results if used at runtime for Spring Integration expression evaluation against messages within data type channels, payload type transformers, and so on.</p>
<p>However, if you do want to use the Spring <code class="literal">conversionService</code> as the Spring Integration <code class="literal">integrationConversionService</code>, you can configure an alias in the application context, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;alias</span> <span class="hl-attribute">name</span>=<span class="hl-value">"conversionService"</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"integrationConversionService"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>In this case, the converters provided by the <code class="literal">conversionService</code> are available for Spring Integration runtime conversion.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="content-type-conversion" href="#content-type-conversion"></a>10.1.7&nbsp;Content Type Conversion</h3></div></div></div>

<p>Starting with version 5.0, by default, the method invocation mechanism is based on the <code class="literal">org.springframework.messaging.handler.invocation.InvocableHandlerMethod</code> infrastructure.
Its <code class="literal">HandlerMethodArgumentResolver</code> implementations (such as <code class="literal">PayloadArgumentResolver</code> and <code class="literal">MessageMethodArgumentResolver</code>) can use the <code class="literal">MessageConverter</code> abstraction to convert an incoming <code class="literal">payload</code> to the target method argument type.
The conversion can be based on the <code class="literal">contentType</code> message header.
For this purpose, Spring Integration provides the <code class="literal">ConfigurableCompositeMessageConverter</code>, which delegates to a list of registered converters to be invoked until one of them returns a non-null result.
By default, this converter provides (in strict order):</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jms/support/converter/MappingJackson2MessageConverter.html" target="_top"><code class="literal">MappingJackson2MessageConverter</code></a> if the Jackson processor is present on the classpath
</li><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/ByteArrayMessageConverter.html" target="_top"><code class="literal">ByteArrayMessageConverter</code></a>
</li><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring-integration/docs/current/api//org/springframework/integration/support/converter/ObjectStringMessageConverter.html" target="_top"><code class="literal">ObjectStringMessageConverter</code></a>
</li><li class="listitem">
<a class="ulink" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/GenericMessageConverter.html" target="_top"><code class="literal">GenericMessageConverter</code></a>
</li></ol></div>
<p>See the Javadoc (linked in the preceding list) for more information about their purpose and appropriate <code class="literal">contentType</code> values for conversion.
The <code class="literal">ConfigurableCompositeMessageConverter</code> is used because it can be be supplied with any other <code class="literal">MessageConverter</code> implementations, including or excluding the previously mentioned default converters.
It can also be registered as an appropriate bean in the application context, overriding the default converter, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean(name = IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME)</span></em>
<span class="hl-keyword">public</span> ConfigurableCompositeMessageConverter compositeMessageConverter() {
    List&lt;MessageConverter&gt; converters =
        Arrays.asList(<span class="hl-keyword">new</span> MarshallingMessageConverter(jaxb2Marshaller()),
                 <span class="hl-keyword">new</span> JavaSerializationMessageConverter());
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> ConfigurableCompositeMessageConverter(converters);
}</pre>
</div>
<p>Those two new converters are registered in the composite before the defaults.
You can also not use a <code class="literal">ConfigurableCompositeMessageConverter</code> but provide your own <code class="literal">MessageConverter</code> by registering a bean with the name, <code class="literal">integrationArgumentResolverMessageConverter</code> (by setting the <code class="literal">IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME</code> property).</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">MessageConverter</code>-based (including <code class="literal">contentType</code> header) conversion is not available when using SpEL method invocation.
In this case, only the regular class-to-class conversion mentioned above in the <a class="xref" href="messaging-endpoints-chapter.html#payload-type-conversion" title="10.1.6&nbsp;Payload Type Conversion">Section&nbsp;10.1.6, &#8220;Payload Type Conversion&#8221;</a> is available.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="async-polling" href="#async-polling"></a>10.1.8&nbsp;Asynchronous Polling</h3></div></div></div>

<p>If you want the polling to be asynchronous, a poller can optionally specify a <code class="literal">task-executor</code> attribute that points to an existing instance of any <code class="literal">TaskExecutor</code> bean (Spring 3.0 provides a convenient namespace configuration through the <code class="literal">task</code> namespace).
However, there are certain things you must understand when configuring a poller with a <code class="literal">TaskExecutor</code>.&nbsp;</p>
<p>The problem is that there are two configurations in place, the poller and the <code class="literal">TaskExecutor</code>.
They must be in tune&nbsp;with each other.
Otherwise, you might end up creating an artificial memory leak.</p>
<p>Consider the following configuration:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"publishChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:queue /&gt;</span>
<span class="hl-tag">&lt;/int:channel&gt;</span>

<span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"publishChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myService"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">receive-timeout</span>=<span class="hl-value">"5000"</span><span class="hl-attribute">&nbsp;task-executor</span>=<span class="hl-value">"taskExecutor"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"50"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;task:executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"taskExecutor"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"20"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p>The preceding configuration demonstrates an out-of-tune configuration.</p>
<p>By default, the task executor has an unbounded task queue.
The poller keeps scheduling new tasks even though all the threads are blocked, waiting for either a new message to arrive or the timeout to expire.
Given that there are 20 threads executing tasks with a five-second timeout, they aree executed at a rate of 4 per second.
However, new tasks are being scheduled at a rate of 20 per second, so the internal queue in the task executor grows at a rate of 16 per second (while the process is idle), so we have a memory leak.</p>
<p>One of the ways to handle this is to set the <code class="literal">queue-capacity</code> attribute of the task executor.
Even 0 is a reasonable value.
You can also manage it by specifying what to do with messages that can not be queued by setting the <code class="literal">rejection-policy</code> attribute of the Task Executor (for example, to <code class="literal">DISCARD</code>).
In other words, there are certain details you must understand when configuring <code class="literal">TaskExecutor</code>.
See <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html" target="_top">"<code class="literal">Task Execution and Scheduling</code>"</a> in the Spring reference manual for more detail on the subject.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="endpoint-inner" href="#endpoint-inner"></a>10.1.9&nbsp;Endpoint Inner Beans</h3></div></div></div>

<p>Many endpoints are composite beans.
This includes all consumers and all polled inbound channel adapters.
Consumers (polled or event-driven) delegate to a <code class="literal">MessageHandler</code>.
Polled adapters obtain messages by delegating to a <code class="literal">MessageSource</code>.
Often, it is useful to obtain a reference to the delegate bean, perhaps to change configuration at runtime or for testing.
These beans can be obtained from the <code class="literal">ApplicationContext</code> with well known names.
<code class="literal">MessageHandler</code> instances are registered with the application context with bean IDs similar to <code class="literal">someConsumer.handler</code> (where <span class="emphasis"><em>consumer</em></span> is the value of the endpoint&#8217;s <code class="literal">id</code> attribute).
<code class="literal">MessageSource</code> instances are registered with bean IDs similar to <code class="literal">somePolledAdapter.source</code>, where <span class="emphasis"><em>somePolledAdapter</em></span> is the ID of the adapter.</p>
<p>The preceding only applies to the framework component itself.
You can instead use an inner bean definition, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleServiceActivator"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span>
            <span class="hl-attribute">output-channel</span> = <span class="hl-value">"outChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"foo"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.ExampleServiceActivator"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
</div>
<p>The bean is treated like any inner bean declared and is not registered with the application context.
If you wish to access this bean in some other manner, declare it at the top level with an <code class="literal">id</code> and use the <code class="literal">ref</code> attribute instead.
See the <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/beans.html#beans-inner-beans" target="_top">Spring Documentation</a> for more information.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-roles" href="#endpoint-roles"></a>10.2&nbsp;Endpoint Roles</h2></div></div></div>

<p>Starting with version 4.2, endpoints can be assigned to roles.
Roles let endpoints be started and stopped as a group.
This is particularly useful when using leadership election, where a set of endpoints can be started or stopped when leadership is granted or revoked, respectively.
For this purpose the framework registers a <code class="literal">SmartLifecycleRoleController</code> bean in the application context with the name <code class="literal">IntegrationContextUtils.INTEGRATION_LIFECYCLE_ROLE_CONTROLLER</code>.
Whenever it is necessary to control lifecycles, this bean can be injected or <code class="literal">@Autowired</code>:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.some.project.SomeLifecycleControl"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"roleController"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"integrationLifecycleRoleController"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<p>You can assign endpoints to roles using XML, Java configuration, or programmatically.
The following example shows how to configure endpoint roles with XML:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"ica"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"someChannel"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"'foo'"</span> <span class="hl-attribute">role</span>=<span class="hl-value">"cluster"</span>
        <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:inbound-channel-adapter&gt;</span></pre>
</div>
<p>The following example shows how to configure endpoint roles for a bean created in Java:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "sendAsyncChannel", autoStartup="false")</span></em>
<em><span class="hl-annotation" style="color: gray">@Role("cluster")</span></em>
<span class="hl-keyword">public</span> MessageHandler sendAsyncHandler() {
    <span class="hl-keyword">return</span> <span class="hl-comment">// some MessageHandler</span>
}</pre>
</div>
<p>The following example shows how to configure endpoint roles on a method in Java:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Payload("#args[0].toLowerCase()")</span></em>
<em><span class="hl-annotation" style="color: gray">@Role("cluster")</span></em>
<span class="hl-keyword">public</span> String handle(String payload) {
    <span class="hl-keyword">return</span> payload.toUpperCase();
}</pre>
</div>
<p>The following example shows how to configure endpoint roles by using the <code class="literal">SmartLifecycleRoleController</code> in Java:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span class="hl-keyword">private</span> SmartLifecycleRoleController roleController;
...
    <span class="hl-keyword">this</span>.roleController.addSmartLifeCycleToRole(<span class="hl-string">"cluster"</span>, someEndpoint);
...</pre>
</div>
<p>The following example shows how to configure endpoint roles by using an <code class="literal">IntegrationFlow</code> in Java:</p>
<div class="informalexample">
<pre class="programlisting">IntegrationFlow flow -&gt; flow
        .handle(..., e -&gt; e.role(<span class="hl-string">"cluster"</span>));</pre>
</div>
<p>Each of these adds the endpoint to the <code class="literal">cluster</code> role.</p>
<p>Invoking <code class="literal">roleController.startLifecyclesInRole("cluster")</code> and the corresponding <code class="literal">stop...</code> method starts and stops the endpoints.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Any object that implements <code class="literal">SmartLifecycle</code> can be programmatically added&#8201;&#8212;&#8201;not just endpoints.</p>
</td></tr></table></div>
<p>The <code class="literal">SmartLifecycleRoleController</code> implements <code class="literal">ApplicationListener&lt;AbstractLeaderEvent&gt;</code> and it automatically starts and stops its configured <code class="literal">SmartLifecycle</code> objects when leadership is granted or revoked (when some bean publishes <code class="literal">OnGrantedEvent</code> or <code class="literal">OnRevokedEvent</code>, respectively).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>When using leadership election to start and stop components, it is important to set the <code class="literal">auto-startup</code> XML attribute (<code class="literal">autoStartup</code> bean property) to <code class="literal">false</code> so that the application context does not start the components during context initialization.</p>
</td></tr></table></div>
<p>Starting with version 4.3.8, the <code class="literal">SmartLifecycleRoleController</code> provides several status methods:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> Collection&lt;String&gt; getRoles() <a name="CO13-1" href="#CO13-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> allEndpointsRunning(String role) <a name="CO13-2" href="#CO13-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>

<span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> noEndpointsRunning(String role) <a name="CO13-3" href="#CO13-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>

<span class="hl-keyword">public</span> Map&lt;String, Boolean&gt; getEndpointsRunningStatus(String role) <a name="CO13-4" href="#CO13-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span></pre>
</div>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO13-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns a list of the roles being managed.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO13-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns <code class="literal">true</code> if all endpoints in the role are running.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO13-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns <code class="literal">true</code> if none of the endpoints in the role are running.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO13-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Returns a map of <code class="literal">component name : running status</code>. The component name is usually the bean name.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="leadership-event-handling" href="#leadership-event-handling"></a>10.3&nbsp;Leadership Event Handling</h2></div></div></div>

<p>Groups of endpoints can be started and stopped based on leadership being granted or revoked, respectively.
This is useful in clustered scenarios where shared resources must be consumed by only a single instance.
An example of this is a file inbound channel adapter that is polling a shared directory.
(See <a class="xref" href="files.html#file-reading" title="17.1&nbsp;Reading Files">Section&nbsp;17.1, &#8220;Reading Files&#8221;</a>).</p>
<p>To participate in a leader election and be notified when elected leader, when leadership is revoked, or on failure to acquire the resources to become leader, an application creates a component in the application context called a "<code class="literal">leader initiator</code>".
Normally, a leader initiator is a <code class="literal">SmartLifecycle</code>, so it starts (optionally) when the context starts and then publishes notifications when leadership changes.
You can also receive failure notifications by setting the <code class="literal">publishFailedEvents</code> to <code class="literal">true</code> (starting with version 5.0), for cases when you want take a specific action if a failure occurs.
By convention, you should provide a <code class="literal">Candidate</code> that receives the callbacks.
You can also revoke the leadership through a <code class="literal">Context</code> object provided by the framework.
Your code can also listen for <code class="literal">o.s.i.leader.event.AbstractLeaderEvent</code> instances (the super class of <code class="literal">OnGrantedEvent</code> and <code class="literal">OnRevokedEvent</code>) and respond accordingly (for instance, by using a <code class="literal">SmartLifecycleRoleController</code>).
The events contain a reference to the <code class="literal">Context</code> object.
The following listing shows the definition of the <code class="literal">Context</code> interface:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Context {

	<span class="hl-keyword">boolean</span> isLeader();

	<span class="hl-keyword">void</span> yield();

	String getRole();

}</pre>
</div>
<p>Starting with version 5.0.6, the context provides a reference to the candidate&#8217;s role.</p>
<p>Spring Integration provides a basic implementation of a leader initiator that is based on the <code class="literal">LockRegistry</code> abstraction.
To use it, you need to create an instance as a bean, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> LockRegistryLeaderInitiator leaderInitiator(LockRegistry locks) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> LockRegistryLeaderInitiator(locks);
}</pre>
</div>
<p>If the lock registry is implemented correctly, there is only ever at most one leader.
If the lock registry also provides locks that throw exceptions (ideally, <code class="literal">InterruptedException</code>) when they expire or are broken, the duration of the leaderless periods can be as short as is allowed by the inherent latency in the lock implementation.
By default, the <code class="literal">busyWaitMillis</code> property adds some additional latency to prevent CPU starvation in the (more usual) case that the locks are imperfect and you only know they expired when you try to obtain one again.</p>
<p>See <a class="xref" href="zookeeper.html#zk-leadership" title="40.3&nbsp;Zookeeper Leadership Event Handling">Section&nbsp;40.3, &#8220;Zookeeper Leadership Event Handling&#8221;</a> for more information about leadership election and events that use Zookeeper.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gateway" href="#gateway"></a>10.4&nbsp;Messaging Gateways</h2></div></div></div>

<p>A gateway hides the messaging API provided by Spring Integration.
It lets your application&#8217;s business logic be unaware of the Spring Integration API.
By using a generic Gateway, your code interacts with only a simple interface.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-proxy" href="#gateway-proxy"></a>10.4.1&nbsp;Enter the <code class="literal">GatewayProxyFactoryBean</code></h3></div></div></div>

<p>As mentioned earlier, it would be great to have no dependency on the Spring Integration API&#8201;&#8212;&#8201;including the gateway class.
For that reason, Spring Integration provides the <code class="literal">GatewayProxyFactoryBean</code>, which generates a proxy for any interface and internally invokes the gateway methods shown below.
By using dependency injection, you can then expose the interface to your business methods.</p>
<p>The following example shows an interface that can be used to interact with Spring Integration:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">package</span> org.cafeteria;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Cafe {

    <span class="hl-keyword">void</span> placeOrder(Order order);

}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-namespace" href="#gateway-namespace"></a>10.4.2&nbsp;Gateway XML Namespace Support</h3></div></div></div>

<p>Namespace support is also provided.
It lets you configure an interface as a service, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cafeService"</span>
         <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.cafeteria.Cafe"</span>
         <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"requestChannel"</span>
         <span class="hl-attribute">default-reply-timeout</span>=<span class="hl-value">"10000"</span>
         <span class="hl-attribute">default-reply-channel</span>=<span class="hl-value">"replyChannel"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>With this configuration defined, the <code class="literal">cafeService</code> can now be injected into other beans, and the code that invokes the methods on that proxied instance of the <code class="literal">Cafe</code> interface has no awareness of the Spring Integration API.
The general approach is similar to that of Spring Remoting (RMI, HttpInvoker, and so on).
See the <a class="link" href="samples.html" title="Appendix&nbsp;G.&nbsp;Spring Integration Samples">"<code class="literal">Samples</code>"</a> Appendix for an example that uses the <code class="literal">gateway</code> element (in the Cafe demo).</p>
<p>The defaults in the preceding configuration are applied to all methods on the gateway interface.
If a reply timeout is not specified, the calling thread waits indefinitely for a reply.
See <a class="xref" href="messaging-endpoints-chapter.html#gateway-no-response" title="10.4.11&nbsp;Gateway Behavior When No response Arrives">Section&nbsp;10.4.11, &#8220;Gateway Behavior When No response Arrives&#8221;</a>.</p>
<p>The defaults can be overridden for individual methods.
See <a class="xref" href="messaging-endpoints-chapter.html#gateway-configuration-annotations" title="10.4.4&nbsp;Gateway Configuration with Annotations and XML">Section&nbsp;10.4.4, &#8220;Gateway Configuration with Annotations and XML&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-default-reply-channel" href="#gateway-default-reply-channel"></a>10.4.3&nbsp;Setting the Default Reply Channel</h3></div></div></div>

<p>Typically, you need not specify the <code class="literal">default-reply-channel</code>, since a Gateway auto-creates a temporary, anonymous reply channel, where it listens for the reply.
However, some cases may prompt you to define a <code class="literal">default-reply-channel</code> (or <code class="literal">reply-channel</code> with adapter gateways, such as HTTP, JMS, and others).</p>
<p>For some background, we briefly discuss some of the inner workings of the gateway.
A gateway creates a temporary point-to-point reply channel.
It is anonymous and is added to the message headers with the name, <code class="literal">replyChannel</code>.
When providing an explicit <code class="literal">default-reply-channel</code> (<code class="literal">reply-channel</code> with remote adapter gateways), you can point to a publish-subscribe channel, which is so named because you can add more than one subscriber to it.
Internally, Spring Integration creates a bridge between the temporary <code class="literal">replyChannel</code> and the explicitly defined <code class="literal">default-reply-channel</code>.</p>
<p>Suppose you want your reply to go not only to the gateway but also to some other consumer.
In this case, you want two things:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
A named channel to which you can subscribe
</li><li class="listitem">
That channel to be a publish-subscribe-channel
</li></ul></div>
<p>The default strategy used by the gateway does not satisfy those needs, because the reply channel added to the header is anonymous and point-to-point.
This means that no other subscriber can get a handle to it and, even if it could, the channel has point-to-point behavior such that only one subscriber would get the message.
By defining a <code class="literal">default-reply-channel</code> you can point to a channel of your choosing.
In this case, that is a <code class="literal">publish-subscribe-channel</code>.
The gateway creates a bridge from it to the temporary, anonymous reply channel that is stored in the header.</p>
<p>You might also want to explicitly provide a reply channel for monitoring or auditing through an interceptor (for example, <a class="link" href="messaging-channels-section.html#channel-wiretap" title="Wire Tap">wiretap</a>).
To configure a channel interceptor, you need a named channel.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-configuration-annotations" href="#gateway-configuration-annotations"></a>10.4.4&nbsp;Gateway Configuration with Annotations and XML</h3></div></div></div>

<p>Consider the following example, which expands on the previous <code class="literal">Cafe</code> interface example by adding a <code class="literal">@Gateway</code> annotation:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Cafe {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel="orders")</span></em>
    <span class="hl-keyword">void</span> placeOrder(Order order);

}</pre>
</div>
<p>The <code class="literal">@Header</code> annotation lets you add values that are interpreted as message headers, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FileWriter {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel="filesOut")</span></em>
    <span class="hl-keyword">void</span> write(<span class="hl-keyword">byte</span>[] content, <em><span class="hl-annotation" style="color: gray">@Header(FileHeaders.FILENAME)</span></em> String filename);

}</pre>
</div>
<p>If you prefer the XML approach to configuring gateway methods, you can add <code class="literal">method</code> elements to the gateway configuration, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myGateway"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.foo.bar.TestGateway"</span>
      <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"inputC"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:default-header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"calledMethod"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"#gatewayMethod.name"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputA"</span> <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"2"</span> <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"200"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoUpperCase"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputB"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoViaDefault"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
</div>
<p>You can also use XML to provide individual headers for each method invocation.
This could be useful if the headers you want to set are static in nature and you do not want to embed them in the gateway&#8217;s method signature by using <code class="literal">@Header</code> annotations.
For example, in the loan broker example, we want to influence how aggregation of the loan quotes is done, based on what type of request was initiated (single quote or all quotes).
Determining the type of the request by evaluating which gateway method was invoked, although possible, would violate the separation of concerns paradigm (the method is a Java artifact).
However, expressing your intention (meta information) in message headers is natural in a messaging architecture.
The following example shows how to add a different message header for each of two methods:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"loanBrokerGateway"</span>
         <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.springframework.integration.loanbroker.LoanBrokerGateway"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"getLoanQuote"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"loanBrokerPreProcessingChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"RESPONSE_TYPE"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"BEST"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"getAllLoanQuotes"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"loanBrokerPreProcessingChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"RESPONSE_TYPE"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"ALL"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
</div>
<p>In the preceding example a different value is set for the <span class="emphasis"><em>RESPONSE_TYPE</em></span> header, based on the gateway&#8217;s method.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_expressions_and_literal_global_literal_headers" href="#_expressions_and_literal_global_literal_headers"></a>Expressions and "<code class="literal">Global</code>" Headers</h4></div></div></div>

<p>The <code class="literal">&lt;header/&gt;</code> element supports <code class="literal">expression</code> as an alternative to <code class="literal">value</code>.
The SpEL expression is evaluated to determine the value of the header.
There is no <code class="literal">#root</code> object, but the following variables are available:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
#args: An <code class="literal">Object[]</code> containing the method arguments
</li><li class="listitem">
#gatewayMethod: The object (derived from <code class="literal">java.reflect.Method</code>) that represents the method in the <code class="literal">service-interface</code> that was invoked.
A header containing this variable can be used later in the flow (for example, for routing).
For example, if you wish to route on the simple method name, you might add a header with the following expression: <code class="literal">#gatewayMethod.name</code>.
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">java.reflect.Method</code> is not serializable.
A header with an expression of <code class="literal">#gatewayMethod</code> is lost if you later serialize the message.
Consequently, you may wish to use <code class="literal">#gatewayMethod.name</code> or <code class="literal">#gatewayMethod.toString()</code> in those cases.
The <code class="literal">toString()</code> method provides a <code class="literal">String</code> representation of the method, including parameter and return types.</p>
</td></tr></table></div>
<p>Since version 3.0, <code class="literal">&lt;default-header/&gt;</code> elements can be defined to add headers to all the messages produced by the gateway, regardless of the method invoked.
Specific headers defined for a method take precedence over default headers.
Specific headers defined for a method here override any <code class="literal">@Header</code> annotations in the service interface.
However, default headers do NOT override any <code class="literal">@Header</code> annotations in the service interface.</p>
<p>The gateway now also supports a <code class="literal">default-payload-expression</code>, which is applied for all methods (unless overridden).</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-mapping" href="#gateway-mapping"></a>10.4.5&nbsp;Mapping Method Arguments to a Message</h3></div></div></div>

<p>Using the configuration techniques in the previous section allows control of how method arguments are mapped to message elements (payload and headers).
When no explicit configuration is used, certain conventions are used to perform the mapping.
In some cases, these conventions cannot determine which argument is the payload and which should be mapped to headers.
Consider the following example:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> String send1(Object thing1, Map thing2);

<span class="hl-keyword">public</span> String send2(Map thing1, Map thing2);</pre>
</div>
<p>In the first case, the convention is to map the first argument to the payload (as long as it is not a <code class="literal">Map</code>) and the contents of the second argument become headers.</p>
<p>In the second case (or the first when the argument for parameter <code class="literal">thing1</code> is a <code class="literal">Map</code>), the framework cannot determine which argument should be the payload.
Consequently, mapping fails.
This can generally be resolved using a <code class="literal">payload-expression</code>, a <code class="literal">@Payload</code> annotation, or a <code class="literal">@Headers</code> annotation.</p>
<p>Alternatively (and whenever the conventions break down), you can take the entire responsibility for mapping the method calls to messages.
To do so, implement an <code class="literal">MethodArgsMessageMapper</code> and provide it to the <code class="literal">&lt;gateway/&gt;</code> by using the <code class="literal">mapper</code> attribute.
The mapper maps a <code class="literal">MethodArgsHolder</code>, which is a simple class that wraps the <code class="literal">java.reflect.Method</code> instance and an <code class="literal">Object[]</code> containing the arguments.
When providing a custom mapper, the <code class="literal">default-payload-expression</code> attribute and <code class="literal">&lt;default-header/&gt;</code> elements are not allowed on the gateway.
Similarly, the <code class="literal">payload-expression</code> attribute and <code class="literal">&lt;header/&gt;</code> elements are not allowed on any <code class="literal">&lt;method/&gt;</code> elements.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_mapping_method_arguments" href="#_mapping_method_arguments"></a>Mapping Method Arguments</h4></div></div></div>

<p>The following examples show how method arguments can be mapped to the message and shows some examples of invalid configuration:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

    <span class="hl-keyword">void</span> payloadAndHeaderMapWithoutAnnotations(String s, Map&lt;String, Object&gt; map);

    <span class="hl-keyword">void</span> payloadAndHeaderMapWithAnnotations(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s, <em><span class="hl-annotation" style="color: gray">@Headers</span></em> Map&lt;String, Object&gt; map);

    <span class="hl-keyword">void</span> headerValuesAndPayloadWithAnnotations(<em><span class="hl-annotation" style="color: gray">@Header("k1")</span></em> String x, <em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s, <em><span class="hl-annotation" style="color: gray">@Header("k2")</span></em> String y);

    <span class="hl-keyword">void</span> mapOnly(Map&lt;String, Object&gt; map); <span class="hl-comment">// the payload is the map and no custom headers are added</span>

    <span class="hl-keyword">void</span> twoMapsAndOneAnnotatedWithPayload(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> Map&lt;String, Object&gt; payload, Map&lt;String, Object&gt; headers);

    <em><span class="hl-annotation" style="color: gray">@Payload("#args[0] + #args[1] + '!'")</span></em>
    <span class="hl-keyword">void</span> payloadAnnotationAtMethodLevel(String a, String b);

    <em><span class="hl-annotation" style="color: gray">@Payload("@someBean.exclaim(#args[0])")</span></em>
    <span class="hl-keyword">void</span> payloadAnnotationAtMethodLevelUsingBeanResolver(String s);

    <span class="hl-keyword">void</span> payloadAnnotationWithExpression(<em><span class="hl-annotation" style="color: gray">@Payload("toUpperCase()")</span></em> String s);

    <span class="hl-keyword">void</span> payloadAnnotationWithExpressionUsingBeanResolver(<em><span class="hl-annotation" style="color: gray">@Payload("@someBean.sum(#this)")</span></em> String s); <span class="hl-comment">//  </span><a name="CO14-1" href="#CO14-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> twoMapsWithoutAnnotations(Map&lt;String, Object&gt; m1, Map&lt;String, Object&gt; m2);

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> twoPayloads(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s1, <em><span class="hl-annotation" style="color: gray">@Payload</span></em> String s2);

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> payloadAndHeaderAnnotationsOnSameParameter(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> <em><span class="hl-annotation" style="color: gray">@Header("x")</span></em> String s);

    <span class="hl-comment">// invalid</span>
    <span class="hl-keyword">void</span> payloadAndHeadersAnnotationsOnSameParameter(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> <em><span class="hl-annotation" style="color: gray">@Headers</span></em> Map&lt;String, Object&gt; map);

}</pre>
</div>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO14-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Note that, in this example, the SpEL variable, <code class="literal">#this</code>, refers to the argument&#8201;&#8212;&#8201;in this case, the value of <code class="literal">s</code>.</p>
</td></tr></table></div>
<p>The XML equivalent looks a little different, since there is no <code class="literal">#this</code> context for the method argument.
However, expressions can refer to method arguments by using the <code class="literal">#args</code> variable, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myGateway"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.something.MyGateway"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send1"</span> <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"#args[0] + 'thing2'"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send2"</span> <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"@someBean.sum(#args[0])"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send3"</span> <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"#method"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"send4"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thing1"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"#args[2].toUpperCase()"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="messaging-gateway-annotation" href="#messaging-gateway-annotation"></a>10.4.6&nbsp;<code class="literal">@MessagingGateway</code> Annotation</h3></div></div></div>

<p>Starting with version 4.0, gateway service interfaces can be marked with a <code class="literal">@MessagingGateway</code> annotation instead of requiring the definition of a <code class="literal">&lt;gateway /&gt;</code> xml element for configuration.
The following pair of examples compares the two approaches for configuring the same gateway:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myGateway"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.something.TestGateway"</span>
      <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"inputC"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;int:default-header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"calledMethod"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"#gatewayMethod.name"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputA"</span> <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"2"</span> <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"200"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoUpperCase"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputB"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thing1"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"thing2"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/int:method&gt;</span>
  <span class="hl-tag">&lt;int:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"echoViaDefault"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:gateway&gt;</span></pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway(name = "myGateway", defaultRequestChannel = "inputC",
		  defaultHeaders = @GatewayHeader(name = "calledMethod",
		                           expression="#gatewayMethod.name"))</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TestGateway {

   <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "inputA", replyTimeout = 2, requestTimeout = 200)</span></em>
   String echo(String payload);

   <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "inputB", headers = @GatewayHeader(name = "thing1", value="thing2"))</span></em>
   String echoUpperCase(String payload);

   String echoViaDefault(String payload);

}</pre>
</div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Similarly to the XML version, when Spring Integration discovers these annotations during a component scan, it creates the <code class="literal">proxy</code> implementation with its messaging infrastructure.
To perform this scan and register the <code class="literal">BeanDefinition</code> in the application context, add the <code class="literal">@IntegrationComponentScan</code> annotation to a <code class="literal">@Configuration</code> class.
The standard <code class="literal">@ComponentScan</code> infrastructure does not deal with interfaces.
Consequently, we introduced the custom <code class="literal">@IntegrationComponentScan</code> logic  to fine the <code class="literal">@MessagingGateway</code> annotation on the interfaces and register <code class="literal">GatewayProxyFactoryBean</code> instances for them.
See also <a class="xref" href="configuration.html#annotations" title="E.5&nbsp;Annotation Support">Section&nbsp;E.5, &#8220;Annotation Support&#8221;</a>.</p>
</td></tr></table></div>
<p>Along with the <code class="literal">@MessagingGateway</code> annotation you can mark a service interface with the <code class="literal">@Profile</code> annotation to avoid the bean creation, if such a profile is not active.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you have no XML configuration, the <code class="literal">@EnableIntegration</code> annotation is required on at least one <code class="literal">@Configuration</code> class.
See <a class="xref" href="overview.html#configuration-enable-integration" title="5.5&nbsp;Configuration and @EnableIntegration">Section&nbsp;5.5, &#8220;Configuration and <code class="literal">@EnableIntegration</code>&#8221;</a> for more information.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-calling-no-argument-methods" href="#gateway-calling-no-argument-methods"></a>10.4.7&nbsp;Invoking No-Argument Methods</h3></div></div></div>

<p>When invoking methods on a Gateway interface that do not have any arguments, the default behavior is to receive a <code class="literal">Message</code> from a <code class="literal">PollableChannel</code>.</p>
<p>Sometimes, however, you may want to trigger no-argument methods so that you can interact with other components downstream that do not require user-provided parameters, such as triggering no-argument SQL calls or stored procedures.</p>
<p>To achieve send-and-receive semantics, you must provide a payload.
To generate a payload, method parameters on the interface are not necessary.
You can either use the <code class="literal">@Payload</code> annotation or the <code class="literal">payload-expression</code> attribute in XML on the <code class="literal">method</code> element.
The following list includes a few examples of what the payloads could be:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
a literal string
</li><li class="listitem">
#gatewayMethod.name
</li><li class="listitem">
new java.util.Date()
</li><li class="listitem">
@someBean.someMethod()'s return value
</li></ul></div>
<p>The following example shows how to use the <code class="literal">@Payload</code> annotation:</p>
<pre class="programlisting">public interface Cafe {

    @Payload("new java.util.Date()")
    List<span class="hl-tag">&lt;Order&gt;</span> retrieveOpenOrders();

}</pre>
<p>If a method has no argument and no return value but does contain a payload expression, it is treated as a send-only operation.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-error-handling" href="#gateway-error-handling"></a>10.4.8&nbsp;Error Handling</h3></div></div></div>

<p>The gateway invocation can result in errors.
By default, any error that occurs downstream is re-thrown "<code class="literal">as is</code>" upon the gateway&#8217;s method invocation.
For example, consider the following simple flow:</p>
<div class="informalexample">
<pre class="screen">gateway -&gt; service-activator</pre>
</div>
<p>If the service invoked by the service activator throws a <code class="literal">MyException</code> (for example), the framework wraps it in a <code class="literal">MessagingException</code> and attaches the message passed to the service activator in the <code class="literal">failedMessage</code> property.
Consequently, any logging performed by the framework has full the context of the failure.
By default, when the exception is caught by the gateway, the <code class="literal">MyException</code> is unwrapped and thrown to the caller.
You can configure a <code class="literal">throws</code> clause on the gateway method declaration to match the particular exception type in the cause chain.
For example, if you want to catch a whole <code class="literal">MessagingException</code> with all the messaging information of the reason of downstream error, you should have a gateway method similar to the following:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

    <span class="hl-keyword">void</span> performProcess() <span class="hl-keyword">throws</span> MessagingException;

}</pre>
</div>
<p>Since we encourage POJO programming, you may not want to expose the caller to messaging infrastructure.</p>
<p>If your gateway method does not have a <code class="literal">throws</code> clause, the gateway traverses the cause tree, looking for a <code class="literal">RuntimeException</code> that is not a <code class="literal">MessagingException</code>.
If none is found, the framework throws the <code class="literal">MessagingException</code>.
If the <code class="literal">MyException</code> in the preceding discussion has a cause of <code class="literal">SomeOtherException</code> and your method <code class="literal">throws SomeOtherException</code>, the gateway further unwraps that and throws it to the caller.</p>
<p>When a gateway is declared with no <code class="literal">service-interface</code>, an internal framework interface <code class="literal">RequestReplyExchanger</code> is used.</p>
<p>Consider the following example:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> RequestReplyExchanger {

	Message&lt;?&gt; exchange(Message&lt;?&gt; request) <span class="hl-keyword">throws</span> MessagingException;

}</pre>
<p>Before version 5.0, this <code class="literal">exchange</code> method did not have a <code class="literal">throws</code> clause and, as a result, the exception was unwrapped.
If you use this interface and want to restore the previous unwrap behavior, use a custom <code class="literal">service-interface</code> instead or access the <code class="literal">cause</code> of the  <code class="literal">MessagingException</code> yourself.</p>
<p>However, you may want to log the error rather than propagating it or you may want to treat an exception as a valid reply (by mapping it to a message that conforms to some "error message" contract that the caller understands).
To accomplish this, the gateway provides support for a message channel dedicated to the errors by including support for the <code class="literal">error-channel</code> attribute.
In the following example, a <span class="emphasis"><em>transformer</em></span> creates a reply <code class="literal">Message</code> from the <code class="literal">Exception</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sampleGateway"</span>
    <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"gatewayChannel"</span>
    <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.bar.SimpleGateway"</span>
    <span class="hl-attribute">error-channel</span>=<span class="hl-value">"exceptionTransformationChannel"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;int:transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exceptionTransformationChannel"</span>
        <span class="hl-attribute">ref</span>=<span class="hl-value">"exceptionTransformer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"createErrorResponse"</span><span class="hl-tag">/&gt;</span></pre>
<p>The <code class="literal">exceptionTransformer</code> could be a simple POJO that knows how to create the expected error response objects.
That becomes the payload that is sent back to the caller.
You could do many more elaborate things in such an "<code class="literal">error flow</code>", if necessary.
It might involve routers (including Spring Integration&#8217;s <code class="literal">ErrorMessageExceptionTypeRouter</code>), filters, and so on.
Most of the time, a simple <span class="emphasis"><em>transformer</em></span> should be sufficient, however.</p>
<p>Alternatively, you might want to only log the exception (or send it somewhere asynchronously).
If you provide a one-way flow, nothing would be sent back to the caller.
If you want to completely suppress exceptions, you can provide a reference to the global <code class="literal">nullChannel</code> (essentially a <code class="literal">/dev/null</code> approach).
Finally, as mentioned above, if no <code class="literal">error-channel</code> is defined, then the exceptions propagate as usual.</p>
<p>When you use the <code class="literal">@MessagingGateway</code> annotation (see <code class="literal">&lt;&lt;messaging-gateway-annotation&gt;&gt;</code>), you can use use the <code class="literal">errorChannel</code> attribute.</p>
<p>Starting with version 5.0, when you use a gateway method with a <code class="literal">void</code> return type (one-way flow), the <code class="literal">error-channel</code> reference (if provided) is populated in the standard <code class="literal">errorChannel</code> header of each sent message.
This feature allows a downstream asynchronous flow, based on the standard <code class="literal">ExecutorChannel</code> configuration (or a <code class="literal">QueueChannel</code>), to override a default global <code class="literal">errorChannel</code> exceptions sending behavior.
Previously you had to manually specify an <code class="literal">errorChannel</code> header with the <code class="literal">@GatewayHeader</code> annotation or the <code class="literal">&lt;header&gt;</code> element.
The <code class="literal">error-channel</code> property was ignored for <code class="literal">void</code> methods with an asynchronous flow.
Instead, error messages were sent to the default <code class="literal">errorChannel</code>.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Exposing the messaging system through simple POJI Gateways  provides benefits, but "<code class="literal">hiding</code>" the reality of the underlying messaging system does come at a price, so there are certain things you should consider.
We want our Java method to return as quickly as possible and not hang for an indefinite amount of time while the caller is waiting on it to return (whether void, a return value, or a thrown Exception).
When regular methods are used as a proxies in front of the messaging system, we have to take into account the potentially asynchronous nature of the underlying messaging.
This means that there might be a chance that a message that was initiated by a gateway could be dropped by a filter and never reach a component that is responsible for producing a reply.
Some service activator method might result in an exception, thus providing no reply (as we do not generate null messages).
In other words, multiple scenarios can cause a reply message to never come.
That is perfectly natural in messaging systems.
However, think about the implication on the gateway method.&nbsp;The gateway&#8217;s method input arguments&nbsp;were incorporated into a message and sent downstream.
The reply message would be converted to a return value of the gateway&#8217;s method.
So you might want to ensure that, for each gateway call, there is always a reply message.
Otherwise, your gateway method might never return and hang indefinitely.
One way to handle this situation is by using an asynchronous gateway (explained later in this section).
Another way of handling it is to explicitly set the <code class="literal">reply-timeout</code> attribute.
That way, the gateway does not hang any longer than the time specified by the <code class="literal">reply-timeout</code> and returns <span class="emphasis"><em>null</em></span> if that timeout does elapse.
Finally, you might want to consider setting downstream flags, such as <span class="emphasis"><em>requires-reply</em></span>, on a service-activator or <span class="emphasis"><em>throw-exceptions-on-rejection</em></span> on a filter.&nbsp;These options are discussed in more detail in the final section of this chapter.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If the downstream flow returns an <code class="literal">ErrorMessage</code>, its <code class="literal">payload</code> (a <code class="literal">Throwable</code>) is treated as a regular downstream error.
If there is an <code class="literal">error-channel</code> configured, it is sent to the error flow.
Otherwise the payload is thrown to the caller of the gateway.
Similarly, if the error flow on the <code class="literal">error-channel</code> returns an <code class="literal">ErrorMessage</code>, its payload is thrown to the caller.
The same applies to any message with a <code class="literal">Throwable</code> payload.
This can be useful in asynchronous situations when when you need to propagate an <code class="literal">Exception</code> directly to the caller.
To do so, you can either return an <code class="literal">Exception</code> (as the <code class="literal">reply</code> from some service) or throw it.
Generally, even with an asynchronous flow, the framework takes care of propagating an exception thrown by the downstream flow back to the gateway.
The <a class="ulink" href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/tcp-client-server-multiplex" target="_top">TCP Client-Server Multiplex</a> sample demonstrates both techniques to return the exception to the caller.
It emulates a socket IO error to the waiting thread by using an <code class="literal">aggregator</code> with <code class="literal">group-timeout</code> (see <a class="xref" href="messaging-routing-chapter.html#agg-and-group-to" title="Aggregator and Group Timeout">the section called &#8220;Aggregator and Group Timeout&#8221;</a>) and a <code class="literal">MessagingTimeoutException</code> reply on the discard flow.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-timeouts" href="#gateway-timeouts"></a>10.4.9&nbsp;Gateway Timeouts</h3></div></div></div>

<p>Gateways have two timeout properties: <code class="literal">requestTimeout</code> and <code class="literal">replyTimeout</code>.
The request timeout applies only if the channel can block (for example, a bounded <code class="literal">QueueChannel</code> that is full).
The <code class="literal">replyTimeout</code> value is how long the gateway waits for a reply or returns <code class="literal">null</code>.
It defaults to infinity.</p>
<p>The timeouts can be set as defaults for all methods on the gateway (<code class="literal">defaultRequestTimeout</code> and <code class="literal">defaultReplyTimeout</code>) or on the <code class="literal">MessagingGateway</code> interface annotation.
Individual methods can override these defaults (in <code class="literal">&lt;method/&gt;</code> child elements) or on the <code class="literal">@Gateway</code> annotation.</p>
<p>Starting with version 5.0, the timeouts can be defined as expressions, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Gateway(payloadExpression = "#args[0]", requestChannel = "someChannel",
        requestTimeoutExpression = "#args[1]", replyTimeoutExpression = "#args[2]")</span></em>
String lateReply(String payload, <span class="hl-keyword">long</span> requestTimeout, <span class="hl-keyword">long</span> replyTimeout);</pre>
</div>
<p>The evaluation context has a <code class="literal">BeanResolver</code> (use <code class="literal">@someBean</code> to reference other beans), and the <code class="literal">#args</code> array variable is available.</p>
<p>When configuring with XML, the timeout attributes can be a long value or a SpEL expression, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"someMethod"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"someRequestChannel"</span>
                      <span class="hl-attribute">payload-expression</span>=<span class="hl-value">"#args[0]"</span>
                      <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"1000"</span>
                      <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"#args[1]"</span><span class="hl-tag">&gt;</span>
<span class="hl-tag">&lt;/method&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="async-gateway" href="#async-gateway"></a>10.4.10&nbsp;Asynchronous Gateway</h3></div></div></div>

<p>As a pattern, the messaging gateway offers a nice way to hide messaging-specific code while still exposing the full capabilities of the messaging system.
As <a class="link" href="messaging-endpoints-chapter.html#gateway-proxy" title="10.4.1&nbsp;Enter the GatewayProxyFactoryBean">described earlier</a>, the <code class="literal">GatewayProxyFactoryBean</code> provides a convenient way to expose a proxy over a service-interface giving you POJO-based access to a messaging system (based on objects in your own domain, primitives/Strings, or other objects).
However, when a gateway is exposed through simple POJO methods that return values, it implies that, for each request message (generated when the method is invoked), there must be a reply message (generated when the method has returned).
Since messaging systems are naturally asynchronous, you may not always be able to guarantee the contract where "<code class="literal">for each request, there will always be be a reply</code>".&nbsp;Spring Integration 2.0 introduced support for an asynchronous gateway, which offers a convenient way to initiate flows when you may not know if a reply is expected or how long it takes for replies to arrive.</p>
<p>To handle these types of scenarios, Spring Integration uses <code class="literal">java.util.concurrent.Future</code> instances to support an asynchronous gateway.</p>
<p>From the XML configuration, nothing changes, and you still define asynchronous gateway the same way as you define a regular gateway, as the following example shows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mathService"</span><span class="hl-attribute">&nbsp;</span>
     <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.springframework.integration.sample.gateway.futures.MathServiceGateway"</span>
     <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"requestChannel"</span><span class="hl-tag">/&gt;</span></pre>
<p>However, the gateway interface (a service interface) is a little different, as follows:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MathServiceGateway {

  Future&lt;Integer&gt; multiplyByTwo(<span class="hl-keyword">int</span> i);

}</pre>
<p>As the preceding example shows, the return type for the gateway method is a <code class="literal">Future</code>.
When <code class="literal">GatewayProxyFactoryBean</code> sees that the return type of the gateway method is a <code class="literal">Future</code>, it immediately switches to the asynchronous mode by using an <code class="literal">AsyncTaskExecutor</code>.
That is the extent of the differences.
The call to such a method always returns immediately with a <code class="literal">Future</code> instance.
Then you can interact with the <code class="literal">Future</code> at your own pace to get the result, cancel, and so on.
Also, as with any other use of <code class="literal">Future</code> instances, calling <code class="literal">get()</code> may reveal a timeout, an execution exception, and so on.
The following example shows how to use a <code class="literal">Future</code> that returns from an asynchronous gateway:</p>
<div class="informalexample">
<pre class="programlisting">MathServiceGateway mathService = ac.getBean(<span class="hl-string">"mathService"</span>, MathServiceGateway.<span class="hl-keyword">class</span>);
Future&lt;Integer&gt; result = mathService.multiplyByTwo(number);
<span class="hl-comment">// do something else here since the reply might take a moment</span>
<span class="hl-keyword">int</span> finalResult =&nbsp; result.get(<span class="hl-number">1000</span>, TimeUnit.SECONDS);</pre>
</div>
<p>For a more detailed example, see the <a class="ulink" href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/async-gateway" target="_top">async-gateway</a> sample in the Spring Integration samples.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_literal_listenablefuture_literal" href="#_literal_listenablefuture_literal"></a><code class="literal">ListenableFuture</code></h4></div></div></div>

<p>Starting with version 4.1, asynchronous gateway methods can also return <code class="literal">ListenableFuture</code> (introduced in Spring Framework 4.0).
These return types let you provide a callback, which is invoked when the result is available (or an exception occurs).
When the gateway detects this return type and the <a class="link" href="messaging-endpoints-chapter.html#gateway-asynctaskexecutor" title="AsyncTaskExecutor">task executor</a> is an <code class="literal">AsyncListenableTaskExecutor</code>, the executor&#8217;s <code class="literal">submitListenable()</code> method is invoked.
The following example shows how to use a <code class="literal">ListenableFuture</code>:</p>
<div class="informalexample">
<pre class="programlisting">ListenableFuture&lt;String&gt; result = <span class="hl-keyword">this</span>.asyncGateway.async(<span class="hl-string">"something"</span>);
result.addCallback(<span class="hl-keyword">new</span> ListenableFutureCallback&lt;String&gt;() {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onSuccess(String result) {
        ...
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> onFailure(Throwable t) {
        ...
    }
});</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gateway-asynctaskexecutor" href="#gateway-asynctaskexecutor"></a><code class="literal">AsyncTaskExecutor</code></h4></div></div></div>

<p>By default, the <code class="literal">GatewayProxyFactoryBean</code> uses <code class="literal">org.springframework.core.task.SimpleAsyncTaskExecutor</code> when submitting internal <code class="literal">AsyncInvocationTask</code> instances for any gateway method whose return type is a <code class="literal">Future</code>.
However, the <code class="literal">async-executor</code> attribute in the <code class="literal">&lt;gateway/&gt;</code> element&#8217;s configuration lets you provide a reference to any implementation of <code class="literal">java.util.concurrent.Executor</code> available within the Spring application context.</p>
<p>The (default) <code class="literal">SimpleAsyncTaskExecutor</code> supports both <code class="literal">Future</code> and <code class="literal">ListenableFuture</code> return types, returning <code class="literal">FutureTask</code> or <code class="literal">ListenableFutureTask</code> respectively. See <a class="xref" href="messaging-endpoints-chapter.html#gw-completable-future" title="CompletableFuture">the section called &#8220;<code class="literal">CompletableFuture</code>&#8221;</a>.
Even though there is a default executor, it is often useful to provide an external one so that you can identify its threads in logs (when using XML, the thread name is based on the executor&#8217;s bean name), as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> AsyncTaskExecutor exec() {
    SimpleAsyncTaskExecutor simpleAsyncTaskExecutor = <span class="hl-keyword">new</span> SimpleAsyncTaskExecutor();
    simpleAsyncTaskExecutor.setThreadNamePrefix(<span class="hl-string">"exec-"</span>);
    <span class="hl-keyword">return</span> simpleAsyncTaskExecutor;
}

<em><span class="hl-annotation" style="color: gray">@MessagingGateway(asyncExecutor = "exec")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ExecGateway {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "gatewayChannel")</span></em>
    Future&lt;?&gt; doAsync(String foo);

}</pre>
</div>
<p>If you wish to return a different <code class="literal">Future</code> implementation, you can provide a custom executor or disable the executor altogether and return the <code class="literal">Future</code> in the reply message payload from the downstream flow.
To disable the executor, set it to <code class="literal">null</code> in the <code class="literal">GatewayProxyFactoryBean</code> (by using <code class="literal">setAsyncTaskExecutor(null)</code>).
When configuring the gateway with XML, use <code class="literal">async-executor=""</code>.
When configuring by using the <code class="literal">@MessagingGateway</code> annotation, use code similar to the following:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway(asyncExecutor = AnnotationConstants.NULL)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> NoExecGateway {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "gatewayChannel")</span></em>
    Future&lt;?&gt; doAsync(String foo);

}</pre>
</div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>If the return type is a specific concrete <code class="literal">Future</code> implementation or some other sub-interface that is not supported by the configured executor, the flow runs on the caller&#8217;s thread and the flow must return the required type in the reply message payload.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gw-completable-future" href="#gw-completable-future"></a><code class="literal">CompletableFuture</code></h4></div></div></div>

<p>Starting with version 4.2, gateway methods can now return <code class="literal">CompletableFuture&lt;?&gt;</code>.
There are two modes of operation when returning this type:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
When an async executor is provided and the return type is exactly <code class="literal">CompletableFuture</code> (not a subclass), the framework runs the task on the executor and immediately returns a <code class="literal">CompletableFuture</code> to the caller.
<code class="literal">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code> is used to create the future.
</li><li class="listitem">
When the async executor is explicitly set to <code class="literal">null</code> and the return type is <code class="literal">CompletableFuture</code> or the return type is a subclass of <code class="literal">CompletableFuture</code>, the flow is invoked on the caller&#8217;s thread.
In this scenario, the downstream flow is expected to return a <code class="literal">CompletableFuture</code> of the appropriate type.
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_usage_scenarios" href="#_usage_scenarios"></a>Usage Scenarios</h5></div></div></div>

<p>In the following scenario, the caller thread returns immediately with a <code class="literal">CompletableFuture&lt;Invoice&gt;</code>, which is completed when the downstream flow replies to the gateway (with an <code class="literal">Invoice</code> object).</p>
<div class="informalexample">
<pre class="programlisting">CompletableFuture&lt;Invoice&gt; order(Order order);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"something.Service"</span> <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"orders"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p>In the following  scenario, the caller thread returns with a <code class="literal">CompletableFuture&lt;Invoice&gt;</code> when the downstream flow provides it as the payload of the reply to the gateway.
Some other process must complete the future when the invoice is ready.</p>
<div class="informalexample">
<pre class="programlisting">CompletableFuture&lt;Invoice&gt; order(Order order);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.Service"</span> <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"orders"</span>
    <span class="hl-attribute">async-executor</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p>In the following scenario, the caller thread returns with a <code class="literal">CompletableFuture&lt;Invoice&gt;</code> when the downstream flow provides it as the payload of the reply to the gateway.
Some other process must complete the future when the invoice is ready.
If <code class="literal">DEBUG</code> logging is enabled, a log entry is emitted, indicating that the async executor cannot be used for this scenario.</p>
<div class="informalexample">
<pre class="programlisting">MyCompletableFuture&lt;Invoice&gt; order(Order order);</pre>
<pre class="programlisting"><span class="hl-tag">&lt;int:gateway</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"foo.Service"</span> <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"orders"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p><code class="literal">CompletableFuture</code> instances can be used to perform additional manipulation on the reply, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">CompletableFuture&lt;String&gt; process(String data);

...

CompletableFuture result = process(<span class="hl-string">"foo"</span>)
    .thenApply(t -&gt; t.toUpperCase());

...

String out = result.get(<span class="hl-number">10</span>, TimeUnit.SECONDS);</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_reactor_literal_mono_literal" href="#_reactor_literal_mono_literal"></a>Reactor <code class="literal">Mono</code></h4></div></div></div>

<p>Starting with version 5.0, the <code class="literal">GatewayProxyFactoryBean</code> allows the use of <a class="ulink" href="https://projectreactor.io/" target="_top">Project Reactor</a> with gateway interface methods, using a <a class="ulink" href="https://github.com/reactor/reactor-core" target="_top"><code class="literal">Mono&lt;T&gt;</code></a> return type.
The internal <code class="literal">AsyncInvocationTask</code> is wrapped in a <code class="literal">Mono.fromCallable()</code>.</p>
<p>A <code class="literal">Mono</code> can be used to retrieve the result later (similar to a <code class="literal">Future&lt;?&gt;</code>), or you can consume from it with the dispatcher by invoking your <code class="literal">Consumer</code> when the result is returned to the gateway.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">Mono</code> is not immediately flushed by the framework.
Consequently, the underlying message flow is not started before the gateway method returns (as it is with a <code class="literal">Future&lt;?&gt;</code> <code class="literal">Executor</code> task).
The flow starts when the <code class="literal">Mono</code> is subscribed to.
Alternatively, the <code class="literal">Mono</code> (being a <code class="literal">Composable</code>) might be a part of Reactor stream, when the <code class="literal">subscribe()</code> is related to the entire <code class="literal">Flux</code>.
The following example shows how to create a gateway with Project Reactor:</p>
</td></tr></table></div>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">interface</span> TestGateway {

	<em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "promiseChannel")</span></em>
	Mono&lt;Integer&gt; multiply(Integer value);

	}

	    ...

	<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "promiseChannel")</span></em>
	<span class="hl-keyword">public</span> Integer multiply(Integer value) {
			<span class="hl-keyword">return</span> value * <span class="hl-number">2</span>;
	}

		...

    Flux.just(<span class="hl-string">"1"</span>, <span class="hl-string">"2"</span>, <span class="hl-string">"3"</span>, <span class="hl-string">"4"</span>, <span class="hl-string">"5"</span>)
            .map(Integer::parseInt)
            .flatMap(<span class="hl-keyword">this</span>.testGateway::multiply)
            .collectList()
            .subscribe(integers -&gt; ...);</pre>
</div>
<p>Another example that uses Project Reactor is a simple callback scenario, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">Mono&lt;Invoice&gt; mono = service.process(myOrder);

mono.subscribe(invoice -&gt; handleInvoice(invoice));</pre>
</div>
<p>The calling thread continues, with <code class="literal">handleInvoice()</code> being called when the flow completes.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_downstream_flows_returning_an_asynchronous_type" href="#_downstream_flows_returning_an_asynchronous_type"></a>Downstream Flows Returning an Asynchronous Type</h4></div></div></div>

<p>As mentioned in the <code class="literal">ListenableFuture</code> section above, if you wish some downstream component to return a message with an async payload (<code class="literal">Future</code>, <code class="literal">Mono</code>, and others), you must explicitly set the async executor to <code class="literal">null</code> (or <code class="literal">""</code> when using XML configuration).
The flow is then invoked on the caller thread and the result can be retrieved later.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_literal_void_literal_return_type" href="#_literal_void_literal_return_type"></a><code class="literal">void</code> Return Type</h4></div></div></div>

<p>Unlike the return types mentioned earlier, when the method return type is <code class="literal">void</code>, the framework cannot implicitly determine that you wish the downstream flow to run asynchronously, with the caller thread returning immediately.
In this case, you must annotate the interface method with <code class="literal">@Async</code>, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

    <em><span class="hl-annotation" style="color: gray">@Gateway(requestChannel = "sendAsyncChannel")</span></em>
    <em><span class="hl-annotation" style="color: gray">@Async</span></em>
    <span class="hl-keyword">void</span> sendAsync(String payload);

}</pre>
</div>
<p>Unlike the <code class="literal">Future&lt;?&gt;</code> return types, there is no way to inform the caller if some exception is thrown by the flow, unless some custom <code class="literal">TaskExecutor</code> (such as an <code class="literal">ErrorHandlingTaskExecutor</code>) is associated with the <code class="literal">@Async</code> annotation.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gateway-no-response" href="#gateway-no-response"></a>10.4.11&nbsp;Gateway Behavior When No response Arrives</h3></div></div></div>

<p>As <a class="link" href="messaging-endpoints-chapter.html#gateway-proxy" title="10.4.1&nbsp;Enter the GatewayProxyFactoryBean">explained earlier</a>, the gateway provides a convenient way of interacting with a messaging system through POJO method invocations.
However, a typical method invocation, which is generally expected to always return (even with an Exception), might not always map one-to-one to message exchanges (for example, a reply message might not arrive&#8201;&#8212;&#8201;the equivalent to a method not returning).</p>
<p>The rest of this section covers various scenarios and how to make the gateway behave more predictably.
Certain attributes can be configured to make synchronous gateway behavior more predictable, but some of them might not always work as you might expect.
One of them is <code class="literal">reply-timeout</code> (at the method level or <code class="literal">default-reply-timeout</code> at the gateway level).
We examine the <code class="literal">reply-timeout</code> attribute to see how it can and cannot influence the behavior of the synchronous gateway in various scenarios.
We examine a single-threaded scenario (all components downstream are connected through a direct channel) and multi-threaded scenarios (for example,&nbsp;somewhere downstream you may have a pollable or executor channel that breaks the single-thread boundary).</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="long-running-process-downstream" href="#long-running-process-downstream"></a>Long-running Process Downstream</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Sync Gateway, single-threaded</span></dt><dd>
If a component downstream is still running (perhaps because of an infinite loop or a slow service), setting a <code class="literal">reply-timeout</code> has no effect, and the gateway method call does not return until the downstream service exits (by returning or throwing an exception).
</dd><dt><span class="term">Sync&nbsp;Gateway, multi-threaded</span></dt><dd>
If a component downstream is still running (perhaps because of an infinite loop or a slow service) in a multi-threaded message flow, setting the <code class="literal">reply-timeout</code> has an effect by allowing gateway method invocation to return once the timeout has been reached, because the <code class="literal">GatewayProxyFactoryBean</code> &nbsp;polls on the reply channel, waiting for a message until the timeout expires.
However, if the timeout has been reached before the actual reply was produced, it could result in a <span class="emphasis"><em>null</em></span> return from the gateway method.&nbsp;
You should understand that the reply message (if produced) is sent to a reply channel after the gateway method invocation might have returned, so you must be aware of that and design your flow with it in mind.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_downstream_component_returns_emphasis_null_emphasis" href="#_downstream_component_returns_emphasis_null_emphasis"></a>Downstream Component Returns <span class="emphasis"><em>null</em></span></h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Sync Gateway&#8201;&#8212;&#8201;single-threaded</span></dt><dd>
If a component downstream returns <span class="emphasis"><em>null</em></span> and no <code class="literal">reply-timeout</code> has been configured, the gateway method call hangs indefinitely, unless a <code class="literal">reply-timeout</code> has been configured or the <code class="literal">requires-reply</code> attribute has been set on the downstream component (for example, a service activator) that might return <span class="emphasis"><em>null</em></span>.
In this case, an exception would be thrown and propagated to the gateway.
</dd><dt><span class="term">Sync Gateway&#8201;&#8212;&#8201;multi-threaded</span></dt><dd>
The behavior is the same as the previous case.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_downstream_component_return_signature_is_emphasis_void_emphasis_while_gateway_method_signature_is_non_void" href="#_downstream_component_return_signature_is_emphasis_void_emphasis_while_gateway_method_signature_is_non_void"></a>Downstream Component Return Signature is <span class="emphasis"><em>void</em></span> While Gateway Method Signature Is Non-void</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Sync Gateway&#8201;&#8212;&#8201;single-threaded</span></dt><dd>
If a component downstream returns <span class="emphasis"><em>void</em></span> and no <code class="literal">reply-timeout</code> has been configured, the gateway method call hangs indefinitely unless a <code class="literal">reply-timeout</code> has been configured.
</dd><dt><span class="term">Sync Gateway&#8201;&#8212;&#8201;multi-threaded</span></dt><dd>
The behavior is the same as the previous case.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_downstream_component_results_in_runtime_exception" href="#_downstream_component_results_in_runtime_exception"></a>Downstream Component Results in Runtime Exception</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Sync Gateway&#8201;&#8212;&#8201;single-threaded</span></dt><dd>
If a component downstream throws a runtime exception, the exception is propagated through an error message back to the gateway and re-thrown.
</dd><dt><span class="term">Sync Gateway&#8201;&#8212;&#8201;multi-threaded</span></dt><dd>
The behavior is the same as the previous case.
</dd></dl></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>You should understand that, by default, <code class="literal">reply-timeout</code> is unbounded.
Consequently, if you do not explicitly set the <code class="literal">reply-timeout</code>, your gateway method invocation might hang indefinitely.
So, to make sure you analyze your flow and if there is even a remote possibility of one of these scenarios to occur, you should set the <code class="literal">reply-timeout</code> attribute to a "<span class="emphasis"><em>safe</em></span>" value.
Even better, you can set the <code class="literal">requires-reply</code> attribute of the downstream component to <span class="emphasis"><em>true</em></span> to ensure a timely response, as produced by the throwing of an exception as soon as that downstream component returns null internally.
However you should also realize that there are some scenarios (see <a class="link" href="messaging-endpoints-chapter.html#long-running-process-downstream" title="Long-running Process Downstream">the first one</a>) where <code class="literal">reply-timeout</code> does not help.
That means it is also important to analyze your message flow and decide when to use a synchronous gateway rather than an asynchrnous gateway.
As <a class="link" href="messaging-endpoints-chapter.html#async-gateway" title="10.4.10&nbsp;Asynchronous Gateway">described earlier</a>, the latter case is a matter of defining gateway methods that return <code class="literal">Future</code> instances.
Then you are guaranteed to receive that return value, and you have more granular control over the results of the invocation.
Also, when dealing with a router, you should remember that setting the <code class="literal">resolution-required</code> attribute to <span class="emphasis"><em>true</em></span> results in an exception thrown by the router if it can not resolve a particular channel.
Likewise, when dealing with a Filter, you can set the <code class="literal">throw-exception-on-rejection</code> attribute.
In both of these cases, the resulting flow behaves like it contain a service activator with the <span class="emphasis"><em>requires-reply</em></span> attribute.
In other words, it helps to ensure a timely response from the gateway method invocation.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p><code class="literal">reply-timeout</code> is unbounded for <code class="literal">&lt;gateway/&gt;</code> elements (created by the <code class="literal">GatewayProxyFactoryBean</code>).
Inbound gateways for external integration (WS, HTTP, and so on) share many characteristics and attributes with these gateways.
However, for those inbound gateways, the default <code class="literal">reply-timeout</code> is 1000 milliseconds (one second).
If a downstream asynchronous hand-off is made to another thread, you may need to increase this attribute to allow enough time for the flow to complete before the gateway times out.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>You should understand that the timer starts when the thread returns to the gateway&#8201;&#8212;&#8201;that is, when the flow completes or a message is handed off to another thread.
At that time, the calling thread starts waiting for the reply.
If the flow was completely synchronous, the reply is immediately available.
For asynchronous flows, the thread waits for up to this time.</p>
</td></tr></table></div>
<p>See <a class="xref" href="java-dsl.html#java-dsl-gateway" title="11.19&nbsp;IntegrationFlow as Gateway">Section&nbsp;11.19, &#8220;<code class="literal">IntegrationFlow</code> as Gateway&#8221;</a> in the Java DSL chapter for options to define gateways through <code class="literal">IntegrationFlows</code>.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-activator" href="#service-activator"></a>10.5&nbsp;Service Activator</h2></div></div></div>

<p>The service activator is the endpoint type for connecting any Spring-managed object to an input channel so that it may play the role of a service.
If the service produces output, it may also be connected to an output channel.
Alternatively, an output-producing service may be located at the end of a processing pipeline or message flow, in which case the inbound message&#8217;s <code class="literal">replyChannel</code> header can be used.
This is the default behavior if no output channel is defined.
As with most of the configuration options described here, the same behavior actually applies for most of the other components.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="service-activator-namespace" href="#service-activator-namespace"></a>10.5.1&nbsp;Configuring Service Activator</h3></div></div></div>

<p>To create a service activator, use the <span class="emphasis"><em>service-activator</em></span> element with the <span class="emphasis"><em>input-channel</em></span> and <span class="emphasis"><em>ref</em></span> attributes, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"exampleHandler"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>The preceding configuration selects all the methods from the <code class="literal">exampleHandler</code> that meet one of the messaging requirements, which are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
annotated with <code class="literal">@ServiceActivator</code>
</li><li class="listitem">
is <code class="literal">public</code>
</li><li class="listitem">
not return <code class="literal">void</code> if <code class="literal">requiresReply == true</code>
</li></ul></div>
<p>The target method for invocation at runtime is selected for each request message by their <code class="literal">payload</code> type or as a fallback to the <code class="literal">Message&lt;?&gt;</code> type if such a method is present on target class.</p>
<p>Starting with version 5.0, one service method can be marked with the <code class="literal">@org.springframework.integration.annotation.Default</code> as a fallback for all non-matching cases.
This can be useful when using <a class="link" href="messaging-endpoints-chapter.html#content-type-conversion" title="10.1.7&nbsp;Content Type Conversion">content-type conversion</a> with the target method being invoked after conversion.</p>
<p>To delegate to an explicitly defined method of any object, you can add the <code class="literal">method</code> attribute, as the following example shows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span><span class="hl-tag">/&gt;</span></pre>
<p>In either case, when the service method returns a non-null value, the endpoint tries to send the reply message to an appropriate reply channel.
To determine the reply channel, it first checks whether an <code class="literal">output-channel</code> was provided in the endpoint configuration, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"replyChannel"</span>
                       <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>If the method returns a result and no <code class="literal">output-channel</code> is defined, the framework then checks the request message&#8217;s <code class="literal">replyChannel</code> header value.
If that value is available, it then checks its type.
If it is a <code class="literal">MessageChannel</code>, the reply message is sent to that channel.
If it is a <code class="literal">String</code>, the endpoint tries to resolve the channel name to a channel instance.
If the channel cannot be resolved, a <code class="literal">DestinationResolutionException</code> is thrown.
It it can be resolved, the message is sent there.
If the request message does not have a <code class="literal">replyChannel</code> header and the <code class="literal">reply</code> object is a <code class="literal">Message</code>, its <code class="literal">replyChannel</code> header is consulted for a target destination.
This is the technique used for request-reply messaging in Spring Integration, and it is also an example of the return address pattern.</p>
<p>If your method returns a result and you want to discard it and end the flow, you should configure the <code class="literal">output-channel</code> to send to a <code class="literal">NullChannel</code>.
For convenience, the framework registers one with the name, <code class="literal">nullChannel</code>.
See <a class="xref" href="messaging-channels-section.html#channel-special-channels" title="6.1.6&nbsp;Special Channels">Section&nbsp;6.1.6, &#8220;Special Channels&#8221;</a> for more information.</p>
<p>The service activator is one of those components that is not required to produce a reply message.
If your method returns <code class="literal">null</code> or has a <code class="literal">void</code> return type, the service activator exits after the method invocation, without any signals.
This behavior can be controlled by the <code class="literal">AbstractReplyProducingMessageHandler.requiresReply</code> option, which is also exposed as <code class="literal">requires-reply</code> when configuring with the XML namespace.
If the flag is set to <code class="literal">true</code> and the method returns null, a <code class="literal">ReplyRequiredException</code> is thrown.</p>
<p>The argument in the service method could be either a message or an arbitrary type.
If the latter, then it is assumed to be a message payload, which is extracted from the message and injected into the service method.
We generally recommend this approach, as it follows and promotes a POJO model when working with Spring Integration.
Arguments may also have <code class="literal">@Header</code> or <code class="literal">@Headers</code> annotations, as described in <a class="xref" href="configuration.html#annotations" title="E.5&nbsp;Annotation Support">Section&nbsp;E.5, &#8220;Annotation Support&#8221;</a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The service method is not required to have any arguments, which means you can implement event-style service activators (where all you care about is an invocation of the service method) and not worry about the contents of the message.
Think of it as a null JMS message.
An example use case for such an implementation is a simple counter or monitor of messages deposited on the input channel.</p>
</td></tr></table></div>
<p>Starting with version 4.1, the framework correctly converts message properties (<code class="literal">payload</code> and <code class="literal">headers</code>) to the Java 8 <code class="literal">Optional</code> POJO method parameters, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyBean {
    <span class="hl-keyword">public</span> String computeValue(Optional&lt;String&gt; payload,
               <em><span class="hl-annotation" style="color: gray">@Header(value="foo", required=false)</span></em> String foo1,
               <em><span class="hl-annotation" style="color: gray">@Header(value="foo")</span></em> Optional&lt;String&gt; foo2) {
        <span class="hl-keyword">if</span> (payload.isPresent()) {
            String value = payload.get();
            ...
        }
        <span class="hl-keyword">else</span> {
           ...
       }
    }

}</pre>
</div>
<p>We generally recommend using a <code class="literal">ref</code> attribute if the custom service activator handler implementation can be reused in other <code class="literal">&lt;service-activator&gt;</code> definitions.
However, if the custom service activator handler implementation is only used within a single definition of the <code class="literal">&lt;service-activator&gt;</code>, you can provide an inner bean definition, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleServiceActivator"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span>
            <span class="hl-attribute">output-channel</span> = <span class="hl-value">"outChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.something.ExampleServiceActivator"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Using both the <code class="literal">ref</code> attribute and an inner handler definition in the same <code class="literal">&lt;service-activator&gt;</code> configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>If the <code class="literal">ref</code> attribute references a bean that extends <code class="literal">AbstractMessageProducingHandler</code> (such as handlers provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.
In this case, each <code class="literal">ref</code> must be to a separate bean instance (or a <code class="literal">prototype</code>-scoped bean) or use the inner <code class="literal">&lt;bean/&gt;</code> configuration type.
If you inadvertently reference the same message handler from multiple beans, you get a configuration exception.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_service_activators_and_the_spring_expression_language_spel" href="#_service_activators_and_the_spring_expression_language_spel"></a>Service Activators and the Spring Expression Language (SpEL)</h4></div></div></div>

<p>Since Spring Integration 2.0, service activators can also benefit from <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions" target="_top">SpEL</a>.</p>
<p>For example, you can invoke any bean method without pointing to the bean in a <code class="literal">ref</code> attribute or including it as an inner bean definition, as follows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span>
	<span class="hl-attribute">expression</span>=<span class="hl-value">"@accountService.processAccount(payload, headers.accountId)"</span><span class="hl-tag">/&gt;</span>

	<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"thing1.thing2.Account"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>In the preceding configuration, instead of injecting <span class="emphasis"><em>accountService</em></span> by using a <code class="literal">ref</code> or as an inner bean, we use SpEL&#8217;s <code class="literal">@beanId</code> notation and invoke a method that takes a type compatible with the message payload.
We also pass a header value.
Any valid SpEL expression can be evaluated against any content in the message.
For simple scenarios, your service activators need not reference a bean if all logic can be encapsulated in such an expression, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload * 2"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>In the preceding configuration, our service logic is to multiply the payload value by two.
SpEL lets us handle it relatively easily.</p>
<p>See <a class="xref" href="java-dsl.html#java-dsl-handle" title="11.10&nbsp;Service Activators and the .handle() method">Section&nbsp;11.10, &#8220;Service Activators and the <code class="literal">.handle()</code> method&#8221;</a> in the Java DSL chapter for more information about configuring service activator.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="async-service-activator" href="#async-service-activator"></a>10.5.2&nbsp;Asynchronous Service Activator</h3></div></div></div>

<p>The service activator is invoked by the calling thread.
This is an upstream thread if the input channel is a <code class="literal">SubscribableChannel</code> or a poller thread for a <code class="literal">PollableChannel</code>.
If the service returns a <code class="literal">ListenableFuture&lt;?&gt;</code>, the default action is to send that as the payload of the message sent to the output (or reply) channel.
Starting with version 4.3, you can now set the <code class="literal">async</code> attribute to <code class="literal">true</code> (by using <code class="literal">setAsync(true)</code> when using Java configuration).
If the service returns a <code class="literal">ListenableFuture&lt;?&gt;</code> when this the <code class="literal">async</code> attribute is set to <code class="literal">true</code>, the calling thread is released immediately and the reply message is sent on the thread (from within your service) that completes the future.
This is particularly advantageous for long-running services that use a <code class="literal">PollableChannel</code>, because the poller thread is released to perform other services within the framework.</p>
<p>If the service completes the future with an <code class="literal">Exception</code>, normal error processing occurs.
An <code class="literal">ErrorMessage</code> is sent to the <code class="literal">errorChannel</code> message header, if present. Otherwise, an <code class="literal">ErrorMessage</code> is sent to the default <code class="literal">errorChannel</code> (if available).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="service-activator-return-type" href="#service-activator-return-type"></a>10.5.3&nbsp;Service Activator and Method Return Type</h3></div></div></div>

<p>The service method can return any type which becomes reply message payload.
In this case a new <code class="literal">Message&lt;?&gt;</code> object is created and all the headers from a request message are copied.
This works the same way for most Spring Integration <code class="literal">MessageHandler</code> implementations, when interaction is based on a POJO method invocation.</p>
<p>A complete <code class="literal">Message&lt;?&gt;</code> object can also be returned from the method.
However keep in mind that, unlike <a class="link" href="messaging-transformation-chapter.html#transformer" title="9.1&nbsp;Transformer">transformers</a>, for a Service Activator this message will be modified by copying the headers from the request message if they are not already present in the returned message.
So, if your method parameter is a <code class="literal">Message&lt;?&gt;</code> and you copy some, but not all, existing headers in your service method, they will reappear in the reply message.
It is not a Service Activator responsibility to remove headers from a reply message and, pursuing the loosely-coupled principle, it is better to add a <code class="literal">HeaderFilter</code> in the integration flow.
Alternatively, a Transformer can be used instead of a Service Activator but, in that case, when returning a full <code class="literal">Message&lt;?&gt;</code> the method is completely responsible for the message, including copying request message headers (if needed).
You must ensure that important framework headers (e.g. <code class="literal">replyChannel</code>, <code class="literal">errorChannel</code>), if present, have to be preserved.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="delayer" href="#delayer"></a>10.6&nbsp;Delayer</h2></div></div></div>

<p>A delayer is a simple endpoint that lets a message flow be delayed by a certain interval.
When a message is delayed, the original sender does not block.
Instead, the delayed messages are scheduled with an instance of <code class="literal">org.springframework.scheduling.TaskScheduler</code> to be sent to the output channel after the delay has passed.
This approach is scalable even for rather long delays, since it does not result in a large number of blocked sender threads.
On the contrary, in the typical case, a thread pool is used for the actual execution of releasing the messages.
This section contains several examples of configuring a delayer.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayer-namespace" href="#delayer-namespace"></a>10.6.1&nbsp;Configuring a Delayer</h3></div></div></div>

<p>The <code class="literal">&lt;delayer&gt;</code> element is used to delay the message flow between two message channels.
As with the other endpoints, you can provide the <span class="emphasis"><em>input-channel</em></span> and <span class="emphasis"><em>output-channel</em></span> attributes, but the delayer also has <span class="emphasis"><em>default-delay</em></span> and <span class="emphasis"><em>expression</em></span> attributes (and the <span class="emphasis"><em>expression</em></span> element) that determine the number of milliseconds by which each message should be delayed.
The following example delays all messages by three seconds:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span>
             <span class="hl-attribute">default-delay</span>=<span class="hl-value">"3000"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>If you need to determine the delay for each message, you can also provide the SpEL expression by using the <span class="emphasis"><em>expression</em></span> attribute, as the following expression shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
             <span class="hl-attribute">default-delay</span>=<span class="hl-value">"3000"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"headers['delay']"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>In the preceding example, the three-second delay applies only when the expression evaluates to null for a given inbound message.
If you want to apply a delay only to messages that have a valid result of the expression evaluation, you can use a <span class="emphasis"><em>default-delay</em></span> of <code class="literal">0</code> (the default).
For any message that has a delay of <code class="literal">0</code> (or less), the message is sent immediately, on the calling thread.</p>
<p>The following example shows the Java configuration equivalent of the preceding example:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "input")</span></em>
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DelayHandler delayer() {
    DelayHandler handler = <span class="hl-keyword">new</span> DelayHandler(<span class="hl-string">"delayer.messageGroupId"</span>);
    handler.setDefaultDelay(<span class="hl-number">3</span>_<span class="hl-number">000L</span>);
    handler.setDelayExpressionString(<span class="hl-string">"headers['delay']"</span>);
    handler.setOutputChannelName(<span class="hl-string">"output"</span>);
    <span class="hl-keyword">return</span> handler;
}</pre>
</div>
<p>The following example shows the Java DSL equivalent of the preceding example:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow flow() {
    <span class="hl-keyword">return</span> IntegrationFlows.from(<span class="hl-string">"input"</span>)
            .delay(<span class="hl-string">"delayer.messageGroupId"</span>, d -&gt; d
                    .defaultDelay(<span class="hl-number">3</span>_<span class="hl-number">000L</span>)
                    .delayExpression(<span class="hl-string">"headers['delay']"</span>))
            .channel(<span class="hl-string">"output"</span>)
            .get();
}</pre>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The XML parser uses a message group ID of <code class="literal">&lt;beanName&gt;.messageGroupId</code>.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>The delay handler supports expression evaluation results that represent an interval in milliseconds (any <code class="literal">Object</code> whose <code class="literal">toString()</code> method produces a value that can be parsed into a <code class="literal">Long</code>) as well as <code class="literal">java.util.Date</code> instances representing an absolute time.
In the first case, the milliseconds are counted from the current time (for example
a value of <code class="literal">5000</code> would delay the message for at least five seconds from the time it is received by the delayer).
With a <code class="literal">Date</code> instance, the message is not released until the time represented by that <code class="literal">Date</code> object.
A value that equates to a non-positive delay or a Date in the past results in no delay.
Instead, it is sent directly to the output channel on the original sender&#8217;s thread.
If the expression evaluation result is not a <code class="literal">Date</code> and can not be parsed as a <code class="literal">Long</code>, the default delay (if any&#8201;&#8212;&#8201;the default is <code class="literal">0</code>) is applied.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The expression evaluation may throw an evaluation exception for various reasons, including an invalid expression or other conditions.
By default, such exceptions are ignored (though logged at the DEBUG level) and the delayer falls back to the default delay (if any).
You can modify this behavior by setting the <code class="literal">ignore-expression-failures</code> attribute.
By default, this attribute is set to <code class="literal">true</code> and the delayer behavior is as described earlier.
However, if you wish to not ignore expression evaluation exceptions and throw them to the delayer&#8217;s caller, set the <code class="literal">ignore-expression-failures</code> attribute to <code class="literal">false</code>.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>In the preceding example, the delay expression is specified as <code class="literal">headers['delay']</code>.
This is the SpEL <code class="literal">Indexer</code> syntax to access a <code class="literal">Map</code> element (<code class="literal">MessageHeaders</code> implements <code class="literal">Map</code>).
It invokes: <code class="literal">headers.get("delay")</code>.
For simple map element names (that do not contain <span class="emphasis"><em>.</em></span>) you can also use the SpEL "<code class="literal">dot accessor</code>" syntax, where the header expression shown earlier can be specified as <code class="literal">headers.delay</code>.
However, different results are achieved if the header is missing.
In the first case, the expression evaluates to <code class="literal">null</code>.
The second results in something similar to the following:</p>
<div class="informalexample">
<pre class="programlisting"> org.springframework.expression.spel.SpelEvaluationException: EL1<span class="hl-number">008E</span>:(pos <span class="hl-number">8</span>):
		   Field or property <span class="hl-string">'delay'</span> cannot be found on object of type <span class="hl-string">'org.springframework.messaging.MessageHeaders'</span></pre>
</div>
<p>Consequently, if there is a possibility of the header being omitted and you want to fall back to the default delay, it is generally more efficient (and recommended) to use the indexer syntax instead of dot property accessor syntax, because detecting the null is faster than catching an exception.</p>
</td></tr></table></div>
<p>The delayer delegates to an instance of Spring&#8217;s <code class="literal">TaskScheduler</code> abstraction.
The default scheduler used by the delayer is the <code class="literal">ThreadPoolTaskScheduler</code> instance provided by Spring Integration on startup.
See <a class="xref" href="configuration.html#namespace-taskscheduler" title="E.2&nbsp;Configuring the Task Scheduler">Section&nbsp;E.2, &#8220;Configuring the Task Scheduler&#8221;</a>.
If you want to delegate to a different scheduler, you can provide a reference through the delayer element&#8217;s <span class="emphasis"><em>scheduler</em></span> attribute, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"headers.delay"</span>
    <span class="hl-attribute">scheduler</span>=<span class="hl-value">"exampleTaskScheduler"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;task:scheduler</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleTaskScheduler"</span> <span class="hl-attribute">pool-size</span>=<span class="hl-value">"3"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>If you configure an external <code class="literal">ThreadPoolTaskScheduler</code>, you can set <code class="literal">waitForTasksToCompleteOnShutdown = true</code> on this property.
It allows successful completion of <span class="emphasis"><em>delay</em></span> tasks that are already in the execution state (releasing the message) when the application is shutdown.
Before Spring Integration 2.2, this property was available on the <code class="literal">&lt;delayer&gt;</code> element, because <code class="literal">DelayHandler</code> could create its own scheduler on the background.
Since 2.2, the delayer requires an external scheduler instance and <code class="literal">waitForTasksToCompleteOnShutdown</code> was deleted.
You should use the scheduler&#8217;s own configuration.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p><code class="literal">ThreadPoolTaskScheduler</code> has a property <code class="literal">errorHandler</code>, which can be injected with some implementation of <code class="literal">org.springframework.util.ErrorHandler</code>.
This handler allows processing an <code class="literal">Exception</code> from the thread of the scheduled task sending the delayed message.
By default, it uses an <code class="literal">org.springframework.scheduling.support.TaskUtils$LoggingErrorHandler</code>, and you can see a stack trace in the logs.
You might want to consider using an <code class="literal">org.springframework.integration.channel.MessagePublishingErrorHandler</code>, which sends an <code class="literal">ErrorMessage</code> into an <code class="literal">error-channel</code>, either from the failed message&#8217;s header or into the default <code class="literal">error-channel</code>.
This error handling is performed after a transaction rolls back (if present).
See <a class="xref" href="messaging-endpoints-chapter.html#delayer-release-failures" title="10.6.3&nbsp;Release Failures">Section&nbsp;10.6.3, &#8220;Release Failures&#8221;</a>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayer-message-store" href="#delayer-message-store"></a>10.6.2&nbsp;Delayer and a Message Store</h3></div></div></div>

<p>The <code class="literal">DelayHandler</code> persists delayed messages into the message group in the provided <code class="literal">MessageStore</code>.
(The <span class="emphasis"><em>groupId</em></span> is based on the required <span class="emphasis"><em>id</em></span> attribute of the <code class="literal">&lt;delayer&gt;</code> element.)
A delayed message is removed from the <code class="literal">MessageStore</code> by the scheduled task immediately before the <code class="literal">DelayHandler</code> sends the message to the <code class="literal">output-channel</code>.
If the provided <code class="literal">MessageStore</code> is persistent (such as <code class="literal">JdbcMessageStore</code>), it provides the ability to not lose messages on the application shutdown.
After application startup, the <code class="literal">DelayHandler</code> reads messages from its message group in the <code class="literal">MessageStore</code> and reschedules them with a delay based on the original arrival time of the message (if the delay is numeric).
For messages where the delay header was a <code class="literal">Date</code>, that <code class="literal">Date</code> is used when rescheduling.
If a delayed message remains in the <code class="literal">MessageStore</code> more than its <span class="emphasis"><em>delay</em></span>, it is sent immediately after startup.</p>
<p>The <code class="literal">&lt;delayer&gt;</code> can be enriched with either of two mutually exclusive elements: <code class="literal">&lt;transactional&gt;</code> and <code class="literal">&lt;advice-chain&gt;</code>.
The <code class="literal">List</code> of these AOP advices is applied to the proxied internal <code class="literal">DelayHandler.ReleaseMessageHandler</code>, which has the responsibility to release the message, after the delay, on a <code class="literal">Thread</code> of the scheduled task.
It might be used, for example, when the downstream message flow throws an exception and the transaction of the <code class="literal">ReleaseMessageHandler</code> is rolled back.
In this case, the delayed message remains in the persistent <code class="literal">MessageStore</code>.
You can use any custom <code class="literal">org.aopalliance.aop.Advice</code> implementation within the <code class="literal">&lt;advice-chain&gt;</code>.
The <code class="literal">&lt;transactional&gt;</code> element defines a simple advice chain that has only the transactional advice.
The following example shows an <code class="literal">advice-chain</code> within a <code class="literal">&lt;delayer&gt;</code>:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:delayer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"delayer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">expression</span>=<span class="hl-value">"headers.delay"</span>
    <span class="hl-attribute">message-store</span>=<span class="hl-value">"jdbcMessageStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:advice-chain&gt;</span>
        <span class="hl-tag">&lt;beans:ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"customAdviceBean"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;tx:advice&gt;</span>
            <span class="hl-tag">&lt;tx:attributes&gt;</span>
                <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/tx:attributes&gt;</span>
        <span class="hl-tag">&lt;/tx:advice&gt;</span>
    <span class="hl-tag">&lt;/int:advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:delayer&gt;</span></pre>
</div>
<p>The <code class="literal">DelayHandler</code> can be exported as a JMX <code class="literal">MBean</code> with managed operations (<code class="literal">getDelayedMessageCount</code> and <code class="literal">reschedulePersistedMessages</code>), which allows the rescheduling of delayed persisted messages at runtime&#8201;&#8212;&#8201;for example, if the <code class="literal">TaskScheduler</code> has previously been stopped.
These operations can be invoked through a <code class="literal">Control Bus</code> command, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">Message&lt;String&gt; delayerReschedulingMessage =
    MessageBuilder.withPayload(<span class="hl-string">"@'delayer.handler'.reschedulePersistedMessages()"</span>).build();
    controlBusChannel.send(delayerReschedulingMessage);</pre>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>For more information regarding the message store, JMX, and the control bus, see <a class="xref" href="system-management-chapter.html" title="12.&nbsp;System Management">Chapter&nbsp;12, <i>System Management</i></a>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delayer-release-failures" href="#delayer-release-failures"></a>10.6.3&nbsp;Release Failures</h3></div></div></div>

<p>Starting with version 5.0.8, there are two new properties on the delayer:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">maxAttempts</code> (default 5)
</li><li class="listitem">
<code class="literal">retryDelay</code> (default 1 second)
</li></ul></div>
<p>When a message is released, if the downstream flow fails, the release will be attempted after the <code class="literal">retryDelay</code>.
If the <code class="literal">maxAttempts</code> is reached, the message is discarded (unless the release is transactional, in which case the message will remain in the store, but will no longer be scheduled for release, until the application is restarted, or the <code class="literal">reschedulePersistedMessages()</code> method is invoked, as discussed above).</p>
<p>In addition, you can configure a <code class="literal">delayedMessageErrorChannel</code>; when a release fails, an <code class="literal">ErrorMessage</code> is sent to that channel with the exception as the payload and has the <code class="literal">originalMessage</code> property.
The <code class="literal">ErrorMessage</code> contains a header <code class="literal">IntegrationMessageHeaderAccessor.DELIVERY_ATTEMPT</code> containing the current count.</p>
<p>If the error flow consumes the error message and exits normally, no further action is taken; if the release is transactional, the transaction will commit and the message deleted from the store.
If the error flow throws an exception, the release will be retried up to <code class="literal">maxAttempts</code> as discussed above.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scripting" href="#scripting"></a>10.7&nbsp;Scripting Support</h2></div></div></div>

<p>Spring Integration 2.1 added support for the <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/pr/jsr223/" target="_top">JSR223 Scripting for Java specification</a>, introduced in Java version 6.
It lets you use scripts written in any supported language (including Ruby, JRuby, Javascript, and Groovy) to provide the logic for various integration components, similar to the way the Spring Expression Language (SpEL) is used in Spring Integration.
For more information about JSR223, see the <a class="ulink" href="https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/prog_guide/api.html" target="_top">documentation</a>.</p>
<p>You need to include this dependency into your project:</p>
<div class="informalexample">
<p>
<b>Maven.&nbsp;</b>

</p><pre class="programlisting"><span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.integration<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>spring-integration-scripting<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>5.1.2.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span></pre><p>

</p>
<p>
<b>Gradle.&nbsp;</b>

</p><pre class="programlisting">compile <span class="hl-string">"org.springframework.integration:spring-integration-scripting:5.1.2.RELEASE"</span></pre><p>

</p>
</div>
<p>In addition you need to add a script engine implementation, e.g. JRuby, Jython.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Note that this feature requires Java 6 or higher.</p>
</td></tr></table></div>
<p>In order to use a JVM scripting language, a JSR223 implementation for that language must be included in your class path.
Java 6 natively supports Javascript.
The <a class="ulink" href="http://www.groovy-lang.org/" target="_top">Groovy</a> and <a class="ulink" href="http://jruby.org/" target="_top">JRuby</a> projects provide JSR233 support in their standard distributions.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Various JSR223 language implementations have been developed by third parties.
A particular implementation&#8217;s compatibility with Spring Integration depends on how well it conforms to the specification and the implementer&#8217;s interpretation of the specification.</p>
</td></tr></table></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>If you plan to use Groovy as your scripting language, we recommended you use <a class="link" href="messaging-endpoints-chapter.html#groovy" title="10.8&nbsp;Groovy support">Spring-Integration&#8217;s Groovy Support</a> as it offers additional features specific to Groovy.
However, this section is relevant as well.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="scripting-config" href="#scripting-config"></a>10.7.1&nbsp;Script Configuration</h3></div></div></div>

<p>Depending on the complexity of your integration requirements, scripts may be provided inline as CDATA in XML configuration&nbsp;or as a reference to a Spring resource that contains the script.
To enable scripting support, Spring Integration defines a <code class="literal">ScriptExecutingMessageProcessor</code>,&nbsp;which binds the message payload to a variable named <code class="literal">payload</code> and the message headers to a <code class="literal">headers</code> variable, both accessible within the script execution context.
All you need to do is write a script that uses these variables.
The following pair of examples show sample configurations that create filters:</p>
<div class="example"><a name="d5e7821" href="#d5e7821"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Filter</b></p><div class="example-contents">

<pre class="programlisting"><span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"referencedScriptInput"</span><span class="hl-tag">&gt;</span>
   <span class="hl-tag">&lt;int-script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"ruby"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"some/path/to/ruby/script/RubyFilterTests.rb"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span>

<span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inlineScriptInput"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;int-script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"groovy"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;![CDATA[</span>
     return payload == 'good'
   <span class="hl-tag">]]&gt;</span>
  <span class="hl-tag">&lt;/int-script:script&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span></pre>
</div></div><br class="example-break">
<p>As the preceding examples show, the script can be included inline or can be included by reference to a resource location (by using the <code class="literal">location</code> attribute).
Additionally, the <code class="literal">lang</code> attribute corresponds to the language name (or its JSR223 alias)</p>
<p>Other Spring Integration endpoint elements that support scripting include <code class="literal">router</code>, <code class="literal">service-activator</code>, <code class="literal">transformer</code>, and <code class="literal">splitter</code>.
The scripting configuration in each case would be identical to the above (besides the endpoint element).</p>
<p>Another useful feature of scripting support is the ability to update (reload) scripts without having to restart the application context.
To do so, specify the <code class="literal">refresh-check-delay</code> attribute on the <code class="literal">script</code> element, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script&nbsp;location="..."</span> <span class="hl-attribute">refresh-check-delay</span>=<span class="hl-value">"5000"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>In the preceding example, the script location is checked for updates every 5 seconds.
If the script is updated, any invocation that occurs later than 5 seconds since the update results in running the new script.</p>
<p>Consider the following example:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script&nbsp;location="..."</span> <span class="hl-attribute">refresh-check-delay</span>=<span class="hl-value">"0"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>In the preceding example, the context is updated with any script modifications as soon as such modification occurs, providing a simple mechanism for <span class="emphasis"><em>real-time</em></span> configuration.
Any negative value means the script is not reloaded after initialization of the application context.
This is the default behavior.
The following example shows a script that never updates:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script&nbsp;location="..."</span> <span class="hl-attribute">refresh-check-delay</span>=<span class="hl-value">"-1"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Inline scripts can not be reloaded.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scripting-script-variable-bindings" href="#scripting-script-variable-bindings"></a>Script Variable Bindings</h4></div></div></div>

<p>Variable bindings are required to enable the script to reference variables externally provided to the script&#8217;s execution context.
By default, <code class="literal">payload</code> and <code class="literal">headers</code> are used as binding variables.
You can bind additional variables to a script by using <code class="literal">&lt;variable&gt;</code> elements, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"js"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"foo/bar/MyScript.js"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"thing1"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"thing2"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"date"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/script:script&gt;</span></pre>
</div>
<p>As shown in the preceding example, you can bind a script variable either to a scalar value or to a Spring bean reference.
Note that <code class="literal">payload</code> and <code class="literal">headers</code> are still included as binding variables.</p>
<p>With Spring Integration 3.0, in addition to the <code class="literal">variable</code> element, the <code class="literal">variables</code> attribute has been introduced.
This attribute and the <code class="literal">variable</code> elements are not mutually exclusive, and you can combine them within one <code class="literal">script</code> component.
However, variables must be unique, regardless of where they are defined.
Also, since Spring Integration 3.0, variable bindings are allowed for inline scripts, too, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;script:script</span> <span class="hl-attribute">lang</span>=<span class="hl-value">"ruby"</span> <span class="hl-attribute">variables</span>=<span class="hl-value">"thing1=THING1, date-ref=dateBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thing2"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"thing2Bean"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;script:variable</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thing3"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"thing2"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;![CDATA[</span>
            payload.foo = thing1
            payload.date = date
            payload.bar = thing2
            payload.baz = thing3
            payload
        <span class="hl-tag">]]&gt;</span>
    <span class="hl-tag">&lt;/script:script&gt;</span>
<span class="hl-tag">&lt;/service-activator&gt;</span></pre>
</div>
<p>The preceding example shows a combination of an inline script, a <code class="literal">variable</code> element, and a <code class="literal">variables</code> attribute.
The <code class="literal">variables</code> attribute contains a comma-separated value, where each segment contains an <span class="emphasis"><em>=</em></span> separated pair of the variable and its value.
The variable name can be suffixed with <code class="literal">-ref</code>, as in the <code class="literal">date-ref</code> variable in the preceding example.
That means that the binding variable has the name, <code class="literal">date</code>, but the value is a reference to the <code class="literal">dateBean</code> bean from the application context.
This may be useful when using property placeholder configuration or command-line arguments.</p>
<p>If you need more control over how variables are generated, you can implement your own Java class that uses the <code class="literal">ScriptVariableGenerator</code> strategy, which is defined by the following interface:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ScriptVariableGenerator {

    Map&lt;String, Object&gt; generateScriptVariables(Message&lt;?&gt; message);

}</pre>
</div>
<p>This interface requires you to implement the <code class="literal">generateScriptVariables(Message)</code> method.
The message argument lets you access any data available in the message payload and headers, and the return value is the <code class="literal">Map</code> of bound variables.
This method is called every time the script is executed for a message.
The following example shows how to provide an implementation of <code class="literal">ScriptVariableGenerator</code> and reference it with the <code class="literal">script-variable-generator</code> attribute:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-script:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">"foo/bar/MyScript.groovy"</span>
        <span class="hl-attribute">script-variable-generator</span>=<span class="hl-value">"variableGenerator"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"variableGenerator"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.MyScriptVariableGenerator"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>If a <code class="literal">script-variable-generator</code> is not provided, script components use <code class="literal">DefaultScriptVariableGenerator</code>, which merges any provided <code class="literal">&lt;variable&gt;</code> elements with <code class="literal">payload</code> and <code class="literal">headers</code> variables from the <code class="literal">Message</code> in its <code class="literal">generateScriptVariables(Message)</code> method.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>You cannot provide both the <code class="literal">script-variable-generator</code> attribute and <code class="literal">&lt;variable&gt;</code> element(s).
They are mutually exclusive.</p>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="groovy" href="#groovy"></a>10.8&nbsp;Groovy support</h2></div></div></div>

<p>In Spring Integration 2.0, we added Groovy support, letting you use the Groovy scripting language to provide the logic for various integration components&#8201;&#8212;&#8201;similar to the way the Spring Expression Language (SpEL) is supported for routing, transformation, and other integration concerns.
For more information about Groovy, see the Groovy documentation, which you can find on the <a class="ulink" href="http://www.groovy-lang.org/" target="_top">project website</a>.</p>
<p>You need to include this dependency into your project:</p>
<div class="informalexample">
<p>
<b>Maven.&nbsp;</b>

</p><pre class="programlisting"><span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.integration<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>spring-integration-groovy<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>5.1.2.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span></pre><p>

</p>
<p>
<b>Gradle.&nbsp;</b>

</p><pre class="programlisting">compile <span class="hl-string">"org.springframework.integration:spring-integration-groovy:5.1.2.RELEASE"</span></pre><p>

</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="groovy-config" href="#groovy-config"></a>10.8.1&nbsp;Groovy Configuration</h3></div></div></div>

<p>With Spring Integration 2.1, the configuration namespace for the Groovy support is an extension of Spring Integration&#8217;s scripting support and shares the core configuration and behavior described in detail in the <a class="xref" href="messaging-endpoints-chapter.html#scripting" title="10.7&nbsp;Scripting Support">Section&nbsp;10.7, &#8220;Scripting Support&#8221;</a> section.
Even though Groovy scripts are well supported by generic scripting support, the Groovy support provides the <code class="literal">Groovy</code> configuration namespace, which is backed by the Spring Framework&#8217;s <code class="literal">org.springframework.scripting.groovy.GroovyScriptFactory</code> and related components, offering extended capabilities for using Groovy.
The following listing shows two sample configurations:</p>
<div class="example"><a name="d5e7917" href="#d5e7917"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Filter</b></p><div class="example-contents">

<pre class="programlisting"><span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"referencedScriptInput"</span><span class="hl-tag">&gt;</span>
   <span class="hl-tag">&lt;int-groovy:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">"some/path/to/groovy/file/GroovyFilterTests.groovy"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span>

<span class="hl-tag">&lt;int:filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inlineScriptInput"</span><span class="hl-tag">&gt;</span>
     <span class="hl-tag">&lt;int-groovy:script&gt;</span><span class="hl-tag">&lt;![CDATA[</span>
     return payload == 'good'
   <span class="hl-tag">]]&gt;</span><span class="hl-tag">&lt;/int-groovy:script&gt;</span>
<span class="hl-tag">&lt;/int:filter&gt;</span></pre>
</div></div><br class="example-break">
<p>As the preceding examples show, the configuration looks identical to the general scripting support configuration.
The only difference is the use of the Groovy namespace, as indicated by the <code class="literal">int-groovy</code> namespace prefix.
Also note that the <code class="literal">lang</code> attribute on the <code class="literal">&lt;script&gt;</code> tag is not valid in this namespace.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_groovy_object_customization" href="#_groovy_object_customization"></a>10.8.2&nbsp;Groovy Object Customization</h3></div></div></div>

<p>If you need to customize the Groovy object itself (beyond setting variables) you can reference a bean that implements <code class="literal">GroovyObjectCustomizer</code> by using the <code class="literal">customizer</code> attribute.
For example, this might be useful if you want to implement a domain-specific language (DSL) by modifying the <code class="literal">MetaClass</code> and registering functions to be available within the script.
The following example shows how to do so:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"groovyChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int-groovy:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">"somewhere/SomeScript.groovy"</span> <span class="hl-attribute">customizer</span>=<span class="hl-value">"groovyCustomizer"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"groovyCustomizer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.something.MyGroovyObjectCustomizer"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>Setting a custom <code class="literal">GroovyObjectCustomizer</code> is not mutually exclusive with <code class="literal">&lt;variable&gt;</code> elements or the <code class="literal">script-variable-generator</code> attribute.
It can also be provided when defining an inline script.</p>
<p>Spring Integration 3.0 introduced the <code class="literal">variables</code> attribute, which works in conjunction with the <code class="literal">variable</code> element.
Also, groovy scripts have the ability to resolve a variable to a bean in the <code class="literal">BeanFactory</code>, if a binding variable was not provided with the name.
The following example shows how to use a variable (<code class="literal">entityManager</code>):</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-groovy:script&gt;</span>
    <span class="hl-tag">&lt;![CDATA[</span>
        entityManager.persist(payload)
        payload
    <span class="hl-tag">]]&gt;</span>
<span class="hl-tag">&lt;/int-groovy:script&gt;</span></pre>
</div>
<p><code class="literal">entityManager</code> must be an appropriate bean in the application context.</p>
<p>For more information regarding the <code class="literal">&lt;variable&gt;</code> element, the <code class="literal">variables</code> attribute, and the <code class="literal">script-variable-generator</code> attribute, see  <a class="xref" href="messaging-endpoints-chapter.html#scripting-script-variable-bindings" title="Script Variable Bindings">the section called &#8220;Script Variable Bindings&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_groovy_script_compiler_customization" href="#_groovy_script_compiler_customization"></a>10.8.3&nbsp;Groovy Script Compiler Customization</h3></div></div></div>

<p>The <code class="literal">@CompileStatic</code> hint is the most popular Groovy compiler customization option.
It can be used on the class or method level.
For more information, see the Groovy <a class="ulink" href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_static_compilation" target="_top">Reference Manual</a> and, specifically, <a class="ulink" href="http://docs.groovy-lang.org/latest/html/documentation/index.html#compilestatic-annotation" target="_top">@CompileStatic</a>.
To utilize this feature for short scripts (in integration scenarios), we are forced to change simple scripts to more Java-like code.
Consider the following <code class="literal">&lt;filter&gt;</code> script:</p>
<div class="informalexample">
<pre class="programlisting">headers.type == <span class="hl-string">'good'</span></pre>
</div>
<p>The preceding script becomes the following method in Spring Integration:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@groovy.transform.CompileStatic</span></em>
String filter(Map headers) {
	headers.type == <span class="hl-string">'good'</span>
}

filter(headers)</pre>
</div>
<p>With that, the <code class="literal">filter()</code> method is transformed and compiled to static Java code, bypassing the Groovy
dynamic phases of invocation, such as <code class="literal">getProperty()</code> factories and <code class="literal">CallSite</code> proxies.</p>
<p>Starting with version 4.3, you can configure the Spring Integration Groovy components with the <code class="literal">compile-static</code> <code class="literal">boolean</code> option, specifying that <code class="literal">ASTTransformationCustomizer</code> for <code class="literal">@CompileStatic</code> should be added to the internal <code class="literal">CompilerConfiguration</code>.
With that in place, you can omit the method declaration with <code class="literal">@CompileStatic</code> in our script code and still get compiled
plain Java code.
In this case, the preceding script can be short but still needs to be a little more verbose than interpreted script, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting">binding.variables.headers.type == <span class="hl-string">'good'</span></pre>
</div>
<p>You must access the <code class="literal">headers</code> and <code class="literal">payload</code> (or any other) variables through the <code class="literal">groovy.lang.Script</code> <code class="literal">binding</code> property because, with <code class="literal">@CompileStatic</code>, we do not have the  dynamic <code class="literal">GroovyObject.getProperty()</code> capability.</p>
<p>In addition, we introduced the <code class="literal">compiler-configuration</code> bean reference.
With this attribute, you can provide any other required Groovy compiler customizations, such as <code class="literal">ImportCustomizer</code>.
For more information about this feature, see the Groovy Documentation for <a class="ulink" href="http://groovy.jmiguel.eu/groovy.codehaus.org/Advanced+compiler+configuration.html" target="_top">advanced compiler configuration</a>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Using <code class="literal">compilerConfiguration</code> does not automatically add an <code class="literal">ASTTransformationCustomizer</code> for the <code class="literal">@CompileStatic</code> annotation, and it overrides the <code class="literal">compileStatic</code> option.
If you still need <code class="literal">CompileStatic</code>, you should manually add a <code class="literal">new ASTTransformationCustomizer(CompileStatic.class)</code> into the <code class="literal">CompilationCustomizers</code> of that custom <code class="literal">compilerConfiguration</code>.</p>
</td></tr></table></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The Groovy compiler customization does not have any effect on the <code class="literal">refresh-check-delay</code> option, and reloadable scripts can be statically compiled, too.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="groovy-control-bus" href="#groovy-control-bus"></a>10.8.4&nbsp;Control Bus</h3></div></div></div>

<p>As described in (<a class="ulink" href="http://www.eaipatterns.com/ControlBus.html" target="_top">Enterprise Integration Patterns</a>), the idea behind the control bus is that you can use the same messaging system for monitoring and managing the components within the framework as is used for "<code class="literal">application-level</code>" messaging.
In Spring Integration, we build upon the adapters described earlier so that you can send Messages as a means of invoking exposed operations.
One option for those operations is Groovy scripts.
The following example configures a Groovy script for the control bus:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-groovy:control-bus</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"operationChannel"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>The control bus has an input channel that can be accessed to invoke operations on the beans in the application context.</p>
<p>The Groovy control bus runs messages on the input channel as Groovy scripts.
It takes a message, compiles the body to a script, customizes it with a <code class="literal">GroovyObjectCustomizer</code>, and runs it.
The control bus' <code class="literal">MessageProcessor</code> exposes all beans in the application context that are annotated with <code class="literal">@ManagedResource</code> and implement Spring&#8217;s <code class="literal">Lifecycle</code> interface or extend Spring&#8217;s <code class="literal">CustomizableThreadCreator</code> base class (for example, several of the <code class="literal">TaskExecutor</code> and <code class="literal">TaskScheduler</code> implementations).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Be careful about using managed beans with custom scopes (such as <span class="emphasis"><em>request</em></span>) in the Control Bus' command scripts, especially inside an asynchronous message flow.
If <code class="literal">MessageProcessor</code> of the control bus cannot expose a bean from the application context, you may end up with some <code class="literal">BeansException</code> during the command script&#8217;s run.
For example, if a custom scope&#8217;s context is not established, the attempt to get a bean within that scope triggers a <code class="literal">BeanCreationException</code>.</p>
</td></tr></table></div>
<p>If you need to further customize the Groovy objects, you can also provide a reference to a bean that implements <code class="literal">GroovyObjectCustomizer</code> through the <code class="literal">customizer</code> attribute, as the following example shows:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-groovy:control-bus</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span>
        <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
        <span class="hl-attribute">customizer</span>=<span class="hl-value">"groovyCustomizer"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"groovyCustomizer"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.MyGroovyObjectCustomizer"</span><span class="hl-tag">/&gt;</span></pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-handler-advice-chain" href="#message-handler-advice-chain"></a>10.9&nbsp;Adding Behavior to Endpoints</h2></div></div></div>

<p>Prior to Spring Integration 2.2, you could add behavior to an entire Integration flow by adding an AOP Advice to a poller&#8217;s <code class="literal">&lt;advice-chain/&gt;</code> element.
However, suppose you want to retry, say, just a REST Web Service call, and not any downstream endpoints.</p>
<p>For example, consider the following flow:</p>
<div class="informalexample">
<pre class="screen">inbound-adapter-&gt;poller-&gt;http-gateway1-&gt;http-gateway2-&gt;jdbc-outbound-adapter</pre>
</div>
<p>If you configure some retry-logic into an advice chain on the poller and the call to <code class="literal">http-gateway2</code> failed because of a network glitch, the retry causes both <code class="literal">http-gateway1</code> and <code class="literal">http-gateway2</code> to be called a second time.
Similarly, after a transient failure in the jdbc-outbound-adapter, both HTTP gateways are called a second time before again calling the <code class="literal">jdbc-outbound-adapter</code>.</p>
<p>Spring Integration 2.2 adds the ability to add behavior to individual endpoints.
This is achieved by the addition of the <code class="literal">&lt;request-handler-advice-chain/&gt;</code> element to many endpoints.
The following example shows how to the <code class="literal">&lt;request-handler-advice-chain/&gt;</code> element within an <code class="literal">outbound-gateway</code>:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-http:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"withAdvice"</span>
    <span class="hl-attribute">url-expression</span>=<span class="hl-value">"'http://localhost/test1'"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requests"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"nextChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"myRetryAdvice"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int-http:outbound-gateway&gt;</span></pre>
<p>In this case, <code class="literal">myRetryAdvice</code> is applied only locally to this gateway and does not apply to further actions taken downstream after the reply is sent to <code class="literal">nextChannel</code>.
The scope of the advice is limited to the endpoint itself.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>At this time, you cannot advise an entire <code class="literal">&lt;chain/&gt;</code> of endpoints.
The schema does not allow a <code class="literal">&lt;request-handler-advice-chain&gt;</code> as a child element of the chain itself.</p>
<p>However, a <code class="literal">&lt;request-handler-advice-chain&gt;</code> can be added to individual reply-producing endpoints within a <code class="literal">&lt;chain&gt;</code> element.
An exception is that, in a chain that produces no reply, because the last element in the chain is an <code class="literal">outbound-channel-adapter</code>, that last element cannot be advised.
If you need to advise such an element, it must be moved outside of the chain (with the <code class="literal">output-channel</code> of the chain being the <code class="literal">input-channel</code> of the adapter).
The adapter can then be advised as usual.
For chains that produce a reply, every child element can be advised.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advice-classes" href="#advice-classes"></a>10.9.1&nbsp;Provided Advice Classes</h3></div></div></div>

<p>In addition to providing the general mechanism to apply AOP advice classes, Spring Integration provides three standard advice classes:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">RequestHandlerRetryAdvice</code> (described in <a class="xref" href="messaging-endpoints-chapter.html#retry-advice" title="Retry Advice">the section called &#8220;Retry Advice&#8221;</a>)
</li><li class="listitem">
<code class="literal">RequestHandlerCircuitBreakerAdvice</code> (described in <a class="xref" href="messaging-endpoints-chapter.html#circuit-breaker-advice" title="Circuit Breaker Advice">the section called &#8220;Circuit Breaker Advice&#8221;</a>)
</li><li class="listitem">
<code class="literal">ExpressionEvaluatingRequestHandlerAdvice</code> (described in <a class="xref" href="messaging-endpoints-chapter.html#expression-advice" title="Expression Evaluating Advice">the section called &#8220;Expression Evaluating Advice&#8221;</a>)
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="retry-advice" href="#retry-advice"></a>Retry Advice</h4></div></div></div>

<p>The retry advice (<code class="literal">o.s.i.handler.advice.RequestHandlerRetryAdvice</code>) leverages the rich retry mechanisms provided by the <a class="ulink" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a> project.
The core component of <code class="literal">spring-retry</code> is the <code class="literal">RetryTemplate</code>, which allows configuration of sophisticated retry scenarios, including <code class="literal">RetryPolicy</code> and <code class="literal">BackoffPolicy</code> strategies (with a number of implementations) as well as a <code class="literal">RecoveryCallback</code> strategy to determine the action to take when retries are exhausted.</p>
<div class="variablelist"><dl class="variablelist"><dt><span class="term">Stateless Retry</span></dt><dd>
Stateless retry is the case where the retry activity is handled entirely within the advice. The thread pauses (if configured to do so) and retries the action.
</dd><dt><span class="term">Stateful Retry</span></dt><dd>
Stateful retry is the case where the retry state is managed within the advice but where an exception is thrown and the caller resubmits the request.
An example for stateful retry is when we want the message originator (for example,JMS) to be responsible for resubmitting, rather than performing it on the current thread.
Stateful retry needs some mechanism to detect a retried submission.
</dd></dl></div>
<p>For more information on <code class="literal">spring-retry</code>, see <a class="ulink" href="https://docs.spring.io/spring-integration/api/" target="_top">the project&#8217;s Javadoc</a> and the reference documentation for <a class="ulink" href="http://docs.spring.io/spring-batch/reference/html/retry.html" target="_top">Spring Batch</a>, where <code class="literal">spring-retry</code> originated.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
<p>The default back off behavior is to not back off. Retries are attempted immediately.
Using a back off policy that causes threads to pause between attempts may cause performance issues, including excessive memory use and thread starvation.
In high-volume environments, back off policies should be used with caution.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="retry-config" href="#retry-config"></a>Configuring the Retry Advice</h5></div></div></div>

<p>The examples in this section use the following <code class="literal">&lt;service-activator&gt;</code> that always throws an exception:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FailingService {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> service(String message) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(<span class="hl-string">"error"</span>);
    }
}</pre>
</div>
<div class="variablelist"><dl class="variablelist"><dt><span class="term">Simple Stateless Retry</span></dt><dd>
<p class="simpara">The default <code class="literal">RetryTemplate</code> has a <code class="literal">SimpleRetryPolicy</code> which tries three times.
There is no <code class="literal">BackOffPolicy</code>, so the three attempts are made back-to-back-to-back with no delay between attempts.
There is no <code class="literal">RecoveryCallback</code>, so the result is to throw the exception to the caller after the final failed retry occurs.
In a Spring Integration environment, this final exception might be handled by using an <code class="literal">error-channel</code> on the inbound endpoint.
The following example uses <code class="literal">RetryTemplate</code> and shows its <code class="literal">DEBUG</code> output:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
DEBUG [task-scheduler-2]Retry: count=0
DEBUG [task-scheduler-2]Checking for rethrow: count=1
DEBUG [task-scheduler-2]Retry: count=1
DEBUG [task-scheduler-2]Checking for rethrow: count=2
DEBUG [task-scheduler-2]Retry: count=2
DEBUG [task-scheduler-2]Checking for rethrow: count=3
DEBUG [task-scheduler-2]Retry failed last attempt: count=3</pre>
</div>
</dd><dt><span class="term">Simple Stateless Retry with Recovery</span></dt><dd>
<p class="simpara">The following example adds a <code class="literal">RecoveryCallback</code> to the preceding example and uses an <code class="literal">ErrorMessageSendingRecoverer</code> to send an <code class="literal">ErrorMessage</code> to a channel:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"recoveryCallback"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.ErrorMessageSendingRecoverer"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:int:service-activator&gt;</span>

DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
DEBUG [task-scheduler-2]Retry: count=0
DEBUG [task-scheduler-2]Checking for rethrow: count=1
DEBUG [task-scheduler-2]Retry: count=1
DEBUG [task-scheduler-2]Checking for rethrow: count=2
DEBUG [task-scheduler-2]Retry: count=2
DEBUG [task-scheduler-2]Checking for rethrow: count=3
DEBUG [task-scheduler-2]Retry failed last attempt: count=3
DEBUG [task-scheduler-2]Sending ErrorMessage :failedMessage:[Payload=...]</pre>
</div>
</dd><dt><span class="term">Stateless Retry with Customized Policies, and Recovery</span></dt><dd>
<p class="simpara">For more sophistication, we can provide the advice with a customized <code class="literal">RetryTemplate</code>.
This example continues to use the <code class="literal">SimpleRetryPolicy</code> but increases the attempts to four.
It also adds an <code class="literal">ExponentialBackoffPolicy</code> where the first retry waits one second, the second waits five seconds and the third waits 25 (for four attempts in all).
The following listing shows the example and its <code class="literal">DEBUG</code> output:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"recoveryCallback"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.ErrorMessageSendingRecoverer"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"retryTemplate"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"retryTemplate"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retryTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.support.RetryTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"retryPolicy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.policy.SimpleRetryPolicy"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxAttempts"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"4"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"backOffPolicy"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.retry.backoff.ExponentialBackOffPolicy"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"initialInterval"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"multiplier"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5.0"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"maxInterval"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

27.058 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]
27.071 DEBUG [task-scheduler-1]Retry: count=0
27.080 DEBUG [task-scheduler-1]Sleeping for 1000
28.081 DEBUG [task-scheduler-1]Checking for rethrow: count=1
28.081 DEBUG [task-scheduler-1]Retry: count=1
28.081 DEBUG [task-scheduler-1]Sleeping for 5000
33.082 DEBUG [task-scheduler-1]Checking for rethrow: count=2
33.082 DEBUG [task-scheduler-1]Retry: count=2
33.083 DEBUG [task-scheduler-1]Sleeping for 25000
58.083 DEBUG [task-scheduler-1]Checking for rethrow: count=3
58.083 DEBUG [task-scheduler-1]Retry: count=3
58.084 DEBUG [task-scheduler-1]Checking for rethrow: count=4
58.084 DEBUG [task-scheduler-1]Retry failed last attempt: count=4
58.086 DEBUG [task-scheduler-1]Sending ErrorMessage :failedMessage:[Payload=...]</pre>
</div>
</dd><dt><span class="term">Namespace Support for Stateless Retry</span></dt><dd>
<p class="simpara">Starting with version 4.0, the preceding configuration can be greatly simplified, thanks to the namespace support for the retry advice, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"retrier"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

<span class="hl-tag">&lt;int:handler-retry-advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retrier"</span> <span class="hl-attribute">max-attempts</span>=<span class="hl-value">"4"</span> <span class="hl-attribute">recovery-channel</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:exponential-back-off</span> <span class="hl-attribute">initial</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">multiplier</span>=<span class="hl-value">"5.0"</span> <span class="hl-attribute">maximum</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:handler-retry-advice&gt;</span></pre>
</div>
<p class="simpara">In the preceding example, the advice is defined as a top-level bean so that it can be used in multiple <code class="literal">request-handler-advice-chain</code> instances.
You can also define the advice directly within the chain, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;int:retry-advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"retrier"</span> <span class="hl-attribute">max-attempts</span>=<span class="hl-value">"4"</span> <span class="hl-attribute">recovery-channel</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;int:exponential-back-off</span> <span class="hl-attribute">initial</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">multiplier</span>=<span class="hl-value">"5.0"</span> <span class="hl-attribute">maximum</span>=<span class="hl-value">"60000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/int:retry-advice&gt;</span>
    <span class="hl-tag">&lt;/request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span></pre>
</div>
<p class="simpara">A <code class="literal">&lt;handler-retry-advice&gt;</code> can have a <code class="literal">&lt;fixed-back-off&gt;</code> or <code class="literal">&lt;exponential-back-off&gt;</code> child element or have no child element.
A <code class="literal">&lt;handler-retry-advice&gt;</code> with no child element uses no back off.
If there is no <code class="literal">recovery-channel</code>, the exception is thrown when retries are exhausted.
The namespace can only be used with stateless retry.</p>
<p class="simpara">For more complex environments (custom policies etc), use normal <code class="literal">&lt;bean&gt;</code> definitions.</p>
</dd><dt><span class="term">Simple Stateful Retry with Recovery</span></dt><dd>
<p class="simpara">To make retry stateful, we need to provide the advice with a <code class="literal">RetryStateGenerator</code> implementation.
This class is used to identify a message as being a resubmission so that the <code class="literal">RetryTemplate</code> can determine the current state of retry for this message.
The framework provides a <code class="literal">SpelExpressionRetryStateGenerator</code>, which determines the message identifier by using a SpEL expression.
This example again uses the default policies (three attempts with no back off).
As with stateless retry, these policies can be customized.
The following listing shows the example and its <code class="literal">DEBUG</code> output:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerRetryAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"retryStateGenerator"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.SpelExpressionRetryStateGenerator"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"headers['jms_messageId']"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"recoveryCallback"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.ErrorMessageSendingRecoverer"</span><span class="hl-tag">&gt;</span>
                    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myErrorChannel"</span><span class="hl-tag"> /&gt;</span>
                <span class="hl-tag">&lt;/bean&gt;</span>
            <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/int:request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

24.351 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
24.368 DEBUG [Container#0-1]Retry: count=0
24.387 DEBUG [Container#0-1]Checking for rethrow: count=1
24.387 DEBUG [Container#0-1]Rethrow in retry for policy: count=1
24.387 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
24.391 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
25.412 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
25.412 DEBUG [Container#0-1]Retry: count=1
25.413 DEBUG [Container#0-1]Checking for rethrow: count=2
25.413 DEBUG [Container#0-1]Rethrow in retry for policy: count=2
25.413 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
25.414 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
26.418 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
26.418 DEBUG [Container#0-1]Retry: count=2
26.419 DEBUG [Container#0-1]Checking for rethrow: count=3
26.419 DEBUG [Container#0-1]Rethrow in retry for policy: count=3
26.419 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
26.420 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
27.425 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
27.426 DEBUG [Container#0-1]Retry failed last attempt: count=3
27.426 DEBUG [Container#0-1]Sending ErrorMessage :failedMessage:[Payload=...]</pre>
</div>
<p class="simpara">If you compare the preceding example with the stateless examples, you can see that, with stateful retry, the exception is thrown to the caller on each failure.</p>
</dd><dt><span class="term">Exception Classification for Retry</span></dt><dd>
<p class="simpara">Spring Retry has a great deal of flexibility for determining which exceptions can invoke retry.
The default configuration retries for all exceptions and the exception classifier looks at the top-level exception.
If you configure it to, say, retry only on <code class="literal">MyException</code> and your application throws a <code class="literal">SomeOtherException</code> where the cause is a <code class="literal">MyException</code>, retry does not occur.</p>
<p class="simpara">Since Spring Retry 1.0.3, the <code class="literal">BinaryExceptionClassifier</code> has a property called <code class="literal">traverseCauses</code> (the default is <code class="literal">false</code>).
When <code class="literal">true</code>, it traverses exception causes until it finds a match or runs out of causes to traverse.</p>
<p class="simpara">To use this classifier for retry, use a <code class="literal">SimpleRetryPolicy</code> created with the constructor that takes the max attempts, the <code class="literal">Map</code> of <code class="literal">Exception</code> objects, and the <code class="literal">traverseCauses</code> boolean. Then you can inject this policy into the <code class="literal">RetryTemplate</code>.</p>
</dd></dl></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="circuit-breaker-advice" href="#circuit-breaker-advice"></a>Circuit Breaker Advice</h4></div></div></div>

<p>The general idea of the circuit breaker pattern is that, if a service is not currently available, do not waste time (and resources) trying to use it.
The <code class="literal">o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice</code> implements this pattern.
When the circuit breaker is in the closed state, the endpoint attempts to invoke the service.
The circuit breaker goes to the open state if a certain number of consecutive attempts fail.
When it is in the open state, new requests "<code class="literal">fail fast</code>" and no attempt is made to invoke the service until some time has expired.</p>
<p>When that time has expired, the circuit breaker is set to the half-open state.
When in this state, if even a single attempt fails, the breaker immediately goes to the open state.
If the attempt succeeds, the breaker goes to the closed state, in which case it does not go to the open state again until the configured number of consecutive failures again occur.
Any successful attempt resets the state to zero failures for the purpose of determining when the breaker might go to the open state again.</p>
<p>Typically, this advice might be used for external services, where it might take some time to fail (such as a timeout attempting to make a network connection).</p>
<p>The <code class="literal">RequestHandlerCircuitBreakerAdvice</code> has two properties: <code class="literal">threshold</code> and <code class="literal">halfOpenAfter</code>.
The <code class="literal">threshold</code> property represents the number of consecutive failures that need to occur before the breaker goes open.
It defaults to <code class="literal">5</code>.
The <code class="literal">halfOpenAfter</code> property represents the time after the last failure that the breaker waits before attempting another request.
The default is 1000 milliseconds.</p>
<p>The following example configures a circuit breaker and shows its <code class="literal">DEBUG</code> and <code class="literal">ERROR</code> output:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"failer"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"service"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"threshold"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span><span class="hl-tag"> /&gt;</span>
            <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"halfOpenAfter"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"12000"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/int:request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/int:service-activator&gt;</span>

05.617 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]
05.638 ERROR [task-scheduler-1]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
10.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
10.600 ERROR [task-scheduler-2]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
15.598 DEBUG [task-scheduler-3]preSend on channel 'input', message: [Payload=...]
15.599 ERROR [task-scheduler-3]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator
...
20.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
20.598 ERROR [task-scheduler-2]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator
...
25.598 DEBUG [task-scheduler-5]preSend on channel 'input', message: [Payload=...]
25.601 ERROR [task-scheduler-5]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
30.598 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=foo...]
30.599 ERROR [task-scheduler-1]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator</pre>
</div>
<p>In the preceding example, the threshold is set to <code class="literal">2</code> and <code class="literal">halfOpenAfter</code> is set to <code class="literal">12</code> seconds.
A new request arrives every 5 seconds.
The first two attempts invoked the service.
The third and fourth failed with an exception indicating that the circuit breaker is open.
The fifth request was attempted because the request was 15 seconds after the last failure.
The sixth attempt fails immediately because the breaker immediately went to open.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="expression-advice" href="#expression-advice"></a>Expression Evaluating Advice</h4></div></div></div>

<p>The final supplied advice class is the <code class="literal">o.s.i.handler.advice.ExpressionEvaluatingRequestHandlerAdvice</code>.
This advice is more general than the other two advices.
It provides a mechanism to evaluate an expression on the original inbound message sent to the endpoint.
Separate expressions are available to be evaluated, after either success or failure.
Optionally, a message containing the evaluation result, together with the input message, can be sent to a message channel.</p>
<p>A typical use case for this advice might be with an <code class="literal">&lt;ftp:outbound-channel-adapter/&gt;</code>, perhaps to move the file to one directory if the transfer was successful or to another directory if it fails:</p>
<p>The advice has properties to set an expression when successful, an expression for failures, and corresponding channels for each.
For the successful case, the message sent to the <code class="literal">successChannel</code> is an <code class="literal">AdviceMessage</code>, with the payload being the result of the expression evaluation.
An additional property, called <code class="literal">inputMessage</code>, contains the original message sent to the handler.
A message sent to the <code class="literal">failureChannel</code> (when the handler throws an exception) is an <code class="literal">ErrorMessage</code> with a payload of <code class="literal">MessageHandlingExpressionEvaluatingAdviceException</code>.
Like all <code class="literal">MessagingException</code> instances, this payload has <code class="literal">failedMessage</code> and <code class="literal">cause</code> properties, as well as an additional property called <code class="literal">evaluationResult</code>, which contains the result of the expression evaluation.</p>
<p>When an exception is thrown in the scope of the advice, by default, that exception is thrown to the caller after any <code class="literal">failureExpression</code> is evaluated.
If you wish to suppress throwing the exception, set the <code class="literal">trapException</code> property to <code class="literal">true</code>.
The following advice shows how to configure an advice with Java DSL:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> EerhaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(EerhaApplication.<span class="hl-keyword">class</span>, args);
        MessageChannel in = context.getBean(<span class="hl-string">"advised.input"</span>, MessageChannel.<span class="hl-keyword">class</span>);
        in.send(<span class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span class="hl-string">"good"</span>));
        in.send(<span class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span class="hl-string">"bad"</span>));
        context.close();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow advised() {
        <span class="hl-keyword">return</span> f -&gt; f.handle((GenericHandler&lt;String&gt;) (payload, headers) -&gt; {
            <span class="hl-keyword">if</span> (payload.equals(<span class="hl-string">"good"</span>)) {
                <span class="hl-keyword">return</span> null;
            }
            <span class="hl-keyword">else</span> {
                <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(<span class="hl-string">"some failure"</span>);
            }
        }, c -&gt; c.advice(expressionAdvice()));
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Advice expressionAdvice() {
        ExpressionEvaluatingRequestHandlerAdvice advice = <span class="hl-keyword">new</span> ExpressionEvaluatingRequestHandlerAdvice();
        advice.setSuccessChannelName(<span class="hl-string">"success.input"</span>);
        advice.setOnSuccessExpressionString(<span class="hl-string">"payload + ' was successful'"</span>);
        advice.setFailureChannelName(<span class="hl-string">"failure.input"</span>);
        advice.setOnFailureExpressionString(
                <span class="hl-string">"payload + ' was bad, with reason: ' + #exception.cause.message"</span>);
        advice.setTrapException(true);
        <span class="hl-keyword">return</span> advice;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow success() {
        <span class="hl-keyword">return</span> f -&gt; f.handle(System.out::println);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow failure() {
        <span class="hl-keyword">return</span> f -&gt; f.handle(System.out::println);
    }

}</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-advice" href="#custom-advice"></a>10.9.2&nbsp;Custom Advice Classes</h3></div></div></div>

<p>In addition to the provided advice classes <a class="link" href="messaging-endpoints-chapter.html#advice-classes" title="10.9.1&nbsp;Provided Advice Classes">described earlier</a>, you can implement your own advice classes.
While you can provide any implementation of <code class="literal">org.aopalliance.aop.Advice</code> (usually <code class="literal">org.aopalliance.intercept.MethodInterceptor</code>), we generally recommend that you subclass <code class="literal">o.s.i.handler.advice.AbstractRequestHandlerAdvice</code>.
This has the benefit of avoiding the writing of low-level aspect-oriented programming code as well as providing a starting point that is specifically tailored for use in this environment.</p>
<p>Subclasses need to implement the <code class="literal">doInvoke()`</code> method, the definition of which follows:</p>
<div class="informalexample">
<pre class="programlisting"><strong class="hl-tag" style="color: blue">/**
 * Subclasses implement this method to apply behavior to the {@link MessageHandler} callback.execute()
 * invokes the handler method and returns its result, or null).
 * @param callback Subclasses invoke the execute() method on this interface to invoke the handler method.
 * @param target The target handler.
 * @param message The message that will be sent to the handler.
 * @return the result after invoking the {@link MessageHandler}.
 * @throws Exception
 */</strong>
<span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Object doInvoke(ExecutionCallback callback, Object target, Message&lt;?&gt; message) <span class="hl-keyword">throws</span> Exception;</pre>
</div>
<p>The callback parameter is a convenience to avoid subclasses that deal with AOP directly.
Invoking the <code class="literal">callback.execute()</code> method invokes the message handler.</p>
<p>The <code class="literal">target</code> parameter is provided for those subclasses that need to maintain state for a specific handler, perhaps by maintaining that state in a <code class="literal">Map</code> keyed by the target.
This feature allows the same advice to be applied to multiple handlers.
The <code class="literal">RequestHandlerCircuitBreakerAdvice</code> uses advice this to keep circuit breaker state for each handler.</p>
<p>The <code class="literal">message</code> parameter is the message sent to the handler.
While the advice cannot modify the message before invoking the handler, it can modify the payload (if it has mutable properties).
Typically, an advice would use the message for logging or to send a copy of the message somewhere before or after invoking the handler.</p>
<p>The return value would normally be the value returned by <code class="literal">callback.execute()</code>.
However, the advice does have the ability to modify the return value.
Note that only <code class="literal">AbstractReplyProducingMessageHandler</code> instances return values.
The following example shows a custom advice class that extends <code class="literal">AbstractRequestHandlerAdvice</code>:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyAdvice <span class="hl-keyword">extends</span> AbstractRequestHandlerAdvice {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> Object doInvoke(ExecutionCallback callback, Object target, Message&lt;?&gt; message) <span class="hl-keyword">throws</span> Exception {
        <span class="hl-comment">// add code before the invocation</span>
        Object result = callback.execute();
        <span class="hl-comment">// add code after the invocation</span>
        <span class="hl-keyword">return</span> result;
    }
}</pre>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>In addition to the <code class="literal">execute()</code> method, <code class="literal">ExecutionCallback</code> provides an additional method: <code class="literal">cloneAndExecute()</code>.
This method must be used in cases where the invocation might be called multiple times within a single execution of <code class="literal">doInvoke()</code>, such as in the <code class="literal">RequestHandlerRetryAdvice</code>.
This is required because the Spring AOP <code class="literal">org.springframework.aop.framework.ReflectiveMethodInvocation</code> object maintains state by keeping track of which advice in a chain was last invoked.
This state must be reset for each call.</p>
<p>For more information, see the <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/framework/ReflectiveMethodInvocation.html" target="_top">ReflectiveMethodInvocation</a> Javadoc.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other-advice" href="#other-advice"></a>10.9.3&nbsp;Other Advice Chain Elements</h3></div></div></div>

<p>While the abstract class mentioned above is a convenience, you can add any <code class="literal">Advice</code>, including a transaction advice, to the chain.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="handle-message-advice" href="#handle-message-advice"></a>10.9.4&nbsp;Handling Message Advice</h3></div></div></div>

<p>As discussed in <a class="link" href="messaging-endpoints-chapter.html#message-handler-advice-chain" title="10.9&nbsp;Adding Behavior to Endpoints">the introduction to this section</a>, advice objects in a request handler advice chain are applied to just the current endpoint, not the downstream flow (if any).
For <code class="literal">MessageHandler</code> objects that produce a reply (such as those that extend <code class="literal">AbstractReplyProducingMessageHandler</code>), the advice is applied to an internal method: <code class="literal">handleRequestMessage()</code> (called from <code class="literal">MessageHandler.handleMessage()</code>).
For other message handlers, the advice is applied to <code class="literal">MessageHandler.handleMessage()</code>.</p>
<p>There are some circumstances where, even if a message handler is an <code class="literal">AbstractReplyProducingMessageHandler</code>, the advice must be applied to the <code class="literal">handleMessage</code> method.
For example, the <a class="link" href="messaging-endpoints-chapter.html#idempotent-receiver" title="10.9.10&nbsp;Idempotent Receiver Enterprise Integration Pattern">idempotent receiver</a> might return <code class="literal">null</code>, which would cause an exception if the handler&#8217;s <code class="literal">replyRequired</code> property is set to <code class="literal">true</code>.
Another example is the <code class="literal">BoundRabbitChannelAdvice</code>&#8201;&#8212;&#8201;see <a class="xref" href="amqp.html#amqp-strict-ordering" title="14.13&nbsp;Strict Message Ordering">Section&nbsp;14.13, &#8220;Strict Message Ordering&#8221;</a>.</p>
<p>Starting with version 4.3.1, a new <code class="literal">HandleMessageAdvice</code> interface and its base implementation (<code class="literal">AbstractHandleMessageAdvice</code>) have been introduced.
<code class="literal">Advice</code> objects that implement <code class="literal">HandleMessageAdvice</code> are always applied to the <code class="literal">handleMessage()</code> method, regardless of the handler type.</p>
<p>It is important to understand that <code class="literal">HandleMessageAdvice</code> implementations (such as <a class="link" href="messaging-endpoints-chapter.html#idempotent-receiver" title="10.9.10&nbsp;Idempotent Receiver Enterprise Integration Pattern">idempotent receiver</a>), when applied to a handlers that return responses, are dissociated from the <code class="literal">adviceChain</code> and properly applied to the <code class="literal">MessageHandler.handleMessage()</code> method.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Because of this disassociation, the advice chain order is not honored.</p>
</td></tr></table></div>
<p>Consider the following configuration:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;some-reply-producing-endpoint</span> <span class="hl-attribute">...</span><span class="hl-tag"> &gt;</span>
    <span class="hl-tag">&lt;int:request-handler-advice-chain&gt;</span>
        <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">...</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myHandleMessageAdvice"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:request-handler-advice-chain&gt;</span>
<span class="hl-tag">&lt;/some-reply-producing-endpoint&gt;</span></pre>
</div>
<p>In the preceding example, the <code class="literal">&lt;tx:advice&gt;</code> is applied to the <code class="literal">AbstractReplyProducingMessageHandler.handleRequestMessage()</code>.
However, <code class="literal">myHandleMessageAdvice</code> is applied for to <code class="literal">MessageHandler.handleMessage()</code>.
Therefore, it is invoked <span class="strong"><strong>before</strong></span> the <code class="literal">&lt;tx:advice&gt;</code>.
To retain the order, you should follow the standard <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html" target="_top">Spring AOP</a> configuration approach and use an endpoint <code class="literal">id</code> together with the <code class="literal">.handler</code> suffix to obtain the target <code class="literal">MessageHandler</code> bean.
Note that, in that case, the entire downstream flow is within the transaction scope.</p>
<p>In the case of a <code class="literal">MessageHandler</code> that does not return a response, the advice chain order is retained.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tx-handle-message-advice" href="#tx-handle-message-advice"></a>10.9.5&nbsp;Transaction Support</h3></div></div></div>

<p>Starting with version 5.0, a new <code class="literal">TransactionHandleMessageAdvice</code> has been introduced to make the whole downstream flow transactional, thanks to the <code class="literal">HandleMessageAdvice</code> implementation.
When a regular <code class="literal">TransactionInterceptor</code> is used in the <code class="literal">&lt;request-handler-advice-chain&gt;</code> element (for example, through configuring <code class="literal">&lt;tx:advice&gt;</code>), a started transaction is only applied only for an internal <code class="literal">AbstractReplyProducingMessageHandler.handleRequestMessage()</code> and is not propagated to the downstream flow.</p>
<p>To simplify XML configuration, along with the <code class="literal">&lt;request-handler-advice-chain&gt;</code>, a <code class="literal">&lt;transactional&gt;</code> element has been added to all <code class="literal">&lt;outbound-gateway&gt;</code> and <code class="literal">&lt;service-activator&gt;</code> and related components.
The following example shows <code class="literal">&lt;transactional&gt;</code> in use:</p>
<pre class="programlisting"><span class="hl-tag">&lt;int-rmi:outbound-gateway</span> <span class="hl-attribute">remote-channel</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>
    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"good"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"reply"</span> <span class="hl-attribute">port</span>=<span class="hl-value">"#{@port}"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int-rmi:transactional/&gt;</span>
<span class="hl-tag">&lt;/int-rmi:outbound-gateway&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.mockito.Mockito"</span> <span class="hl-attribute">factory-method</span>=<span class="hl-value">"mock"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.springframework.transaction.PlatformTransactionManager"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>If you are familiar with the <a class="link" href="jpa.html" title="22.&nbsp;JPA Support">JPA integration components</a>, such a configuration is not new, but now we can start a transaction from any point in our flow&#8201;&#8212;&#8201;not only from the <code class="literal">&lt;poller&gt;</code> or a message-driven channel adapter such as <a class="link" href="jms.html#jms-message-driven-channel-adapter" title="23.2&nbsp;Message-driven Channel Adapter">JMS</a>.</p>
<p>Java configuration can be simplified by using the <code class="literal">TransactionInterceptorBuilder</code>, and the result bean name can be used in the <a class="link" href="configuration.html#annotations" title="E.5&nbsp;Annotation Support">messaging annotations</a> <code class="literal">adviceChain</code> attribute, as the following example shows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> ConcurrentMetadataStore store() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SimpleMetadataStore(hazelcastInstance()
                       .getMap(<span class="hl-string">"idempotentReceiverMetadataStore"</span>));
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IdempotentReceiverInterceptor idempotentReceiverInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> IdempotentReceiverInterceptor(
            <span class="hl-keyword">new</span> MetadataStoreSelector(
                    message -&gt; message.getPayload().toString(),
                    message -&gt; message.getPayload().toString().toUpperCase(), store()));
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> TransactionInterceptor transactionInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> TransactionInterceptorBuilder(true)
                .transactionManager(<span class="hl-keyword">this</span>.transactionManager)
                .isolation(Isolation.READ_COMMITTED)
                .propagation(Propagation.REQUIRES_NEW)
                .build();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@org.springframework.integration.annotation.Transformer(inputChannel = "input",
         outputChannel = "output",
         adviceChain = { "idempotentReceiverInterceptor",
                 "transactionInterceptor" })</span></em>
<span class="hl-keyword">public</span> Transformer transformer() {
    <span class="hl-keyword">return</span> message -&gt; message;
}</pre>
<p>Note the <code class="literal">true</code> parameter on the <code class="literal">TransactionInterceptorBuilder</code> constructor.
It causes the creation of a <code class="literal">TransactionHandleMessageAdvice</code>, not a regular <code class="literal">TransactionInterceptor</code>.</p>
<p>Java DSL supports an <code class="literal">Advice</code> through the <code class="literal">.transactional()</code> options on the endpoint configuration, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow updatingGatewayFlow() {
    <span class="hl-keyword">return</span> f -&gt; f
        .handle(Jpa.updatingGateway(<span class="hl-keyword">this</span>.entityManagerFactory),
                e -&gt; e.transactional(true))
        .channel(c -&gt; c.queue(<span class="hl-string">"persistResults"</span>));
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advising-filters" href="#advising-filters"></a>10.9.6&nbsp;Advising Filters</h3></div></div></div>

<p>There is an additional consideration when advising <code class="literal">Filter</code> advices.
By default, any discard actions (when the filter returns <code class="literal">false</code>) are performed within the scope of the advice chain.
This could include all the flow downstream of the discard channel.
So, for example, if an element downstream of the discard channel throws an exception and there is a retry advice, the process is retried.
Also, if <code class="literal">throwExceptionOnRejection</code> is set to <code class="literal">true</code> (the exception is thrown within the scope of the advice).</p>
<p>Setting <code class="literal">discard-within-advice</code> to <code class="literal">false</code> modifies this behavior and the discard (or exception) occurs after the advice chain is called.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advising-with-annotations" href="#advising-with-annotations"></a>10.9.7&nbsp;Advising Endpoints Using Annotations</h3></div></div></div>

<p>When configuring certain endpoints by using annotations (<code class="literal">@Filter</code>, <code class="literal">@ServiceActivator</code>, <code class="literal">@Splitter</code>, and <code class="literal">@Transformer</code>), you can supply a bean name for the advice chain in the <code class="literal">adviceChain</code> attribute.
In addition, the <code class="literal">@Filter</code> annotation also has the <code class="literal">discardWithinAdvice</code> attribute, which can be used to configure the discard behavior, as discussed in <a class="xref" href="messaging-endpoints-chapter.html#advising-filters" title="10.9.6&nbsp;Advising Filters">Section&nbsp;10.9.6, &#8220;Advising Filters&#8221;</a>.
The following example causes the discard to be performed after the advice:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@MessageEndpoint</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyAdvisedFilter {

    <em><span class="hl-annotation" style="color: gray">@Filter(inputChannel="input", outputChannel="output",
            adviceChain="adviceChain", discardWithinAdvice="false")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> filter(String s) {
        <span class="hl-keyword">return</span> s.contains(<span class="hl-string">"good"</span>);
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advice-order" href="#advice-order"></a>10.9.8&nbsp;Ordering Advices within an Advice Chain</h3></div></div></div>

<p>Advice classes are "<code class="literal">around</code>" advices and are applied in a nested fashion.
The first advice is the outermost, while the last advice is the innermost (that is, closest to the handler being advised).
It is important to put the advice classes in the correct order to achieve the functionality you desire.</p>
<p>For example, suppose you want to add a retry advice and a transaction advice.
You may want to place the retry advice advice first, followed by the transaction advice.
Consequently, each retry is performed in a new transaction.
On the other hand, if you want all the attempts and any recovery operations (in the retry <code class="literal">RecoveryCallback</code>) to be scoped within the transaction, you could put the transaction advice first.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="advised-handler-properties" href="#advised-handler-properties"></a>10.9.9&nbsp;Advised Handler Properties</h3></div></div></div>

<p>Sometimes, it is useful to access handler properties from within the advice.
For example, most handlers implement <code class="literal">NamedComponent</code> to let you access the component name.</p>
<p>The target object can be accessed through the <code class="literal">target</code> argument (when subclassing <code class="literal">AbstractRequestHandlerAdvice</code>) or
<code class="literal">invocation.getThis()</code> (when implementing <code class="literal">org.aopalliance.intercept.MethodInterceptor</code>).</p>
<p>When the entire handler is advised (such as when the handler does not produce replies or the advice implements <code class="literal">HandleMessageAdvice</code>), you can cast the target object to an interface, such as <code class="literal">NamedComponent</code>, as shown in the following example:</p>
<div class="informalexample">
<pre class="programlisting">String componentName = ((NamedComponent) target).getComponentName();</pre>
</div>
<p>When you implement <code class="literal">MethodInterceptor</code> directly, you could cast the target object as follows:</p>
<div class="informalexample">
<pre class="programlisting">String componentName = ((NamedComponent) invocation.getThis()).getComponentName();</pre>
</div>
<p>When only the <code class="literal">handleRequestMessage()</code> method is advised (in a reply-producing handler), you need to access the
full handler, which is an <code class="literal">AbstractReplyProducingMessageHandler</code>.
The following example shows how to do so:</p>
<div class="informalexample">
<pre class="programlisting">AbstractReplyProducingMessageHandler handler =
    ((AbstractReplyProducingMessageHandler.RequestHandler) target).getAdvisedHandler();

String componentName = handler.getComponentName();</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idempotent-receiver" href="#idempotent-receiver"></a>10.9.10&nbsp;Idempotent Receiver Enterprise Integration Pattern</h3></div></div></div>

<p>Starting with version 4.1, Spring Integration provides an implementation of the <a class="ulink" href="http://www.eaipatterns.com/IdempotentReceiver.html" target="_top">Idempotent Receiver</a> Enterprise Integration Pattern.
It is a functional pattern and the whole idempotency logic should be implemented in the application.
However, to simplify the decision-making, the <code class="literal">IdempotentReceiverInterceptor</code> component is provided.
This is an AOP <code class="literal">Advice</code> that is applied to the <code class="literal">MessageHandler.handleMessage()</code> method and that can <code class="literal">filter</code> a request message or mark it as a <code class="literal">duplicate</code>, according to its configuration.</p>
<p>Previously, you could have implemented this pattern by using a custom <code class="literal">MessageSelector</code> in a <code class="literal">&lt;filter/&gt;</code> (see <a class="xref" href="messaging-routing-chapter.html#filter" title="8.2&nbsp;Filter">Section&nbsp;8.2, &#8220;Filter&#8221;</a>), for example.
However, since this pattern really defines the behavior of an endpoint rather than being an endpoint itself, the idempotent receiver implementation does not provide an endpoint component.
Rather, it is applied to endpoints declared in the application.</p>
<p>The logic of the <code class="literal">IdempotentReceiverInterceptor</code> is based on the provided <code class="literal">MessageSelector</code> and, if the message is not accepted by that selector, it is enriched with the <code class="literal">duplicateMessage</code> header set to <code class="literal">true</code>.
The target <code class="literal">MessageHandler</code> (or downstream flow) can consult this header to implement the correct idempotency logic.
If the <code class="literal">IdempotentReceiverInterceptor</code> is configured with a <code class="literal">discardChannel</code> or <code class="literal">throwExceptionOnRejection = true</code>, the duplicate message is not sent to the target <code class="literal">MessageHandler.handleMessage()</code>.
Rather, it is discarded.
If you want to discard (do nothing with) the duplicate message, the <code class="literal">discardChannel</code> should be configured with a <code class="literal">NullChannel</code>, such as the default <code class="literal">nullChannel</code> bean.</p>
<p>To maintain state between messages and provide the ability to compare messages for the idempotency, we provide the <code class="literal">MetadataStoreSelector</code>.
It accepts a <code class="literal">MessageProcessor</code> implementation (which creates a lookup key based on the <code class="literal">Message</code>) and an optional <code class="literal">ConcurrentMetadataStore</code> (<a class="xref" href="system-management-chapter.html#metadata-store" title="12.5&nbsp;Metadata Store">Section&nbsp;12.5, &#8220;Metadata Store&#8221;</a>).
See the <a class="ulink" href="https://docs.spring.io/spring-integration/api/org/springframework/integration/selector/MetadataStoreSelector.html" target="_top"><code class="literal">MetadataStoreSelector</code> Javadoc</a> for more information.
You can also customize the <code class="literal">value</code> for <code class="literal">ConcurrentMetadataStore</code> by using an additional <code class="literal">MessageProcessor</code>.
By default, <code class="literal">MetadataStoreSelector</code> uses the <code class="literal">timestamp</code> message header.</p>
<p>For convenience, the <code class="literal">MetadataStoreSelector</code> options are configurable directly on the <code class="literal">&lt;idempotent-receiver&gt;</code> component.
The following listing shows all the possible attributes:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;idempotent-receiver</span>
        <span class="hl-attribute">id</span>=<span class="hl-value">""</span>  <a name="CO15-1" href="#CO15-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
        endpoint=""  <a name="CO15-2" href="#CO15-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
        selector=""  <a name="CO15-3" href="#CO15-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
        discard-channel=""  <a name="CO15-4" href="#CO15-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
        metadata-store=""  <a name="CO15-5" href="#CO15-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
        key-strategy=""  <a name="CO15-6" href="#CO15-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
        key-expression=""  <a name="CO15-7" href="#CO15-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
        value-strategy=""  <a name="CO15-8" href="#CO15-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
        value-expression=""  <a name="CO15-9" href="#CO15-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
        throw-exception-on-rejection="" /&gt;  <a name="CO15-10" href="#CO15-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The ID of the <code class="literal">IdempotentReceiverInterceptor</code> bean.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Consumer endpoint name(s) or pattern(s) to which this interceptor is applied.
Separate names (patterns) with commas (<code class="literal">,</code>), such as <code class="literal">endpoint="aaa, bbb*, *ccc, *ddd*, eee*fff"</code>.
Endpoint bean names matching these patterns are then used to retrieve the target endpoint&#8217;s <code class="literal">MessageHandler</code> bean (using its <code class="literal">.handler</code> suffix), and the <code class="literal">IdempotentReceiverInterceptor</code> is applied to those beans.
Required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">MessageSelector</code> bean reference.
Mutually exclusive with <code class="literal">metadata-store</code> and <code class="literal">key-strategy (key-expression)</code>.
When <code class="literal">selector</code> is not provided, one of <code class="literal">key-strategy</code> or <code class="literal">key-strategy-expression</code> is required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Identifies the channel to which to send a message when the <code class="literal">IdempotentReceiverInterceptor</code> does not accept it.
When omitted, duplicate messages are forwarded to the handler with a <code class="literal">duplicateMessage</code> header.
Optional.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">ConcurrentMetadataStore</code> reference.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Mutually exclusive with <code class="literal">selector</code>.
Optional.
The default <code class="literal">MetadataStoreSelector</code> uses an internal <code class="literal">SimpleMetadataStore</code> that does not maintain state across application executions.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">MessageProcessor</code> reference.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates an <code class="literal">idempotentKey</code> from the request message.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">key-expression</code>.
When a <code class="literal">selector</code> is not provided, one of <code class="literal">key-strategy</code> or <code class="literal">key-strategy-expression</code> is required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL expression to populate an <code class="literal">ExpressionEvaluatingMessageProcessor</code>.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates an <code class="literal">idempotentKey</code> by using the request message as the evaluation context root object.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">key-strategy</code>.
When a <code class="literal">selector</code> is not provided, one of <code class="literal">key-strategy</code> or <code class="literal">key-strategy-expression</code> is required.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">MessageProcessor</code> reference.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates a <code class="literal">value</code> for the <code class="literal">idempotentKey</code> from the request message.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">value-expression</code>.
By default, the <span class="emphasis"><em>MetadataStoreSelector</em></span> uses the <span class="emphasis"><em>timestamp</em></span> message header as the Metadata <span class="emphasis"><em>value</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL expression to populate an <code class="literal">ExpressionEvaluatingMessageProcessor</code>.
Used by the underlying <code class="literal">MetadataStoreSelector</code>.
Evaluates a <code class="literal">value</code> for the <code class="literal">idempotentKey</code> by using the request message as the evaluation context root object.
Mutually exclusive with <code class="literal">selector</code> and <code class="literal">value-strategy</code>.
By default, the <span class="emphasis"><em>MetadataStoreSelector</em></span> uses the <span class="emphasis"><em>timestamp</em></span> message header as the metadata <span class="emphasis"><em>value</em></span>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO15-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Whether to throw an exception if the <code class="literal">IdempotentReceiverInterceptor</code> rejects the message.
Defaults to <code class="literal">false</code>.
It is applied regardless of whether or not a <code class="literal">discard-channel</code> is provided.</p>
</td></tr></table></div>
</div>
<p>For Java configuration, Spring Integration provides the method-level <code class="literal">@IdempotentReceiver</code> annotation.
It is used to mark a <code class="literal">method</code> that has a messaging annotation (<code class="literal">@ServiceActivator</code>, <code class="literal">@Router, and others) to specify which `IdempotentReceiverInterceptor</code> objects are applied to this endpoint.
The following example shows how to use the <code class="literal">@IdempotentReceiver</code> annotation:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IdempotentReceiverInterceptor idempotentReceiverInterceptor() {
   <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> IdempotentReceiverInterceptor(<span class="hl-keyword">new</span> MetadataStoreSelector(m -&gt;
                                                    m.getHeaders().get(INVOICE_NBR_HEADER)));
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "input", outputChannel = "output")</span></em>
<em><span class="hl-annotation" style="color: gray">@IdempotentReceiver("idempotentReceiverInterceptor")</span></em>
<span class="hl-keyword">public</span> MessageHandler myService() {
    ....
}</pre>
</div>
<p>When you use the Java DSL, you can add the interceptor to the endpoint&#8217;s advice chain, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow flow() {
    ...
        .handle(<span class="hl-string">"someBean"</span>, <span class="hl-string">"someMethod"</span>,
            e -&gt; e.advice(idempotentReceiverInterceptor()))
    ...
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">IdempotentReceiverInterceptor</code> is designed only for the <code class="literal">MessageHandler.handleMessage(Message&lt;?&gt;)</code> method.
Starting with version 4.3.1, it implements <code class="literal">HandleMessageAdvice</code>, with the <code class="literal">AbstractHandleMessageAdvice</code> as a base class, for better dissociation.
See <a class="xref" href="messaging-endpoints-chapter.html#handle-message-advice" title="10.9.4&nbsp;Handling Message Advice">Section&nbsp;10.9.4, &#8220;Handling Message Advice&#8221;</a> for more information.</p>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="logging-channel-adapter" href="#logging-channel-adapter"></a>10.10&nbsp;Logging Channel Adapter</h2></div></div></div>

<p>The <code class="literal">&lt;logging-channel-adapter&gt;</code> is often used in conjunction with a wire tap, as discussed in <a class="xref" href="messaging-channels-section.html#channel-wiretap" title="Wire Tap">the section called &#8220;Wire Tap&#8221;</a>.
However, it can also be used as the ultimate consumer of any flow.
For example, consider a flow that ends with a <code class="literal">&lt;service-activator&gt;</code> that returns a result, but you wish to discard that result.
To do that, you could send the result to <code class="literal">NullChannel</code>.
Alternatively, you can route it to an <code class="literal">INFO</code> level <code class="literal">&lt;logging-channel-adapter&gt;</code>.
That way, you can see the discarded message when logging at <code class="literal">INFO</code> level but not see it when logging at (for example) the <code class="literal">WARN</code> level.
With a <code class="literal">NullChannel</code>, you would see only the discarded message when logging at the <code class="literal">DEBUG</code> level.
The following listing shows all the possible attributes for the <code class="literal">logging-channel-adapter</code> element:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:logging-channel-adapter</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">""</span> <a name="CO16-1" href="#CO16-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
    level="INFO" <a name="CO16-2" href="#CO16-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    expression="" <a name="CO16-3" href="#CO16-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    log-full-message="false" <a name="CO16-4" href="#CO16-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
    logger-name="" /&gt; <a name="CO16-5" href="#CO16-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span></pre>
</div>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The channel connecting the logging adapter to an upstream component.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The logging level at which messages sent to this adapter will be logged.
Default: <code class="literal">INFO</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL expression representing exactly what parts of the message are logged.
Default: <code class="literal">payload</code>&#8201;&#8212;&#8201;only the payload is logged.
if <code class="literal">log-full-message</code> is specified, this attribute cannot be specified.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>When <code class="literal">true</code>, the entire message (including headers) is logged.
Default: <code class="literal">false</code>&#8201;&#8212;&#8201;only the payload is logged.
This attribute cannot be specified if <code class="literal">expression</code> is specified.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO16-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies the <code class="literal">name</code> of the logger (known as <code class="literal">category</code> in <code class="literal">log4j</code>).
Used to identify log messages created by this adapter.
This enables setting the log name (in the logging subsystem) for individual adapters.
By default, all adapters log under the following name: <code class="literal">org.springframework.integration.handler.LoggingHandler</code>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_java_configuration" href="#_using_java_configuration"></a>10.10.1&nbsp;Using Java Configuration</h3></div></div></div>

<p>The following Spring Boot application shows an example of configuring the <code class="literal">LoggingHandler</code> by using Java configuration:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> LoggingJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context =
             <span class="hl-keyword">new</span> SpringApplicationBuilder(LoggingJavaApplication.<span class="hl-keyword">class</span>)
                    .web(false)
                    .run(args);
         MyGateway gateway = context.getBean(MyGateway.<span class="hl-keyword">class</span>);
         gateway.sendToLogger(<span class="hl-string">"foo"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "logChannel")</span></em>
    <span class="hl-keyword">public</span> LoggingHandler logging() {
        LoggingHandler adapter = <span class="hl-keyword">new</span> LoggingHandler(LoggingHandler.Level.DEBUG);
        adapter.setLoggerName(<span class="hl-string">"TEST_LOGGER"</span>);
        adapter.setLogExpressionString(<span class="hl-string">"headers.id + ': ' + payload"</span>);
        <span class="hl-keyword">return</span> adapter;
    }

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway(defaultRequestChannel = "logChannel")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

        <span class="hl-keyword">void</span> sendToLogger(String data);

    }

}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_with_the_java_dsl" href="#_configuring_with_the_java_dsl"></a>10.10.2&nbsp;Configuring with the Java DSL</h3></div></div></div>

<p>The following Spring Boot application shows an example of configuring the logging channel adapter by using the Java DSL:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> LoggingJavaApplication {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
        ConfigurableApplicationContext context =
             <span class="hl-keyword">new</span> SpringApplicationBuilder(LoggingJavaApplication.<span class="hl-keyword">class</span>)
                    .web(false)
                    .run(args);
         MyGateway gateway = context.getBean(MyGateway.<span class="hl-keyword">class</span>);
         gateway.sendToLogger(<span class="hl-string">"foo"</span>);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> IntegrationFlow loggingFlow() {
        <span class="hl-keyword">return</span> IntegrationFlows.from(MyGateway.<span class="hl-keyword">class</span>)
                     .log(LoggingHandler.Level.DEBUG, <span class="hl-string">"TEST_LOGGER"</span>,
                           m -&gt; m.getHeaders().getId() + <span class="hl-string">": "</span> + m.getPayload());
    }

    <em><span class="hl-annotation" style="color: gray">@MessagingGateway</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MyGateway {

        <span class="hl-keyword">void</span> sendToLogger(String data);

    }

}</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="functions-support" href="#functions-support"></a>10.11&nbsp;<code class="literal">java.util.function</code> Interfaces Support</h2></div></div></div>

<p>Starting with version 5.1, Spring Integration provides direct support for interfaces in the <code class="literal">java.util.function</code> package.
All messaging endpoints, (Service Activator, Transformer, Filter, etc.) can now refer to <code class="literal">Function</code> (or <code class="literal">Consumer</code>) beans.
The <a class="link" href="configuration.html#annotations" title="E.5&nbsp;Annotation Support">Messaging Annotations</a> can be applied directly on these beans similar to regular <code class="literal">MessageHandler</code> definitions.
For example if you have this <code class="literal">Function</code> bean definition:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FunctionConfiguration {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> Function&lt;String, String&gt; functionAsService() {
        <span class="hl-keyword">return</span> String::toUpperCase;
    }

}</pre>
</div>
<p>You can use it as a simple reference in an XML configuration file:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"processorViaFunctionChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"functionAsService"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>When we configure our flow with Messaging Annotations, the code is straightforward:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = "functionServiceChannel")</span></em>
<span class="hl-keyword">public</span> Function&lt;String, String&gt; functionAsService() {
    <span class="hl-keyword">return</span> String::toUpperCase;
}</pre>
</div>
<p>When the function returns an array, <code class="literal">Collection</code> (essentially, any <code class="literal">Iterable</code>), <code class="literal">Stream</code> or Reactor <code class="literal">Flux</code>, <code class="literal">@Splitter</code> can be used on such a bean to perform iteration over the result content.</p>
<p>The <code class="literal">java.util.function.Consumer</code> interface can be used for an <code class="literal">&lt;int:outbound-channel-adapter&gt;</code> or, together with the <code class="literal">@ServiceActivator</code> annotation, to perform the final step of a flow:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "messageConsumerServiceChannel")</span></em>
<span class="hl-keyword">public</span> Consumer&lt;Message&lt;?&gt;&gt; messageConsumerAsService() {
    <span class="hl-comment">// Has to be an anonymous class for proper type inference</span>
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Consumer&lt;Message&lt;?&gt;&gt;() {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> accept(Message&lt;?&gt; e) {
            collector().add(e);
        }

    };
}</pre>
</div>
<p>Also, pay attention to the comment in the code snippet above: if you would like to deal with the whole message in your <code class="literal">Function</code>/<code class="literal">Consumer</code> you cannot use a lambda definition.
Because of Java type erasure we cannot determine the target type for the <code class="literal">apply()/accept()</code> method call.</p>
<p>The <code class="literal">java.util.function.Supplier</code> interface can simply be used together with the <code class="literal">@InboundChannelAdapter</code> annotation, or as a <code class="literal">ref</code> in an <code class="literal">&lt;int:inbound-channel-adapter&gt;</code>:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(value = "inputChannel", poller = @Poller(fixedDelay = "1000"))</span></em>
<span class="hl-keyword">public</span> Supplier&lt;String&gt; pojoSupplier() {
    <span class="hl-keyword">return</span> () -&gt; <span class="hl-string">"foo"</span>;
}</pre>
</div>
<p>With the Java DSL we just need to use a reference to the function bean in the endpoint definitions.
Meanwhile an implementation of the <code class="literal">Supplier</code> interface can be used as regular <code class="literal">MessageSource</code> definition:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Function&lt;String, String&gt; toUpperCaseFunction() {
    <span class="hl-keyword">return</span> String::toUpperCase;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> Supplier&lt;String&gt; stringSupplier() {
    <span class="hl-keyword">return</span> () -&gt; <span class="hl-string">"foo"</span>;
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> IntegrationFlow supplierFlow() {
    <span class="hl-keyword">return</span> IntegrationFlows.from(stringSupplier())
                .transform(toUpperCaseFunction())
                .channel(<span class="hl-string">"suppliedChannel"</span>)
                .get();
}</pre>
</div>
<p>This function support is useful when used together with the <a class="ulink" href="https://cloud.spring.io/spring-cloud-function/" target="_top">Spring Cloud Function</a> framework, where we have a function catalog and can refer to its member functions from an integration flow definition.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kotlin-functions-support" href="#kotlin-functions-support"></a>10.11.1&nbsp;Kotlin Lambdas</h3></div></div></div>

<p>The Framework also has been improved to support Kotlin lambdas for functions so now you can use a combination of the Kotlin language and Spring Integration flow definitions:</p>
<div class="informalexample">
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = "functionServiceChannel")</span></em>
fun kotlinFunction(): (String) -&gt; String {
    <span class="hl-keyword">return</span> { it.toUpperCase() }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "messageConsumerServiceChannel")</span></em>
fun kotlinConsumer(): (Message&lt;Any&gt;) -&gt; Unit {
    <span class="hl-keyword">return</span> { print(it) }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(value = "counterChannel",
        poller = [Poller(fixedRate = "10", maxMessagesPerPoll = "1")])</span></em>
fun kotlinSupplier(): () -&gt; String {
    <span class="hl-keyword">return</span> { <span class="hl-string">"baz"</span> }
}</pre>
</div>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="messaging-transformation-chapter.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-core-messaging.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="java-dsl.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">9.&nbsp;Message Transformation&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;11.&nbsp;Java DSL</td></tr></table></div></body></html>