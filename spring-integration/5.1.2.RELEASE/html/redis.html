<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>27.&nbsp;Redis Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-endpoints.html" title="Part&nbsp;V.&nbsp;Integration Endpoints"><link rel="prev" href="mqtt.html" title="26.&nbsp;MQTT Support"><link rel="next" href="resource.html" title="28.&nbsp;Resource Support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">27.&nbsp;Redis Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mqtt.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Integration Endpoints</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="resource.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="redis" href="#redis"></a>27.&nbsp;Redis Support</h2></div></div></div>

<p>Spring Integration 2.1 introduced support for <a class="ulink" href="http://redis.io/" target="_top">Redis</a>: "<code class="literal">an open source advanced key-value store</code>".
This support comes in the form of a Redis-based <code class="literal">MessageStore</code> as well as publish-subscribe messaging adapters that are supported by Redis through its <a class="ulink" href="http://redis.io/topics/pubsub" target="_top"><code class="literal">PUBLISH</code>, <code class="literal">SUBSCRIBE</code>, and <code class="literal">UNSUBSCRIBE</code></a> commands.</p>
<p>You need to include this dependency into your project:</p>
<div class="informalexample">
<p>
<b>Maven.&nbsp;</b>

</p><pre class="programlisting"><span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.integration<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>spring-integration-redis<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>5.1.2.RELEASE<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span></pre><p>

</p>
<p>
<b>Gradle.&nbsp;</b>

</p><pre class="programlisting">compile <span class="hl-string">"org.springframework.integration:spring-integration-redis:5.1.2.RELEASE"</span></pre><p>

</p>
</div>
<p>You also need to include Redis client dependency, e.g. Lettuce.</p>
<p>To download, install, and run Redis, see the <a class="ulink" href="http://redis.io/download" target="_top">Redis documentation</a>.</p>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-connection" href="#redis-connection"></a>27.1&nbsp;Connecting to Redis</h2></div></div></div>

<p>To begin interacting with Redis, you first need to connect to it.
Spring Integration uses support provided by another Spring project, <a class="ulink" href="https://github.com/SpringSource/spring-data-redis" target="_top">Spring Data Redis</a>, which provides typical Spring constructs: <code class="literal">ConnectionFactory</code> and <code class="literal">Template</code>.
Those abstractions simplify integration with several Redis client Java APIs.
Currently Spring Data Redis supports <a class="ulink" href="https://github.com/xetorthio/jedis" target="_top">Jedis</a> and <a class="ulink" href="https://lettuce.io/" target="_top">Lettuce</a>.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_literal_redisconnectionfactory_literal" href="#_using_literal_redisconnectionfactory_literal"></a>27.1.1&nbsp;Using <code class="literal">RedisConnectionFactory</code></h3></div></div></div>

<p>To connect to Redis, you can use one of the implementations of the <code class="literal">RedisConnectionFactory</code> interface.
The following listing shows the interface definition:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> RedisConnectionFactory <span class="hl-keyword">extends</span> PersistenceExceptionTranslator {

    <strong class="hl-tag" style="color: blue">/**
     * Provides a suitable connection for interacting with Redis.
     * @return connection for interacting with Redis.
     */</strong>
    RedisConnection getConnection();
}</pre>
</div>
<p>The following example shows how to create a <code class="literal">LettuceConnectionFactory</code> in Java:</p>
<div class="informalexample">
<pre class="programlisting">LettuceConnectionFactory cf = <span class="hl-keyword">new</span> LettuceConnectionFactory();
cf.afterPropertiesSet();</pre>
</div>
<p>The following example shows how to create a <code class="literal">LettuceConnectionFactory</code> in Spring&#8217;s XML configuration:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.data.redis.connection.lettuce.LettuceConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"7379"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<p>The implementations of <code class="literal">RedisConnectionFactory</code> provide a set of properties, such as port and host, that you can set if needed.
Once you have an instance of <code class="literal">RedisConnectionFactory</code>, you can create an instance of <code class="literal">RedisTemplate</code> and inject it with the <code class="literal">RedisConnectionFactory</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_literal_redistemplate_literal" href="#_using_literal_redistemplate_literal"></a>27.1.2&nbsp;Using <code class="literal">RedisTemplate</code></h3></div></div></div>

<p>As with other template classes in Spring (such as <code class="literal">JdbcTemplate</code> and <code class="literal">JmsTemplate</code>) <code class="literal">RedisTemplate</code> is a helper class that simplifies Redis data access code.
For more information about <code class="literal">RedisTemplate</code> and its variations (such as <code class="literal">StringRedisTemplate</code>) see the <a class="ulink" href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/" target="_top">Spring Data Redis documentation</a>.</p>
<p>The following example shows how to create an instance of <code class="literal">RedisTemplate</code> in Java:</p>
<div class="informalexample">
<pre class="programlisting">RedisTemplate rt = <span class="hl-keyword">new</span> RedisTemplate&lt;String, Object&gt;();
rt.setConnectionFactory(redisConnectionFactory);</pre>
</div>
<p>The following example shows how to create an instance of <code class="literal">RedisTemplate</code> in Spring&#8217;s XML configuration:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisTemplate"</span>
         <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.redis.core.RedisTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"redisConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-messages" href="#redis-messages"></a>27.2&nbsp;Messaging with Redis</h2></div></div></div>

<p>As mentioned in <a class="link" href="redis.html" title="27.&nbsp;Redis Support">the introduction</a>, Redis provides support for publish-subscribe messaging through its <code class="literal">PUBLISH</code>, <code class="literal">SUBSCRIBE</code>, and <code class="literal">UNSUBSCRIBE</code> commands.
As with JMS and AMQP, Spring Integration provides message channels and adapters for sending and receiving messages through Redis.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-pub-sub-channel" href="#redis-pub-sub-channel"></a>27.2.1&nbsp;Redis Publish/Subscribe channel</h3></div></div></div>

<p>Similarly to JMS, there are cases where both the producer and consumer are intended to be part of the same application, running within the same process.
You can accomplished this by using a pair of inbound and outbound channel adapters.
However, as with Spring Integration&#8217;s JMS support, there is a simpler way to address this use case.
You can create a publish-subscribe channel, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:publish-subscribe-channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisChannel"</span> <span class="hl-attribute">topic-name</span>=<span class="hl-value">"si.test.topic"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>A <code class="literal">publish-subscribe-channel</code> behaves much like a normal <code class="literal">&lt;publish-subscribe-channel/&gt;</code> element from the main Spring Integration namespace.
It can be referenced by both the <code class="literal">input-channel</code> and the <code class="literal">output-channel</code> attributes of any endpoint.
The difference is that this channel is backed by a Redis topic name: a <code class="literal">String</code> value specified by the <code class="literal">topic-name</code> attribute.
However, unlike JMS, this topic does not have to be created in advance or even auto-created by Redis.
In Redis, topics are simple <code class="literal">String</code> values that play the role of an address.
The producer and consumer can communicate by using the same <code class="literal">String</code> value as their topic name.
A simple subscription to this channel means that asynchronous publish-subscribe messaging is possible between the producing and consuming endpoints.
However, unlike the asynchronous message channels created by adding a <code class="literal">&lt;queue/&gt;</code> element within a simple Spring Integration <code class="literal">&lt;channel/&gt;</code> element, the messages are not stored in an in-memory queue.
Instead, those messages are passed through Redis, which lets you rely on its support for persistence and clustering as well as its interoperability with other non-Java platforms.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-inbound-channel-adapter" href="#redis-inbound-channel-adapter"></a>27.2.2&nbsp;Redis Inbound Channel Adapter</h3></div></div></div>

<p>The Redis inbound channel adapter (<code class="literal">RedisInboundChannelAdapter</code>) adapts incoming Redis messages into Spring messages in the same way as other inbound adapters.
It receives platform-specific messages (Redis in this case) and converts them to Spring messages by using a <code class="literal">MessageConverter</code> strategy.
The following example shows how to configure a Redis inbound channel adapter:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisAdapter"</span>
       <span class="hl-attribute">topics</span>=<span class="hl-value">"thing1, thing2"</span>
       <span class="hl-attribute">channel</span>=<span class="hl-value">"receiveChannel"</span>
       <span class="hl-attribute">error-channel</span>=<span class="hl-value">"testErrorChannel"</span>
       <span class="hl-attribute">message-converter</span>=<span class="hl-value">"testConverter"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.data.redis.connection.lettuce.LettuceConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"7379"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testConverter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"things.something.SampleMessageConverter"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p>The preceding example shows a simple but complete configuration of a Redis inbound channel adapter.
Note that the preceding configuration relies on the familiar Spring paradigm of auto-discovering certain beans.
In this case, the <code class="literal">redisConnectionFactory</code> is implicitly injected into the adapter.
You can specify it explicitly by using the <code class="literal">connection-factory</code> attribute instead.</p>
<p>Also, note that the preceding configuration injects the adapter with a custom <code class="literal">MessageConverter</code>.
The approach is similar to JMS, where <code class="literal">MessageConverter</code> instances are used to convert between Redis messages and the Spring Integration message payloads.
The default is a <code class="literal">SimpleMessageConverter</code>.</p>
<p>Inbound adapters can subscribe to multiple topic names, hence the comma-separated set of values in the <code class="literal">topics</code> attribute.</p>
<p>Since version 3.0, the inbound adapter, in addition to the existing <code class="literal">topics</code> attribute, now has the <code class="literal">topic-patterns</code> attribute.
This attribute contains a comma-separated set of Redis topic patterns.
For more information regarding Redis publish-subscribe, see <a class="ulink" href="http://redis.io/topics/pubsub" target="_top">Redis Pub/Sub</a>.</p>
<p>Inbound adapters can use a <code class="literal">RedisSerializer</code> to deserialize the body of Redis messages.
The <code class="literal">serializer</code> attribute of the <code class="literal">&lt;int-redis:inbound-channel-adapter&gt;</code> can be set to an empty string, which results in a <code class="literal">null</code> value for the <code class="literal">RedisSerializer</code> property.
In this case, the raw <code class="literal">byte[]</code> bodies of Redis messages are provided as the message payloads.</p>
<p>Since version 5.0, you can provide an <code class="literal">Executor</code> instance to the inbound adapter by using the <code class="literal">task-executor</code> attribute of the <code class="literal">&lt;int-redis:inbound-channel-adapter&gt;</code>.
Also, the received Spring Integration messages now have the <code class="literal">RedisHeaders.MESSAGE_SOURCE</code> header to indicate the source of the published message: topic or pattern.
You can use this downstream for routing logic.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-outbound-channel-adapter" href="#redis-outbound-channel-adapter"></a>27.2.3&nbsp;Redis Outbound Channel Adapter</h3></div></div></div>

<p>The Redis outbound channel adapter adapts outgoing Spring Integration messages into Redis messages in the same way as other outbound adapters.
It receives Spring Integration messages and converts them to platform-specific messages (Redis in this case) by using a <code class="literal">MessageConverter</code> strategy.
The following example shows how to configure a Redis outbound channel adapter:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundAdapter"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"sendChannel"</span>
    <span class="hl-attribute">topic</span>=<span class="hl-value">"thing1"</span>
    <span class="hl-attribute">message-converter</span>=<span class="hl-value">"testConverter"</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisConnectionFactory"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.data.redis.connection.lettuce.LettuceConnectionFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"7379"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testConverter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"things.something.SampleMessageConverter"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p>The configuration parallels the Redis inbound channel adapter.
The adapter is implicitly injected with a <code class="literal">RedisConnectionFactory</code>, which is defined with <code class="literal">redisConnectionFactory</code> as its bean name.
This example also includes the optional (and custom) <code class="literal">MessageConverter</code> (the <code class="literal">testConverter</code> bean).</p>
<p>Since Spring Integration 3.0, the <code class="literal">&lt;int-redis:outbound-channel-adapter&gt;</code> offers an alternative to the <code class="literal">topic</code> attribute: You can use the <code class="literal">topic-expression</code> attribute to determine the Redis topic for the message at runtime.
These attributes are mutually exclusive.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-queue-inbound-channel-adapter" href="#redis-queue-inbound-channel-adapter"></a>27.2.4&nbsp;Redis Queue Inbound Channel Adapter</h3></div></div></div>

<p>Spring Integration 3.0 introduced a queue inbound channel adapter to "<code class="literal">pop</code>" messages from a Redis list. By default, it uses "<code class="literal">right pop</code>", but you can configure it to use "<code class="literal">left pop</code>" instead.
The adapter is message-driven.
It uses an internal listener thread and does not use a poller.</p>
<p>The following listing shows all the available attributes for <code class="literal">queue-inbound-channel-adapter</code>:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:queue-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">""</span>  <a name="CO43-1" href="#CO43-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                    channel=""  <a name="CO43-2" href="#CO43-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                    auto-startup=""  <a name="CO43-3" href="#CO43-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
                    phase=""  <a name="CO43-4" href="#CO43-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
                    connection-factory=""  <a name="CO43-5" href="#CO43-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
                    queue=""  <a name="CO43-6" href="#CO43-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
                    error-channel=""  <a name="CO43-7" href="#CO43-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
                    serializer=""  <a name="CO43-8" href="#CO43-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
                    receive-timeout=""  <a name="CO43-9" href="#CO43-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
                    recovery-interval=""  <a name="CO43-10" href="#CO43-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span>
                    expect-message=""  <a name="CO43-11" href="#CO43-11"></a><span><img src="images/callouts/11.png" alt="11" border="0"></span>
                    task-executor=""  <a name="CO43-12" href="#CO43-12"></a><span><img src="images/callouts/12.png" alt="12" border="0"></span>
                    right-pop=""/&gt;  <a name="CO43-13" href="#CO43-13"></a><span><img src="images/callouts/13.png" alt="13" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The component bean name.
If you do not provide the <code class="literal">channel</code> attribute, a <code class="literal">DirectChannel</code> is created and registered in the application context with this <code class="literal">id</code> attribute as the bean name.
In this case, the endpoint itself is registered with the bean name <code class="literal">id</code> plus <code class="literal">.adapter</code>.
(If the bean name were <code class="literal">thing1</code>, the endpoint is registered as <code class="literal">thing1.adapter</code>.)</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> to which to send <code class="literal">Message</code> instances from this Endpoint.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">SmartLifecycle</code> attribute to specify whether this endpoint should start automatically after the application context start or not.
It defaults to <code class="literal">true</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">SmartLifecycle</code> attribute to specify the phase in which this endpoint is started.
It defaults to <code class="literal">0</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a <code class="literal">RedisConnectionFactory</code> bean.
It defaults to <code class="literal">redisConnectionFactory</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The name of the Redis list on which the queue-based <span class="emphasis"><em>pop</em></span> operation is performed to get Redis messages.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> to which to send <code class="literal">ErrorMessage</code> instances when exceptions are received from the listening task of the endpoint.
By default, the underlying <code class="literal">MessagePublishingErrorHandler</code> uses the default <code class="literal">errorChannel</code> from the application context.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">RedisSerializer</code> bean reference.
It can be an empty string, which means <span class="emphasis"><em>no serializer</em></span>.
In this case, the raw <code class="literal">byte[]</code> from the inbound Redis message is sent to the <code class="literal">channel</code> as the <code class="literal">Message</code> payload.
By default it is a <code class="literal">JdkSerializationRedisSerializer</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The timeout in milliseconds for <span class="emphasis"><em>pop</em></span> operation to wait for a Redis message from the queue.
The default is 1 second.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The time in milliseconds for which the listener task should sleep after exceptions on the <span class="emphasis"><em>pop</em></span> operation, before restarting the listener task.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-11"><span><img src="images/callouts/11.png" alt="11" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this endpoint expects data from the Redis queue to contain entire <code class="literal">Message</code> instances.
If this attribute is set to <code class="literal">true</code>, the <code class="literal">serializer</code> cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).
Its default is <code class="literal">false</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-12"><span><img src="images/callouts/12.png" alt="12" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a Spring <code class="literal">TaskExecutor</code> (or standard JDK 1.5+ <code class="literal">Executor</code>) bean.
It is used for the underlying listening task.
It defaults to a <code class="literal">SimpleAsyncTaskExecutor</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO43-13"><span><img src="images/callouts/13.png" alt="13" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this endpoint should use "<code class="literal">right pop</code>" (when <code class="literal">true</code>) or "<code class="literal">left pop</code>" (when <code class="literal">false</code>) to read messages from the Redis list.
If <code class="literal">true</code>, the Redis List acts as a <code class="literal">FIFO</code> queue when used with a default Redis queue outbound channel adapter. Set it to <code class="literal">false</code> to use with software that writes to the list with "<code class="literal">right push</code>" or to achieve a stack-like message order.
Its default is <code class="literal">true</code>.
Since version 4.3.</p>
</td></tr></table></div>
</div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">task-executor</code> has to be configured with more than one thread for processing; otherwise there is a possible deadlock when the <code class="literal">RedisQueueMessageDrivenEndpoint</code> tries to restart the listener task after an error.
The <code class="literal">errorChannel</code> can be used to process those errors, to avoid restarts, but it preferable to not expose your application to the possible deadlock situation.
See Spring Framework <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-executor-types" target="_top">Reference Manual</a> for possible <code class="literal">TaskExecutor</code> implementations.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-queue-outbound-channel-adapter" href="#redis-queue-outbound-channel-adapter"></a>27.2.5&nbsp;Redis Queue Outbound Channel Adapter</h3></div></div></div>

<p>Spring Integration 3.0 introduced a queue outbound channel adapter to "<code class="literal">push</code>" to a Redis list from Spring Integration messages.
By default, it uses "<code class="literal">left push</code>", but you can configure it to use "<code class="literal">right push</code>" instead.
The following listing shows all the available attributes for a Redis <code class="literal">queue-outbound-channel-adapter</code>:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:queue-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">""</span>  <a name="CO44-1" href="#CO44-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
                    channel=""  <a name="CO44-2" href="#CO44-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
                    connection-factory=""  <a name="CO44-3" href="#CO44-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
                    queue=""  <a name="CO44-4" href="#CO44-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
                    queue-expression=""  <a name="CO44-5" href="#CO44-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
                    serializer=""  <a name="CO44-6" href="#CO44-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
                    extract-payload=""  <a name="CO44-7" href="#CO44-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
                    left-push=""/&gt;  <a name="CO44-8" href="#CO44-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The component bean name.
If you do not provide the <code class="literal">channel</code> attribute, a <code class="literal">DirectChannel</code> is created and registered in the application context with this <code class="literal">id</code> attribute as the bean name.
In this case, the endpoint is registered with a bean name of <code class="literal">id</code> plus <code class="literal">.adapter</code>.
(If the bean name were <code class="literal">thing1</code>, the endpoint is registered as <code class="literal">thing1.adapter</code>.)</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> from which this endpoint receives <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a <code class="literal">RedisConnectionFactory</code> bean.
It defaults to <code class="literal">redisConnectionFactory</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The name of the Redis list on which the queue-based <span class="emphasis"><em>push</em></span> operation is performed to send Redis messages.
This attribute is mutually exclusive with <code class="literal">queue-expression</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A SpEL <code class="literal">Expression</code> to determine the name of the Redis list.
It uses the incoming <code class="literal">Message</code> at runtime as the <code class="literal">#root</code> variable.
This attribute is mutually exclusive with <code class="literal">queue</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">RedisSerializer</code> bean reference.
It defaults to a <code class="literal">JdkSerializationRedisSerializer</code>.
However, for <code class="literal">String</code> payloads, a <code class="literal">StringRedisSerializer</code> is used, if a <code class="literal">serializer</code> reference is not provided.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this endpoint should send only the payload or the entire <code class="literal">Message</code> to the Redis queue.
It defaults to <code class="literal">true</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO44-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this endpoint should use "<code class="literal">left push</code>" (when <code class="literal">true</code>) or "<code class="literal">right push</code>" (when <code class="literal">false</code>) to write messages to the Redis list.
If <code class="literal">true</code>, the Redis list acts as a <code class="literal">FIFO</code> queue when used with a default Redis queue inbound channel adapter.
Set it to <code class="literal">false</code> to use with software that reads from the list with "<code class="literal">left pop</code>" or to achieve a stack-like message order.
It defaults to <code class="literal">true</code>.
Since version 4.3.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-application-events" href="#redis-application-events"></a>27.2.6&nbsp;Redis Application Events</h3></div></div></div>

<p>Since Spring Integration 3.0, the Redis module provides an implementation of <code class="literal">IntegrationEvent</code>, which, in turn, is a <code class="literal">org.springframework.context.ApplicationEvent</code>.
The <code class="literal">RedisExceptionEvent</code> encapsulates exceptions from Redis operations (with the endpoint being the "<code class="literal">source</code>" of the event).
For example, the <code class="literal">&lt;int-redis:queue-inbound-channel-adapter/&gt;</code> emits those events after catching exceptions from the <code class="literal">BoundListOperations.rightPop</code> operation.
The exception may be any generic <code class="literal">org.springframework.data.redis.RedisSystemException</code> or a <code class="literal">org.springframework.data.redis.RedisConnectionFailureException</code>.
Handling these events with an <code class="literal">&lt;int-event:inbound-channel-adapter/&gt;</code> can be useful to determine problems with background Redis tasks and to take administrative actions.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-message-store" href="#redis-message-store"></a>27.3&nbsp;Redis Message Store</h2></div></div></div>

<p>As described in the <span class="emphasis"><em>Enterprise Integration Patterns</em></span> (EIP) book, a <a class="ulink" href="http://www.eaipatterns.com/MessageStore.html" target="_top">message store</a> lets you persist messages.
This can be useful when dealing with components that have a capability to buffer messages (aggregator, resequencer, and others) when reliability is a concern.
In Spring Integration, the <code class="literal">MessageStore</code> strategy also provides the foundation for the <a class="ulink" href="http://www.eaipatterns.com/StoreInLibrary.html" target="_top">claim check</a> pattern, which is described in EIP as well.</p>
<p>Spring Integration&#8217;s Redis module provides the <code class="literal">RedisMessageStore</code>.
The following example shows how to use it with a aggregator:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisMessageStore"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.redis.store.RedisMessageStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"redisConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:aggregator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inputChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"outputChannel"</span>
         <span class="hl-attribute">message-store</span>=<span class="hl-value">"redisMessageStore"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>The preceding example is a bean configuration, and it expects a <code class="literal">RedisConnectionFactory</code> as a constructor argument.</p>
<p>By default, the <code class="literal">RedisMessageStore</code> uses Java serialization to serialize the message.
However, if you want to use a different serialization technique (such as JSON), you can provide your own serializer by setting the <code class="literal">valueSerializer</code> property of the <code class="literal">RedisMessageStore</code>.</p>
<p>Starting with version 4.3.10, the Framework provides Jackson serializer and deserializer implementations for <code class="literal">Message</code> instances and <code class="literal">MessageHeaders</code> instances&#8201;&#8212;&#8201;<code class="literal">MessageJacksonDeserializer</code> and <code class="literal">MessageHeadersJacksonSerializer</code>, respectively.
They have to be configured with the <code class="literal">SimpleModule</code> options for the <code class="literal">ObjectMapper</code>.
In addition, you should set <code class="literal">enableDefaultTyping</code> on the <code class="literal">ObjectMapper</code> to add type information for each serialized complex object.
That type information is then used during deserialization.
The framework provides a utility method called <code class="literal">JacksonJsonUtils.messagingAwareMapper()</code>, which is already supplied with all the previously mentioned properties and serializers.
To manage JSON serialization in the <code class="literal">RedisMessageStore</code>, you must configure it in a fashion similar to the following example:</p>
<div class="informalexample">
<pre class="programlisting">RedisMessageStore store = <span class="hl-keyword">new</span> RedisMessageStore(redisConnectionFactory);
ObjectMapper mapper = JacksonJsonUtils.messagingAwareMapper();
RedisSerializer&lt;Object&gt; serializer = <span class="hl-keyword">new</span> GenericJackson2JsonRedisSerializer(mapper);
store.setValueSerializer(serializer);</pre>
</div>
<p>Starting with version 4.3.12, <code class="literal">RedisMessageStore</code> supports the <code class="literal">prefix</code> option to allow distinguishing between instances of the store on the same Redis server.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="redis-cms" href="#redis-cms"></a>27.3.1&nbsp;Redis Channel Message Stores</h3></div></div></div>

<p>The <code class="literal">RedisMessageStore</code> <a class="link" href="redis.html#redis-message-store" title="27.3&nbsp;Redis Message Store">shown earlier</a> maintains each group as a value under a single key (the group ID).
While you can use this to back a <code class="literal">QueueChannel</code> for persistence, a specialized <code class="literal">RedisChannelMessageStore</code> is provided for that purpose (since version 4.0).
This store uses a <code class="literal">LIST</code> for each channel, <code class="literal">LPUSH</code> when sending messages, and <code class="literal">RPOP</code> when receiving messages.
By default, this store also uses JDK serialization, but you can modify the value serializer, as <a class="link" href="redis.html#redis-message-store" title="27.3&nbsp;Redis Message Store">described earlier</a>.</p>
<p>We recommend using this store backing channels, instead of using the general <code class="literal">RedisMessageStore</code>.
The following example defines a Redis message store and uses it in a channel with a queue:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisMessageStore"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.redis.store.RedisChannelMessageStore"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"redisConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;int:channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"somePersistentQueueChannel"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:queue</span> <span class="hl-attribute">message-store</span>=<span class="hl-value">"redisMessageStore"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;int:channel&gt;</span></pre>
</div>
<p>The keys used to store the data have the form: <code class="literal">&lt;storeBeanName&gt;:&lt;channelId&gt;</code> (in the preceding example, <code class="literal">redisMessageStore:somePersistentQueueChannel</code>).</p>
<p>In addition, a subclass <code class="literal">RedisChannelPriorityMessageStore</code> is also provided.
When you use this with a <code class="literal">QueueChannel</code>, the messages are received in (FIFO) priority order.
It uses the standard <code class="literal">IntegrationMessageHeaderAccessor.PRIORITY</code> header and supports priority values (<code class="literal">0 - 9</code>).
Messages with other priorities (and messages with no priority) are retrieved in FIFO order after any messages with priority.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>These stores implement only <code class="literal">BasicMessageGroupStore</code> and do not implement <code class="literal">MessageGroupStore</code>.
They can be used only for situations such as backing a <code class="literal">QueueChannel</code>.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-metadata-store" href="#redis-metadata-store"></a>27.4&nbsp;Redis Metadata Store</h2></div></div></div>

<p>Spring Integration 3.0 introduced a new Redis-based <a class="ulink" href="http://docs.spring.io/spring-integration/docs/latest-ga/api/org/springframework/integration/metadata/MetadataStore.html" target="_top"><code class="literal">MetadataStore</code></a> (see <a class="xref" href="system-management-chapter.html#metadata-store" title="12.5&nbsp;Metadata Store">Section&nbsp;12.5, &#8220;Metadata Store&#8221;</a>) implementation.
You can use the <code class="literal">RedisMetadataStore</code> to maintain the state of a <code class="literal">MetadataStore</code> across application restarts.
You can use this new <code class="literal">MetadataStore</code> implementation with adapters such as:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="feed.html#feed-inbound-channel-adapter" title="16.1&nbsp;Feed Inbound Channel Adapter">Feed</a>
</li><li class="listitem">
<a class="link" href="files.html#file-reading" title="17.1&nbsp;Reading Files">File</a>
</li><li class="listitem">
<a class="link" href="ftp.html#ftp-inbound" title="18.4&nbsp;FTP Inbound Channel Adapter">FTP</a>
</li><li class="listitem">
<a class="link" href="sftp.html#sftp-inbound" title="30.6&nbsp;SFTP Inbound Channel Adapter">SFTP</a>
</li></ul></div>
<p>To instruct these adapters to use the new <code class="literal">RedisMetadataStore</code>, declare a Spring bean named <code class="literal">metadataStore</code>.
The Feed inbound channel adapter and the feed inbound channel adapter both automatically pick up and use the declared <code class="literal">RedisMetadataStore</code>.
The following example shows how to declare such a bean:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">name</span>=<span class="hl-value">"metadataStore"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.redis.store.metadata.RedisMetadataStore"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"redisConnectionFactory"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<p>The <code class="literal">RedisMetadataStore</code> is backed by <a class="ulink" href="http://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/support/collections/RedisProperties.html" target="_top"><code class="literal">RedisProperties</code></a>.
Interaction with it uses <a class="ulink" href="http://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/core/BoundHashOperations.html" target="_top"><code class="literal">BoundHashOperations</code></a>, which, in turn, requires a <code class="literal">key</code> for the entire <code class="literal">Properties</code> store.
In the case of the <code class="literal">MetadataStore</code>, this <code class="literal">key</code> plays the role of a region, which is useful in a distributed environment, when several applications use the same Redis server.
By default, this <code class="literal">key</code> has a value of <code class="literal">MetaData</code>.</p>
<p>Starting with version 4.0, this store implements <code class="literal">ConcurrentMetadataStore</code>, letting it be reliably shared across multiple application instances where only one instance is allowed to store or modify a key&#8217;s value.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>You cannot use the <code class="literal">RedisMetadataStore.replace()</code> (for example, in the <code class="literal">AbstractPersistentAcceptOnceFileListFilter</code>) with a Redis cluster, since the <code class="literal">WATCH</code> command for atomicity is not currently supported.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-store-inbound-channel-adapter" href="#redis-store-inbound-channel-adapter"></a>27.5&nbsp;Redis Store Inbound Channel Adapter</h2></div></div></div>

<p>The Redis store inbound channel adapter is a polling consumer that reads data from a Redis collection and sends it as a <code class="literal">Message</code> payload.
The following example shows how to configure a Redis store inbound channel adapter:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:store-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"listAdapter"</span>
    <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"redisConnectionFactory"</span>
    <span class="hl-attribute">key</span>=<span class="hl-value">"myCollection"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"redisChannel"</span>
    <span class="hl-attribute">collection-type</span>=<span class="hl-value">"LIST"</span><span class="hl-tag"> &gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"2000"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"10"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int-redis:store-inbound-channel-adapter&gt;</span></pre>
</div>
<p>The preceding example shows how to configure a Redis store inbound channel adapter by using the <code class="literal">store-inbound-channel-adapter</code> element, providing values for various attributes, such as:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">key</code> or <code class="literal">key-expression</code>: The name of the key for the collection being used.
</li><li class="listitem">
<code class="literal">collection-type</code>: An enumeration of the collection types supported by this adapter.
The supported Collections are <code class="literal">LIST</code>, <code class="literal">SET</code>, <code class="literal">ZSET</code>, <code class="literal">PROPERTIES</code>, and <code class="literal">MAP</code>.
</li><li class="listitem">
<code class="literal">connection-factory</code>: Reference to an instance of <code class="literal">o.s.data.redis.connection.RedisConnectionFactory</code>.
</li><li class="listitem">
<code class="literal">redis-template</code>: Reference to an instance of <code class="literal">o.s.data.redis.core.RedisTemplate</code>.
</li><li class="listitem">
Other attributes that are common across all other inbound adapters (such as <span class="emphasis"><em>channel</em></span>).
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>You cannot set both <code class="literal">redis-template</code> and <code class="literal">connection-factory</code>.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>By default, the adapter uses a <code class="literal">StringRedisTemplate</code>.
This uses <code class="literal">StringRedisSerializer</code> instances for keys, values, hash keys, and hash values.
If your Redis store contains objects that are serialized with other techniques, you must supply a <code class="literal">RedisTemplate</code> configured with appropriate serializers.
For example, if the store is written to using a Redis store outbound adapter that has its <code class="literal">extract-payload-elements</code> set to <code class="literal">false</code>, you must provide a <code class="literal">RedisTemplate</code> configured as follows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.redis.core.RedisTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"redisConnectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"keySerializer"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.redis.serializer.StringRedisSerializer"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hashKeySerializer"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.redis.serializer.StringRedisSerializer"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
</div>
<p>Th <code class="literal">RedisTemplate</code> uses <code class="literal">String</code> serializers for keys and hash keys and the default JDK Serialization serializers for values and hash values.</p>
</td></tr></table></div>
<p>Because it has a literal value for the <code class="literal">key</code>, the preceding example is relatively simple and static.
Sometimes, you may need to change the value of the key at runtime based on some condition.
To do so, use <code class="literal">key-expression</code> instead, where the provided expression can be any valid SpEL expression.</p>
<p>Also, you may wish to perform some post-processing on the successfully processed data that was read from the Redis collection.
For example, you may want to move or remove the value after its been processed.
You can do so by using the transaction synchronization feature that was added with Spring Integration 2.2.
The following example uses <code class="literal">key-expression</code> and transaction synchronization:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:store-inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"zsetAdapterWithSingleScoreAndSynchronization"</span>
        <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"redisConnectionFactory"</span>
        <span class="hl-attribute">key-expression</span>=<span class="hl-value">"'presidents'"</span>
        <span class="hl-attribute">channel</span>=<span class="hl-value">"otherRedisChannel"</span>
        <span class="hl-attribute">auto-startup</span>=<span class="hl-value">"false"</span>
        <span class="hl-attribute">collection-type</span>=<span class="hl-value">"ZSET"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"2"</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">synchronization-factory</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int-redis:store-inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;int:transaction-synchronization-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;int:after-commit</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload.removeByScore(18, 18)"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/int:transaction-synchronization-factory&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.transaction.PseudoTransactionManager"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>You can declare your poller to be transactional by using a <code class="literal">transactional</code> element.
This element can reference a real transaction manager (for example, if some other part of your flow invokes JDBC).
If you do not have a "<code class="literal">real</code>" transaction, you can use an <code class="literal">o.s.i.transaction.PseudoTransactionManager</code>, which is an implementation of Spring&#8217;s <code class="literal">PlatformTransactionManager</code> and enables the use of the transaction synchronization features of the Redis adapter when there is no actual transaction.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>This does not make the Redis activities themselves transactional. It lets the synchronization of actions be taken before or after success (commit) or after failure (rollback).</p>
</td></tr></table></div>
<p>Once your poller is transactional, you can set an instance of the <code class="literal">o.s.i.transaction.TransactionSynchronizationFactory</code> on the <code class="literal">transactional</code> element.
<code class="literal">TransactionSynchronizationFactory</code> creates an instance of the <code class="literal">TransactionSynchronization</code>.
For your convenience, we have exposed a default SpEL-based <code class="literal">TransactionSynchronizationFactory</code>, which lets you configure SpEL expressions, with their execution being coordinated (synchronized) with a transaction.
Expressions for before-commit, after-commit, and after-rollback are supported, together with channels (one for each kind of event) where the evaluation result (if any) is sent.
For each child element, you can specify <code class="literal">expression</code> and <code class="literal">channel</code> attributes.
If only the <code class="literal">channel</code> attribute is present, the received message is sent there as part of the particular synchronization scenario.
If only the <code class="literal">expression</code> attribute is present and the result of an expression is a non-null value, a message with the result as the payload is generated and sent to a default channel (<code class="literal">NullChannel</code>) and appears in the logs (at the <code class="literal">DEBUG</code> level).
If you want the evaluation result to go to a specific channel, add a <code class="literal">channel</code> attribute.
If the result of an expression is null or void, no message is generated.</p>
<p>For more information about transaction synchronization, see <a class="xref" href="transactions.html#transaction-synchronization" title="C.3&nbsp;Transaction Synchronization">Section&nbsp;C.3, &#8220;Transaction Synchronization&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-store-outbound-channel-adapter" href="#redis-store-outbound-channel-adapter"></a>27.6&nbsp;RedisStore Outbound Channel Adapter</h2></div></div></div>

<p>The RedisStore outbound channel adapter lets you write a message payload to a Redis collection, as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:store-outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"redisListAdapter"</span>
          <span class="hl-attribute">collection-type</span>=<span class="hl-value">"LIST"</span>
          <span class="hl-attribute">channel</span>=<span class="hl-value">"requestChannel"</span>
          <span class="hl-attribute">key</span>=<span class="hl-value">"myCollection"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
<p>The preceding configuration a Redis store outbound channel adapter by using the <code class="literal">store-inbound-channel-adapter</code> element.
It provides values for various attributes, such as:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">key</code> or <code class="literal">key-expression</code>: The name of the key for the collection being used.
</li><li class="listitem">
<code class="literal">extract-payload-elements</code>: If set to <code class="literal">true</code> (the default) and the payload is an instance of a "<code class="literal">multi-value</code>" object (that is, a <code class="literal">Collection</code> or a <code class="literal">Map</code>), it is stored by using "<code class="literal">addAll</code>" and "<code class="literal">putAll</code>" semantics.
Otherwise, if set to <code class="literal">false</code>, the payload is stored as a single entry regardless of its type.
If the payload is not an instance of a "<code class="literal">multi-value</code>" object, the value of this attribute is ignored and the payload is always stored as a single entry.
</li><li class="listitem">
<code class="literal">collection-type</code>: An enumeration of the <code class="literal">Collection</code> types supported by this adapter.
The supported Collections are <code class="literal">LIST</code>, <code class="literal">SET</code>, <code class="literal">ZSET</code>, <code class="literal">PROPERTIES</code>, and <code class="literal">MAP</code>.
</li><li class="listitem">
<code class="literal">map-key-expression</code>: SpEL expression that returns the name of the key for the entry being stored.
It applies only if the <code class="literal">collection-type</code> is <code class="literal">MAP</code> or <code class="literal">PROPERTIES</code> and <span class="emphasis"><em>extract-payload-elements</em></span> is false.
</li><li class="listitem">
<code class="literal">connection-factory</code>: Reference to an instance of <code class="literal">o.s.data.redis.connection.RedisConnectionFactory</code>.
</li><li class="listitem">
<code class="literal">redis-template</code>: Reference to an instance of <code class="literal">o.s.data.redis.core.RedisTemplate</code>.
</li><li class="listitem">
Other attributes that are common across all other inbound adapters (such as <span class="emphasis"><em>channel</em></span>).
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>You cannot set both <code class="literal">redis-template</code> and <code class="literal">connection-factory</code>.</p>
</td></tr></table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>By default, the adapter uses a <code class="literal">StringRedisTemplate</code>.
This uses <code class="literal">StringRedisSerializer</code> instances for keys, values, hash keys, and hash values.
However, if <code class="literal">extract-payload-elements</code> is set to <code class="literal">false</code>, a <code class="literal">RedisTemplate</code> that has <code class="literal">StringRedisSerializer</code> instances for keys and hash keys and <code class="literal">JdkSerializationRedisSerializer</code> instances s for values and hash values will be used.
With the JDK serializer, it is important to understand that Java serialization is used for all values, regardless of whether the value is actually a collection or not.
If you need more control over the serialization of values, consider providing your own <code class="literal">RedisTemplate</code> rather than relying upon these defaults.</p>
</td></tr></table></div>
<p>Because it has literal values for the <code class="literal">key</code> and other attributes, the preceding example is relatively simple and static.
Sometimes, you may need to change the values dynamically at runtime based on some condition.
To do so, use their <code class="literal">-expression</code> equivalents (<code class="literal">key-expression</code>, <code class="literal">map-key-expression</code>, and so on), where the provided expression can be any valid SpEL expression.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-outbound-gateway" href="#redis-outbound-gateway"></a>27.7&nbsp;Redis Outbound Command Gateway</h2></div></div></div>

<p>Spring Integration 4.0 introduced the Redis command gateway to let you perform any standard Redis command by using the generic <code class="literal">RedisConnection#execute</code> method.
The following listing shows the available attributes for the Redis outbound gateway:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:outbound-gateway</span>
        <span class="hl-attribute">request-channel</span>=<span class="hl-value">""</span>  <a name="CO45-1" href="#CO45-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
        reply-channel=""  <a name="CO45-2" href="#CO45-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
        requires-reply=""  <a name="CO45-3" href="#CO45-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
        reply-timeout=""  <a name="CO45-4" href="#CO45-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
        connection-factory=""  <a name="CO45-5" href="#CO45-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
        redis-template=""  <a name="CO45-6" href="#CO45-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
        arguments-serializer=""  <a name="CO45-7" href="#CO45-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
        command-expression=""  <a name="CO45-8" href="#CO45-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
        argument-expressions=""  <a name="CO45-9" href="#CO45-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
        use-command-variable=""  <a name="CO45-10" href="#CO45-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span>
        arguments-strategy="" /&gt; <a name="CO45-11" href="#CO45-11"></a><span><img src="images/callouts/11.png" alt="11" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> from which this endpoint receives <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> where this endpoint sends reply <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this outbound gateway must return a non-null value.
It defaults to <code class="literal">true</code>.
A <code class="literal">ReplyRequiredException</code> is thrown when Redis returns a <code class="literal">null</code> value.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The timeout (in milliseconds) to wait until the reply message is sent.
It is typically applied for queue-based limited reply-channels.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a <code class="literal">RedisConnectionFactory</code> bean.
It defaults to <code class="literal">redisConnectionFactory</code>.
It is mutually exclusive with <span class="emphasis"><em>redis-template</em></span> attribute.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a <code class="literal">RedisTemplate</code> bean.
It is mutually exclusive with <span class="emphasis"><em>connection-factory</em></span> attribute.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to an instance of <code class="literal">org.springframework.data.redis.serializer.RedisSerializer</code>.
It is used to serialize each command argument to byte[], if necessary.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The SpEL expression that returns the command key.
It defaults to the <code class="literal">redis_command</code> message header.
It must not evaluate to <code class="literal">null</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Comma-separated SpEL expressions that are evaluated as command arguments.
Mutually exclusive with the <code class="literal">arguments-strategy</code> attribute.
If you provide neither attribute, the <code class="literal">payload</code> is used as the command arguments.
The argument expressions can evaluate to <span class="emphasis"><em>null</em></span> to support a variable number of arguments.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A <code class="literal">boolean</code> flag to specify whether the evaluated Redis command string is made available as the <code class="literal">#cmd</code> variable in the expression evaluation context in the <code class="literal">o.s.i.redis.outbound.ExpressionArgumentsStrategy</code> when <code class="literal">argument-expressions</code> is configured.
Otherwise this attribute is ignored.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO45-11"><span><img src="images/callouts/11.png" alt="11" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Reference to an instance of <code class="literal">o.s.i.redis.outbound.ArgumentsStrategy</code>.
It is mutually exclusive with <code class="literal">argument-expressions</code> attribute.
If you provide neither attribute, the <code class="literal">payload</code> is used as the command arguments.</p>
</td></tr></table></div>
</div>
<p>You can use the <code class="literal">&lt;int-redis:outbound-gateway&gt;</code> as a common component to perform any desired Redis operation.
For example, the following examlpe shows how to get incremented values from Redis atomic number:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:outbound-gateway</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requestChannel"</span>
    <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"replyChannel"</span>
    <span class="hl-attribute">command-expression</span>=<span class="hl-value">"'INCR'"</span><span class="hl-tag">/&gt;</span></pre>
</div>
<p>The <code class="literal">Message</code> payload should have a name of <code class="literal">redisCounter</code>, which may be provided by <code class="literal">org.springframework.data.redis.support.atomic.RedisAtomicInteger</code> bean definition.</p>
<p>The <code class="literal">RedisConnection#execute</code> method has a generic <code class="literal">Object</code> as its return type.
Real result depends on command type.
For example, <code class="literal">MGET</code> returns a <code class="literal">List&lt;byte[]&gt;</code>.
For more information about commands, their arguments and result type, see <a class="ulink" href="http://redis.io/commands" target="_top">Redis Specification</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-queue-outbound-gateway" href="#redis-queue-outbound-gateway"></a>27.8&nbsp;Redis Queue Outbound Gateway</h2></div></div></div>

<p>Spring Integration introduced the Redis queue outbound gateway to perform request and reply scenarios.
It pushes a conversation <code class="literal">UUID</code> to the provided <code class="literal">queue</code>, pushes the value with that <code class="literal">UUID</code> as its key to a Redis list, and waits for the reply from a Redis list with a key of <code class="literal">UUID' plus '.reply</code>.
A different UUID is used for each interaction.
The following listing shows the available attributes for a Redis outbound gateway:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:queue-outbound-gateway</span>
        <span class="hl-attribute">request-channel</span>=<span class="hl-value">""</span>  <a name="CO46-1" href="#CO46-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
        reply-channel=""  <a name="CO46-2" href="#CO46-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
        requires-reply=""  <a name="CO46-3" href="#CO46-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
        reply-timeout=""  <a name="CO46-4" href="#CO46-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
        connection-factory=""  <a name="CO46-5" href="#CO46-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
        queue=""  <a name="CO46-6" href="#CO46-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
        order=""  <a name="CO46-7" href="#CO46-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
        serializer=""  <a name="CO46-8" href="#CO46-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
        extract-payload=""/&gt;  <a name="CO46-9" href="#CO46-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> from which this endpoint receives <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> where this endpoint sends reply <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this outbound gateway must return a non-null value.
This value is <code class="literal">false</code> by default.
Otherwise, a <code class="literal">ReplyRequiredException</code> is thrown when Redis returns a <code class="literal">null</code> value.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The timeout (in milliseconds) to wait until the reply message is sent.
It is typically applied for queue-based limited reply-channels.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a <code class="literal">RedisConnectionFactory</code> bean.
It defaults to <code class="literal">redisConnectionFactory</code>.
It is mutually exclusive with the <span class="emphasis"><em>redis-template</em></span> attribute.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The name of the Redis list to which the outbound gateway sends a conversation <code class="literal">UUID</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The order of this outbound gateway when multiple gateways are registered.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">RedisSerializer</code> bean reference.
It can be an empty string, which means "<code class="literal">no serializer</code>".
In this case, the raw <code class="literal">byte[]</code> from the inbound Redis message is sent to the <code class="literal">channel</code> as the <code class="literal">Message</code> payload.
By default, it is a <code class="literal">JdkSerializationRedisSerializer</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO46-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this endpoint expects data from the Redis queue to contain entire <code class="literal">Message</code> instances.
If this attribute is set to <code class="literal">true</code>, the <code class="literal">serializer</code> cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-queue-inbound-gateway" href="#redis-queue-inbound-gateway"></a>27.9&nbsp;Redis Queue Inbound Gateway</h2></div></div></div>

<p>Spring Integration 4.1 introduced the Redis queue inbound gateway to perform request and reply scenarios.
It pops a conversation <code class="literal">UUID</code> from the provided <code class="literal">queue</code>, pops the value with that <code class="literal">UUID</code> as its key from the Redis list, and pushes the reply to the Redis list with a key of <code class="literal">UUID</code> plus <code class="literal">.reply</code>.
The following listing shows the available attributes for a Redis queue inbound gateway:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-redis:queue-inbound-gateway</span>
        <span class="hl-attribute">request-channel</span>=<span class="hl-value">""</span>  <a name="CO47-1" href="#CO47-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
        reply-channel=""  <a name="CO47-2" href="#CO47-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
        executor=""  <a name="CO47-3" href="#CO47-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
        reply-timeout=""  <a name="CO47-4" href="#CO47-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
        connection-factory=""  <a name="CO47-5" href="#CO47-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
        queue=""  <a name="CO47-6" href="#CO47-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
        order=""  <a name="CO47-7" href="#CO47-7"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
        serializer=""  <a name="CO47-8" href="#CO47-8"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
        receive-timeout=""  <a name="CO47-9" href="#CO47-9"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
        expect-message=""  <a name="CO47-10" href="#CO47-10"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span>
        recovery-interval=""/&gt;  <a name="CO47-11" href="#CO47-11"></a><span><img src="images/callouts/11.png" alt="11" border="0"></span></pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> from which this endpoint receives <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">MessageChannel</code> where this endpoint sends reply <code class="literal">Message</code> instances.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a Spring <code class="literal">TaskExecutor</code> (or a standard JDK 1.5+ <code class="literal">Executor</code>) bean.
It is used for the underlying listening task.
It defaults to a <code class="literal">SimpleAsyncTaskExecutor</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The timeout (in milliseconds) to wait until the reply message is sent.
It is typically applied for queue-based limited reply-channels.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left">
<p>A reference to a <code class="literal">RedisConnectionFactory</code> bean.
It defaults to <code class="literal">redisConnectionFactory</code>.
It is mutually exclusive with <span class="emphasis"><em>redis-template</em></span> attribute.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The name of the Redis list for the conversation <code class="literal">UUID</code>.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-7"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The order of this inbound gateway when multiple gateways are registered.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-8"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The <code class="literal">RedisSerializer</code> bean reference.
It can be an empty string, which means "<code class="literal">no serializer</code>".
In this case, the raw <code class="literal">byte[]</code> from the inbound Redis message is sent to the <code class="literal">channel</code> as the <code class="literal">Message</code> payload.
It default to a <code class="literal">JdkSerializationRedisSerializer</code>.
(Note that, in releases before version 4.3, it was a <code class="literal">StringRedisSerializer</code> by default.
To restore that behavior, provide a reference to a <code class="literal">StringRedisSerializer</code>).</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-9"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The timeout (in milliseconds) to wait until the receive message is fetched.
It is typically applied for queue-based limited request-channels.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-10"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left">
<p>Specifies whether this endpoint expects data from the Redis queue to contain entire <code class="literal">Message</code> instances.
If this attribute is set to <code class="literal">true</code>, the <code class="literal">serializer</code> cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO47-11"><span><img src="images/callouts/11.png" alt="11" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The time (in milliseconds) the listener task should sleep after exceptions on the "<code class="literal">right pop</code>" operation before restarting the listener task.</p>
</td></tr></table></div>
</div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>The <code class="literal">task-executor</code> has to be configured with more than one thread for processing; otherwise there is a possible deadlock when the <code class="literal">RedisQueueMessageDrivenEndpoint</code> tries to restart the listener task after an error.
The <code class="literal">errorChannel</code> can be used to process those errors, to avoid restarts, but it preferable to not expose your application to the possible deadlock situation.
See Spring Framework <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-executor-types" target="_top">Reference Manual</a> for possible <code class="literal">TaskExecutor</code> implementations.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="redis-lock-registry" href="#redis-lock-registry"></a>27.10&nbsp;Redis Lock Registry</h2></div></div></div>

<p>Spring Integration 4.0 introduced the <code class="literal">RedisLockRegistry</code>.
Certain components (for example, aggregator and resequencer) use a lock obtained from a <code class="literal">LockRegistry</code> instance to ensure that only one thread manipulates a group at a time.
The <code class="literal">DefaultLockRegistry</code> performs this function within a single component.
You can now configure an external lock registry on these components.
When you use it with a shared <code class="literal">MessageGroupStore</code>, you can use the <code class="literal">RedisLockRegistry</code> to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.</p>
<p>When a lock is released by a local thread, another local thread can generally acquire the lock immediately.
If a lock is released by a thread using a different registry instance, it can take up to 100ms to acquire the lock.</p>
<p>To avoid "<code class="literal">hung</code>" locks (when a server fails), the locks in this registry are expired after a default 60 seconds, but you can configure this value on the registry.
Locks are normally held for a much smaller time.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>Because the keys can expire, an attempt to unlock an expired lock results in an exception being thrown.
However, the resources protected by such a lock may have been compromised, so such exceptions should be considered to be severe.
You should set the expiry at a large enough value to prevent this condition, but set it low enough that the lock can be recovered after a server failure in a reasonable amount of time.</p>
</td></tr></table></div>
<p>Starting with version 5.0, the <code class="literal">RedisLockRegistry</code> implements <code class="literal">ExpirableLockRegistry</code>, which removes locks last acquired more than <code class="literal">age</code> ago and that are not currently locked.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mqtt.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-endpoints.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="resource.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">26.&nbsp;MQTT Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;28.&nbsp;Resource Support</td></tr></table></div></body></html>