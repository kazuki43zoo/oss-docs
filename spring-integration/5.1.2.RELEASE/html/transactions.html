<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Appendix&nbsp;C.&nbsp;Transaction Support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Integration Reference Manual"><link rel="up" href="spring-integration-appendices.html" title="Part&nbsp;VI.&nbsp;Appendices"><link rel="prev" href="message-publishing.html" title="Appendix&nbsp;B.&nbsp;Message Publishing"><link rel="next" href="security.html" title="Appendix&nbsp;D.&nbsp;Security in Spring Integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix&nbsp;C.&nbsp;Transaction Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="message-publishing.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;VI.&nbsp;Appendices</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr></table><hr></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="transactions" href="#transactions"></a>Appendix&nbsp;C.&nbsp;Transaction Support</h2></div></div></div>

<p>This chapter covers Spring Integration&#8217;s support for transactions. It covers the following topics:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="xref" href="transactions.html#understanding-transaction" title="C.1&nbsp;Understanding Transactions in Message flows">Section&nbsp;C.1, &#8220;Understanding Transactions in Message flows&#8221;</a>
</li><li class="listitem">
<a class="xref" href="transactions.html#transaction-boundaries" title="C.2&nbsp;Transaction Boundaries">Section&nbsp;C.2, &#8220;Transaction Boundaries&#8221;</a>
</li><li class="listitem">
<a class="xref" href="transactions.html#transaction-synchronization" title="C.3&nbsp;Transaction Synchronization">Section&nbsp;C.3, &#8220;Transaction Synchronization&#8221;</a>
</li><li class="listitem">
<a class="xref" href="transactions.html#pseudo-transactions" title="C.4&nbsp;Pseudo Transactions">Section&nbsp;C.4, &#8220;Pseudo Transactions&#8221;</a>
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="understanding-transaction" href="#understanding-transaction"></a>C.1&nbsp;Understanding Transactions in Message flows</h2></div></div></div>

<p>Spring Integration exposes several hooks to address the transactional needs of your message flows.
To better understand these hooks and how you can benefit from them, we must first revisit the six mechanisms that you can use to initiate message flows and see how you can address the transactional needs of these flows within each of these mechanisms.</p>
<p>The following six mechanisms initiate a message flow (details for each are provided throughout this manual):</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Gateway proxy: A basic messaging gateway.
</li><li class="listitem">
Message channel: Direct interactions with <code class="literal">MessageChannel</code> methods (for example, <code class="literal">channel.send(message)</code>).
</li><li class="listitem">
Message publisher: The way to initiate a message flow as the by-product of method invocations on Spring beans.
</li><li class="listitem">
Inbound channel adapters and gateways: The way to initiate a message flow based on connecting third-party system with the Spring Integration messaging system (for example, <code class="literal">[JmsMessage] -&gt; Jms Inbound Adapter[SI Message] -&gt; SI Channel</code>).
</li><li class="listitem">
Scheduler: The way to initiate a message flow based on scheduling events distributed by a pre-configured scheduler.
</li><li class="listitem">
Poller: Similar to the scheduler, this is the way to initiate message flow based on scheduling or interval-based events distributed by a pre-configured poller.
</li></ul></div>
<p>We can split these six mechanisms into two general categories:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Message flows initiated by a user process: Example scenarios in this category would be invoking a gateway method or explicitly sending a <code class="literal">Message</code> to a <code class="literal">MessageChannel</code>.
In other words, these message flows depend on a third party process (such as some code that you wrote) to be initiated.
</li><li class="listitem">
Message flows initiated by a daemon process: Example scenarios in this category include a Poller polling a message queue to initiate a new message flow with the polled message or a scheduler scheduling the process by creating a new message and initiating a message flow at a predefined time.
</li></ul></div>
<p>Clearly the&nbsp;gateway proxy, <code class="literal">MessageChannel.send(...)</code> and <code class="literal">MessagePublisher</code> all belong to the first category, and inbound adapters and gateways, scheduler, and poller belong to the second category.</p>
<p>So, how can you address transactional needs in various scenarios within each category, and is there a need for Spring Integration to provide something explicit with regard to transactions for a particular scenario?
Or can you use Spring&#8217;s transaction support instead?</p>
<p>Spring itself provides first class support for transaction management.
So our goal here is not to provide something new but rather use Spring to benefit from its existing support for transactions.
In other words, as a framework, we must expose hooks to Spring&#8217;s transaction management functionality.
However, since Spring Integration configuration is based on Spring configuration, we need not always expose these hooks, because Spring already exposes them .
After all, every Spring Integration component is a Spring Bean.</p>
<p>With this goal in mind, we can again consider the two scenarios: messgae flows initiated by a user process and message flows initiated by a daemon.</p>
<p>Message flows that are initiated by a user process and configured in a Spring application context are subject to the usual transactional configuration of such processes.
Therefore they need not be explicitly configured by Spring Integration to support transactions.
The transaction could and should be initiated through Spring&#8217;s standard transaction support.
The Spring Integration message flow naturally honors the transactional semantics of the components, because it is itself configured by Spring.
For example, a gateway or service activator method could be annotated with <code class="literal">@Transactional</code>, or a <code class="literal">TransactionInterceptor</code> could be defined in an XML configuration with a pointcut expression that pointa to specific methods that should be transactional.
The bottom line is that you have full control over transaction configuration and boundaries in these scenarios.</p>
<p>However, things are a bit different when it comes to message flows initiated by a daemon process.
Although configured by the developer, these flows do not directly involve a human or some other process to be initiated.
These are trigger-based flows that are initiated by a trigger process (a daemon process) based on the configuration of the process.
For example, we could have a scheduler initiate a message flow every Friday night.
We can also configure a trigger that initiates a message flow every second and so on.
As a result, we need a way to let these trigger-based processes know of our intention to make the resulting message flows be transactional, so that a Transaction context can be created whenever a new message flow is initiated.
In other words, we need to expose some transaction configuration, but only enough to delegate to the transaction support already provided by Spring (as we do in other scenarios).</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-poller" href="#transaction-poller"></a>C.1.1&nbsp;Poller Transaction Support</h3></div></div></div>

<p>Spring Integration provides transactional support for pollers.
Pollers are a special type of component because, within a poller task, we can call <code class="literal">receive()</code> against a resource that is itself transactional, thus including the <code class="literal">receive()</code> call in the the boundaries of the transaction, which lets it be rolled back in case of a task failure.
If we were to add the same support for channels, the added transactions would affect all downstream components starting with the <code class="literal">send()</code> call.
That provides a rather wide scope for transaction demarcation without any strong reason, especially when Spring already provides several ways to address the transactional needs of any component downstream.
However the <code class="literal">receive()</code> method being&nbsp;included&nbsp;in a transaction boundary is the "<code class="literal">strong reason</code>" for pollers.</p>
<p>Any time you configure a Poller, you can provide transactional configuration by using the <code class="literal">transactional</code> child element and its attributes,as the following example shows:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"1000"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span><span class="hl-attribute">&nbsp;</span>
                   <span class="hl-attribute">isolation</span>=<span class="hl-value">"DEFAULT"</span>
                   <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span><span class="hl-attribute">&nbsp;</span>
                   <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-attribute">&nbsp;</span>
                   <span class="hl-attribute">timeout</span>=<span class="hl-value">"1000"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/poller&gt;</span></pre>
</div>
<p>The preceding configuration looks similar to a native Spring transaction configuration.
You must still provide a reference to a transaction manager and either specify transaction attributes or rely on defaults (for example, if the <span class="emphasis"><em>transaction-manager</em></span> attribute is not specified, it defaults to the bean named <span class="emphasis"><em>transactionManager</em></span>).
Internally, the process is wrapped in Spring&#8217;s native transaction, where <code class="literal">TransactionInterceptor</code> is responsible for handling transactions.
For more information on how to configure a transaction manager, the types of transaction managers (such as JTA, Datasource, and others), and other details related to transaction configuration, see the <a class="ulink" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction" target="_top">Spring Framework Reference Guide</a>.</p>
<p>With the preceding configuration, all message flows initiated by this poller are transactional.
For more information and details on a poller&#8217;s transactional configuration, see <a class="xref" href="jdbc.html#jdbc-polling-transactions" title="21.1.1&nbsp;Polling and Transactions">Section&nbsp;21.1.1, &#8220;Polling and Transactions&#8221;</a>.</p>
<p>Along with transactions, you might need to address several more cross-cutting concerns when you run a poller.
To help with that, the poller element accepts an <code class="literal">&lt;advice-chain&gt;</code> child element, which lets you define a custom chain of advice instances to be applied on the Poller.
(See <a class="xref" href="messaging-channels-section.html#pollable-message-source" title="6.2.2&nbsp;Pollable Message Source">Section&nbsp;6.2.2, &#8220;Pollable Message Source&#8221;</a> for more details.)
In Spring Integration 2.0, the Poller went through a refactoring effort and now uses a proxy mechanism to address transactional concerns as well as other cross-cutting concerns.
One of the significant changes evolving from this effort is that we made the <code class="literal">&lt;transactional&gt;</code> and <code class="literal">&lt;advice-chain&gt;</code> elements be mutually exclusive.
The rationale behind this is that, if you need more than one advice and one of them is Transaction advice, you can include it in the <code class="literal">&lt;advice-chain&gt;</code> with the same convenience as before but with much more control, since you now have an option to position the advice in the desired order.
The following example shows how to do so:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"10000"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;advice-chain&gt;</span>
    <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"txAdvice"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"someAotherAdviceBean"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"foo.bar.SampleAdvice"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/advice-chain&gt;</span>
<span class="hl-tag">&lt;/poller&gt;</span>

<span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"get*"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre>
</div>
<p>The preceding example shows a basic XML-based configuration of Spring Transaction advice (<code class="literal">txAdvice</code>) and included it within the <code class="literal">&lt;advice-chain&gt;</code> defined by the Poller.
If you need to address only the transactional concerns of the poller, you can still use the <code class="literal">&lt;transactional&gt;</code> element as a convenience.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-boundaries" href="#transaction-boundaries"></a>C.2&nbsp;Transaction Boundaries</h2></div></div></div>

<p>Another important factor is the boundaries of Transactions within a Message flow.
When a transaction is started, the transaction context is bound to the current thread.
So regardless of how many endpoints and channels you have in your Message flow your transaction context will be preserved as long as you are ensuring that the flow continues on the same thread.
As soon as you break it by introducing a <span class="emphasis"><em>Pollable Channel</em></span> or <span class="emphasis"><em>Executor Channel</em></span> or initiate a new thread manually in some service, the Transactional boundary will be broken as well.
Essentially the Transaction will END right there, and if a successful handoff has transpired between the threads, the flow would be considered a success and a COMMIT signal would be sent even though the flow will continue and might still result in an Exception somewhere downstream.
If such a flow were synchronous, that Exception could be thrown back to the initiator of the Message flow who is also the initiator of the transactional context and the transaction would result in a ROLLBACK.
The middle ground is to use transactional channels at any point where a thread boundary is being broken.
For example, you can use a Queue-backed Channel that delegates to a transactional MessageStore strategy, or you could use a JMS-backed channel.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-synchronization" href="#transaction-synchronization"></a>C.3&nbsp;Transaction Synchronization</h2></div></div></div>

<p>In some environments, it help to synchronize operations with a transaction that encompasses the entire flow.
For example, consider a <code class="literal">&lt;file:inbound-channel-adapter/&gt;</code> at the start of a flow that performs a number of database updates.
If the transaction commits, we might want to move the file to a <code class="literal">success</code> directory, while we might want to move it to a <code class="literal">failure</code> directory if the transaction rolls back.</p>
<p>Spring Integration 2.2 introduced the capability of synchronizing these operations with a transaction.
In addition, you can configure a <code class="literal">PseudoTransactionManager</code> if you do not have a <span class="emphasis"><em>real</em></span> transaction but still want to perform different actions on success or failure.
For more information, see <a class="xref" href="transactions.html#pseudo-transactions" title="C.4&nbsp;Pseudo Transactions">Section&nbsp;C.4, &#8220;Pseudo Transactions&#8221;</a>.</p>
<p>The following listing shows the key strategy interfaces for this feature:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TransactionSynchronizationFactory {

    TransactionSynchronization create(Object key);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TransactionSynchronizationProcessor {

    <span class="hl-keyword">void</span> processBeforeCommit(IntegrationResourceHolder holder);

    <span class="hl-keyword">void</span> processAfterCommit(IntegrationResourceHolder holder);

    <span class="hl-keyword">void</span> processAfterRollback(IntegrationResourceHolder holder);

}</pre>
</div>
<p>The factory is responsible for creating a <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionSynchronization.html" target="_top"><code class="literal">TransactionSynchronization</code></a> object.
You can implement your own or use the one provided by the framework: <code class="literal">DefaultTransactionSynchronizationFactory</code>.
This implementation returns a <code class="literal">TransactionSynchronization</code> that delegates to a default implementation of <code class="literal">TransactionSynchronizationProcessor</code>: <code class="literal">ExpressionEvaluatingTransactionSynchronizationProcessor</code>.
This processor supports three SpEL expressions: <code class="literal">beforeCommitExpression</code>, <code class="literal">afterCommitExpression</code>, and <code class="literal">afterRollbackExpression</code>.</p>
<p>These actions should be self-explanatory to those familiar with transactions.
In each case, the <code class="literal">#root</code> variable is the original <code class="literal">Message</code>.
In some cases, other SpEL variables are made available, depending on the <code class="literal">MessageSource</code> being polled by the poller.
For example, the <code class="literal">MongoDbMessageSource</code> provides the <code class="literal">#mongoTemplate</code> variable, which references the message source&#8217;s <code class="literal">MongoTemplate</code>.
Similarly, the <code class="literal">RedisStoreMessageSource</code> provides the <code class="literal">#store</code> variable, which references the <code class="literal">RedisStore</code> created by the poll.</p>
<p>To enable the feature for a particular poller, you can provide a reference to the <code class="literal">TransactionSynchronizationFactory</code> on the poller&#8217;s <code class="literal">&lt;transactional/&gt;</code> element by using the <code class="literal">synchronization-factory</code> attribute.</p>
<p>Starting with version 5.0, Spring Integration provides <code class="literal">PassThroughTransactionSynchronizationFactory</code>, which is applied by default to polling endpoints when no <code class="literal">TransactionSynchronizationFactory</code> is configured but an advice of type <code class="literal">TransactionInterceptor</code> exists in the advice chain.
When using any out-of-the-box <code class="literal">TransactionSynchronizationFactory</code> implementation, polling endpoints bind a polled message to the current transactional context and provide it as a <code class="literal">failedMessage</code> in a <code class="literal">MessagingException</code> if an exception is thrown after the transaction advice.
When using a custom transaction advice that does not implement <code class="literal">TransactionInterceptor</code>, you can explicitly configure a <code class="literal">PassThroughTransactionSynchronizationFactory</code> to achieve this behavior.
In either case, the <code class="literal">MessagingException</code> becomes the payload of the <code class="literal">ErrorMessage</code> that is sent to the <code class="literal">errorChannel</code>, and the cause is the raw exception thrown by the advice.
Previously, the <code class="literal">ErrorMessage</code> had a payload that was the raw exception thrown by the advice and did not provide a reference to the <code class="literal">failedMessage</code> information, making it difficult to determine the reasons for the transaction commit problem.</p>
<p>To simplify configuration of these components, Spring Integration provides namespace support for the default factory.
The following example shows how to use the namespace to configure a file inbound channel adapter:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;int-file:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inputDirPoller"</span>
    <span class="hl-attribute">channel</span>=<span class="hl-value">"someChannel"</span>
    <span class="hl-attribute">directory</span>=<span class="hl-value">"/foo/bar"</span>
    <span class="hl-attribute">filter</span>=<span class="hl-value">"filter"</span>
    <span class="hl-attribute">comparator</span>=<span class="hl-value">"testComparator"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:poller</span> <span class="hl-attribute">fixed-rate</span>=<span class="hl-value">"5000"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;int:transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">synchronization-factory</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/int:poller&gt;</span>
<span class="hl-tag">&lt;/int-file:inbound-channel-adapter&gt;</span>

<span class="hl-tag">&lt;int:transaction-synchronization-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"syncFactory"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;int:after-commit</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload.renameTo('/success/' + payload.name)"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"committedChannel"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;int:after-rollback</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"payload.renameTo('/failed/' + payload.name)"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"rolledBackChannel"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/int:transaction-synchronization-factory&gt;</span></pre>
</div>
<p>The result of the SpEL evaluation is sent as the payload to either <code class="literal">committedChannel</code> or <code class="literal">rolledBackChannel</code> (in this case, this would be <code class="literal">Boolean.TRUE</code> or <code class="literal">Boolean.FALSE</code>&#8201;&#8212;&#8201;the result of the <code class="literal">java.io.File.renameTo()</code> method call).</p>
<p>If you wish to send the entire payload for further Spring Integration processing, use the <span class="emphasis"><em>payload</em></span> expression.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
<p>It is important to understand that this synchronizes the actions with a transaction.
It does not make a resource that is not inherently transactional actually be transactional.
Instead, the transaction (be it JDBC or otherwise) is started before the poll and either committed or rolled back when the flow completes, followed by the synchronized action.</p>
<p>If you provide a custom <code class="literal">TransactionSynchronizationFactory</code>, it is responsible for creating a resource synchronization that causes the bound resource to be unbound automatically when the transaction completes.
The default <code class="literal">TransactionSynchronizationFactory</code> does so by returning a subclass of <code class="literal">ResourceHolderSynchronization</code>, with the default <code class="literal">shouldUnbindAtCompletion()</code> returning <code class="literal">true</code>.</p>
</td></tr></table></div>
<p>In addition to the <code class="literal">after-commit</code> and <code class="literal">after-rollback</code> expressions, <code class="literal">before-commit</code> is also supported.
In that case, if the evaluation (or downstream processing) throws an exception, the transaction is rolled back instead of being committed.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pseudo-transactions" href="#pseudo-transactions"></a>C.4&nbsp;Pseudo Transactions</h2></div></div></div>

<p>After reading the <a class="xref" href="transactions.html#transaction-synchronization" title="C.3&nbsp;Transaction Synchronization">Section&nbsp;C.3, &#8220;Transaction Synchronization&#8221;</a> section, you might think it would be useful to take these <span class="emphasis"><em>success</em></span> or <span class="emphasis"><em>failure</em></span> actions when a flow completes, even if there is no "<code class="literal">real</code>" transactional resources (such as JDBC) downstream of the poller.
For example, consider a "<code class="literal">&lt;file:inbound-channel-adapter/&gt;</code>" followed by an "<code class="literal">&lt;ftp:outbout-channel-adapter/&gt;</code>".
Neither of these components is transactional, but we might want to move the input file to different directories, based on the success or failure of the FTP transfer.</p>
<p>To provide this functionality, the framework provides a <code class="literal">PseudoTransactionManager</code>, enabling the above configuration even when there is no real transactional resource involved.
If the flow completes normally, the <code class="literal">beforeCommit</code> and <code class="literal">afterCommit</code> synchronizations are called.
On failure, the <code class="literal">afterRollback</code> synchronization is called.
Because it is not a real transaction, no actual commit or rollback occurs.
The pseudo transaction is a vehicle used to enable the synchronization features.</p>
<p>To use a <code class="literal">PseudoTransactionManager</code>, you can define it as a &lt;bean/&gt;, in the same way you would configure a real transaction manager.
The following example shows how to do so:</p>
<div class="informalexample">
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"o.s.i.transaction.PseudoTransactionManager"</span><span class="hl-tag"> /&gt;</span></pre>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="message-publishing.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="spring-integration-appendices.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Appendix&nbsp;B.&nbsp;Message Publishing&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Appendix&nbsp;D.&nbsp;Security in Spring Integration</td></tr></table></div></body></html>