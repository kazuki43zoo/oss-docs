<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 24 June 2018 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Clinton Begin" />
    <meta name="Date-Revision-yyyymmdd" content="20180624" />
    <meta http-equiv="Content-Language" content="en" />
    <title>mybatis &#x2013; MyBatis 3 | The SQL BUilder Class</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
      <script type="text/javascript" src="./js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarDisabled">
      <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>mybatis</h2>
</div>
</div>
        <div class="pull-right"><a href="../" id="bannerRight" title="MyBatis logo"><img src="../images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 24 June 2018<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 3.4.6</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Reference Documentation</li>
    <li><a href="index.html" title="Introduction"><span class="none"></span>Introduction</a>  </li>
    <li><a href="getting-started.html" title="Getting Started"><span class="none"></span>Getting Started</a>  </li>
    <li><a href="configuration.html" title="Configuration XML"><span class="icon-chevron-right"></span>Configuration XML</a>  </li>
    <li><a href="sqlmap-xml.html" title="Mapper XML Files"><span class="icon-chevron-right"></span>Mapper XML Files</a>  </li>
    <li><a href="dynamic-sql.html" title="Dynamic SQL"><span class="none"></span>Dynamic SQL</a>  </li>
    <li><a href="java-api.html" title="Java API"><span class="icon-chevron-right"></span>Java API</a>  </li>
    <li class="active"><a href="#"><span class="none"></span>SQL Builder Class</a>
  </li>
    <li><a href="logging.html" title="Logging"><span class="none"></span>Logging</a>  </li>
          <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a>  </li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a>  </li>
  </ul>
          <hr />
          <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >


  
    <div class="section">
<h2><a name="The_SQL_Builder_Class"></a>The SQL Builder Class</h2>
      
<div class="section">
<h3><a name="The_Problem"></a>The Problem</h3>
        
<p>One of the nastiest things a Java developer will ever have to do is embed SQL in Java code. Usually this is
          done because the SQL has to be dynamically generated - otherwise you could externalize it in a file or a
          stored proc. As you've already seen, MyBatis has a powerful answer for dynamic SQL generation in its
          XML mapping features. However, sometimes it becomes necessary to build a SQL statement string inside of Java
          code. In that case, MyBatis has one more feature to help you out, before reducing yourself to the typical mess
          of plus signs, quotes, newlines, formatting problems and nested conditionals to deal with extra commas or
          AND conjunctions. Indeed, dynamically generating SQL code in Java can be a real nightmare.  For example:
        </p>

        
<div class="source"><pre class="prettyprint">
String sql = &quot;SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, &quot;
&quot;P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON &quot; +
&quot;FROM PERSON P, ACCOUNT A &quot; +
&quot;INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID &quot; +
&quot;INNER JOIN COMPANY C on D.COMPANY_ID = C.ID &quot; +
&quot;WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) &quot; +
&quot;OR (P.LAST_NAME like ?) &quot; +
&quot;GROUP BY P.ID &quot; +
&quot;HAVING (P.LAST_NAME like ?) &quot; +
&quot;OR (P.FIRST_NAME like ?) &quot; +
&quot;ORDER BY P.ID, P.FULL_NAME&quot;;
</pre></div>
      </div>
      
<div class="section">
<h3><a name="The_Solution"></a>The Solution</h3>
      
<p>MyBatis 3 offers a convenient utility class to help with the problem.
        With the SQL class, you simply create an instance that lets you call methods against it to build a SQL statement
        one step at a time.  The example problem above would look like this when rewritten with the SQL class:
      </p>

      
<div class="source"><pre class="prettyprint">
private String selectPersonSql() {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
    SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
    FROM(&quot;PERSON P&quot;);
    FROM(&quot;ACCOUNT A&quot;);
    INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
    INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
    WHERE(&quot;P.ID = A.ID&quot;);
    WHERE(&quot;P.FIRST_NAME like ?&quot;);
    OR();
    WHERE(&quot;P.LAST_NAME like ?&quot;);
    GROUP_BY(&quot;P.ID&quot;);
    HAVING(&quot;P.LAST_NAME like ?&quot;);
    OR();
    HAVING(&quot;P.FIRST_NAME like ?&quot;);
    ORDER_BY(&quot;P.ID&quot;);
    ORDER_BY(&quot;P.FULL_NAME&quot;);
  }}.toString();
}
</pre></div>

      
<p>What is so special about that example? Well, if you look closely, it doesn't have to worry about
          accidentally duplicating &quot;AND&quot; keywords, or choosing between &quot;WHERE&quot;
          and &quot;AND&quot; or none at all. The SQL class takes care of understanding where &quot;WHERE&quot;
          needs to go, where an &quot;AND&quot; should be used and all of the String concatenation.
        </p>

      </div>

      
<div class="section">
<h3><a name="The_SQL_Class"></a>The SQL Class</h3>

        
<p>Here are some examples:</p>

        
<div class="source"><pre class="prettyprint">
// Anonymous inner class
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

// Builder / Fluent style
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;)
    .VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;)
    .toString();
  return sql;
}

// With conditionals (note the final parameters, required for the anonymous inner class to access them)
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;);
    FROM(&quot;PERSON P&quot;);
    if (id != null) {
      WHERE(&quot;P.ID like #{id}&quot;);
    }
    if (firstName != null) {
      WHERE(&quot;P.FIRST_NAME like #{firstName}&quot;);
    }
    if (lastName != null) {
      WHERE(&quot;P.LAST_NAME like #{lastName}&quot;);
    }
    ORDER_BY(&quot;P.LAST_NAME&quot;);
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO(&quot;PERSON&quot;);
    VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;);
    VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;);
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE(&quot;PERSON&quot;);
    SET(&quot;FIRST_NAME = #{firstName}&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}
</pre></div>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Method</th>
              
<th>Description</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td>
                
<ul>
                  
<li>
                    <tt>SELECT(String)</tt>
                  </li>
                  
<li>
                    <tt>SELECT(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Starts or appends to a
                <tt>SELECT</tt>
                clause. Can be called more than once, and parameters will be appended to
                the
                <tt>SELECT</tt>
                clause. The parameters are usually a comma separated list of columns and aliases, but can be
                anything acceptable to the driver.
              </td>
            </tr>
            
<tr class="a">
              
<td>
                
<ul>
                  
<li>
                    <tt>SELECT_DISTINCT(String)</tt>
                  </li>
                  
<li>
                    <tt>SELECT_DISTINCT(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Starts or appends to a
                <tt>SELECT</tt>
                clause, also adds the
                <tt>DISTINCT</tt>
                keyword to the generated query.
                Can be called more than once, and parameters will be appended to the
                <tt>SELECT</tt>
                clause. The parameters
                are usually a comma separated list of columns and aliases, but can be anything acceptable to the driver.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                
<ul>
                  
<li>
                    <tt>FROM(String)</tt>
                  </li>
                  
<li>
                    <tt>FROM(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Starts or appends to a
                <tt>FROM</tt>
                clause. Can be called more than once, and parameters will be appended to the
                <tt>FROM</tt>
                clause. Parameters are usually a table name and an alias, or anything acceptable to the driver.
              </td>
            </tr>
            
<tr class="a">
              
<td>
                
<ul>
                  
<li>
                    <tt>JOIN(String)</tt>
                  </li>
                  
<li>
                    <tt>JOIN(String...)</tt>
                  </li>
                  
<li>
                    <tt>INNER_JOIN(String)</tt>
                  </li>
                  
<li>
                    <tt>INNER_JOIN(String...)</tt>
                  </li>
                  
<li>
                    <tt>LEFT_OUTER_JOIN(String)</tt>
                  </li>
                  
<li>
                    <tt>LEFT_OUTER_JOIN(String...)</tt>
                  </li>
                  
<li>
                    <tt>RIGHT_OUTER_JOIN(String)</tt>
                  </li>
                  
<li>
                    <tt>RIGHT_OUTER_JOIN(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Adds a new
                <tt>JOIN</tt>
                clause of the appropriate type, depending on the method called. The parameter can include
                a standard join consisting of the columns and the conditions to join on.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                
<ul>
                  
<li>
                    <tt>WHERE(String)</tt>
                  </li>
                  
<li>
                    <tt>WHERE(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Appends a new
                <tt>WHERE</tt>
                clause condition, concatenated by<tt>AND</tt>. Can be called multiple times, which causes it
                to concatenate the new conditions each time with<tt>AND</tt>. Use
                <tt>OR()</tt>
                to split with an<tt>OR</tt>.
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <tt>OR()</tt>
              </td>
              
<td>Splits the current
                <tt>WHERE</tt>
                clause conditions with an<tt>OR</tt>. Can be called more than once, but calling more
                than once in a row will generate erratic<tt>SQL</tt>.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <tt>AND()</tt>
              </td>
              
<td>Splits the current
                <tt>WHERE</tt>
                clause conditions with an<tt>AND</tt>. Can be called more than once, but calling more
                than once in a row will generate erratic<tt>SQL</tt>. Because
                <tt>WHERE</tt>
                and
                <tt>HAVING</tt>
                both automatically concatenate with
                <tt>AND</tt>, this is a very uncommon method to use and is only really included for completeness.
              </td>
            </tr>
            
<tr class="a">
              
<td>
                
<ul>
                  
<li>
                    <tt>GROUP_BY(String)</tt>
                  </li>
                  
<li>
                    <tt>GROUP_BY(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Appends a new
                <tt>GROUP BY</tt>
                clause elements, concatenated by a comma. Can be called multiple times, which
                causes it to concatenate the new conditions each time with a comma.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                
<ul>
                  
<li>
                    <tt>HAVING(String)</tt>
                  </li>
                  
<li>
                    <tt>HAVING(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Appends a new
                <tt>HAVING</tt>
                clause condition, concatenated by AND. Can be called multiple times, which causes it
                to concatenate the new conditions each time with<tt>AND</tt>. Use
                <tt>OR()</tt>
                to split with an<tt>OR</tt>.
              </td>
            </tr>
            
<tr class="a">
              
<td>
                
<ul>
                  
<li>
                    <tt>ORDER_BY(String)</tt>
                  </li>
                  
<li>
                    <tt>ORDER_BY(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Appends a new
                <tt>ORDER BY</tt>
                clause elements, concatenated by a comma. Can be called multiple times, which
                causes it to concatenate the new conditions each time with a comma.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <tt>DELETE_FROM(String)</tt>
              </td>
              
<td>Starts a delete statement and specifies the table to delete from. Generally this should be followed by
                a
                WHERE statement!
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <tt>INSERT_INTO(String)</tt>
              </td>
              
<td>Starts an insert statement and specifies the table to insert into. This should be followed by one or
                more VALUES() or INTO_COLUMNS() and INTO_VALUES() calls.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                
<ul>
                  
<li>
                    <tt>SET(String)</tt>
                  </li>
                  
<li>
                    <tt>SET(String...)</tt>
                  </li>
                </ul>
              </td>
              
<td>Appends to the &quot;set&quot; list for an update statement.</td>
            </tr>
            
<tr class="a">
              
<td>
                <tt>UPDATE(String)</tt>
              </td>
              
<td>Starts an update statement and specifies the table to update. This should be followed by one or more
                SET() calls, and usually a WHERE() call.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <tt>VALUES(String, String)</tt>
              </td>
              
<td>Appends to an insert statement. The first parameter is the column(s) to insert, the second parameter
                is
                the value(s).
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <tt>INTO_COLUMNS(String...)</tt>
              </td>
              
<td>
                Appends columns phrase to an insert statement.
                This should be call INTO_VALUES() with together.
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <tt>INTO_VALUES(String...)</tt>
              </td>
              
<td>
                Appends values phrase to an insert statement.
                This should be call INTO_COLUMNS() with together.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>Since version 3.4.2, you can use variable-length arguments as follows:</p>


<div class="source"><pre class="prettyprint">
public String selectPersonSql() {
  return new SQL()
    .SELECT(&quot;P.ID&quot;, &quot;A.USERNAME&quot;, &quot;A.PASSWORD&quot;, &quot;P.FULL_NAME&quot;, &quot;D.DEPARTMENT_NAME&quot;, &quot;C.COMPANY_NAME&quot;)
    .FROM(&quot;PERSON P&quot;, &quot;ACCOUNT A&quot;)
    .INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;, &quot;COMPANY C on D.COMPANY_ID = C.ID&quot;)
    .WHERE(&quot;P.ID = A.ID&quot;, &quot;P.FULL_NAME like #{name}&quot;)
    .ORDER_BY(&quot;P.ID&quot;, &quot;P.FULL_NAME&quot;)
    .toString();
}

public String insertPersonSql() {
  return new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;)
    .INTO_VALUES(&quot;#{id}&quot;, &quot;#{fullName}&quot;)
    .toString();
}

public String updatePersonSql() {
  return new SQL()
    .UPDATE(&quot;PERSON&quot;)
    .SET(&quot;FULL_NAME = #{fullName}&quot;, &quot;DATE_OF_BIRTH = #{dateOfBirth}&quot;)
    .WHERE(&quot;ID = #{id}&quot;)
    .toString();
}
</pre></div>

      </div>

      
<div class="section">
<h3><a name="SqlBuilder_and_SelectBuilder_DEPRECATED"></a>SqlBuilder and SelectBuilder (DEPRECATED)</h3>
        
<p>
          Before version 3.2 we took a bit of a different approach, by utilizing a ThreadLocal variable to mask some of the
          language limitations that make Java DSLs a bit cumbersome. However, this approach is now deprecated, as modern
          frameworks have warmed people to the idea of using builder-type patterns and anonymous inner classes for such
          things. Therefore the SelectBuilder and SqlBuilder classes have been deprecated.
        </p>
        
<p>
          The following methods apply to only the deprecated SqlBuilder and SelectBuilder classes.
        </p>
        
<table border="0" class="table table-striped">
        <thead>
          
<tr class="a">
            
<th>Method</th>
            
<th>Description</th>
          </tr>
        </thead>
        <tbody>
        
<tr class="b">
          
<td>
            <tt>BEGIN()</tt>
            /
            <tt>RESET()</tt>
          </td>
          
<td>These methods clear the ThreadLocal state of the SelectBuilder class, and prepare it for a new
            statement to be
            built.
            <tt>BEGIN()</tt>
            reads best when starting a new statement.
            <tt>RESET()</tt>
            reads best when clearing a
            statement in the middle of execution for some reason (perhaps if the logic demands a completely
            different
            statement under some conditions).
          </td>
        </tr>
        
<tr class="a">
          
<td>
            <tt>SQL()</tt>
          </td>
          
<td>This returns the generated
            <tt>SQL()</tt>
            and resets the
            <tt>SelectBuilder</tt>
            state (as if
            <tt>BEGIN()</tt>
            or
            <tt>RESET()</tt>
            were called).
            Thus, this method can only be called ONCE!
          </td>
        </tr>
        </tbody>
        </table>

        
<p>
          The SelectBuilder and SqlBuilder classes are not magical, but it's important to know how they work.
          SelectBuilder and SqlBuilder use a combination of
          Static Imports and a ThreadLocal variable to enable a clean syntax that can be easily interlaced with
          conditionals.  To use them, you statically import the methods from the classes like this (one or the other,
          not both):
        </p>

        
<div class="source"><pre class="prettyprint">import static org.apache.ibatis.jdbc.SelectBuilder.*;</pre></div>
        
<div class="source"><pre class="prettyprint">import static org.apache.ibatis.jdbc.SqlBuilder.*;</pre></div>

        
<p>This allows us to create methods like these:</p>

        
<div class="source"><pre class="prettyprint">
/* DEPRECATED */
public String selectBlogsSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT(&quot;*&quot;);
  FROM(&quot;BLOG&quot;);
  return SQL();
}
        </pre></div>

        
<div class="source"><pre class="prettyprint">
/* DEPRECATED */
private String selectPersonSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
  SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
  FROM(&quot;PERSON P&quot;);
  FROM(&quot;ACCOUNT A&quot;);
  INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
  INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
  WHERE(&quot;P.ID = A.ID&quot;);
  WHERE(&quot;P.FIRST_NAME like ?&quot;);
  OR();
  WHERE(&quot;P.LAST_NAME like ?&quot;);
  GROUP_BY(&quot;P.ID&quot;);
  HAVING(&quot;P.LAST_NAME like ?&quot;);
  OR();
  HAVING(&quot;P.FIRST_NAME like ?&quot;);
  ORDER_BY(&quot;P.ID&quot;);
  ORDER_BY(&quot;P.FULL_NAME&quot;);
  return SQL();
}
        </pre></div>

      </div>


    </div>
  


        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2009&#x2013;2018
<a href="http://www.mybatis.org/">MyBatis.org</a>.
All rights reserved.</p>
        </div>
        </div>
    </footer>
    </body>
</html>
