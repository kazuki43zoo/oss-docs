<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Web Services Reference Documentation</title><link rel="stylesheet" type="text/css" href="css/manual-singlepage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="spring-framework-reference"></a>Spring Web Services Reference Documentation</h1></div><div><div class="authorgroup"><h2>Authors</h2>
            <span class="author"><span class="firstname">Arjen</span> <span class="surname">Poutsma</span></span>
            , <span class="author"><span class="firstname">Rick</span> <span class="surname">Evans</span></span>
            , <span class="author"><span class="firstname">Tareq</span> <span class="surname">Abed Rabbo</span></span>
        </div></div><div><p class="releaseinfo">2.4.0.RELEASE</p></div><div><p class="copyright">Copyright &copy; 2005-2014 </p></div><div><div class="legalnotice"><a name="d5e21" href="#d5e21"></a>
            <p>
                Copies of this document may be made for your own use and for distribution
                to others, provided that you do not charge any fee for such copies and
                further provided that each copy contains this Copyright Notice, whether
                distributed in print or electronically.
            </p>
        </div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#overview">Preface</a></span></dt><dt><span class="part"><a href="#d5e32">I. Introduction</a></span></dt><dd><dl><dt><span class="chapter"><a href="#what-is-spring-ws">1. What is Spring Web Services?</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e40">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e65">1.2. Runtime environment</a></span></dt><dt><span class="section"><a href="#d5e96">1.3. Supported standards</a></span></dt></dl></dd><dt><span class="chapter"><a href="#why-contract-first">2. Why Contract First?</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e112">2.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e123">2.2. Object/XML Impedance Mismatch</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e131">2.2.1. XSD extensions</a></span></dt><dt><span class="section"><a href="#d5e136">2.2.2. Unportable types</a></span></dt><dt><span class="section"><a href="#d5e152">2.2.3. Cyclic graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e164">2.3. Contract-first versus Contract-last</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e167">2.3.1. Fragility</a></span></dt><dt><span class="section"><a href="#d5e173">2.3.2. Performance</a></span></dt><dt><span class="section"><a href="#d5e177">2.3.3. Reusability</a></span></dt><dt><span class="section"><a href="#d5e185">2.3.4. Versioning</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#tutorial">3. Writing Contract-First Web Services</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e193">3.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e200">3.2. Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e203">3.2.1. Holiday</a></span></dt><dt><span class="section"><a href="#d5e209">3.2.2. Employee</a></span></dt><dt><span class="section"><a href="#d5e216">3.2.3. HolidayRequest</a></span></dt></dl></dd><dt><span class="section"><a href="#tutorial.xsd">3.3. Data Contract</a></span></dt><dt><span class="section"><a href="#tutorial-service-contract">3.4. Service contract</a></span></dt><dt><span class="section"><a href="#tutorial-creating-project">3.5. Creating the project</a></span></dt><dt><span class="section"><a href="#tutorial.implementing.endpoint">3.6. Implementing the Endpoint</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e399">3.6.1. Handling the XML Message</a></span></dt><dt><span class="section"><a href="#d5e454">3.6.2. Routing the Message to the Endpoint</a></span></dt><dt><span class="section"><a href="#d5e468">3.6.3. Providing the Service and Stub implementation</a></span></dt></dl></dd><dt><span class="section"><a href="#tutorial-publishing-wsdl">3.7. Publishing the WSDL</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#d5e529">II. Reference</a></span></dt><dd><dl><dt><span class="chapter"><a href="#common">4. Shared components</a></span></dt><dd><dl><dt><span class="section"><a href="#web-service-messages">4.1. Web service messages</a></span></dt><dd><dl><dt><span class="section"><a href="#web-service-message">4.1.1. <code class="interfacename">WebServiceMessage</code></a></span></dt><dt><span class="section"><a href="#soap-message">4.1.2. <code class="interfacename">SoapMessage</code></a></span></dt><dt><span class="section"><a href="#message-factories">4.1.3. Message Factories</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e610"><code class="classname">SaajSoapMessageFactory</code></a></span></dt><dt><span class="section"><a href="#d5e652"><code class="classname">AxiomSoapMessageFactory</code></a></span></dt><dt><span class="section"><a href="#soap_11_or_12"><acronym class="acronym">SOAP</acronym> 1.1 or 1.2</a></span></dt></dl></dd><dt><span class="section"><a href="#message-context">4.1.4. <code class="interfacename">MessageContext</code></a></span></dt></dl></dd><dt><span class="section"><a href="#transport-context">4.2. <code class="interfacename">TransportContext</code></a></span></dt><dt><span class="section"><a href="#xpath">4.3. Handling XML With XPath</a></span></dt><dd><dl><dt><span class="section"><a href="#xpath-expression">4.3.1. <code class="interfacename">XPathExpression</code></a></span></dt><dt><span class="section"><a href="#xpath-template">4.3.2. <code class="classname">XPathTemplate</code></a></span></dt></dl></dd><dt><span class="section"><a href="#logging">4.4. Message Logging and Tracing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#server">5. Creating a Web service with Spring-WS</a></span></dt><dd><dl><dt><span class="section"><a href="#ws-introduction">5.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e780">5.2. The <code class="classname">MessageDispatcher</code></a></span></dt><dt><span class="section"><a href="#d5e820">5.3. Transports</a></span></dt><dd><dl><dt><span class="section"><a href="#message-dispatcher-servlet">5.3.1. <code class="classname">MessageDispatcherServlet</code></a></span></dt><dd><dl><dt><span class="section"><a href="#server-automatic-wsdl-exposure">Automatic WSDL exposure</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e949">5.3.2. Wiring up Spring-WS in a <code class="classname">DispatcherServlet</code></a></span></dt><dt><span class="section"><a href="#d5e972">5.3.3. JMS transport</a></span></dt><dt><span class="section"><a href="#d5e980">5.3.4. Email transport</a></span></dt><dt><span class="section"><a href="#d5e1002">5.3.5. Embedded HTTP Server transport</a></span></dt><dt><span class="section"><a href="#d5e1030">5.3.6. XMPP transport</a></span></dt><dt><span class="section"><a href="#d5e1041">5.3.7. MTOM</a></span></dt></dl></dd><dt><span class="section"><a href="#server-endpoints">5.4. Endpoints</a></span></dt><dd><dl><dt><span class="section"><a href="#server-atEndpoint-methods">5.4.1. <code class="interfacename">@Endpoint</code> handling methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1137">Handling method parameters</a></span></dt><dt><span class="section"><a href="#d5e1297">Handling method return types</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#server-endpoint-mapping">5.5. Endpoint mappings</a></span></dt><dd><dl><dt><span class="section"><a href="#server-ws-addressing">5.5.1. WS-Addressing</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1425"><code class="classname">AnnotationActionEndpointMapping</code></a></span></dt></dl></dd><dt><span class="section"><a href="#server-endpoint-interceptor">5.5.2. Intercepting requests - the <code class="interfacename">EndpointInterceptor</code> interface</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1494"><code class="classname">PayloadLoggingInterceptor</code> and
                    <code class="classname">SoapEnvelopeLoggingInterceptor</code></a></span></dt><dt><span class="section"><a href="#d5e1509"><code class="classname">PayloadValidatingInterceptor</code></a></span></dt><dt><span class="section"><a href="#d5e1527"><code class="classname">PayloadTransformingInterceptor</code></a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#server-endpoint-exception-resolver">5.6. Handling Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1552">5.6.1. <code class="classname">SoapFaultMappingExceptionResolver</code></a></span></dt><dt><span class="section"><a href="#d5e1565">5.6.2. <code class="classname">SoapFaultAnnotationExceptionResolver</code></a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1577">5.7. Server-side testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1590">5.7.1. Writing server-side integration tests</a></span></dt><dt><span class="section"><a href="#server-test-request-creator">5.7.2. <code class="interfacename">RequestCreator</code> and <code class="classname">RequestCreators</code></a></span></dt><dt><span class="section"><a href="#server-test-response-matcher">5.7.3. <code class="interfacename">ResponseMatcher</code> and <code class="classname">ResponseMatchers</code></a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#client">6. Using Spring Web Services on the Client</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1768">6.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e1774">6.2. Using the client-side API</a></span></dt><dd><dl><dt><span class="section"><a href="#client-web-service-template">6.2.1. <code class="classname">WebServiceTemplate</code></a></span></dt><dd><dl><dt><span class="section"><a href="#client-transports">URIs and Transports</a></span></dt><dt><span class="section"><a href="#d5e1866">Message factories</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1874">6.2.2. Sending and receiving a <code class="interfacename">WebServiceMessage</code>
            </a></span></dt><dt><span class="section"><a href="#d5e1898">6.2.3. Sending and receiving POJOs - marshalling and unmarshalling</a></span></dt><dt><span class="section"><a href="#d5e1912">6.2.4. 
                <code class="interfacename">WebServiceMessageCallback</code>
            </a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1923">WS-Addressing</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1935">6.2.5. 
                <code class="interfacename">WebServiceMessageExtractor</code>
            </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1950">6.3. Client-side testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1965">6.3.1. Writing client-side integration tests</a></span></dt><dt><span class="section"><a href="#client-test-request-matcher">6.3.2. <code class="interfacename">RequestMatcher</code> and <code class="classname">RequestMatchers</code></a></span></dt><dt><span class="section"><a href="#client-test-response-creator">6.3.3. <code class="interfacename">ResponseCreator</code> and <code class="classname">ResponseCreators</code></a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#security">7. Securing your Web services with Spring-WS</a></span></dt><dd><dl><dt><span class="section"><a href="#security-introduction">7.1. Introduction</a></span></dt><dt><span class="section"><a href="#security-xws-security-interceptor">7.2. 
            <code class="classname">XwsSecurityInterceptor</code>
        </a></span></dt><dd><dl><dt><span class="section"><a href="#keystore">7.2.1. Keystores</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2255">KeyTool</a></span></dt><dt><span class="section"><a href="#d5e2263">KeyStoreFactoryBean</a></span></dt><dt><span class="section"><a href="#security-key-store-callback-handler">KeyStoreCallbackHandler</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2330">7.2.2. Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2334">Plain Text Username Authentication</a></span></dt><dt><span class="section"><a href="#d5e2400">Digest Username Authentication</a></span></dt><dt><span class="section"><a href="#security-certificate-authentication">Certificate Authentication</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2507">7.2.3. Digital Signatures</a></span></dt><dd><dl><dt><span class="section"><a href="#security-verifying-signatures">Verifying Signatures</a></span></dt><dt><span class="section"><a href="#d5e2536">Signing Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2561">7.2.4. Encryption and Decryption</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2566">Decryption</a></span></dt><dt><span class="section"><a href="#d5e2589">Encryption</a></span></dt></dl></dd><dt><span class="section"><a href="#security-xws-exception-handling">7.2.5. Security Exception Handling</a></span></dt></dl></dd><dt><span class="section"><a href="#security-wss4j-security-interceptor">7.3. 
            <code class="classname">Wss4jSecurityInterceptor</code>
        </a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2649">7.3.1. Configuring
                <code class="classname">Wss4jSecurityInterceptor</code>
            </a></span></dt><dt><span class="section"><a href="#d5e2718">7.3.2. Handling Digital Certificates</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2726">CryptoFactoryBean</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2739">7.3.3. Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2741">Validating Username Token</a></span></dt><dt><span class="section"><a href="#d5e2765">Adding Username Token</a></span></dt><dt><span class="section"><a href="#d5e2787">Certificate Authentication</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2802">7.3.4. Security Timestamps</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2806">Validating Timestamps</a></span></dt><dt><span class="section"><a href="#d5e2819">Adding Timestamps</a></span></dt></dl></dd><dt><span class="section"><a href="#security-wss4j-digital-signatures">7.3.5. Digital Signatures</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2831">Verifying Signatures</a></span></dt><dt><span class="section"><a href="#d5e2839">Signing Messages</a></span></dt><dt><span class="section"><a href="#d5e2867">Signature Confirmation</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2875">7.3.6. Encryption and Decryption</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2879">Decryption</a></span></dt><dt><span class="section"><a href="#d5e2899">Encryption</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2951">7.3.7. Security Exception Handling</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#resources">III. Other Resources</a></span></dt><dd><dl><dt><span class="bibliography"><a href="#d5e2961">Bibliography</a></span></dt></dl></dd></dl></div>
    

    

    <div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="overview" href="#overview"></a>Preface</h1></div></div></div>
	
	<p>
        In the current age of Service Oriented Architectures, more and more people are using Web Services to
        connect previously unconnected systems. Initially, Web services were considered to be just another way to do
        a Remote Procedure Call (RPC). Over time however, people found out that there is a big difference
        between RPCs and Web services. Especially when interoperability with other platforms is important, it is often
        better to send encapsulated XML documents, containing all the data necessary to process the request.
        Conceptually, XML-based Web services are better off being compared to message queues rather than remoting
        solutions.
        Overall, XML should be considered the platform-neutral representation of data, the 
        <span class="foreignphrase"><em class="foreignphrase">interlingua</em></span> of SOA. When developing or using Web services, the focus should be 
        on this XML, and not on Java.
    </p>
    <p>
        Spring Web Services focuses on creating these document-driven Web services.
        Spring Web Services facilitates contract-first SOAP service development, allowing for the creation of
        flexible web services using one of the many ways to manipulate XML payloads. 
        Spring-WS provides a powerful <a class="link" href="#server" title="5.&nbsp;Creating a Web service with Spring-WS">message dispatching framework</a>, a <a class="link" href="#security" title="7.&nbsp;Securing your Web services with Spring-WS">WS-Security</a> solution that integrates with your existing application security
        solution, and a <a class="link" href="#client" title="6.&nbsp;Using Spring Web Services on the Client">Client-side API</a> that follows the familiar Spring template pattern.
    </p>
</div>
    <div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="d5e32" href="#d5e32"></a>Part&nbsp;I.&nbsp;Introduction</h1></div></div></div>
        
        <div class="partintro"><div></div>
            <p>
                This first part of the reference documentation
                <a class="link" href="#what-is-spring-ws" title="1.&nbsp;What is Spring Web Services?">is an overview</a> of
                Spring Web Services and the underlying concepts. Spring-WS is
                then introduced, and <a class="link" href="#why-contract-first" title="2.&nbsp;Why Contract First?">the concepts</a>
                behind contract-first Web service development are explained.
            </p>
        </div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="what-is-spring-ws" href="#what-is-spring-ws"></a>1.&nbsp;What is Spring Web Services?</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e40" href="#d5e40"></a>1.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            Spring Web Services (Spring-WS) is a product of the Spring community focused on creating document-driven 
            Web services.
            Spring Web Services aims to facilitate contract-first SOAP service development, allowing for the creation of
            flexible web services using one of the many ways to manipulate XML payloads.
            The product is based on Spring itself, which means you can use the Spring concepts such as dependency 
            injection as an integral part of your Web service.
        </p>
        <p>
            People use Spring-WS for many reasons, but most are drawn to it after finding alternative SOAP stacks 
            lacking when it comes to following Web service best practices.
            Spring-WS makes the best practice an easy practice. This includes practices such as the WS-I basic profile,
            Contract-First development, and having a loose coupling between contract and implementation.
            The other key features of Spring Web services are:
        </p>
        <p>
            <b>Powerful mappings.&nbsp;</b>
            
                You can distribute incoming XML requests to any object, depending on message payload, SOAP Action header, 
                or an XPath expression.
            
        </p>
        <p>
            <b>XML API support.&nbsp;</b>
            
                Incoming XML messages can be handled not only with standard JAXP APIs such as DOM, SAX, and StAX, but also JDOM, 
                dom4j, XOM, or even marshalling technologies.
            
        </p>
        <p>
            <b>Flexible XML Marshalling.&nbsp;</b>
            
                Spring Web Services builds on the Object/XML Mapping module in the Spring Framework, which supports JAXB 1 and 2, Castor,
                XMLBeans, JiBX, and XStream.
            
        </p>
        <p>
            <b>Reuses your Spring expertise.&nbsp;</b>
            
                Spring-WS uses Spring application contexts for all configuration, which should help Spring developers 
                get up-to-speed nice and quickly. Also, the architecture of Spring-WS resembles that of Spring-MVC.
            
        </p>
        <p>
            <b>Supports WS-Security.&nbsp;</b>
            
                WS-Security allows you to sign SOAP messages, encrypt and decrypt them, or authenticate against them.
            
        </p>
        <p>
            <b>Integrates with Spring Security.&nbsp;</b>
            
                The WS-Security implementation of Spring Web Services provides integration with Spring Security.
                This means you can use your existing Spring Security configuration for your SOAP service as well.
            
        </p>
        <p>
            <b>Apache license.&nbsp;</b>
            
                You can confidently use Spring-WS in your project.
            
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e65" href="#d5e65"></a>1.2&nbsp;Runtime environment</h2></div></div></div>
        
        <p>
            Spring Web Services requires a standard Java 7 Runtime Environment. Java 8 is also supported.
            Spring-WS is built on Spring Framework 4.0.9, but higher versions are supported.
        </p>
        <p>
            Spring-WS consists of a number of modules, which are described in the remainder of this section.
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <p>
                The XML module (<code class="filename">spring-xml.jar</code>) contains various XML support classes for Spring Web 
                Services. This module is mainly intended for the Spring-WS framework itself, and not a Web service 
                developers.
            </p>
            </li><li class="listitem">
                <p>
                    The Core module (<code class="filename">spring-ws-core.jar</code>) is the central part of the Spring's
                    Web services functionality.
                    It provides the central <a class="link" href="#web-service-messages" title="4.1&nbsp;Web service messages">
                    <code class="classname">WebServiceMessage</code></a> and <a class="link" href="#soap-message" title="4.1.2&nbsp;SoapMessage">
                    <code class="classname">SoapMessage</code></a> interfaces, the <a class="link" href="#server" title="5.&nbsp;Creating a Web service with Spring-WS">server-side</a> 
                    framework, with powerful message dispatching, and the various support classes for implementing Web
                    service endpoints; and the <a class="link" href="#client" title="6.&nbsp;Using Spring Web Services on the Client">client-side</a>
                    <code class="classname">WebServiceTemplate</code>.
                </p>
            </li><li class="listitem">
                <p>
                    The Support module (<code class="filename">spring-ws-support.jar</code>) contains additional transports
                    (JMS, Email, and others).
                </p>
            </li><li class="listitem">
                <p>
                    The <a class="link" href="#security" title="7.&nbsp;Securing your Web services with Spring-WS">Security</a> package (<code class="filename">spring-ws-security.jar</code>)
                    provides a WS-Security implementation that integrates
                    with the core Web service package. It allows you to add principal tokens, sign, and decrypt and encrypt SOAP
                    messages. Additionally, it allows you to leverage your existing Spring Security security implementation for
                    authentication and authorization.
                </p>
            </li></ul></div>
        <p>
            The following figure illustrates the Spring-WS modules and the dependencies between them. Arrows indicate 
            dependencies, i.e. Spring-WS Core depends on Spring-XML and the OXM module found in Spring 3 and higher.
            </p><div class="mediaobject" align="center"><img src="images/spring-deps.png" align="middle"><div class="caption">
                        <p>
                            Dependencies between Spring-WS modules
                        </p>
                    </div></div><p>
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e96" href="#d5e96"></a>1.3&nbsp;Supported standards</h2></div></div></div>
        
        <p>
            Spring Web Services supports the following standards:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>SOAP 1.1 and 1.2</p></li><li class="listitem"><p>WSDL 1.1 and 2.0 (XSD-based generation only supported for WSDL 1.1)</p></li><li class="listitem"><p>WS-I Basic Profile 1.0, 1.1, 1.2 and 2.0</p></li><li class="listitem"><p>WS-Addressing 1.0 and the August 2004 draft</p></li><li class="listitem"><p>SOAP Message Security 1.1, Username Token Profile 1.1, X.509 Certificate Token Profile 1.1, SAML Token Profile 1.1, Kerberos Token Profile 1.1, Basic Security Profile 1.1</p></li></ul></div>
    </div>
</div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="why-contract-first" href="#why-contract-first"></a>2.&nbsp;Why Contract First?</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e112" href="#d5e112"></a>2.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            When creating Web services, there are two development styles: <span class="emphasis"><em>Contract Last</em></span> and 
            <span class="emphasis"><em>Contract First</em></span>. When using a contract-last approach, you start with the Java code, and 
            let the Web service contract (<acronym class="acronym">WSDL</acronym>, see sidebar) be generated from that.
            When using contract-first, you start with the WSDL contract, and use Java to implement said contract.
        </p>
        <div class="sidebar"><div class="titlepage"><div><div><p class="title"><b>What is WSDL?</b></p></div></div></div>
            
            <p>
                WSDL stands for Web Services Description Language. A WSDL file is an XML document that describes a Web 
                service. It specifies the location of the service and the operations (or methods) the service exposes.
                For more information about WSDL, refer to the 
                <a class="ulink" href="http://www.w3.org/TR/wsdl" target="_top">WSDL specification</a>.
            </p>
        </div>
        <p> 
            Spring-WS only supports the contract-first development style, and this section explains why.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e123" href="#d5e123"></a>2.2&nbsp;Object/XML Impedance Mismatch</h2></div></div></div>
        
        <p>
            Similar to the field of ORM, where we have an 
            <a class="ulink" href="http://en.wikipedia.org/wiki/Object-Relational_impedance_mismatch" target="_top">Object/Relational impedance mismatch</a>,
            there is a similar problem when converting Java objects to XML.
            At first glance, the O/X mapping problem appears simple: create an XML element for each Java object, 
            converting all Java properties and fields to sub-elements or attributes. However, things are not as  
            simple as they appear: there is a fundamental difference between hierarchical languages such as XML 
            (and especially XSD) and the graph model of Java<a href="#ftn.d5e127" class="footnote" name="d5e127"><sup class="footnote">[1]</sup></a>.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e131" href="#d5e131"></a>2.2.1&nbsp;XSD extensions</h3></div></div></div>
            
            <p>
                In Java, the only way to change the behavior of a class is to subclass it, adding the new behavior to 
                that subclass. In XSD, you can extend a data type by restricting it: that is, constraining the valid values
                for the elements and attributes.
                For instance, consider the following example:</p><pre class="programlisting">
&lt;simpleType name="AirportCode"&gt;
  &lt;restriction base="string"&gt;
      &lt;pattern value="[A-Z][A-Z][A-Z]"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;</pre><p>
                This type restricts a XSD string by ways of a regular expression, allowing only three upper case 
                letters. If this type is converted to Java, we will end up with an ordinary 
                <code class="classname">java.lang.String</code>; the regular expression is lost in the conversion process, 
                because Java does not allow for these sorts of extensions.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e136" href="#d5e136"></a>2.2.2&nbsp;Unportable types</h3></div></div></div>
            
            <p>
                One of the most important goals of a Web service is to be interoperable: to support multiple platforms
                such as Java, .NET, Python, etc. Because all of these languages have different class libraries, you
                must use some common, interlingual format to communicate between them. That format is XML, which is
                supported by all of these languages.
            </p>
            <p>
                Because of this conversion, you must make sure that you use portable types in your service 
                implementation. Consider, for example, a service that returns a 
                <code class="classname">java.util.TreeMap</code>, like so:</p><pre class="programlisting">
public Map getFlights() {
  // use a tree map, to make sure it's sorted
  TreeMap map = new TreeMap();
  map.put("KL1117", "Stockholm");
  ...
  return map;
}</pre><p>
                Undoubtedly, the contents of this map can be converted into some sort of 
                XML, but since there is no <span class="emphasis"><em>standard</em></span> way to describe a map in XML, it will be 
                proprietary. Also, even if it can be converted to XML, many platforms do not have a data structure 
                similar to the <code class="classname">TreeMap</code>. So when a .NET client accesses your Web service, it
                will probably end up with a <code class="classname">System.Collections.Hashtable</code>, which has different 
                semantics.
            </p>
            <p>
                This problem is also present when working on the client side. Consider the following XSD snippet, which
                describes a service contract:</p><pre class="programlisting">
&lt;element name="GetFlightsRequest"&gt;
  &lt;complexType&gt;
    &lt;all&gt;
      &lt;element name="departureDate" type="date"/&gt;
      &lt;element name="from" type="string"/&gt;
      &lt;element name="to" type="string"/&gt;
    &lt;/all&gt;
  &lt;/complexType&gt;
&lt;/element&gt;</pre><p>
                This contract defines a request that takes an <span class="type">date</span>, which is a XSD datatype representing
                a year, month, and day. If we call this service from Java, we will probably use 
                either a <code class="classname">java.util.Date</code> or <code class="classname">java.util.Calendar</code>. However,
                both of these classes actually describe times, rather than dates. So, we will actually end up sending data that
                represents the fourth of April 2007 at midnight (<code class="literal">2007-04-04T00:00:00</code>), which is not
                the same as <code class="literal">2007-04-04</code>.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e152" href="#d5e152"></a>2.2.3&nbsp;Cyclic graphs</h3></div></div></div>
            
            <p>
                Imagine we have the following simple class structure:</p><pre class="programlisting">
public class Flight {
  private String number;
  private List&lt;Passenger&gt; passengers;
    
  // getters and setters omitted
}

public class Passenger {
  private String name;
  private Flight flight;
    
  // getters and setters omitted
}</pre><p>
                This is a cyclic graph: the <code class="classname">Flight</code> refers to the <code class="classname">Passenger</code>,
                which refers to the <code class="classname">Flight</code> again. Cyclic graphs like these are quite common in 
                Java. If we took a naive approach to converting this to XML, we will end up with something 
                like:</p><pre class="programlisting">
&lt;flight number="KL1117"&gt;
  &lt;passengers&gt;
    &lt;passenger&gt;
      &lt;name&gt;Arjen Poutsma&lt;/name&gt;
      &lt;flight number="KL1117"&gt;
        &lt;passengers&gt;
          &lt;passenger&gt;
            &lt;name&gt;Arjen Poutsma&lt;/name&gt;
            &lt;flight number="KL1117"&gt;
              &lt;passengers&gt;
                &lt;passenger&gt;
                   &lt;name&gt;Arjen Poutsma&lt;/name&gt;
                   ...</pre><p>
                which will take a pretty long time to finish, because there is no stop condition for this loop.
            </p>
            <p>
                One way to solve this problem is to use references to objects that were already marshalled, like 
                so:</p><pre class="programlisting">
&lt;flight number="KL1117"&gt;
  &lt;passengers&gt;
    &lt;passenger&gt;
      &lt;name&gt;Arjen Poutsma&lt;/name&gt;
      &lt;flight href="KL1117" /&gt;
    &lt;/passenger&gt;
    ...
  &lt;/passengers&gt;
&lt;/flight&gt;</pre><p>
                This solves the recursiveness problem, but introduces new ones. For one, you cannot use an XML validator
                to validate this structure. Another issue is that the standard way to use these references in SOAP 
                (RPC/encoded) has been deprecated in favor of document/literal (see WS-I
                <a class="ulink" href="http://www.ws-i.org/Profiles/BasicProfile-1.1.html#SOAP_encodingStyle_Attribute" target="_top">Basic
                Profile</a>).
            </p>
        </div>
        <p>
            These are just a few of the problems when dealing with O/X mapping. It is important to respect these issues
            when writing Web services. The best way to respect them is to focus on the XML completely, while using Java
            as an implementation language. This is what contract-first is all about.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e164" href="#d5e164"></a>2.3&nbsp;Contract-first versus Contract-last</h2></div></div></div>
        
        <p>
            Besides the Object/XML Mapping issues mentioned in the previous section, there are other reasons for 
            preferring a contract-first development style.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e167" href="#d5e167"></a>2.3.1&nbsp;Fragility</h3></div></div></div>
            
            <p>
                As mentioned earlier, the contract-last development style results in your web service contract 
                (WSDL and your XSD) being generated from your Java contract (usually an interface). If you are using 
                this approach, you will have no guarantee that the contract stays constant over time. Each time you 
                change your Java contract and redeploy it, there might be subsequent changes to the web service
                contract.
            </p>
            <p>
                Aditionally, not all SOAP stacks generate the same web service contract from a Java contract. This 
                means changing your current SOAP stack for a different one (for whatever reason), might also change
                your web service contract.
            </p>
            <p>
                When a web service contract changes, users of the contract will have to be instructed to obtain 
                the new contract and potentially change their code to accommodate for any changes in the contract.
            </p>
            <p>
                In order for a contract to be useful, it must remain constant for as long as possible. If a contract 
                changes, you will have to contact all of the users of your service, and instruct them to get the new 
                version of the contract.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e173" href="#d5e173"></a>2.3.2&nbsp;Performance</h3></div></div></div>
            
            <p>
                When Java is automatically transformed into XML, there is no way to be sure as to what is sent across 
                the wire. An object might reference another object, which refers to another, etc. In the end, half of 
                the objects on the heap in your virtual machine might be converted into XML,
                which will result in slow response times. 
            </p>
            <p>
                When using contract-first, you explicitly describe what XML is sent where, thus making sure that it is 
                exactly what you want.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e177" href="#d5e177"></a>2.3.3&nbsp;Reusability</h3></div></div></div>
            
            <p>
                Defining your schema in a separate file allows you to reuse that file in different scenarios. If you 
                define an <span class="type">AirportCode</span> in a file called <code class="filename">airline.xsd</code>, like so:                
            </p>
            <pre class="programlisting">
&lt;simpleType name="AirportCode"&gt;
    &lt;restriction base="string"&gt;
        &lt;pattern value="[A-Z][A-Z][A-Z]"/&gt;
    &lt;/restriction&gt;
&lt;/simpleType&gt;</pre>
            <p>
                You can reuse this definition in other schemas, or even WSDL files, using an
                <code class="literal">import</code> statement.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e185" href="#d5e185"></a>2.3.4&nbsp;Versioning</h3></div></div></div>
            
            <p>
                Even though a contract must remain constant for as long as possible, they <span class="emphasis"><em>do</em></span> need 
                to be changed sometimes. In Java, this typically results in a new Java interface, such as 
                <code class="interfacename">AirlineService2</code>, and a (new) implementation of that interface. Of 
                course, the old service must be kept around, because there might be clients who have not migrated 
                yet.
            </p>
            <p>
                If using contract-first, we can have a looser coupling between contract and implementation. Such a 
                looser coupling allows us to implement both versions of the contract in one class. We could, for 
                instance, use an XSLT stylesheet to convert any "old-style" messages to the "new-style" messages.
            </p>
        </div>
    </div>
<div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.d5e127" class="footnote">
            <p><a href="#d5e127" class="para"><sup class="para">[1] </sup></a>Most of the contents in this section was inspired by <a class="xref" href="#alpine" title="Rethinking the Java SOAP Stack">[alpine]</a> and 
            <a class="xref" href="#effective-enterprise-java" title="Effective Enterprise Java">[effective-enterprise-java]</a>.</p></div></div></div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial" href="#tutorial"></a>3.&nbsp;Writing Contract-First Web Services</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e193" href="#d5e193"></a>3.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            This tutorial shows you how to write
            <a class="link" href="#why-contract-first" title="2.&nbsp;Why Contract First?">contract-first Web services</a>, that is,
            developing web services that start with the XML Schema/WSDL contract first
            followed by the Java code second. Spring-WS focuses on this development style,
            and this tutorial will help you get started. Note that the first part of this
            tutorial contains almost no Spring-WS specific information: it is mostly about
            XML, XSD, and WSDL. The <a class="link" href="#tutorial-creating-project" title="3.5&nbsp;Creating the project">second part</a>
            focuses on implementing this contract using Spring-WS .
        </p>
        <p>
            The most important thing when doing contract-first Web service development is
            to try and think in terms of XML. This means that Java-language concepts are
            of lesser importance. It is the XML that is sent across the wire, and you
            should focus on that. The fact that Java is used to implement the Web service
            is an implementation detail. An important detail, but a detail nonetheless.
        </p>
        <p>
            In this tutorial, we will define a Web service that is created by a Human Resources
            department. Clients can send holiday request forms to this service to book a holiday.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e200" href="#d5e200"></a>3.2&nbsp;Messages</h2></div></div></div>
        
        <p>
            In this section, we will focus on the actual XML messages that are sent to
            and from the Web service. We will start out by determining what these messages
            look like.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e203" href="#d5e203"></a>3.2.1&nbsp;Holiday</h3></div></div></div>
            
            <p>
                In the scenario, we have to deal with holiday requests, so it makes sense
                to determine what a holiday looks like in XML:
            </p>
            <pre class="programlisting">
&lt;Holiday xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;StartDate&gt;2006-07-03&lt;/StartDate&gt;
    &lt;EndDate&gt;2006-07-07&lt;/EndDate&gt;
&lt;/Holiday&gt;</pre>
            <p>
                A holiday consists of a start date and an end date. We have also decided to
                use the standard
                <a class="ulink" href="http://www.cl.cam.ac.uk/~mgk25/iso-time.html" target="_top">ISO 8601</a>
                date format for the dates, because that will save a lot of parsing hassle.
                We have also added a namespace to the element, to make sure our elements
                can used within other XML documents.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e209" href="#d5e209"></a>3.2.2&nbsp;Employee</h3></div></div></div>
            
            <p>
                There is also the notion of an employee in the scenario. Here is what it
                looks like in XML:
            </p>
            <pre class="programlisting">
&lt;Employee xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;Number&gt;42&lt;/Number&gt;
    &lt;FirstName&gt;Arjen&lt;/FirstName&gt;
    &lt;LastName&gt;Poutsma&lt;/LastName&gt;
&lt;/Employee&gt;</pre>
            <p>
                We have used the same namespace as before. If this
                <code class="literal">&lt;Employee/&gt;</code> element could be used in other
                scenarios, it might make sense to use a different namespace, such as
                <code class="literal">http://mycompany.com/employees/schemas</code>.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e216" href="#d5e216"></a>3.2.3&nbsp;HolidayRequest</h3></div></div></div>
            
            <p>
                Both the holiday and employee element can be put in a
                <code class="literal">&lt;HolidayRequest/&gt;</code>:
            </p>
            <pre class="programlisting">
&lt;HolidayRequest xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;Holiday&gt;
        &lt;StartDate&gt;2006-07-03&lt;/StartDate&gt;
        &lt;EndDate&gt;2006-07-07&lt;/EndDate&gt;
    &lt;/Holiday&gt;
    &lt;Employee&gt;
        &lt;Number&gt;42&lt;/Number&gt;
        &lt;FirstName&gt;Arjen&lt;/FirstName&gt;
        &lt;LastName&gt;Poutsma&lt;/LastName&gt;
    &lt;/Employee&gt;
&lt;/HolidayRequest&gt;</pre>
            <p>
                The order of the two elements does not matter: <code class="literal">&lt;Employee/&gt;</code>
                could have been the first element just as well. What is important is
                that all of the data is there. In fact, the data is the only thing
                that is important: we are taking a <span class="emphasis"><em>data-driven</em></span>
                approach.
            </p>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial.xsd" href="#tutorial.xsd"></a>3.3&nbsp;Data Contract</h2></div></div></div>
        
        <p>
            Now that we have seen some examples of the XML data that we will use,
            it makes sense to formalize this into a schema. This data contract
            defines the message format we accept. There are four different ways
            of defining such a contract for XML:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>DTDs</p></li><li class="listitem"><p><a class="ulink" href="http://www.w3.org/XML/Schema" target="_top">XML Schema (XSD)</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.relaxng.org/" target="_top">RELAX NG</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.schematron.com/" target="_top">Schematron</a></p></li></ul></div>
        <p>
            DTDs have limited namespace support, so they are not suitable for Web
            services. Relax NG and Schematron certainly are easier than XML Schema.
            Unfortunately, they are not so widely supported across platforms. We
            will use XML Schema.
        </p>
        <p>
            By far the easiest way to create an XSD is to infer it from sample
            documents. Any good XML editor or Java IDE offers this functionality.
            Basically, these tools use some sample XML documents, and generate a
            schema from it that validates them all. The end result certainly needs
            to be polished up, but it's a great starting point.
        </p>
        <p>
            Using the sample described above, we end up with the following
            generated schema:
        </p>
        <pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"
        xmlns:hr="http://mycompany.com/hr/schemas"&gt;
    &lt;xs:element name="HolidayRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="hr:Holiday"/&gt;
                &lt;xs:element ref="hr:Employee"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="Holiday"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="hr:StartDate"/&gt;
                &lt;xs:element ref="hr:EndDate"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="StartDate" type="xs:NMTOKEN"/&gt;
    &lt;xs:element name="EndDate" type="xs:NMTOKEN"/&gt;
    &lt;xs:element name="Employee"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="hr:Number"/&gt;
                &lt;xs:element ref="hr:FirstName"/&gt;
                &lt;xs:element ref="hr:LastName"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="Number" type="xs:integer"/&gt;
    &lt;xs:element name="FirstName" type="xs:NCName"/&gt;
    &lt;xs:element name="LastName" type="xs:NCName"/&gt;
&lt;/xs:schema&gt;</pre>
        <p>
            This generated schema obviously can be improved. The first thing
            to notice is that every type has a root-level element declaration.
            This means that the Web service should be able to accept all of
            these elements as data. This is not desirable: we only want to
            accept a <code class="literal">&lt;HolidayRequest/&gt;</code>. By removing
            the wrapping element tags (thus keeping the types), and inlining
            the results, we can accomplish this.
        </p>
        <pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:hr="http://mycompany.com/hr/schemas"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"&gt;
    &lt;xs:element name="HolidayRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="Holiday" type="hr:HolidayType"/&gt;
                &lt;xs:element name="Employee" type="hr:EmployeeType"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:complexType name="HolidayType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="StartDate" type="xs:NMTOKEN"/&gt;
            &lt;xs:element name="EndDate" type="xs:NMTOKEN"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="EmployeeType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Number" type="xs:integer"/&gt;
            &lt;xs:element name="FirstName" type="xs:NCName"/&gt;
            &lt;xs:element name="LastName" type="xs:NCName"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre>
        <p>
            The schema still has one problem: with a schema like this, you
            can expect the following messages to validate:
        </p>
        <pre class="programlisting">
&lt;HolidayRequest xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;Holiday&gt;
        &lt;StartDate&gt;this is not a date&lt;/StartDate&gt;
        &lt;EndDate&gt;neither is this&lt;/EndDate&gt;
    &lt;/Holiday&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- ... --&gt;</span></em>
&lt;/HolidayRequest&gt;</pre>
        <p>
            Clearly, we must make sure that the start and end date are really dates.
            XML Schema has an excellent built-in <code class="literal">date</code> type which
            we can use. We also change the <code class="literal">NCName</code>s to
            <code class="literal">string</code>s. Finally, we change the <code class="literal">sequence</code> in
            <code class="literal">&lt;HolidayRequest/&gt;</code> to <code class="literal">all</code>.
            This tells the XML parser that the order of
            <code class="literal">&lt;Holiday/&gt;</code> and
            <code class="literal">&lt;Employee/&gt;</code> is not significant. Our final
            XSD now looks like this:
        </p>
        <div class="programlistingco"><pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:hr="http://mycompany.com/hr/schemas"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"&gt;
    &lt;xs:element name="HolidayRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:all&gt;
                &lt;xs:element name="Holiday" type="hr:HolidayType"/&gt;                                                     <span class="co" id="tutorial.xsd.all"><img src="images/callouts/1.png" alt="(1)"></span>
                &lt;xs:element name="Employee" type="hr:EmployeeType"/&gt;
            &lt;/xs:all&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:complexType name="HolidayType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="StartDate" type="xs:date"/&gt;
            &lt;xs:element name="EndDate" type="xs:date"/&gt;                                                                <span class="co" id="tutorial.xsd.dates.1"><img src="images/callouts/2.png" alt="(2)"></span>
        &lt;/xs:sequence&gt;                                                                                                 <span class="co" id="tutorial.xsd.dates.2"><img src="images/callouts/2.png" alt="(2)"></span>
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="EmployeeType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Number" type="xs:integer"/&gt;
            &lt;xs:element name="FirstName" type="xs:string"/&gt;
            &lt;xs:element name="LastName" type="xs:string"/&gt;                                                             <span class="co" id="tutorial.xsd.strings.1"><img src="images/callouts/3.png" alt="(3)"></span>
        &lt;/xs:sequence&gt;                                                                                                 <span class="co" id="tutorial.xsd.strings.2"><img src="images/callouts/3.png" alt="(3)"></span>
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        <code class="literal">all</code> tells the XML parser that the order of
                        <code class="literal">&lt;Holiday/&gt;</code> and
                        <code class="literal">&lt;Employee/&gt;</code> is not significant.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We use the <code class="literal">xsd:date</code> data type, which consist of a year, month, and day, for
                        <code class="literal">&lt;StartDate/&gt;</code> and <code class="literal">&lt;EndDate/&gt;</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        <code class="literal">xsd:string</code> is used for the first and last name.
                    </p>
                </td></tr></table></div></div>
        <p>
            We store this file as <code class="filename">hr.xsd</code>.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-service-contract" href="#tutorial-service-contract"></a>3.4&nbsp;Service contract</h2></div></div></div>
        
        <p>
            A service contract is generally expressed as a <a class="ulink" href="http://www.w3.org/TR/wsdl" target="_top">WSDL</a> file.
            Note that in Spring-WS, <span class="emphasis"><em>writing the WSDL by hand is not required</em></span>. Based on the XSD and
            some conventions, Spring-WS can create the WSDL for you, as explained in the section entitled
            <a class="xref" href="#tutorial.implementing.endpoint" title="3.6&nbsp;Implementing the Endpoint">Section&nbsp;3.6, &#8220;Implementing the Endpoint&#8221;</a>.
            You can skip to <a class="link" href="#tutorial-creating-project" title="3.5&nbsp;Creating the project">the next section</a> if you want to; the
            remainder of this section will show you how to write your own WSDL by hand.
         </p>
         <p>
            We start our WSDL with the standard preamble, and by importing our existing XSD. To
            separate the schema from the definition, we will use a separate namespace for the WSDL definitions:
            <code class="uri">http://mycompany.com/hr/definitions</code>.
        </p>
        <pre class="programlisting">&lt;wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  xmlns:schema="http://mycompany.com/hr/schemas"
                  xmlns:tns="http://mycompany.com/hr/definitions"
                  targetNamespace="http://mycompany.com/hr/definitions"&gt;
    &lt;wsdl:types&gt;
        &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
            &lt;xsd:import namespace="http://mycompany.com/hr/schemas" schemaLocation="hr.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;</pre>
        <p>
            Next, we add our messages based on the written schema types. We only have one message: one with the
            <code class="literal">&lt;HolidayRequest/&gt;</code> we put in the schema:
        </p>
        <pre class="programlisting">
    &lt;wsdl:message name="HolidayRequest"&gt;
        &lt;wsdl:part element="schema:HolidayRequest" name="HolidayRequest"/&gt;
    &lt;/wsdl:message&gt;</pre>
        <p>
            We add the message to a port type as an operation:
        </p>
        <pre class="programlisting">
    &lt;wsdl:portType name="HumanResource"&gt;
        &lt;wsdl:operation name="Holiday"&gt;
            &lt;wsdl:input message="tns:HolidayRequest" name="HolidayRequest"/&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;</pre>
        <p>
            That finished the abstract part of the WSDL (the interface, as it were), and leaves the concrete part.
            The concrete part consists of a <code class="literal">binding</code>, which tells the client <span class="emphasis"><em>how</em></span>
            to invoke the operations you've just defined; and a <code class="literal">service</code>, which tells it
            <span class="emphasis"><em>where</em></span> to invoke it.
        </p>
        <p>
            Adding a concrete part is pretty standard: just refer to the abstract part you defined previously, make sure
            you use <span class="emphasis"><em>document/literal</em></span> for the <code class="literal">soap:binding</code> elements
            (<code class="literal">rpc/encoded</code> is deprecated), pick a <code class="literal">soapAction</code> for the operation
            (in this case <code class="uri">http://mycompany.com/RequestHoliday</code>, but any URI will do), and determine the
            <code class="literal">location</code> URL where you want request to come in (in this case
            <code class="uri">http://mycompany.com/humanresources</code>):
        </p>
        <div class="programlistingco"><pre class="programlisting">
&lt;wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  xmlns:schema="http://mycompany.com/hr/schemas"
                  xmlns:tns="http://mycompany.com/hr/definitions"
                  targetNamespace="http://mycompany.com/hr/definitions"&gt;
    &lt;wsdl:types&gt;
        &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
            &lt;xsd:import namespace="http://mycompany.com/hr/schemas"                                                    <span class="co" id="tutorial.wsdl.import"><img src="images/callouts/1.png" alt="(1)"></span>
                schemaLocation="hr.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;
    &lt;wsdl:message name="HolidayRequest"&gt;                                                                               <span class="co" id="tutorial.wsdl.message.def"><img src="images/callouts/2.png" alt="(2)"></span>
        &lt;wsdl:part element="schema:HolidayRequest" name="HolidayRequest"/&gt;                                             <span class="co" id="tutorial.wsdl.message.part"><img src="images/callouts/3.png" alt="(3)"></span>
    &lt;/wsdl:message&gt;
    &lt;wsdl:portType name="HumanResource"&gt;                                                                               <span class="co" id="tutorial.wsdl.portType.def"><img src="images/callouts/4.png" alt="(4)"></span>
        &lt;wsdl:operation name="Holiday"&gt;
            &lt;wsdl:input message="tns:HolidayRequest" name="HolidayRequest"/&gt;                                           <span class="co" id="tutorial.wsdl.message.ref"><img src="images/callouts/2.png" alt="(2)"></span>
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;
    &lt;wsdl:binding name="HumanResourceBinding" type="tns:HumanResource"&gt;                                                <span class="co" id="tutorial.wsdl.portType.ref"><img src="images/callouts/4.png" alt="(4)"></span><span class="co" id="tutorial.wsdl.binding.def"><img src="images/callouts/5.png" alt="(5)"></span>
        &lt;soap:binding style="document"                                                                                 <span class="co" id="tutorial.wsdl.doclit.doc"><img src="images/callouts/6.png" alt="(6)"></span>
            transport="http://schemas.xmlsoap.org/soap/http"/&gt;                                                         <span class="co" id="tutorial.wsdl.transport"><img src="images/callouts/7.png" alt="(7)"></span>
        &lt;wsdl:operation name="Holiday"&gt;
            &lt;soap:operation soapAction="http://mycompany.com/RequestHoliday"/&gt;                                         <span class="co" id="tutorial.wsdl.soapAction"><img src="images/callouts/8.png" alt="(8)"></span>
            &lt;wsdl:input name="HolidayRequest"&gt;
                &lt;soap:body use="literal"/&gt;                                                                             <span class="co" id="tutorial.wsdl.doclit.lit"><img src="images/callouts/6.png" alt="(6)"></span>
            &lt;/wsdl:input&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:binding&gt;
    &lt;wsdl:service name="HumanResourceService"&gt;
        &lt;wsdl:port binding="tns:HumanResourceBinding" name="HumanResourcePort"&gt;                                        <span class="co" id="tutorial.wsdl.binding.ref"><img src="images/callouts/5.png" alt="(5)"></span>
            &lt;soap:address location="http://localhost:8080/holidayService/"/&gt;                                           <span class="co" id="tutorial.wsdl.address"><img src="images/callouts/9.png" alt="(9)"></span>
        &lt;/wsdl:port&gt;
    &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We import the schema defined in <a class="xref" href="#tutorial.xsd" title="3.3&nbsp;Data Contract">Section&nbsp;3.3, &#8220;Data Contract&#8221;</a>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the <code class="literal">HolidayRequest</code> message, which gets used in the
                        <code class="literal">portType</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="literal">HolidayRequest</code> type is defined in the schema.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the <code class="literal">HumanResource</code> port type, which gets used in the
                        <code class="literal">binding</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the <code class="literal">HumanResourceBinding</code> binding, which gets used in the
                        <code class="literal">port</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/6.png" alt="6" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We use a document/literal style.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/7.png" alt="7" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The literal <code class="uri">http://schemas.xmlsoap.org/soap/http</code> signifies a
                        HTTP transport.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/8.png" alt="8" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="literal">soapAction</code> attribute signifies the <code class="literal">SOAPAction</code> HTTP
                        header that will be sent with every request.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/9.png" alt="9" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="uri">http://localhost:8080/holidayService/</code> address is the URL where the Web
                        service can be invoked.
                    </p>
                </td></tr></table></div></div>
        <p>
            This is the final WSDL. We will describe how to implement the resulting schema and WSDL in the next section.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-creating-project" href="#tutorial-creating-project"></a>3.5&nbsp;Creating the project</h2></div></div></div>
        
        <p>
            In this section, we will be using <a class="ulink" href="http://maven.apache.org/" target="_top">Maven3</a> to create the
            initial project structure for us. Doing so is not required, but greatly reduces the amount of code we
            have to write to setup our HolidayService.
        </p>
        <p>
            The following command creates a Maven3 web application project for us, using the Spring-WS archetype
            (that is, project template)
        </p>
<pre class="screen">mvn archetype:create -DarchetypeGroupId=org.springframework.ws \
  -DarchetypeArtifactId=spring-ws-archetype \
  -DarchetypeVersion= \
  -DgroupId=com.mycompany.hr \
  -DartifactId=holidayService
</pre>
        <p>
            This command will create a new directory called <code class="filename">holidayService</code>. In this directory,
            there is a <code class="filename">'src/main/webapp'</code> directory, which will contain the root of the WAR file.
            You will find the standard web application deployment descriptor <code class="filename">'WEB-INF/web.xml'</code>
            here, which defines a Spring-WS <code class="classname">MessageDispatcherServlet</code> and maps all incoming
            requests to this servlet.
        </p>
        <pre class="programlisting">
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
             http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         version="2.4"&gt;

    &lt;display-name&gt;MyCompany HR Holiday Service&lt;/display-name&gt;

    <em class="lineannotation"><span class="lineannotation">&lt;!-- take especial notice of the name of this servlet --&gt;</span></em>
    &lt;servlet&gt;
        &lt;servlet-name&gt;<em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>spring-ws</strong></span></span></em>&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.ws.transport.http.MessageDispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre>
        <p>
            In addition to the above <code class="filename">'WEB-INF/web.xml'</code> file, you will also need another,
            Spring-WS-specific configuration file, named <code class="filename">'WEB-INF/spring-ws-servlet.xml'</code>.
            This file contains all of the Spring-WS-specific beans such as <code class="literal">EndPoints</code>,
            <code class="literal">WebServiceMessageReceivers</code>, and suchlike, and is used to create a new Spring container.
            The name of this file is derived from the name of the attendant servlet (in this case
            <code class="literal">'spring-ws'</code>) with <code class="literal">'-servlet.xml'</code> appended to it.
            So if you defined a <code class="classname">MessageDispatcherServlet</code> with the name
            <code class="literal">'dynamite'</code>, the name of the Spring-WS-specific configuration file would be
            <code class="filename">'WEB-INF/dynamite-servlet.xml'</code>.
        </p>
        <p>
            (You can see the contents of the <code class="filename">'WEB-INF/spring-ws-servlet.xml'</code> file for this
            example in <a class="xref" href="#tutorial.example.sws-conf-file">???</a>.)
        </p>
        <p>
            Once you had the project structure created, you can put the schema and wsdl from previous section into
            <code class="filename">'WEB-INF/'</code> folder.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial.implementing.endpoint" href="#tutorial.implementing.endpoint"></a>3.6&nbsp;Implementing the Endpoint</h2></div></div></div>
        
        <p>
           In Spring-WS, you will implement <span class="emphasis"><em>Endpoints</em></span> to handle incoming XML messages.
           An endpoint is typically created by annotating a class with the <code class="interfacename">@Endpoint</code>
           annotation.
           In this endpoint class, you will create one or more methods that handle incoming request.
           The method signatures can be quite flexible: you can include just about any sort of parameter type related
           to the incoming XML message, as will be explained later.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e399" href="#d5e399"></a>3.6.1&nbsp;Handling the XML Message</h3></div></div></div>
            
            <p>
                In this sample application, we are going to use <a class="ulink" href="http://www.jdom.org" target="_top">JDom 2</a> to handle
                the XML message.
                We are also using <a class="ulink" href="https://www.w3.org/TR/xpath20/" target="_top">XPath</a>, because it allows us to
                select particular parts of the XML JDOM tree, without requiring strict schema conformance.
            </p>
            <div class="programlistingco"><pre class="programlisting">package com.mycompany.hr.ws;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;

import com.mycompany.hr.service.HumanResourceService;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.filter.Filters;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;

@Endpoint                                                                                                              <span class="co" id="tutorial.endpoint.atEndpoint"><img src="images/callouts/1.png" alt="(1)"></span>
public class HolidayEndpoint {

    private static final String NAMESPACE_URI = "http://mycompany.com/hr/schemas";

    private XPathExpression&lt;Element&gt; startDateExpression;

    private XPathExpression&lt;Element&gt; endDateExpression;

    private XPathExpression&lt;Element&gt; firstNameExpression;

    private XPathExpression&lt;Element&gt; lastNameExpression;

    private HumanResourceService humanResourceService;
                                                                                                                       <span class="co" id="tutorial.endpoint.constr"><img src="images/callouts/2.png" alt="(2)"></span>
    @Autowired
    public HolidayEndpoint(HumanResourceService humanResourceService) throws JDOMException {
        this.humanResourceService = humanResourceService;

        Namespace namespace = Namespace.getNamespace("hr", NAMESPACE_URI);
        XPathFactory xPathFactory = XPathFactory.instance();
        startDateExpression = xPathFactory.compile("//hr:StartDate", Filters.element(), null, namespace);
        endDateExpression = xPathFactory.compile("//hr:EndDate", Filters.element(), null, namespace);
        firstNameExpression = xPathFactory.compile("//hr:FirstName", Filters.element(), null, namespace);
        lastNameExpression = xPathFactory.compile("//hr:LastName", Filters.element(), null, namespace);
    }

    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "HolidayRequest")                                              <span class="co" id="tutorial.endpoint.payloadRoot"><img src="images/callouts/3.png" alt="(3)"></span>
    public void handleHolidayRequest(@RequestPayload Element holidayRequest) throws Exception {                        <span class="co" id="tutorial.endpoint.method"><img src="images/callouts/4.png" alt="(4)"></span>
        Date startDate = parseDate(startDateExpression, holidayRequest);
        Date endDate = parseDate(endDateExpression, holidayRequest);
        String name = firstNameExpression.evaluateFirst(holidayRequest).getText() + " " + lastNameExpression.evaluateFirst(holidayRequest).getText();

        humanResourceService.bookHoliday(startDate, endDate, name);
    }

    private Date parseDate(XPathExpression&lt;Element&gt; expression, Element element) throws ParseException {
        Element result = expression.evaluateFirst(element);
        if (result != null) {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            return dateFormat.parse(result.getText());
        } else {
            throw new IllegalArgumentException("Could not evaluate [" + expression + "] on [" + element + "]");
        }
    }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">HolidayEndpoint</code> is annotated with
                            <code class="interfacename">@Endpoint</code>.
                            This marks the class as a special sort of <code class="interfacename">@Component</code>,
                            suitable for handling XML messages in Spring-WS, and also making it eligible for suitable
                            for component scanning.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">HolidayEndpoint</code> requires the
                            <code class="interfacename">HumanResourceService</code> business service to operate, so we
                            inject the dependency via the constructor and annotate it with
                            <code class="interfacename">@Autowired</code>.
                        </p>
                        <p>
                            Next, we set up XPath expressions using the JDOM2 API.
                            There are four expressions: <code class="literal">//hr:StartDate</code> for
                            extracting the <code class="literal">&lt;StartDate&gt;</code> text value,
                            <code class="literal">//hr:EndDate</code> for
                            extracting the end date and two for extracting the names of
                            the employee.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="interfacename">@PayloadRoot</code> annotation tells Spring-WS that the
                            <code class="methodname">handleHolidayRequest</code> method is suitable for handling XML messages.
                            The sort of message that this method can handle is indicated by the annotation values,
                            in this case, it can handle XML elements that have the <code class="literal">HolidayRequest</code>
                            local part and the <code class="literal">http://mycompany.com/hr/schemas</code> namespace.
                        </p>
                        <p>
                            More information about mapping messages to endpoints is provided in the next section.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="methodname">handleHolidayRequest(..)</code> method is the main handling method
                            method, which gets passed with the <code class="literal">&lt;HolidayRequest/&gt;</code> element from
                            the incoming XML message.
                            The <code class="interfacename">@RequestPayload</code> annotation indicates that the
                            <em class="parameter"><code>holidayRequest</code></em> parameter should be mapped to the payload of the
                            request message.
                        </p>
                        <p>
                            We use the XPath expressions to extract the string values from the XML messages,
                            and convert these values to <code class="classname">Date</code> objects using a
                            <code class="classname">SimpleDateFormat</code> (the <code class="methodname">parseData</code> method).
                        </p>
                        <p>
                            With these values, we invoke a method on the business service.
                            Typically, this will result in a database transaction being started, and some records being
                            altered in the database.
                        </p>
                        <p>
                            Finally, we define a <code class="literal">void</code> return type, which indicates to Spring-WS
                            that we do not want to send a response message.
                            If we wanted a response message, we could have returned a JDOM Element
                            that represents the payload of the response message.
                        </p>
                    </td></tr></table></div></div>
            <p>
                 Using JDOM is just one of the options to handle the XML: other options include DOM, dom4j, XOM,
                 SAX, and StAX, but also marshalling techniques like JAXB, Castor, XMLBeans,
                 JiBX, and XStream, as is explained in the next chapter.
                 We chose JDOM because it gives us access to the raw XML, and because it
                 is based on classes (not interfaces and factory methods as with W3C DOM and dom4j), which makes the
                 code less verbose. We use XPath because it is less fragile than marshalling technologies: we don't
                 care for strict schema conformance, as long as we can find the dates and the name.
             </p>
             <p>
                 Because we use JDOM, we must add some dependencies to the Maven <code class="filename">pom.xml</code>, which is in the
                 root of our project directory. Here is the relevant section of the POM:
             </p>
             <pre class="programlisting">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.ws&lt;/groupId&gt;
        &lt;artifactId&gt;spring-ws-core&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jdom&lt;/groupId&gt;
        &lt;artifactId&gt;jdom&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jaxen&lt;/groupId&gt;
        &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>
             <p>
                Here is how we would configure these classes in our <code class="filename">spring-ws-servlet.xml</code>
                Spring XML configuration file, by using component scanning.
                We also instruct Spring-WS to use annotation-driven endpoints, with the
                <code class="literal">&lt;sws:annotation-driven&gt;</code> element.
            </p>
            <a name="tutorial.example.sws-conf-file" href="#tutorial.example.sws-conf-file"></a><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:sws="http://www.springframework.org/schema/web-services"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/web-services http://www.springframework.org/schema/web-services/web-services-2.0.xsd
  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

  &lt;context:component-scan base-package="com.mycompany.hr"/&gt;

  &lt;sws:annotation-driven/&gt;

&lt;/beans&gt;</pre>
            </div>
            <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e454" href="#d5e454"></a>3.6.2&nbsp;Routing the Message to the Endpoint</h3></div></div></div>
                
                <p>
                    As part of writing the endpoint, we also used the <code class="interfacename">@PayloadRoot</code>
                    annotation to indicate which sort of messages can be handled by the
                    <code class="methodname">handleHolidayRequest</code> method.
                    In Spring-WS, this process is the responsibility of an
                    <code class="interfacename">EndpointMapping</code>.
                    Here we route messages based on
                    their content, by using a <code class="classname">PayloadRootAnnotationMethodEndpointMapping</code>.
                    The annotation used above:</p><pre class="programlisting">
@PayloadRoot(namespace = "http://mycompany.com/hr/schemas", localPart = "HolidayRequest")</pre><p>
                    basically means that whenever an XML message is received with the namespace
                    <code class="literal">http://mycompany.com/hr/schemas</code> and the
                    <code class="literal">HolidayRequest</code> local name, it will be routed to the
                    <code class="methodname">handleHolidayRequest</code> method.
                    By using the <code class="literal">&lt;sws:annotation-driven&gt;</code> element in our configuration, we
                    enable the detection of the <code class="interfacename">@PayloadRoot</code> annotations.
                    It is possible (and quite common) to have multiple, related handling methods in an endpoint, each
                    of them handling different XML messages.
                </p>
                <p>
                    There are also other ways to map endpoints to XML messages, which will be described in the next
                    chapter.
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e468" href="#d5e468"></a>3.6.3&nbsp;Providing the Service and Stub implementation</h3></div></div></div>
                
                <p>
                    Now that we have the <span class="emphasis"><em>Endpoint</em></span>, we need 
                    <code class="interfacename">HumanResourceService</code> and its implementation for use by 
                    <code class="classname">HolidayEndpoint</code>.
                </p>
                <pre class="programlisting">package com.mycompany.hr.service;

import java.util.Date;

public interface HumanResourceService {
    void bookHoliday(Date startDate, Date endDate, String name);
}</pre>
                <p>
                    For tutorial purposes, we will use a simple stub implementation of the 
                    <code class="interfacename">HumanResourceService</code>.
                </p>
                <div class="programlistingco"><pre class="programlisting">package com.mycompany.hr.service;

import java.util.Date;

import org.springframework.stereotype.Service;

@Service                                                                                                               <span class="co" id="tutorial.stubimpl.atService"><img src="images/callouts/1.png" alt="(1)"></span>
public class StubHumanResourceService implements HumanResourceService {
    public void bookHoliday(Date startDate, Date endDate, String name) {
        System.out.println("Booking holiday for [" + startDate + "-" + endDate + "] for [" + name + "] ");
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">StubHumanResourceService</code> is annotated with
                            <code class="interfacename">@Service</code>.
                            This marks the class as a business facade, which makes this a candidate for injection 
                            by <code class="interfacename">@Autowired</code> in <code class="classname">HolidayEndpoint</code>.
                        </p>
                    </td></tr></table></div></div>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-publishing-wsdl" href="#tutorial-publishing-wsdl"></a>3.7&nbsp;Publishing the WSDL</h2></div></div></div>
        
        <p>
            Finally, we need to publish the WSDL. As stated in <a class="xref" href="#tutorial-service-contract" title="3.4&nbsp;Service contract">Section&nbsp;3.4, &#8220;Service contract&#8221;</a>, we don't
            need to write a WSDL ourselves; Spring-WS can generate one for us based on some conventions.
            Here is how we define the generation:
        </p>
        <div class="programlistingco"><pre class="programlisting">&lt;sws:dynamic-wsdl id="holiday"                                                                                         <span class="co" id="tutorial.wsdl.gen.bean"><img src="images/callouts/1.png" alt="(1)"></span>
    portTypeName="HumanResource"                                                                                       <span class="co" id="tutorial.wsdl.gen.portType"><img src="images/callouts/3.png" alt="(3)"></span>
    locationUri="/holidayService/"                                                                                     <span class="co" id="tutorial.wsdl.gen.locationUri"><img src="images/callouts/4.png" alt="(4)"></span>
    targetNamespace="http://mycompany.com/hr/definitions"&gt;                                                             <span class="co" id="tutorial.wsdl.gen.tns"><img src="images/callouts/5.png" alt="(5)"></span>
  &lt;sws:xsd location="/WEB-INF/hr.xsd"/&gt;                                                                                <span class="co" id="tutorial.wsdl.gen.schema"><img src="images/callouts/2.png" alt="(2)"></span>
&lt;/sws:dynamic-wsdl&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The id determines the URL where the WSDL can be retrieved.
                        In this case, the id is <code class="varname">holiday</code>, which means that the WSDL can be retrieved
                        as <code class="filename">holiday.wsdl</code> in the servlet context.
                        The full URL will typically be <code class="uri">http://localhost:8080/holidayService/holiday.wsdl</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        Next, we set the WSDL port type to be <code class="literal">HumanResource</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We set the location where the service can be reached:
                        <code class="uri">/holidayService/</code>.
                        We use a relative URI and we instruct the framework to transform it
                        dynamically to an absolute URI.
                        Hence, if the service is deployed to different contexts we don't have
                        to change the URI manually.
                        For more information, please refer to <a class="xref" href="#server-automatic-wsdl-exposure" title="Automatic WSDL exposure">the section called &#8220;Automatic WSDL exposure&#8221;</a>
                    </p>
                    <p>
                        For the location transformation to work, we need to add an init parameter to <code class="classname">spring-ws</code>
                        servlet in <code class="filename">web.xml</code>:</p><pre class="programlisting">&lt;init-param&gt;
  &lt;param-name&gt;transformWsdlLocations&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/init-param&gt;</pre><p>
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the target namespace for the WSDL definition itself.
                        Setting this attribute is not required.
                        If not set, the WSDL will have the same namespace as the XSD schema.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="varname">xsd</code> element refers to the human resource schema we defined in
                        <a class="xref" href="#tutorial.xsd" title="3.3&nbsp;Data Contract">Section&nbsp;3.3, &#8220;Data Contract&#8221;</a>.
                        We simply placed the schema in the <code class="filename">WEB-INF</code> directory of the application.
                    </p>
                </td></tr></table></div></div>
        <p>
            You can create a WAR file using <span class="command"><strong>mvn install</strong></span>.
            If you deploy the application (to Tomcat, Jetty, etc.), and point your browser at
            <a class="ulink" href="http://localhost:8080/holidayService/holiday.wsdl" target="_top">this location</a>, you will
            see the generated WSDL. This WSDL is ready to be used by clients, such as
            <a class="ulink" href="http://www.soapui.org/" target="_top">soapUI</a>, or other SOAP frameworks.
        </p>
    </div>
    <p>
        That concludes this tutorial. The tutorial code can be found in the full distribution of Spring-WS.
        The next step would be to look at the echo sample application that is part
        of the distribution. After that, look at the airline sample, which is a bit more complicated, because it
        uses JAXB, WS-Security, Hibernate, and a transactional service layer.
        Finally, you can read the rest of the reference documentation.
    </p>
</div>
    </div>
    <div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="d5e529" href="#d5e529"></a>Part&nbsp;II.&nbsp;Reference</h1></div></div></div>
        
        <div class="partintro"><div></div>
            <p>
                This part of the reference documentation details the various components
                that comprise Spring Web Services. This includes
                <a class="link" href="#common" title="4.&nbsp;Shared components">a chapter</a> that discusses the parts common
                to both client- and server-side WS, a chapter devoted to the specifics
                of <a class="link" href="#server" title="5.&nbsp;Creating a Web service with Spring-WS">writing server-side Web services</a>,
                a chapter about using Web services on
                <a class="link" href="#client" title="6.&nbsp;Using Spring Web Services on the Client">the client-side</a>, and a chapters on using
                <a class="link" href="#security" title="7.&nbsp;Securing your Web services with Spring-WS">WS-Security</a>.
            </p>
        </div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="common" href="#common"></a>4.&nbsp;Shared components</h2></div></div></div>
    
    <p>
        In this chapter, we will explore the components which are shared between client- and server-side
        Spring-WS development. These interfaces and classes represent the building blocks of Spring-WS, so
        it is important to understand what they do, even if you do not use them directly.
    </p>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-service-messages" href="#web-service-messages"></a>4.1&nbsp;Web service messages</h2></div></div></div>
        
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="web-service-message" href="#web-service-message"></a>4.1.1&nbsp;<code class="interfacename">WebServiceMessage</code></h3></div></div></div>
            
            <p>
                One of the core interfaces of Spring Web Services is the <code class="interfacename">WebServiceMessage</code>.
                This interface represents a protocol-agnostic XML message. The interface contains methods that provide
                access to the payload of the message, in the form of a
                <code class="interfacename">javax.xml.transform.Source</code> or a
                <code class="interfacename">javax.xml.transform.Result</code>. <code class="interfacename">Source</code> and
                <code class="interfacename">Result</code> are tagging interfaces that represent an abstraction over XML
                input and output. Concrete implementations wrap various XML representations, as indicated in the
                following table.
                </p><div class="informaltable">
                    <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Source/Result implementation</th><th style="border-bottom: 0.5pt solid ; ">Wraps XML representation</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.xml.transform.dom.DOMSource</code></td><td style="border-bottom: 0.5pt solid ; "><code class="interfacename">org.w3c.dom.Node</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.xml.transform.dom.DOMResult</code></td><td style="border-bottom: 0.5pt solid ; "><code class="interfacename">org.w3c.dom.Node</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.xml.transform.sax.SAXSource</code></td><td style="border-bottom: 0.5pt solid ; "><code class="classname">org.xml.sax.InputSource</code> and
                                    <code class="interfacename">org.xml.sax.XMLReader</code>
                                </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.xml.transform.sax.SAXResult</code></td><td style="border-bottom: 0.5pt solid ; "><code class="interfacename">org.xml.sax.ContentHandler</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.xml.transform.stream.StreamSource</code></td><td style="border-bottom: 0.5pt solid ; ">
                                    <code class="classname">java.io.File</code>, <code class="classname">java.io.InputStream</code>, or
                                    <code class="classname">java.io.Reader</code>
                                </td></tr><tr><td style="border-right: 0.5pt solid ; ">
                                    <code class="classname">javax.xml.transform.stream.StreamResult</code>
                                </td><td style="">
                                    <code class="classname">java.io.File</code>, <code class="classname">java.io.OutputStream</code>, or
                                    <code class="classname">java.io.Writer</code>
                                </td></tr></tbody></table>
                </div><p>
                In addition to reading from and writing to the payload, a Web service message can write itself to an
                output stream.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="soap-message" href="#soap-message"></a>4.1.2&nbsp;<code class="interfacename">SoapMessage</code></h3></div></div></div>
            
            <p>
                The <code class="interfacename">SoapMessage</code> is a subclass of
                <code class="interfacename">WebServiceMessage</code>. It contains SOAP-specific methods, such as getting
                SOAP Headers, SOAP Faults, etc.
                Generally, your code should not be dependent on <code class="interfacename">SoapMessage</code>, because
                the content of the SOAP Body (the payload of the message) can be obtained via
                <code class="methodname">getPayloadSource()</code> and <code class="methodname">getPayloadResult()</code> in the
                <code class="interfacename">WebServiceMessage</code>.
                Only when it is necessary to perform SOAP-specific actions, such as adding a header, getting an
                attachment, etc., should you need to cast <code class="interfacename">WebServiceMessage</code> to
                <code class="interfacename">SoapMessage</code>.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-factories" href="#message-factories"></a>4.1.3&nbsp;Message Factories</h3></div></div></div>
            
            <p>
                Concrete message implementations are created by a <code class="interfacename">WebServiceMessageFactory</code>.
                This factory can create an empty message, or read a message based on an input stream. There are two
                concrete implementations of <code class="interfacename">WebServiceMessageFactory</code>; one is based on
                SAAJ, the SOAP with Attachments API for Java, the other based on Axis 2's AXIOM, the AXis Object Model.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e610" href="#d5e610"></a><code class="classname">SaajSoapMessageFactory</code></h4></div></div></div>
                
                <p>
                    The <code class="classname">SaajSoapMessageFactory</code> uses the SOAP with Attachments API for Java to
                    create <code class="classname">SoapMessage</code> implementations. <acronym class="acronym">SAAJ</acronym> is part of
                    <acronym class="acronym">J2EE</acronym> 1.4, so it should be supported under most modern application servers.
                    Here is an overview of the <acronym class="acronym">SAAJ</acronym> versions supplied
                    by common application servers:
                    </p><div class="informaltable">
                        <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Application Server</th><th style="border-bottom: 0.5pt solid ; "><acronym class="acronym">SAAJ</acronym> Version</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">BEA WebLogic 8</td><td style="border-bottom: 0.5pt solid ; ">1.1</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">BEA WebLogic 9</td><td style="border-bottom: 0.5pt solid ; ">1.1/1.2<a href="#ftn.d5e633" class="footnote" name="d5e633"><sup class="footnote">[1]</sup></a></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">IBM WebSphere 6</td><td style="border-bottom: 0.5pt solid ; ">1.2</td></tr><tr><td style="border-right: 0.5pt solid ; ">SUN Glassfish 1</td><td style="">1.3</td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.d5e633" class="footnote">
                                        <p><a href="#d5e633" class="para"><sup class="para">[1] </sup></a>
                                            Weblogic 9 has a known bug in the <acronym class="acronym">SAAJ</acronym> 1.2
                                            implementation: it implement all the 1.2 interfaces, but throws a
                                            <code class="classname">UnsupportedOperationException</code> when called.
                                            Spring Web Services has a workaround: it uses <acronym class="acronym">SAAJ</acronym> 1.1
                                            when operating on WebLogic 9.
                                        </p>
                                    </div></td></tr></tbody></table>
                    </div><p>
                    Additionally, Java SE 6 includes <acronym class="acronym">SAAJ</acronym> 1.3.
                    You wire up a
                    <code class="classname">SaajSoapMessageFactory</code> like so:
                </p><pre class="programlisting">&lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory" /&gt;</pre><p>
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                    <p>
                        <acronym class="acronym">SAAJ</acronym> is based on DOM, the Document Object Model. This means that all SOAP messages are
                        stored <span class="emphasis"><em>in memory</em></span>. For larger SOAP messages, this may not be very performant.
                        In that case, the <code class="classname">AxiomSoapMessageFactory</code> might be more applicable.
                    </p>
                </td></tr></table></div>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e652" href="#d5e652"></a><code class="classname">AxiomSoapMessageFactory</code></h4></div></div></div>
                
                <p>
                    The <code class="classname">AxiomSoapMessageFactory</code> uses the AXis 2 Object Model to create
                    <code class="interfacename">SoapMessage</code> implementations. <acronym class="acronym">AXIOM</acronym> is based on
                    <acronym class="acronym">StAX</acronym>, the Streaming API for XML. StAX provides a pull-based mechanism for
                    reading XML messages, which can be more efficient for larger messages.
                </p>
                <p>
                    To increase reading performance on the <code class="classname">AxiomSoapMessageFactory</code>,
                    you can set the <span class="property">payloadCaching</span> property to false (default is true).
                    This will read the contents of the SOAP body directly from the socket stream.
                    When this setting is enabled, the payload can only be read once.
                    This means that you have to make sure that any pre-processing (logging etc.) of the message does
                    not consume it.
                </p>
                <p>
                    You use the <code class="classname">AxiomSoapMessageFactory</code> as follows:
                    </p><pre class="programlisting">
&lt;bean id="messageFactory" class="org.springframework.ws.soap.axiom.AxiomSoapMessageFactory"&gt;
    &lt;property name="payloadCaching" value="true"/&gt;
&lt;/bean&gt;</pre><p>
                </p>
                <p>
                    In addition to payload caching, <acronym class="acronym">AXIOM</acronym> also supports full streaming messages,
                    as defined in the <code class="interfacename">StreamingWebServiceMessage</code>.
                    This means that the payload can be directly set on the response message, rather than being written
                    to a DOM tree or buffer.
                </p>
                <p>
                    Full streaming for <acronym class="acronym">AXIOM</acronym> is used when a handler method returns a
                    <acronym class="acronym">JAXB2</acronym>-supported object.
                    It will automatically set this marshalled object into the response message, and write it out to
                    the outgoing socket stream when the response is going out.
                </p>
                <p>
                    For more information about full streaming, refer to the class-level Javadoc for
                    <code class="interfacename">StreamingWebServiceMessage</code> and
                    <code class="interfacename">StreamingPayload</code>.
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="soap_11_or_12" href="#soap_11_or_12"></a><acronym class="acronym">SOAP</acronym> 1.1 or 1.2</h4></div></div></div>
                
                <p>
                    Both the <code class="classname">SaajSoapMessageFactory</code> and the
                    <code class="classname">AxiomSoapMessageFactory</code> have a <span class="property">soapVersion</span> property,
                    where you can inject a <code class="interfacename">SoapVersion</code> constant. By default, the version
                    is 1.1, but you can set it to 1.2 like so:
                </p>
                <pre class="programlisting">
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/util
       http://www.springframework.org/schema/util/spring-util-2.0.xsd"&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"&gt;
        &lt;property name="soapVersion"&gt;
            &lt;util:constant static-field="org.springframework.ws.soap.SoapVersion.SOAP_12"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
                <p>
                    In the example above, we define a <code class="classname">SaajSoapMessageFactory</code> that only accepts
                    <acronym class="acronym">SOAP</acronym> 1.2 messages.
                </p>
                <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
                    <p>
                        Even though both versions of <acronym class="acronym">SOAP</acronym> are quite similar in format, the 1.2
                        version is not backwards compatible with 1.1 because it uses a different XML namespace.
                        Other major differences between <acronym class="acronym">SOAP</acronym> 1.1 and 1.2 include the different structure
                        of a Fault, and the fact that <code class="literal">SOAPAction</code> HTTP headers are effectively
                        deprecated, thought they still work.
                    </p>
                    <p>
                        One important thing to note with <acronym class="acronym">SOAP</acronym> version numbers, or WS-* specification
                        version numbers in general, is that the latest version of a specification is
                        generally not the most popular version.
                        For <acronym class="acronym">SOAP</acronym>, this means that currently, the best version to use is 1.1.
                        Version 1.2 might become more popular in the future, but currently 1.1 is the safest bet.
                    </p>
                </td></tr></table></div>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-context" href="#message-context"></a>4.1.4&nbsp;<code class="interfacename">MessageContext</code></h3></div></div></div>
        	
        	<p>
        		Typically, messages come in pairs: a request and a response. A request is created on the client-side,
                which is sent over some transport to the server-side, where a response is generated. This response gets
        		sent back to the client, where it is read.
        	</p>
        	<p>
        		In Spring Web Services, such a conversation is contained in a
        		<code class="interfacename">MessageContext</code>, which has properties to get request and response
        		messages.
        		On the client-side, the message context is created by the <a class="link" href="#client-web-service-template" title="6.2.1&nbsp;WebServiceTemplate">
        		<code class="classname">WebServiceTemplate</code></a>.
        		On the server-side, the message context is read from the transport-specific input stream.
                For example, in HTTP, it is read from the <code class="interfacename">HttpServletRequest</code> and the
                response is written back to the <code class="interfacename">HttpServletResponse</code>.
       		</p>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transport-context" href="#transport-context"></a>4.2&nbsp;<code class="interfacename">TransportContext</code></h2></div></div></div>
        
        <p>
            One of the key properties of the SOAP protocol is that it tries to be transport-agnostic. This is why, for
            instance, Spring-WS does not support mapping messages to endpoints by HTTP request URL, but
            rather by mesage content.
        </p>
        <p>
            However, sometimes it is necessary to get access to the underlying transport, either on the client or server
            side. For this, Spring Web Services has the <code class="interfacename">TransportContext</code>. The transport
            context allows access to the underlying <code class="interfacename">WebServiceConnection</code>, which typically
            is a <code class="classname">HttpServletConnection</code> on the server side; or a
            <code class="classname">HttpUrlConnection</code> or <code class="classname">CommonsHttpConnection</code> on the client side.
            For example, you can obtain the IP address of the current request in a server-side endpoint or
            interceptor like so:
        </p>
        <pre class="programlisting">
TransportContext context = TransportContextHolder.getTransportContext();
HttpServletConnection connection = (HttpServletConnection )context.getConnection();
HttpServletRequest request = connection.getHttpServletRequest();
String ipAddress = request.getRemoteAddr();</pre>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xpath" href="#xpath"></a>4.3&nbsp;Handling XML With XPath</h2></div></div></div>
        
        <p>
            One of the best ways to handle XML is to use XPath.
            Quoting <a class="xref" href="#effective-xml" title="Effective XML">[effective-xml]</a>, item 35:
        </p>
        <div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>
                XPath is a fourth generation declarative language that allows you to specify which nodes you want to
                process without specifying exactly how the processor is supposed to navigate to those nodes. XPath's
                data model is very well designed to support exactly what almost all developers want from XML. For
                instance, it merges all adjacent text including that in CDATA sections, allows values to be
                calculated that skip over comments and processing instructions` and include text from child and
                descendant elements, and requires all external entity references to be resolved. In practice, XPath
                expressions tend to be much more robust against unexpected but perhaps insignificant changes in the
                input document.
            </p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Elliotte Rusty Harold</span></td></tr></table></div>
        <p>
            Spring Web Services has two ways to use XPath within your application: the faster
            <code class="interfacename">XPathExpression</code> or the more flexible <code class="classname">XPathTemplate</code>.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xpath-expression" href="#xpath-expression"></a>4.3.1&nbsp;<code class="interfacename">XPathExpression</code></h3></div></div></div>
            
            <p>
                The <code class="interfacename">XPathExpression</code> is an abstraction over a compiled XPath expression,
                such as the Java 5 <code class="interfacename">javax.xml.xpath.XPathExpression</code>, or the Jaxen
                <code class="classname">XPath</code> class.
                To construct an expression in an application context, there is the
                <code class="classname">XPathExpressionFactoryBean</code>. Here is an example which uses this factory bean:
            </p>
            <pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;

    &lt;bean id="nameExpression" class="org.springframework.xml.xpath.XPathExpressionFactoryBean"&gt;
        &lt;property name="expression" value="/Contacts/Contact/Name"/&gt;
    &lt;/bean&gt;

    &lt;bean id="myEndpoint" class="sample.MyXPathClass"&gt;
        &lt;constructor-arg ref="nameExpression"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
            <p>
                The expression above does not use namespaces, but we could set those using the
                <span class="property">namespaces</span> property of the factory bean. The expression
                can be used in the code as follows:
            </p>
            <pre class="programlisting">package sample;

public class MyXPathClass {

    private final XPathExpression nameExpression;

    public MyXPathClass(XPathExpression nameExpression) {
        this.nameExpression = nameExpression;
    }

    public void doXPath(Document document) {
        String name = nameExpression.evaluateAsString(document.getDocumentElement());
        System.out.println("Name: " + name);
    }

}</pre>
            <p>
                For a more flexible approach, you can use a <code class="interfacename">NodeMapper</code>, which is similar
                to the <code class="interfacename">RowMapper</code> in Spring's JDBC support. The following
                example shows how we can use it:
            </p>
            <pre class="programlisting">package sample;

public class MyXPathClass  {

   private final XPathExpression contactExpression;

   public MyXPathClass(XPathExpression contactExpression) {
      this.contactExpression = contactExpression;
   }

   public void doXPath(Document document) {
      List contacts = contactExpression.evaluate(document,
        new NodeMapper() {
           public Object mapNode(Node node, int nodeNum) throws DOMException {
              Element contactElement = (Element) node;
              Element nameElement = (Element) contactElement.getElementsByTagName("Name").item(0);
              Element phoneElement = (Element) contactElement.getElementsByTagName("Phone").item(0);
              return new Contact(nameElement.getTextContent(), phoneElement.getTextContent());
           }
        });
      <em class="lineannotation"><span class="lineannotation">// do something with list of Contact objects</span></em>
   }
}</pre>
            <p>
                Similar to mapping rows in Spring JDBC's <code class="interfacename">RowMapper</code>, each result node is
                mapped using an anonymous inner class. In this case, we create a <code class="classname">Contact</code> object,
                which we use later on.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xpath-template" href="#xpath-template"></a>4.3.2&nbsp;<code class="classname">XPathTemplate</code></h3></div></div></div>
            
            <p>
                The <code class="interfacename">XPathExpression</code> only allows you to evaluate a single, pre-compiled
                expression. A more flexible, though slower, alternative is the <code class="classname">XpathTemplate</code>.
                This class follows the common template pattern used throughout Spring (JdbcTemplate, JmsTemplate, etc.).
                Here is an example:
            </p>
            <pre class="programlisting">package sample;

public class MyXPathClass {

    private XPathOperations template = new Jaxp13XPathTemplate();

    public void doXPath(Source source) {
        String name = template.evaluateAsString("/Contacts/Contact/Name", request);
        <em class="lineannotation"><span class="lineannotation">// do something with name</span></em>
    }

}</pre>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="logging" href="#logging"></a>4.4&nbsp;Message Logging and Tracing</h2></div></div></div>
        
        <p>
            When developing or debugging a Web service, it can be quite useful to look at the content of a (SOAP)
            message when it arrives, or just before it is sent. Spring Web Services offer this functionality, via the
            standard Commons Logging interface.
        </p>
        <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
            <p>
                Make sure to use Commons Logging version 1.1 or higher. Earlier versions have class loading issues, and
                do not integrate with the Log4J TRACE level.
            </p>
        </td></tr></table></div>
        <p>
            To log all server-side messages, simply set the
            <code class="literal">org.springframework.ws.server.MessageTracing</code> logger to level DEBUG or TRACE. On the debug
            level, only the payload root element is logged; on the TRACE level, the entire message content.
            If you only want to log sent messages, use the
            <code class="literal">org.springframework.ws.server.MessageTracing.sent</code> logger; or
            <code class="literal">org.springframework.ws.server.MessageTracing.received</code> to log received messages.
        </p>
        <p>
            On the client-side, similar loggers exist:
            <code class="literal">org.springframework.ws.client.MessageTracing.sent</code> and
            <code class="literal">org.springframework.ws.client.MessageTracing.received</code>.
        </p>
        <p>
            Here is an example <code class="filename">log4j.properties</code> configuration, logging the full content of
            sent messages on the client side, and only the payload root element for client-side received messages. On
            the server-side, the payload root is logged for both sent and received messages:
        </p>
        <pre class="programlisting">log4j.rootCategory=INFO, stdout
log4j.logger.org.springframework.ws.client.MessageTracing.sent=TRACE
log4j.logger.org.springframework.ws.client.MessageTracing.received=DEBUG

log4j.logger.org.springframework.ws.server.MessageTracing=DEBUG

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%p [%c{3}] %m%n</pre>
        <p>
            With this configuration, a typical output will be:
        </p>
        <pre class="screen">TRACE [client.MessageTracing.sent] Sent request [&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="...
DEBUG [server.MessageTracing.received] Received request [SaajSoapMessage {http://example.com}request] ...
DEBUG [server.MessageTracing.sent] Sent response [SaajSoapMessage {http://example.com}response] ...
DEBUG [client.MessageTracing.received] Received response [SaajSoapMessage {http://example.com}response] ...</pre>
    </div>
</div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="server" href="#server"></a>5.&nbsp;Creating a Web service with Spring-WS</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ws-introduction" href="#ws-introduction"></a>5.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            Spring-WS's server-side support is designed around a
            <code class="classname">MessageDispatcher</code> that dispatches incoming
            messages to endpoints, with configurable endpoint mappings, response
            generation, and endpoint interception.
            Endpoints are typically annotated with the <code class="interfacename">@Endpoint</code> annotation, and have
            one or more handling methods.
            These methods handle incoming XML request messages by inspecting parts of the message (typically the
            payload), and create some sort of response.
            You annotate the method with another annotation, typically <code class="interfacename">@PayloadRoot</code>,
            to indicate what sort of messages it can handle.
        </p>
        <p>
           Spring-WS's XML handling is extremely flexible. An endpoint can choose from
           a large amount of XML handling libraries supported by Spring-WS, including the DOM family (W3C DOM, JDOM,
           dom4j, and XOM), SAX or StAX for faster performance, XPath to extract information from the message, or even
           marshalling techniques (JAXB, Castor, XMLBeans, JiBX, or XStream) to convert
           the XML to objects and vice-versa.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e780" href="#d5e780"></a>5.2&nbsp;The <code class="classname">MessageDispatcher</code></h2></div></div></div>
        
        <p>
            The server-side of Spring-WS is designed around a central class that dispatches incoming XML messages to
            endpoints. Spring-WS's <code class="classname">MessageDispatcher</code> is extremely flexible, allowing you to
            use any sort of class as an endpoint, as long as it can be configured in the Spring IoC container.
            In a way, the message dispatcher resembles Spring's <code class="classname">DispatcherServlet</code>, the
            <span class="quote">&#8220;<span class="quote">Front Controller</span>&#8221;</span> used in Spring Web MVC.
        </p>
        <p>
            The processing and dispatching flow of the <code class="classname">MessageDispatcher</code> is illustrated in the
            following sequence diagram.
            </p><div class="mediaobject" align="center"><img src="images/sequence.png" align="middle"><div class="caption">
                    <p>The request processing workflow in Spring Web Services</p>
                </div></div><p>
        </p>
        <p>
               When a <code class="classname">MessageDispatcher</code> is set up for use and a request comes in for that
               specific dispatcher, said <code class="classname">MessageDispatcher</code> starts processing the request. The
               list below describes the complete process a request goes through when handled by a
               <code class="classname">MessageDispatcher</code>:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>
                    An appropriate endpoint is searched for using the configured <code class="literal">EndpointMapping(s)</code>.
                    If an endpoint is found, the invocation chain associated with the endpoint (pre-processors,
                    post-processors, and endpoints) will be executed in order to create a response.
                </p>
            </li><li class="listitem">
                <p>
                    An appropriate adapter is searched for the endpoint. The <code class="classname">MessageDispatcher</code>
                    delegates to this adapter to invoke the endpoint.
                </p>
            </li><li class="listitem">
                <p>
                    If a response is returned, it is sent on its way. If no response is returned (which could be due to
                    a pre- or post-processor intercepting the request, for example, for security reasons), no response
                    is sent.
                </p>
            </li></ol></div>
        <p>
            Exceptions that are thrown during handling of the request get picked up by any of the endpoint exception
            resolvers that are declared in the application context. Using these exception resolvers allows you to define
            custom behaviors (such as returning a SOAP Fault) in case such exceptions get thrown.
        </p>
        <p>
            The <code class="classname">MessageDispatcher</code> has several properties, for setting endpoint adapters,
            <a class="link" href="#server-endpoint-mapping" title="5.5&nbsp;Endpoint mappings">mappings</a>,
            <a class="link" href="#server-endpoint-exception-resolver" title="5.6&nbsp;Handling Exceptions">exception resolvers</a>.
            However, setting these properties is not required, since the dispatcher will automatically detect all of
            these types that are registered in the application context. Only when detection needs to be overriden,
            should these properties be set.
        </p>
        <p>
            The message dispatcher operates on a <a class="link" href="#message-context" title="4.1.4&nbsp;MessageContext">message context</a>, and not
            transport-specific input stream and output stream. As a result, transport specific requests need to read
            into a <code class="interfacename">MessageContext</code>. For HTTP, this is done with a
            <code class="classname">WebServiceMessageReceiverHandlerAdapter</code>, which is a Spring Web
            <code class="interfacename">HandlerInterceptor</code>, so that the <code class="classname">MessageDispatcher</code>
            can be wired in a standard <code class="classname">DispatcherServlet</code>. There is a more convenient way to do
            this, however, which is shown in <a class="xref" href="#message-dispatcher-servlet" title="5.3.1&nbsp;MessageDispatcherServlet">Section&nbsp;5.3.1, &#8220;<code class="classname">MessageDispatcherServlet</code>&#8221;</a>.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e820" href="#d5e820"></a>5.3&nbsp;Transports</h2></div></div></div>
        
        <p>
            Spring Web Services supports multiple transport protocols. The most common is the HTTP transport, for which
            a custom servlet is supplied, but it is also possible to send messages over JMS, and even email.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="message-dispatcher-servlet" href="#message-dispatcher-servlet"></a>5.3.1&nbsp;<code class="classname">MessageDispatcherServlet</code></h3></div></div></div>
            
            <p>
                The <code class="classname">MessageDispatcherServlet</code> is a standard <code class="interfacename">Servlet</code>
                which
                conveniently extends from the standard Spring Web <code class="classname">DispatcherServlet</code>, and wraps
                a <code class="classname">MessageDispatcher</code>.  As such, it combines the attributes of these into one:
                as a <code class="classname">MessageDispatcher</code>, it follows the same request handling flow as described
                in the previous section.
                As a servlet, the
                <code class="classname">MessageDispatcherServlet</code> is configured in the <code class="filename">web.xml</code> of
                your web application. Requests that you want the <code class="classname">MessageDispatcherServlet</code> to
                handle will have to be mapped using a URL mapping in the same <code class="literal">web.xml</code> file. This is
                standard Java EE servlet configuration; an example of such a
                <code class="classname">MessageDispatcherServlet</code> declaration and mapping can be found below.
            </p>
            <pre class="programlisting">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.ws.transport.http.MessageDispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre>
            <p>
                In the example above, all requests will be handled by the <code class="literal">'spring-ws'</code>
                <code class="classname">MessageDispatcherServlet</code>. This is only the first step in setting up Spring Web
                Services, because the various component beans used by the Spring-WS framework also need to be
                configured; this configuration consists of standard Spring XML <code class="literal">&lt;bean/&gt;</code>
                definitions. Because the <code class="classname">MessageDispatcherServlet</code> is a standard Spring
                <code class="classname">DispatcherServlet</code>, it will <span class="emphasis"><em>look for a file named
                <code class="literal">[servlet-name]-servlet.xml</code></em></span> in the <code class="literal">WEB-INF</code> directory
                of your web application and create the beans defined there in a Spring container. In the example above,
                that means that it looks for '<code class="filename">/WEB-INF/spring-ws-servlet.xml</code>'. This file will
                contain all of the Spring Web Services beans such as endpoints, marshallers and suchlike.
            </p>
            <p>
                As an alternative for <code class="filename">web.xml</code>, if you are running on a Servlet 3+ environment, you
                can configure Spring-WS programmatically.
                For this purpose, Spring-WS provides a number of abstract base classes that extend the
                <code class="interfacename">WebApplicationInitializer</code> interface found in the Spring Framework.
                If you are also using <code class="interfacename">@Configuration</code> classes for your bean definitions, you are
                best of extending the <code class="classname">AbstractAnnotationConfigMessageDispatcherServletInitializer</code>, like so:
            </p>
            <pre class="programlisting">public class MyServletInitializer
    extends AbstractAnnotationConfigMessageDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{MyRootConfig.class};
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{MyEndpointConfig.class};
    }

}</pre>
            <p>
                In the example above, we tell Spring that endpoint bean definitions can be found in the <code class="classname">MyEndpointConfig</code>
                class (which is a <code class="interfacename">@Configuration</code> class).
                Other bean definitions (typically services, repositories, etc.) can be found in the <code class="classname">MyRootConfig</code>
                class.
                By default, the <code class="classname">AbstractAnnotationConfigMessageDispatcherServletInitializer</code> maps the servlet to
                two patterns: <code class="filename">/services</code> and <code class="filename">*.wsdl</code>, though this can be changed by overriding the
                <code class="methodname">getServletMappings()</code> method.
                For more details on the programmatic configuration of the <code class="classname">MessageDispatcherServlet</code>, refer to the
                Javadoc of <code class="classname">AbstractMessageDispatcherServletInitializer</code> and
                <code class="classname">AbstractAnnotationConfigMessageDispatcherServletInitializer</code>.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="server-automatic-wsdl-exposure" href="#server-automatic-wsdl-exposure"></a>Automatic WSDL exposure</h4></div></div></div>
                
                <p>
                    The <code class="classname">MessageDispatcherServlet</code> will automatically detect any
                    <code class="interfacename">WsdlDefinition</code> beans defined in it's Spring container. All such
                    <code class="interfacename">WsdlDefinition</code> beans that are detected will also be exposed via
                    a <code class="classname">WsdlDefinitionHandlerAdapter</code>; this is a very convenient way to expose your
                    WSDL to clients simply by just defining some beans.
                </p>
                <p>
                    By way of an example, consider the following <code class="literal">&lt;static-wsdl&gt;</code>definition,
                    defined in the Spring-WS configuration file
                    (<code class="filename">/WEB-INF/[servlet-name]-servlet.xml</code>).
                    Take notice of the value of the '<code class="literal">id</code>' attribute, because this will be used when
                    exposing the WSDL.
                </p>
                <pre class="programlisting">&lt;sws:static-wsdl id="orders" location="orders.wsdl"/&gt;</pre>
                <p>
                    Or as <code class="interfacename">@Bean</code> method in a <code class="interfacename">@Configuration</code> class:
                </p>
                <pre class="programlisting">@Bean
public SimpleWsdl11Definition orders() {
	return new SimpleWsdl11Definition(new ClassPathResource("orders.xml"));
}</pre>
                <p>
                    The WSDL defined in the '<code class="filename">orders.wsdl</code>' file on the classpath can then be accessed via
                    <code class="literal">GET</code> requests to a URL of the following form (substitute the host, port and
                    servlet context path as appropriate).
                </p>
                <pre class="programlisting">http://localhost:8080/spring-ws/orders.wsdl</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                    <p>
                        All <code class="interfacename">WsdlDefinition</code> bean definitions are exposed by the
                        <code class="classname">MessageDispatcherServlet</code> under their bean name with the
                        suffix <code class="literal">.wsdl</code>.
                        So if the bean name is <code class="literal">echo</code>, the host name is "server", and the Servlet
                        context (war name) is "spring-ws", the WSDL can be obtained via
                        <code class="uri">http://server/spring-ws/echo.wsdl</code>
                    </p>
                </td></tr></table></div>
                <p>
                    Another nice feature of the <code class="classname">MessageDispatcherServlet</code> (or more correctly the
                    <code class="classname">WsdlDefinitionHandlerAdapter</code>) is that it is able to
                    transform the value of the '<code class="literal">location</code>' of all the WSDL that it exposes to reflect
                    the URL of the incoming request.
                </p>
                <p>
                    Please note that this '<code class="literal">location</code>' transformation feature is
                    <span class="emphasis"><em>off</em></span> by default.To switch this feature on, you just need to specify an
                    initialization parameter to the <code class="classname">MessageDispatcherServlet</code>, like so:
                </p>
                <pre class="programlisting">&lt;web-app&gt;

  &lt;servlet&gt;
    &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.ws.transport.http.MessageDispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;transformWsdlLocations&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre>
                <p>
                    If you use the <code class="classname">AbstractAnnotationConfigMessageDispatcherServletInitializer</code>,
                    enabling transformation is as simple as overriding the <code class="methodname">isTransformWsdlLocations()</code>
                    method to return <code class="literal">true</code>.
                </p>
                <p>
                    Consult the class-level Javadoc on the <code class="classname">WsdlDefinitionHandlerAdapter</code> class
                    to learn more about the whole transformation process.
                </p>
                <p>
                    As an alternative to writing the WSDL by hand, and exposing it with
                    <code class="literal">&lt;static-wsdl&gt;</code>, Spring Web Services can also generate a WSDL
                    from an XSD schema.
                    This is the approach shown in <a class="xref" href="#tutorial-publishing-wsdl" title="3.7&nbsp;Publishing the WSDL">Section&nbsp;3.7, &#8220;Publishing the WSDL&#8221;</a>.
                    The next application context snippet shows how to create such a dynamic WSDL file:
                </p>
                <pre class="programlisting">&lt;sws:dynamic-wsdl id="orders"
    portTypeName="Orders"
    locationUri="http://localhost:8080/ordersService/"&gt;
  &lt;sws:xsd location="Orders.xsd"/&gt;
&lt;/sws:dynamic-wsdl&gt;</pre>
                <p>
                    Or, as <code class="interfacename">@Bean</code> method:
                </p>
                <pre class="programlisting">@Bean
public DefaultWsdl11Definition orders() {
    DefaultWsdl11Definition definition = new DefaultWsdl11Definition();
    definition.setPortTypeName("Orders");
    definition.setLocationUri("http://localhost:8080/ordersService/");
    definition.setSchema(new SimpleXsdSchema(new ClassPathResource("echo.xsd")));

    return definition;
}</pre>
                <p>
                    The <code class="literal">&lt;dynamic-wsdl&gt;</code> element depends on the
                    <code class="classname">DefaultWsdl11Definition</code> class.
                    This definition class uses WSDL providers in the
                    <span class="package">org.springframework.ws.wsdl.wsdl11.provider</span> package and the
                    <code class="classname">ProviderBasedWsdl4jDefinition</code>
                    to generate a WSDL the first time it is requested.
                    Refer to the class-level Javadoc of these classes to see how you can extend this mechanism,
                    if necessary.
                </p>
                <p>
                    The <code class="classname">DefaultWsdl11Definition</code> (and therefore, the <code class="literal">&lt;dynamic-wsdl&gt;</code> tag)
                    builds a WSDL from a XSD schema by using conventions.
                    It iterates over all <code class="literal">element</code> elements
                    found in the schema, and creates a <code class="literal">message</code> for all elements.
                    Next, it creates WSDL <code class="literal">operation</code> for all messages that end with the
                    defined request or response suffix.
                    The default request suffix is <code class="literal">Request</code>;
                    the default response suffix is <code class="literal">Response</code>, though these can be changed by
                    setting the <span class="property">requestSuffix</span> and <span class="property">responseSuffix</span>
                    attributes on <code class="literal">&lt;dynamic-wsdl /&gt;</code>, respectively.
                    It also builds a <code class="literal">portType</code>, <code class="literal">binding</code>, and
                    <code class="literal">service</code> based on the operations.
                </p>
                <p>
                    For instance, if our <code class="filename">Orders.xsd</code> schema defines the
                    <code class="literal">GetOrdersRequest</code> and <code class="literal">GetOrdersResponse</code> elements,
                    <code class="literal">&lt;dynamic-wsdl&gt;</code> will create a
                    <code class="literal">GetOrdersRequest</code> and <code class="literal">GetOrdersResponse</code> message, and a
                    <code class="literal">GetOrders</code> operation, which is put in a <code class="literal">Orders</code> port type.
                </p>
                <p>
                    If you want to use multiple schemas, either by includes or imports, you will want to
                    put Commons XMLSchema on the class path.
                    If Commons XMLSchema is on the class path, the above <code class="literal">&lt;dynamic-wsdl&gt;</code>
                    element will follow all XSD imports and includes,
                    and will inline them in the WSDL as a single XSD.
                    This greatly simplifies the deployment of the schemas, which still making it possible to edit them
                    separately.
                </p>
                <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
                    <p>
                        Even though it can be quite handy to create the WSDL at runtime from your XSDs, there
                        are a couple of drawbacks to this approach. First off, though we try to keep the WSDL generation
                        process consistent between releases, there is still the possibility that it changes (slightly).
                        Second, the generation is a bit slow, though once generated, the WSDL is cached for later
                        reference.
                    </p>
                    <p>
                        It is therefore recommended to only use <code class="literal">&lt;dynamic-wsdl&gt;</code>
                        during the development stages of your project.
                        Then, we recommend to use your browser to download the generated WSDL, store it in the project,
                        and expose it with <code class="literal">&lt;static-wsdl&gt;</code>.
                        This is the only way to be really sure that the WSDL does not change over time.
                    </p>
                </td></tr></table></div>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e949" href="#d5e949"></a>5.3.2&nbsp;Wiring up Spring-WS in a <code class="classname">DispatcherServlet</code></h3></div></div></div>
            
            <p>
                As an alternative to the <code class="classname">MessageDispatcherServlet</code>, you can wire up a
                <code class="classname">MessageDispatcher</code> in a standard, Spring-Web MVC
                <code class="classname">DispatcherServlet</code>.
                By default, the <code class="classname">DispatcherServlet</code> can only delegate to
                <code class="interfacename">Controllers</code>, but we can instruct it to delegate to a
                <code class="classname">MessageDispatcher</code> by adding a
                <code class="classname">WebServiceMessageReceiverHandlerAdapter</code> to the servlet's web application
                context:
                </p><pre class="programlisting">&lt;beans&gt;

    &lt;bean class="org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter"/&gt;

    &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="defaultHandler" ref="messageDispatcher"/&gt;
    &lt;/bean

    &lt;bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher"/&gt;

    ...

    &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;

&lt;/beans&gt;</pre><p>
                Note that by explicitly adding the <code class="classname">WebServiceMessageReceiverHandlerAdapter</code>,
                the dispatcher servlet does not load the default adapters, and is unable to handle standard Spring-MVC
                <code class="interfacename">@Controllers</code>. Therefore, we add the
                <code class="classname">RequestMappingHandlerAdapter</code> at the end.
            </p>
            <p>
                In a similar fashion, you can wire up a <code class="classname">WsdlDefinitionHandlerAdapter</code> to make sure
                the <code class="classname">DispatcherServlet</code> can handle implementations of the
                <code class="interfacename">WsdlDefinition</code> interface:
                </p><pre class="programlisting">&lt;beans&gt;

    &lt;bean class="org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter"/&gt;

    <span class="bold"><strong>&lt;bean class="org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapter"/&gt;</strong></span>

    &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
           &lt;props&gt;
             <span class="bold"><strong>&lt;prop key="*.wsdl"&gt;myServiceDefinition&lt;/prop&gt;</strong></span>
           &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="defaultHandler" ref="messageDispatcher"/&gt;
    &lt;/bean&gt;

    &lt;bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher"/&gt;

    <span class="bold"><strong>&lt;bean id="myServiceDefinition" class="org.springframework.ws.wsdl.wsdl11.SimpleWsdl11Definition"&gt;
       &lt;prop name="wsdl" value="/WEB-INF/myServiceDefintion.wsdl"/&gt;
    &lt;/bean&gt;</strong></span>

    ...

&lt;/beans&gt;</pre><p>
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e972" href="#d5e972"></a>5.3.3&nbsp;JMS transport</h3></div></div></div>
            
            <p>
                Spring Web Services supports server-side JMS handling through the JMS functionality provided in the
                Spring framework. Spring Web Services provides the <code class="classname">WebServiceMessageListener</code>
                to plug in to a <code class="classname">MessageListenerContainer</code>. This message listener requires a
                <code class="interfacename">WebServiceMessageFactory</code> to and
                <code class="interfacename">MessageDispatcher</code> to operate. The following piece of configuration
                shows this:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="vm://localhost?broker.persistent=false"/&gt;
    &lt;/bean&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;property name="destinationName" value="RequestQueue"/&gt;
        &lt;property name="messageListener"&gt;
            &lt;bean class="org.springframework.ws.transport.jms.WebServiceMessageListener"&gt;
                &lt;property name="messageFactory" ref="messageFactory"/&gt;
                &lt;property name="messageReceiver" ref="messageDispatcher"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher"&gt;
        &lt;property name="endpointMappings"&gt;
            &lt;bean
              class="org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping"&gt;
                &lt;property name="defaultEndpoint"&gt;
                    &lt;bean class="com.example.MyEndpoint"/&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e980" href="#d5e980"></a>5.3.4&nbsp;Email transport</h3></div></div></div>
            
            <p>
                In addition to HTTP and JMS, Spring Web Services also provides server-side email handling. This
                functionality is provided through the <code class="classname">MailMessageReceiver</code> class. This class
                monitors a POP3 or IMAP folder, converts the email to a <code class="interfacename">WebServiceMessage</code>,
                sends any response using SMTP. The host names can be configured through the
                <span class="property">storeUri</span>, which indicates the mail folder to monitor for requests (typically a POP3 or IMAP folder),
                and a <span class="property">transportUri</span>, which indicates the server to use for sending responses (typically a SMTP server).
            </p>
            <p>
                How the <code class="classname">MailMessageReceiver</code> monitors incoming messages can be configured with
                a pluggable strategy: the <code class="interfacename">MonitoringStrategy</code>. By default, a polling
                strategy is used, where the incoming folder is polled for new messages every five minutes. This interval
                can be changed by setting the <span class="property">pollingInterval</span> property on the strategy.
                By default, all <code class="interfacename">MonitoringStrategy</code> implementations delete the handled
                messages; this can be changed by setting the <span class="property">deleteMessages</span> property.
            </p>
            <p>
                As an alternative to the polling approaches, which are quite inefficient, there is a monitoring strategy
                that uses IMAP <span class="command"><strong>IDLE</strong></span>. The <span class="command"><strong>IDLE</strong></span> command is an optional
                expansion of the IMAP email protocol that allows the mail server to send new message updates to the
                <code class="classname">MailMessageReceiver</code> asynchronously. If you use a IMAP server that supports the
                <span class="command"><strong>IDLE</strong></span> command, you can plug in the <code class="classname">ImapIdleMonitoringStrategy</code>
                into the <span class="property">monitoringStrategy</span> property.
                In addition to a supporting server, you will need to use JavaMail version 1.4.1 or higher.
            </p>
            <p>
                The following piece of configuration shows how to use the server-side email support, overiding the
                default polling interval to a value which checks every 30 seconds
                (30.000 milliseconds):</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean id="messagingReceiver" class="org.springframework.ws.transport.mail.MailMessageReceiver"&gt;
        &lt;property name="messageFactory" ref="messageFactory"/&gt;
        &lt;property name="from" value="Spring-WS SOAP Server &amp;lt;server@example.com&amp;gt;"/&gt;
        &lt;property name="storeUri" value="imap://server:s04p@imap.example.com/INBOX"/&gt;
        &lt;property name="transportUri" value="smtp://smtp.example.com"/&gt;
        &lt;property name="messageReceiver" ref="messageDispatcher"/&gt;
        &lt;property name="monitoringStrategy"&gt;
            &lt;bean class="org.springframework.ws.transport.mail.monitor.PollingMonitoringStrategy"&gt;
                &lt;property name="pollingInterval" value="30000"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher"&gt;
        &lt;property name="endpointMappings"&gt;
            &lt;bean
              class="org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping"&gt;
                &lt;property name="defaultEndpoint"&gt;
                    &lt;bean class="com.example.MyEndpoint"/&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1002" href="#d5e1002"></a>5.3.5&nbsp;Embedded HTTP Server transport</h3></div></div></div>
        	
        	<p>
        		Spring Web Services provides a transport based on Sun's JRE 1.6 
        		<a class="ulink" href="http://java.sun.com/javase/6/docs/jre/api/net/httpserver/spec/index.html" target="_top">HTTP server</a>.
        		The embedded HTTP Server is a standalone server that is simple to configure. It lends itself to a lighter 
        		alternative to conventional servlet containers.
        	</p>
        	<p>
        		When using the embedded HTTP server, no external deployment descriptor is needed
                (<code class="filename">web.xml</code>).
        		You only need to define an instance of the server and configure it to handle incoming requests.
        		The remoting module in the Core Spring Framework contains a convenient factory bean for the HTTP server:
                the <code class="classname">SimpleHttpServerFactoryBean</code>.
        		The most important property is <span class="property">contexts</span>, which maps context paths to corresponding
        		<code class="interfacename">HttpHandler</code>s.
        	</p>
        	<p>
				Spring Web Services provides 2 implementations of the <code class="interfacename">HttpHandler</code>
                interface: <code class="classname">WsdlDefinitionHttpHandler</code>
				and <code class="classname">WebServiceMessageReceiverHttpHandler</code>.
                The former maps an incoming GET request to a <code class="interfacename">WsdlDefinition</code>.
                The latter is responsible for handling POST requests for web services messages and thus
				needs a <code class="interfacename">WebServiceMessageFactory</code> (typically a
                <code class="classname">SaajSoapMessageFactory</code>) and a
                <code class="interfacename">WebServiceMessageReceiver</code> (typically the
                <code class="classname">SoapMessageDispatcher</code>) to accomplish its task.
        	</p>
        	<p>
        		To draw parallels with the servlet world, the <span class="property">contexts</span> property plays
        		the role of servlet mappings in <code class="filename">web.xml</code> and the
                <code class="classname">WebServiceMessageReceiverHttpHandler</code> is the equivalent of
                a <code class="classname">MessageDispatcherServlet</code>.
        	</p>
        	<p>
        		The following snippet shows a simple configuration example of the HTTP server
                transport:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;
    
    &lt;bean id="messageReceiver" class="org.springframework.ws.soap.server.SoapMessageDispatcher"&gt;
        &lt;property name="endpointMappings" ref="endpointMapping"/&gt;
    &lt;/bean&gt;

    &lt;bean id="endpointMapping" class="org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping"&gt;
        &lt;property name="defaultEndpoint" ref="stockEndpoint"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="httpServer" class="org.springframework.remoting.support.SimpleHttpServerFactoryBean"&gt;
        &lt;property name="contexts"&gt;
            &lt;map&gt;
                &lt;entry key="/StockService.wsdl" value-ref="wsdlHandler"/&gt;
                &lt;entry key="/StockService" value-ref="soapHandler"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="soapHandler" class="org.springframework.ws.transport.http.WebServiceMessageReceiverHttpHandler"&gt;
        &lt;property name="messageFactory" ref="messageFactory"/&gt;
        &lt;property name="messageReceiver" ref="messageReceiver"/&gt;
    &lt;/bean&gt;

    &lt;bean id="wsdlHandler" class="org.springframework.ws.transport.http.WsdlDefinitionHttpHandler"&gt;
        &lt;property name="definition" ref="wsdlDefinition"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
        	</p>
        	<p>
                For more information on the <code class="classname">SimpleHttpServerFactoryBean</code>, refer to the
                <a class="ulink" href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/remoting/support/SimpleHttpServerFactoryBean.html" target="_top">Javadoc</a>.
        	</p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1030" href="#d5e1030"></a>5.3.6&nbsp;XMPP transport</h3></div></div></div>
            
            <p>
                Finally, Spring Web Services 2.0 introduced support for XMPP, otherwise known as Jabber. The support
                is based on the <a class="ulink" href="http://www.igniterealtime.org/projects/smack/index.jsp" target="_top">Smack</a>
                library.
            </p>
            <p>
                Spring Web Services support for XMPP is very similar to the other transports: there is a a
                <code class="classname">XmppMessageSender</code> for the <code class="classname">WebServiceTemplate</code> and
                and a <code class="classname">XmppMessageReceiver</code> to use with the
                <code class="classname">MessageDispatcher</code>.
            </p>
            <p>The following example shows how to set up the server-side XMPP components:
            </p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean id="connection" class="org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean"&gt;
        &lt;property name="host" value="jabber.org"/&gt;
        &lt;property name="username" value="username"/&gt;
        &lt;property name="password" value="password"/&gt;
    &lt;/bean&gt;

    &lt;bean id="messagingReceiver" class="org.springframework.ws.transport.xmpp.XmppMessageReceiver"&gt;
        &lt;property name="messageFactory" ref="messageFactory"/&gt;
        &lt;property name="connection" ref="connection"/&gt;
        &lt;property name="messageReceiver" ref="messageDispatcher"/&gt;
    &lt;/bean&gt;

    &lt;bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher"&gt;
        &lt;property name="endpointMappings"&gt;
            &lt;bean
              class="org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping"&gt;
                &lt;property name="defaultEndpoint"&gt;
                    &lt;bean class="com.example.MyEndpoint"/&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1041" href="#d5e1041"></a>5.3.7&nbsp;MTOM</h3></div></div></div>
            
            <p>
                <a class="ulink" href="https://en.wikipedia.org/wiki/Message_Transmission_Optimization_Mechanism" target="_top">MTOM</a> is
                the mechanism of sending binary data to and from Web Services. You can look at how to implement
                this with Spring WS through the
                <a class="ulink" href="https://github.com/spring-projects/spring-ws-samples/tree/master/mtom" target="_top">MTOM sample</a>.
            </p>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="server-endpoints" href="#server-endpoints"></a>5.4&nbsp;Endpoints</h2></div></div></div>
        
        <p>
            Endpoints are the central concept in Spring-WS's server-side support. Endpoints provide access to the
            application behavior which is typically defined by a business service interface. An endpoint interprets the XML
            request message and uses that input to invoke a method on the business service (typically). The result of that service
            invocation is represented as a response message. Spring-WS has a wide variety of endpoints, using various
            ways to handle the XML message, and to create a response.
        </p>
        <p>
            You create an endpoint by annotating a class with the <code class="interfacename">@Endpoint</code> annotation.
            In the class, you define one or more methods that handle the incoming XML request, by using a wide
            variety of parameter types (such as DOM elements, JAXB2 objects, etc).
            You indicate the sort of messages a method can handle by using another annotation (typically
            <code class="interfacename">@PayloadRoot</code>).
        </p>
        <p>
            Consider the following sample endpoint:
            </p><div class="programlistingco"><pre class="programlisting">package samples;

import org.w3c.dom.Element;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.soap.SoapHeader;

@Endpoint                                                                                                              <span class="co" id="server-endpoint-atEndpoint"><img src="images/callouts/1.png" alt="(1)"></span>
public class AnnotationOrderEndpoint {

  private final OrderService orderService;

  @Autowired                                                                                                           <span class="co" id="server-endpoint-constructor"><img src="images/callouts/2.png" alt="(2)"></span>
  public AnnotationOrderEndpoint(OrderService orderService) {
      this.orderService = orderService;
  }

  @PayloadRoot(localPart = "order", namespace = "http://samples")                                                      <span class="co" id="server-endpoint-payloadRoot-1"><img src="images/callouts/5.png" alt="(5)"></span>
  public void order(@RequestPayload Element orderElement) {                                                            <span class="co" id="server-endpoint-order"><img src="images/callouts/3.png" alt="(3)"></span>
    Order order = createOrder(orderElement);
    orderService.createOrder(order);
  }

  @PayloadRoot(localPart = "orderRequest", namespace = "http://samples")                                               <span class="co" id="server-endpoint-payloadRoot-2"><img src="images/callouts/5.png" alt="(5)"></span>
  @ResponsePayload
  public Order getOrder(@RequestPayload OrderRequest orderRequest, SoapHeader header) {                                <span class="co" id="server-endpoint-getOrder"><img src="images/callouts/4.png" alt="(4)"></span>
    checkSoapHeaderForSomething(header);
    return orderService.getOrder(orderRequest.getId());
  }

  ...

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The class is annotated with <code class="interfacename">@Endpoint</code>, marking it as a
                            Spring-WS endpoint.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The constructor is marked with <code class="interfacename">@Autowired</code>, so that the
                            <code class="classname">OrderService</code> business service is injected into this endpoint.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="methodname">order</code> method takes a <code class="interfacename">Element</code>
                            as a parameter, annotated with <code class="interfacename">@RequestPayload</code>.
                            This means that the payload of the message is passed on this method as a DOM element.
                            The method has a <code class="literal">void</code> return type, indicating that no response message
                            is sent.
                        </p>
                        <p>
                            For more information about endpoint methods, refer to
                            <a class="xref" href="#server-atEndpoint-methods" title="5.4.1&nbsp;@Endpoint handling methods">Section&nbsp;5.4.1, &#8220;<code class="interfacename">@Endpoint</code> handling methods&#8221;</a>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="methodname">getOrder</code> method takes a <code class="classname">OrderRequest</code>
                            as a parameter, annotated with <code class="interfacename">@RequestPayload</code> as well.
                            This parameter is a JAXB2-supported object (it is annotated with
                            <code class="interfacename">@XmlRootElement</code>).
                            This means that the payload of the message is passed on to this method as a unmarshalled
                            object.
                            The <code class="interfacename">SoapHeader</code> type is also given as a parameter.
                            On invocation, this parameter will contain the SOAP header of the request message.
                            The method is also annotated with <code class="interfacename">@ResponsePayload</code>,
                            indicating that the return value (the <code class="classname">Order</code>) is used as the payload
                            of the response message.
                        </p>
                        <p>
                            For more information about endpoint methods, refer to
                            <a class="xref" href="#server-atEndpoint-methods" title="5.4.1&nbsp;@Endpoint handling methods">Section&nbsp;5.4.1, &#8220;<code class="interfacename">@Endpoint</code> handling methods&#8221;</a>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The two handling methods of this endpoint are marked with
                            <code class="interfacename">@PayloadRoot</code>, indicating what sort of request messages
                            can be handled by the method: the <code class="methodname">getOrder</code> method
                            will be invoked for requests with a <code class="literal">orderRequest</code> local name and a
                            <code class="uri">http://samples</code> namespace URI; the <code class="methodname">order</code> method
                            for requests with a <code class="literal">order</code> local name.
                        </p>
                        <p>
                            For more information about <code class="interfacename">@PayloadRoot</code>, refer to
                            <a class="xref" href="#server-endpoint-mapping" title="5.5&nbsp;Endpoint mappings">Section&nbsp;5.5, &#8220;Endpoint mappings&#8221;</a>.
                        </p>
                    </td></tr></table></div></div><p>
        </p>
        <p>
            To enable the support for <code class="interfacename">@Endpoint</code> and related Spring-WS annotations,
            you will need to add the following to your Spring application context:

            </p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  <span class="bold"><strong>xmlns:sws="http://www.springframework.org/schema/web-services"</strong></span>
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
    <span class="bold"><strong>http://www.springframework.org/schema/web-services
      http://www.springframework.org/schema/web-services/web-services.xsd"&gt;</strong></span>

  <span class="bold"><strong>&lt;sws:annotation-driven /&gt;</strong></span>

&lt;/beans&gt;</pre><p>
        </p>
        <p>
            Or, if you are using <code class="interfacename">@Configuration</code> classes instead of Spring XML, you can
            annotate your configuration class with <code class="interfacename">@EnableWs</code>, like so:
        </p>
        <pre class="programlisting"><span class="bold"><strong>@EnableWs</strong></span>
@Configuration
public class EchoConfig {

    // @Bean definitions go here

}</pre>
        <p>
            To customize the <code class="interfacename">@EnableWs</code> configuration, you can implement
            <code class="interfacename">WsConfigurer</code>, or better yet extend the
            <code class="classname">WsConfigurerAdapter</code>.
            For instance:</p><pre class="programlisting">@Configuration
@EnableWs
@ComponentScan(basePackageClasses = { MyConfiguration.class })
public class MyConfiguration extends WsConfigurerAdapter {

  @Override
  public void addInterceptors(List&lt;EndpointInterceptor&gt; interceptors) {
    interceptors.add(new MyInterceptor());
  }

  @Override
  public void addArgumentResolvers(List&lt;MethodArgumentResolver&gt; argumentResolvers) {
    argumentResolvers.add(new MyArgumentResolver());
  }

  // More overridden methods ...
}</pre><p>
        </p>
        <p>
            In the next couple of sections, a more elaborate description of the <code class="interfacename">@Endpoint</code>
            programming model is given.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
            <p>
                Endpoints, like any other Spring Bean, are scoped as a singleton by default, i.e. one instance of the
                bean definition is created per container. Being a singleton implies that more than one thread
                can use it at the same time, so the endpoint has to be thread safe. If you want to use a different
                scope, such as prototype, refer to the
                <a class="ulink" href="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-scopes" target="_top">Spring Reference documentation</a>.
            </p>
            <p>
                Note that all abstract base classes provided in Spring-WS are thread safe, unless otherwise indicated
                in the class-level Javadoc.
            </p>
        </td></tr></table></div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-atEndpoint-methods" href="#server-atEndpoint-methods"></a>5.4.1&nbsp;<code class="interfacename">@Endpoint</code> handling methods</h3></div></div></div>
            
            <p>
                In order for an endpoint to actually handle incoming XML messages, it needs to have one or more handling
                methods.
                Handling methods can take wide range of parameters and return types, but typically they have one
                parameter that will contain the message payload, and they return the payload of the response message
                (if any).
                You will learn which parameter and return types are supported in this section.
            </p>
            <p>
                To indicate what sort of messages a method can handle, the method is typically annotated with either the
                <code class="interfacename">@PayloadRoot</code> or <code class="interfacename">@SoapAction</code> annotation.
                You will learn more about these annotations in <a class="xref" href="#server-endpoint-mapping" title="5.5&nbsp;Endpoint mappings">Section&nbsp;5.5, &#8220;Endpoint mappings&#8221;</a>.
            </p>
            <p>
                Here is an example of a handling method:
                </p><pre class="programlisting">@PayloadRoot(localPart = "order", namespace = "http://samples")
public void order(@RequestPayload Element orderElement) {
  Order order = createOrder(orderElement);
  orderService.createOrder(order);
}</pre><p>
                The <code class="methodname">order</code> method takes a <code class="interfacename">Element</code>
                as a parameter, annotated with <code class="interfacename">@RequestPayload</code>.
                This means that the payload of the message is passed on this method as a DOM element.
                The method has a <code class="literal">void</code> return type, indicating that no response message
                is sent.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1137" href="#d5e1137"></a>Handling method parameters</h4></div></div></div>
                
                <p>
                    The handling method typically has one or more parameters that refer to various parts of the
                    incoming XML message.
                    Most commonly, the handling method will have a single parameter that will map to the payload of
                    the message, but it is also possible to map to other parts of the request message, such as a SOAP
                    header.
                    This section will describe the parameters you can use in your handling method signatures.
                </p>
                <p>
                    To map a parameter to the payload of the request message, you will need to annotate this parameter
                    with the <code class="interfacename">@RequestPayload</code> annotation.
                    This annotation tells Spring-WS that the parameter needs to be bound to the request payload.
                </p>
                <p>
                    The following table describes the supported parameter types.
                    It shows the supported types, whether the parameter should be annotated with
                    <code class="interfacename">@RequestPayload</code>, and any additional notes.
                    </p><div class="informaltable">
                        <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Supported parameter types</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">@RequestPayload</code> required?</th><th style="border-bottom: 0.5pt solid ; ">Additional notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">TrAX</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <code class="interfacename">javax.xml.transform.Source</code> and sub-interfaces
                                        (<code class="interfacename">DOMSource</code>, <code class="interfacename">SAXSource</code>,
                                        <code class="interfacename">StreamSource</code>, and <code class="interfacename">StAXSource</code>)
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">W3C DOM</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">org.w3c.dom.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">dom4j</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">org.dom4j.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when dom4j is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">JDOM</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">org.jdom.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when JDOM is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">XOM</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">nu.xom.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when XOM is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">StAX</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <code class="interfacename">javax.xml.stream.XMLStreamReader</code> and
                                        <code class="interfacename">javax.xml.stream.XMLEventReader</code>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when StAX is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">XPath</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        Any boolean, double, <code class="classname">String</code>,
                                        <code class="interfacename">org.w3c.Node</code>,
                                        <code class="interfacename">org.w3c.dom.NodeList</code>, or
                                        type that can be converted from a <code class="classname">String</code> by a Spring 3
                                        <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/validation.html#core-convert" target="_top">conversion service</a>,
                                        and that is annotated with <code class="interfacename">@XPathParam</code>.
                                   </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">No</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default, see <a class="xref" href="#server-xpath-param" title="@XPathParam">the section called &#8220;<code class="interfacename">@XPathParam</code>&#8221;</a>.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Message context</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">org.springframework.ws.context.MessageContext</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">No</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">SOAP</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <code class="interfacename">org.springframework.ws.soap.SoapMessage</code>,
                                        <code class="interfacename">org.springframework.ws.soap.SoapBody</code>,
                                        <code class="interfacename">org.springframework.ws.soap.SoapEnvelope</code>,
                                        <code class="interfacename">org.springframework.ws.soap.SoapHeader</code>, and
                                        <code class="interfacename">org.springframework.ws.soap.SoapHeaderElement</code>s
                                        when used in combination with the <code class="interfacename">@SoapHeader</code>
                                        annotation.
                                   </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">No</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">JAXB2</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        Any type that is annotated with
                                        <code class="interfacename">javax.xml.bind.annotation.XmlRootElement</code>,
                                        and <code class="classname">javax.xml.bind.JAXBElement</code>.
                                   </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when JAXB2 is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; " align="center">OXM</td><td style="border-right: 0.5pt solid ; ">
                                        Any type supported by a Spring OXM
                                        <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/oxm.html#d0e26164" target="_top"><code class="interfacename">Unmarshaller</code></a>.
                                   </td><td style="border-right: 0.5pt solid ; " align="center">Yes</td><td style="">
                                        Enabled when the <code class="literal">unmarshaller</code> attribute of
                                        <code class="literal">&lt;sws:annotation-driven/&gt;</code> is specified.
                                    </td></tr></tbody></table>
                    </div><p>
                </p>
                <p>
                    Here are some examples of possible method signatures:
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            </p><pre class="programlisting">public void handle(@RequestPayload Element element)</pre><p>
                            This method will be invoked with the payload of the request message as a DOM
                            <code class="interfacename">org.w3c.dom.Element</code>.
                        </p></li><li class="listitem"><p>
                            </p><pre class="programlisting">public void handle(@RequestPayload DOMSource domSource, SoapHeader header)</pre><p>
                            This method will be invoked with the payload of the request message as a
                            <code class="interfacename">javax.xml.transform.dom.DOMSource</code>.
                            The <em class="parameter"><code>header</code></em> parameter will be bound to the SOAP header of the request
                            message.
                        </p></li><li class="listitem"><p>
                            </p><pre class="programlisting">public void handle(@RequestPayload MyJaxb2Object requestObject, @RequestPayload Element element, Message messageContext)</pre><p>
                            This method will be invoked with the payload of the request message unmarshalled into
                            a <code class="classname">MyJaxb2Object</code> (which is annotated with
                            <code class="interfacename">@XmlRootElement</code>).
                            The payload of the message is also given as a DOM <code class="interfacename">Element</code>.
                            The whole <a class="link" href="#message-context" title="4.1.4&nbsp;MessageContext">message context</a> is passed on as the
                            third parameter.
                        </p></li></ul></div><p>
                    As you can see, there are a lot of possibilities when it comes to defining handling method
                    signatures.
                    It is even possible to extend this mechanism, and to support your own parameter types.
                    Refer to the class-level Javadoc of <code class="classname">DefaultMethodEndpointAdapter</code> and
                    <code class="interfacename">MethodArgumentResolver</code> to see how.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="server-xpath-param" href="#server-xpath-param"></a><code class="interfacename">@XPathParam</code></h5></div></div></div>
                    
                    <p>
                        One parameter type needs some extra explanation: <code class="interfacename">@XPathParam</code>.
                        The idea here is that you simply annotate one or more method
                        parameter with an XPath expression, and that each such annotated parameter will be bound to the
                        evaluation of the expression.
                        Here is an example:
                    </p>
                    <a name="server-payload-root-annotation" href="#server-payload-root-annotation"></a><pre class="programlisting">package samples;

import javax.xml.transform.Source;

import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.Namespace;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.XPathParam;

@Endpoint
public class AnnotationOrderEndpoint {

  private final OrderService orderService;

  public AnnotationOrderEndpoint(OrderService orderService) {
    this.orderService = orderService;
  }

  @PayloadRoot(localPart = "orderRequest", namespace = "http://samples")
  <span class="bold"><strong>@Namespace(prefix = "s", uri="http://samples")</strong></span>
  public Order getOrder(<span class="bold"><strong>@XPathParam("/s:orderRequest/@id") int orderId</strong></span>) {
    Order order = orderService.getOrder(orderId);
    <em class="lineannotation"><span class="lineannotation">// create <code class="interfacename">Source</code> from order and return it</span></em>
}

}</pre>
                    <p>
                        Since we use the prefix '<code class="literal">s</code>' in our XPath expression, we must bind it to the
                        <code class="uri">http://samples</code> namespace.
                        This is accomplished with the <code class="interfacename">@Namespace</code> annotation.
                        Alternatively, we could have placed this annotation on the type-level to use the same namespace
                        mapping for all handler methods, or even the package-level
                        (in <code class="filename">package-info.java</code>) to use it for multiple endpoints.
                    </p>
                    <p>
                        Using the <code class="interfacename">@XPathParam</code>, you can bind to all the data types
                        supported by XPath:
                        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="type">boolean</span> or <code class="classname">Boolean</code></p></li><li class="listitem"><p><span class="type">double</span> or <code class="classname">Double</code></p></li><li class="listitem"><p><code class="classname">String</code></p></li><li class="listitem"><p><code class="interfacename">Node</code></p></li><li class="listitem"><p><code class="interfacename">NodeList</code></p></li></ul></div><p>
                        In addition to this list, you can use any type that can be converted from a
                        <code class="classname">String</code> by a Spring 3
                        <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/validation.html#core-convert" target="_top">conversion service</a>.
                    </p>
                </div>

            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1297" href="#d5e1297"></a>Handling method return types</h4></div></div></div>
                
                <p>
                    To send a response message, the handling needs to specify a return type.
                    If no response message is required, the method can simply declare a <code class="literal">void</code> return
                    type.
                    Most commonly, the return type is used to create the payload of the response message, but it is
                    also possible to map to other parts of the response message.
                    This section will describe the return types you can use in your handling method signatures.
                </p>
                <p>
                    To map the return value to the payload of the response message, you will need to annotate the
                    method with the <code class="interfacename">@ResponsePayload</code> annotation.
                    This annotation tells Spring-WS that the return value needs to be bound to the response payload.
                </p>
                <p>
                    The following table describes the supported return types.
                    It shows the supported types, whether the parameter should be annotated with
                    <code class="interfacename">@ResponsePayload</code>, and any additional notes.
                    </p><div class="informaltable">
                        <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Name</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Supported return types</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">@ResponsePayload</code> required?</th><th style="border-bottom: 0.5pt solid ; ">Additional notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">No response</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <code class="literal">void</code>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">No</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">TrAX</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <code class="interfacename">javax.xml.transform.Source</code> and sub-interfaces
                                        (<code class="interfacename">DOMSource</code>, <code class="interfacename">SAXSource</code>,
                                        <code class="interfacename">StreamSource</code>, and <code class="interfacename">StAXSource</code>)
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">W3C DOM</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">org.w3c.dom.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled by default</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">dom4j</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="interfacename">org.dom4j.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when dom4j is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">JDOM</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">org.jdom.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when JDOM is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">XOM</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">nu.xom.Element</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when XOM is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">JAXB2</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        Any type that is annotated with
                                        <code class="interfacename">javax.xml.bind.annotation.XmlRootElement</code>,
                                        and <code class="classname">javax.xml.bind.JAXBElement</code>.
                                   </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Yes</td><td style="border-bottom: 0.5pt solid ; ">Enabled when JAXB2 is on the classpath.</td></tr><tr><td style="border-right: 0.5pt solid ; " align="center">OXM</td><td style="border-right: 0.5pt solid ; ">
                                        Any type supported by a Spring OXM
                                        <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/oxm.html#d0e26096" target="_top"><code class="interfacename">Marshaller</code></a>.
                                   </td><td style="border-right: 0.5pt solid ; " align="center">Yes</td><td style="">
                                        Enabled when the <code class="literal">marshaller</code> attribute of
                                        <code class="literal">&lt;sws:annotation-driven/&gt;</code> is specified.
                                    </td></tr></tbody></table>
                    </div><p>
                </p>
                <p>
                    As you can see, there are a lot of possibilities when it comes to defining handling method
                    signatures.
                    It is even possible to extend this mechanism, and to support your own parameter types.
                    Refer to the class-level Javadoc of <code class="classname">DefaultMethodEndpointAdapter</code> and
                    <code class="interfacename">MethodReturnValueHandler</code> to see how.
                </p>
            </div>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="server-endpoint-mapping" href="#server-endpoint-mapping"></a>5.5&nbsp;Endpoint mappings</h2></div></div></div>
        
        <p>
            The endpoint mapping is responsible for mapping incoming messages to appropriate endpoints.
            There are some endpoint mappings that are enabled out of the box, for example, the
            <code class="classname">PayloadRootAnnotationMethodEndpointMapping</code> or the
            <code class="classname">SoapActionAnnotationMethodEndpointMapping</code>, but let's first examine the general
            concept of an <code class="interfacename">EndpointMapping</code>.
        </p>
        <p>
            An <code class="interfacename">EndpointMapping</code> delivers a <code class="classname">EndpointInvocationChain</code>,
            which contains the endpoint that matches the incoming request, and may also contain a list of endpoint
            interceptors that will be applied to the request and response.
            When a request comes in, the <code class="classname">MessageDispatcher</code> will hand it over to the endpoint
            mapping to let it inspect the request and come up with an appropriate
            <code class="classname">EndpointInvocationChain</code>.
            Then the <code class="classname">MessageDispatcher</code> will invoke the endpoint and any interceptors in the
            chain.
        </p>
        <p>
            The concept of configurable endpoint mappings that can optionally contain interceptors (which can manipulate
            the request or the response, or both) is extremely powerful.
            A lot of supporting functionality can be built into custom <code class="interfacename">EndpointMapping</code>s.
            For example, there could be a custom endpoint mapping that chooses an endpoint not only based on the
            contents of a message, but also on a specific SOAP header (or indeed multiple SOAP headers).
        </p>
        <p>
            Most endpoint mappings inherit from the <code class="classname">AbstractEndpointMapping</code>, which offers an
            '<span class="property">interceptors</span>' property, which is the list of interceptors to use.
            <code class="interfacename">EndpointInterceptors</code> are discussed in
            <a class="xref" href="#server-endpoint-interceptor" title="5.5.2&nbsp;Intercepting requests - the EndpointInterceptor interface">Section&nbsp;5.5.2, &#8220;Intercepting requests - the <code class="interfacename">EndpointInterceptor</code> interface&#8221;</a>.
            Additionally, there is the '<span class="property">defaultEndpoint</span>', which is the default endpoint to use
            when this endpoint mapping does not result in a matching endpoint.
        </p>
        <p>
            As explained in <a class="xref" href="#server-endpoints" title="5.4&nbsp;Endpoints">Section&nbsp;5.4, &#8220;Endpoints&#8221;</a>, the <code class="interfacename">@Endpoint</code> style
            allows you to handle multiple requests in one endpoint class.
            This is the responsibility of the <code class="classname">MethodEndpointMapping</code>.
            This mapping determines which method is to be invoked for an incoming request message.
        </p>
        <p>
            There are two endpoint mappings that can direct requests to methods: the
            <code class="classname">PayloadRootAnnotationMethodEndpointMapping</code> and the
            <code class="classname">SoapActionAnnotationMethodEndpointMapping</code>, both of which are enabled by using
            <code class="literal">&lt;sws:annotation-driven/&gt;</code> in your application context.
        </p>
        <p>
            The <code class="classname">PayloadRootAnnotationMethodEndpointMapping</code> uses the
            <code class="interfacename">@PayloadRoot</code> annotation, with the <code class="literal">localPart</code> and
            <code class="literal">namespace</code> elements, to mark methods with a particular qualified
            name.
            Whenever a message comes in which has this qualified name for the payload root element, the
            method will be invoked.
            For an example, see <a class="link" href="#server-payload-root-annotation">above</a>.
        </p>
        <p>
            Alternatively, the <code class="classname">SoapActionAnnotationMethodEndpointMapping</code> uses the
            <code class="interfacename">@SoapAction</code> annotation to mark methods with a particular SOAP Action.
            Whenever a message comes in which has this <code class="literal">SOAPAction</code> header, the
            method will be invoked.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-ws-addressing" href="#server-ws-addressing"></a>5.5.1&nbsp;WS-Addressing</h3></div></div></div>
            
            <p>
                WS-Addressing specifies a transport-neutral routing mechanism.
                It is based on a <code class="literal">To</code> and <code class="literal">Action</code> SOAP header, which indicate the
                destination and intent of the SOAP message, respectively.
                Additionally, WS-Addressing allows you to define a return address (for normal messages and for faults),
                and a unique message identifier which can be used for correlation
                <a href="#ftn.d5e1417" class="footnote" name="d5e1417"><sup class="footnote">[2]</sup></a>.
                Here is an example of a WS-Addressing message:
                </p><pre class="programlisting">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope"
    xmlns:wsa="http://www.w3.org/2005/08/addressing"&gt;
  &lt;SOAP-ENV::Header&gt;
    &lt;wsa:MessageID&gt;urn:uuid:21363e0d-2645-4eb7-8afd-2f5ee1bb25cf&lt;/wsa:MessageID&gt;
    &lt;wsa:ReplyTo&gt;
      &lt;wsa:Address&gt;http://example.com/business/client1&lt;/wsa:Address&gt;
    &lt;/wsa:ReplyTo&gt;
    &lt;wsa:To S:mustUnderstand="true"&gt;http://example/com/fabrikam&lt;/wsa:To&gt;
    &lt;wsa:Action&gt;http://example.com/fabrikam/mail/Delete&lt;/wsa:Action&gt;
  &lt;/SOAP-ENV:Header&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;f:Delete xmlns:f="http://example.com/fabrikam"&gt;
      &lt;f:maxCount&gt;42&lt;/f:maxCount&gt;
    &lt;/f:Delete&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre><p>
                In this example, the destination is set to <code class="uri">http://example/com/fabrikam</code>, while the action is
                set to <code class="uri">http://example.com/fabrikam/mail/Delete</code>.
                Additionally, there is a message identifier, and an reply-to address.
                By default, this address is the "anonymous" address, indicating that a response should be sent using
                the same channel as the request (i.e. the HTTP response), but it can also be another address,
                as indicated in this example.
            </p>
            <p>
                In Spring Web Services, WS-Addressing is implemented as an endpoint mapping.
                Using this mapping, you associate WS-Addressing actions with endpoints, similar to the
                <code class="classname">SoapActionAnnotationMethodEndpointMapping</code> described above.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1425" href="#d5e1425"></a><code class="classname">AnnotationActionEndpointMapping</code></h4></div></div></div>
                
                <p>
                    The <code class="classname">AnnotationActionEndpointMapping</code> is similar to the
                    <code class="classname">SoapActionAnnotationMethodEndpointMapping</code>, but uses WS-Addressing headers
                    instead of the SOAP Action transport header.
                </p>
                <p>
                    To use the <code class="classname">AnnotationActionEndpointMapping</code>, annotate the handling methods
                    with the <code class="interfacename">@Action</code> annotation, similar to the
                    <code class="interfacename">@PayloadRoot</code> and <code class="interfacename">@SoapAction</code>
                    annotations described in <a class="xref" href="#server-atEndpoint-methods" title="5.4.1&nbsp;@Endpoint handling methods">Section&nbsp;5.4.1, &#8220;<code class="interfacename">@Endpoint</code> handling methods&#8221;</a> and
                    <a class="xref" href="#server-endpoint-mapping" title="5.5&nbsp;Endpoint mappings">Section&nbsp;5.5, &#8220;Endpoint mappings&#8221;</a>. Here is an example:
                    </p><pre class="programlisting">package samples;

import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.soap.addressing.server.annotation.Action

@Endpoint
public class AnnotationOrderEndpoint {
    private final OrderService orderService;

    public AnnotationOrderEndpoint(OrderService orderService) {
        this.orderService = orderService;
    }

    @Action("http://samples/RequestOrder")
    public Order getOrder(OrderRequest orderRequest) {
        return orderService.getOrder(orderRequest.getId());
    }

    @Action("http://samples/CreateOrder")
    public void order(Order order) {
        orderService.createOrder(order);
    }

}</pre><p>
                </p>
                <p>
                    The mapping above routes requests which have a WS-Addressing <code class="literal">Action</code> of
                    <code class="uri">http://samples/RequestOrder</code> to the <code class="methodname">getOrder</code> method.
                    Requests with <code class="uri">http://samples/CreateOrder</code> will be routed to the
                    <code class="methodname">order</code> method..
                </p>
                <p>
                    By default, the <code class="classname">AnnotationActionEndpointMapping</code> supports both the 1.0
                    (May 2006), and the August 2004 editions of WS-Addressing. These two versions are most popular, and
                    are interoperable with Axis 1 and 2, JAX-WS, XFire, Windows Communication Foundation (WCF), and
                    Windows Services Enhancements (WSE) 3.0.
                    If necessary, specific versions of the spec can be injected into the
                    <span class="property">versions</span> property.
                </p>
                <p>
                    In addition to the <code class="interfacename">@Action</code> annotation, you can annotate the class
                    with the <code class="interfacename">@Address</code> annotation. If set, the value is compared to the
                    <code class="literal">To</code> header property of the incoming message.
                </p>
                <p>
                    Finally, there is the <span class="property">messageSenders</span> property, which is required for sending
                    response messages to non-anonymous, out-of-bound addresses. You can set <code class="interfacename">MessageSender</code>
                    implementations in this property, the same as you would on the <code class="classname">WebServiceTemplate</code>.
                    See <a class="xref" href="#client-transports" title="URIs and Transports">the section called &#8220;URIs and Transports&#8221;</a>.
                </p>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-endpoint-interceptor" href="#server-endpoint-interceptor"></a>5.5.2&nbsp;Intercepting requests - the <code class="interfacename">EndpointInterceptor</code> interface</h3></div></div></div>
            
            <p>
                The endpoint mapping mechanism has the notion of endpoint interceptors. These can be extremely useful
                when you want to apply specific functionality to certain requests, for example, dealing with
                security-related SOAP headers, or the logging of request and response message.
            </p>
            <p>
                Endpoint interceptors are typically defined by using a <code class="literal">&lt;sws:interceptors&gt;</code>
                element in your application context.
                In this element, you can simply define endpoint interceptor beans that apply to all endpoints defined
                in that application context.
                Alternatively, you can use <code class="literal">&lt;sws:payloadRoot&gt;</code> or
                <code class="literal">&lt;sws:soapAction&gt;</code> elements to specify for which payload root name or SOAP
                action the interceptor should apply.
                For example:
                </p><pre class="programlisting">&lt;sws:interceptors&gt;
  &lt;bean class="samples.MyGlobalInterceptor"/&gt;
  &lt;sws:payloadRoot namespaceUri="http://www.example.com"&gt;
    &lt;bean class="samples.MyPayloadRootInterceptor"/&gt;
  &lt;/sws:payloadRoot&gt;
  &lt;sws:soapAction value="http://www.example.com/SoapAction"&gt;
    &lt;bean class="samples.MySoapActionInterceptor1"/&gt;
    &lt;ref bean="mySoapActionInterceptor2"/&gt;
  &lt;/sws:soapAction&gt;
&lt;/sws:interceptors&gt;

&lt;bean id="mySoapActionInterceptor2" class="samples.MySoapActionInterceptor2"/&gt;</pre><p>
                Here, we define one 'global' interceptor (<code class="classname">MyGlobalInterceptor</code>) that intercepts
                all request and responses.
                We also define an interceptor that only applies to XML messages that have the
                <code class="uri">http://www.example.com</code> as a payload root namespace.
                Here, we could have defined a <code class="literal">localPart</code> attribute in addition to the
                <code class="literal">namespaceUri</code> to further limit the messages the interceptor applies to.
                Finally, we define two interceptors that apply when the message has a
                <code class="uri">http://www.example.com/SoapAction</code> SOAP action. Notice how the second interceptor
                is actually a reference to a bean definition outside of the <code class="literal">&lt;interceptors&gt;</code>
                element. You can use bean references anywhere inside the <code class="literal">&lt;interceptors&gt;</code> element.
            </p>
            <p>
                When using <code class="interfacename">@Configuration</code> classes, you can extend from
                <code class="classname">WsConfigurerAdapter</code> to add interceptors.
                Like so:</p><pre class="programlisting">@Configuration
@EnableWs
public class MyWsConfiguration extends WsConfigurerAdapter {

  @Override
  public void addInterceptors(List&lt;EndpointInterceptor&gt; interceptors) {
    interceptors.add(new MyPayloadRootInterceptor());
  }

}</pre><p>
            </p>
            <p>
                Interceptors must implement the
                <code class="interfacename">EndpointInterceptor</code> interface from the
                <span class="package">org.springframework.ws.server</span> package. This interface defines three methods, one that
                can be used for handling the request message <span class="emphasis"><em>before</em></span> the actual
                endpoint will be executed, one that can be used for handling a normal response message, and one that
                can be used for handling fault messages, both of which will be called <span class="emphasis"><em>after</em></span> the
                endpoint is executed. These three methods should provide enough flexibility to do all kinds of
                pre- and post-processing.
            </p>
            <p>
                The <code class="methodname">handleRequest(..)</code> method on the interceptor returns a boolean value. You
                can use this method to interrupt or continue the processing of the invocation chain. When this method
                returns <code class="literal">true</code>, the endpoint execution chain will continue, when it returns
                <code class="literal">false</code>, the <code class="classname">MessageDispatcher</code> interprets this to mean that
                the interceptor itself
                has taken care of things and does not continue executing the other interceptors and the actual endpoint
                in the invocation chain. The <code class="methodname">handleResponse(..)</code> and
                <code class="methodname">handleFault(..)</code> methods also have a boolean return value. When these methods
                return <code class="literal">false</code>, the response will not be sent back to the client.
            </p>
            <p>
                There are a number of standard <code class="interfacename">EndpointInterceptor</code> implementations you
                can use in your Web service. Additionally, there is the <code class="classname">XwsSecurityInterceptor</code>,
                which is described in <a class="xref" href="#security-xws-security-interceptor" title="7.2&nbsp; XwsSecurityInterceptor">Section&nbsp;7.2, &#8220;
            <code class="classname">XwsSecurityInterceptor</code>
        &#8221;</a>.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1494" href="#d5e1494"></a><code class="classname">PayloadLoggingInterceptor</code> and
                    <code class="classname">SoapEnvelopeLoggingInterceptor</code></h4></div></div></div>
                
                <p>
                    When developing a Web service, it can be useful to log the incoming and outgoing XML messages.
                    SWS facilitates this with the <code class="classname">PayloadLoggingInterceptor</code> and
                    <code class="classname">SoapEnvelopeLoggingInterceptor</code> classes. The former logs just the payload of
                    the message to the Commons Logging Log; the latter logs the entire SOAP envelope, including SOAP
                    headers. The following example shows you how to define them in an endpoint mapping:
                </p>
                <pre class="programlisting">
  &lt;sws:interceptors&gt;
    &lt;bean class="org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor"/&gt;
  &lt;/sws:interceptors&gt;</pre>
                <p>
                    Both of these interceptors have two properties: '<span class="property">logRequest</span>' and
                    '<span class="property">logResponse</span>', which can be set to <code class="literal">false</code> to disable logging
                    for either request or response messages.
                </p>
                <p>
                    Of course, you could use the <code class="classname">WsConfigurerAdapter</code> approach, as described above,
                    for the <code class="classname">PayloadLoggingInterceptor</code> as well.
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1509" href="#d5e1509"></a><code class="classname">PayloadValidatingInterceptor</code></h4></div></div></div>
                
                <p>
                    One of the benefits of using a contract-first development style is that we can use the schema to
                    validate incoming and outgoing XML messages. Spring-WS facilitates this with the
                    <code class="classname">PayloadValidatingInterceptor</code>. This interceptor requires a reference to one
                    or more W3C XML or RELAX NG schemas, and can be set to validate requests or responses, or both.
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                    <p>
                        Note that request validation may sound like a good idea, but makes the resulting Web service
                        very strict. Usually, it is not really important whether the request validates, only if the
                        endpoint can get sufficient information to fullfill a request. Validating the response
                        <span class="emphasis"><em>is</em></span> a good idea, because the endpoint should adhere to its schema.
                        Remember Postel's Law:
                        <span class="quote">&#8220;<span class="quote">Be conservative in what you do; be liberal in what you accept from others.</span>&#8221;</span>
                    </p>
                </td></tr></table></div>
                <p>
                    Here is an example that uses the <code class="classname">PayloadValidatingInterceptor</code>; in this
                    example, we use the schema in <code class="filename">/WEB-INF/orders.xsd</code> to validate the response, but
                    not the request. Note that the <code class="classname">PayloadValidatingInterceptor</code> can also accept
                    multiple schemas using the <span class="property">schemas</span> property.
                </p>
                <pre class="programlisting">&lt;bean id="validatingInterceptor"
        class="org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor"&gt;
    &lt;property name="schema" value="/WEB-INF/orders.xsd"/&gt;
    &lt;property name="validateRequest" value="false"/&gt;
    &lt;property name="validateResponse" value="true"/&gt;
&lt;/bean&gt;</pre>
                <p>
                    Of course, you could use the <code class="classname">WsConfigurerAdapter</code> approach, as described above,
                    for the <code class="classname">PayloadValidatingInterceptor</code> as well.
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1527" href="#d5e1527"></a><code class="classname">PayloadTransformingInterceptor</code></h4></div></div></div>
                
                <p>
                    To transform the payload to another XML format, Spring Web Services offers the
                    <code class="classname">PayloadTransformingInterceptor</code>. This endpoint interceptor is based on XSLT
                    style sheets, and is especially useful when supporting multiple versions of a Web service:
                    you can transform the older message format to the newer format. Here is an example to use the
                    <code class="classname">PayloadTransformingInterceptor</code>:
                </p>
                <pre class="programlisting">&lt;bean id="transformingInterceptor"
        class="org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptor"&gt;
    &lt;property name="requestXslt" value="/WEB-INF/oldRequests.xslt"/&gt;
    &lt;property name="responseXslt" value="/WEB-INF/oldResponses.xslt"/&gt;
&lt;/bean&gt;</pre>
                <p>
                    We are simply transforming requests using <code class="filename">/WEB-INF/oldRequests.xslt</code>, and
                    response messages using <code class="filename">/WEB-INF/oldResponses.xslt</code>. Note that, since
                    endpoint interceptors are registered at the endpoint mapping level, you can simply create a
                    endpoint mapping that applies to the "old style" messages, and add the interceptor to that mapping.
                    Hence, the transformation will apply only to these "old style" message.
                </p>
                <p>
                    Of course, you could use the <code class="classname">WsConfigurerAdapter</code> approach, as described above,
                    for the <code class="classname">PayloadTransformingInterceptor</code> as well.
                </p>
            </div>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="server-endpoint-exception-resolver" href="#server-endpoint-exception-resolver"></a>5.6&nbsp;Handling Exceptions</h2></div></div></div>
        
        <p>
            Spring-WS provides <code class="classname">EndpointExceptionResolvers</code> to ease the pain of unexpected
            exceptions occurring while your message is being processed by an endpoint which matched the request.
            Endpoint exception resolvers somewhat resemble the exception mappings that can be
            defined in the web application descriptor <code class="filename">web.xml</code>.
            However, they provide a more flexible way to handle exceptions. They provide information about what
            endpoint was invoked when the exception was thrown. Furthermore, a programmatic way of handling exceptions
            gives you many more options for how to respond appropriately. Rather than expose the innards of your
            application by giving an exception and stack trace, you can handle the exception any way you want, for
            example by returning a SOAP fault with a specific fault code and string.
        </p>
        <p>
            Endpoint exception resolvers are automatically picked up by the <code class="classname">MessageDispatcher</code>,
            so no explicit configuration is necessary.
        </p>
        <p>
            Besides implementing the <code class="classname">EndpointExceptionResolver</code> interface, which is only a
            matter of implementing the <code class="methodname">resolveException(MessageContext, endpoint, Exception)</code>
            method, you may also use one of the provided implementations.
            The simplest implementation is the <code class="classname">SimpleSoapExceptionResolver</code>, which just
            creates a SOAP 1.1 Server or SOAP 1.2 Receiver Fault, and uses the exception message as the fault string.
            The <code class="classname">SimpleSoapExceptionResolver</code> is the default, but it can be overriden by
            explicitly adding another resolver.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1552" href="#d5e1552"></a>5.6.1&nbsp;<code class="classname">SoapFaultMappingExceptionResolver</code></h3></div></div></div>
            
            <p>
                The <code class="classname">SoapFaultMappingExceptionResolver</code> is a more sophisticated implementation.
                This resolver enables you to take the class name of any exception that might be thrown and map it to a
                SOAP Fault, like so:
            </p>
            <pre class="programlisting">&lt;beans&gt;
    &lt;bean id="exceptionResolver"
        class="org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver"&gt;
        &lt;property name="defaultFault" value="SERVER"/&gt;
        &lt;property name="exceptionMappings"&gt;
            &lt;value&gt;
                org.springframework.oxm.ValidationFailureException=CLIENT,Invalid request
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre>
            <p>
                The key values and default endpoint use the format <code class="literal">faultCode,faultString,locale</code>, where
                only the fault code is required. If the fault string is not set, it will default to the exception message.
                If the language is not set, it will default to English. The above configuration will map exceptions of
                type <code class="classname">ValidationFailureException</code> to a client-side SOAP Fault with a fault string
                <code class="literal">"Invalid request"</code>, as can be seen in the following response:
            </p>
            <pre class="programlisting">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;SOAP-ENV:Body&gt;<span class="bold"><strong>
       &lt;SOAP-ENV:Fault&gt;
           &lt;faultcode&gt;SOAP-ENV:Client&lt;/faultcode&gt;
           &lt;faultstring&gt;Invalid request&lt;/faultstring&gt;
       &lt;/SOAP-ENV:Fault&gt;</strong></span>
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
            <p>
                If any other exception occurs, it will return the default fault: a server-side fault with the exception
                message as fault string.
            </p>
            </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1565" href="#d5e1565"></a>5.6.2&nbsp;<code class="classname">SoapFaultAnnotationExceptionResolver</code></h3></div></div></div>
            
            <p>
                Finally, it is also possible to annotate exception classes with the
                <code class="interfacename">@SoapFault</code> annotation, to indicate the SOAP Fault that should be returned
                whenever that exception is thrown. In order for these annotations to be picked up, you need to add the
                <code class="classname">SoapFaultAnnotationExceptionResolver</code> to your application context.
                The elements of the annotation include a fault code enumeration, fault string or reason, and language.
                Here is an example exception:
            </p>
            <pre class="programlisting">package samples;

import org.springframework.ws.soap.server.endpoint.annotation.FaultCode;
import org.springframework.ws.soap.server.endpoint.annotation.SoapFault;

@SoapFault(faultCode = FaultCode.SERVER)
public class MyBusinessException extends Exception {

    public MyClientException(String message) {
        super(message);
    }
}</pre>
            <p>
            </p>
            <p>
                Whenever the <code class="classname">MyBusinessException</code> is thrown with the constructor string
                <code class="literal">"Oops!"</code> during endpoint invocation, it will result in the following response:
            </p>
            <pre class="programlisting">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;SOAP-ENV:Body&gt;
       &lt;SOAP-ENV:Fault&gt;
           &lt;faultcode&gt;SOAP-ENV:Server&lt;/faultcode&gt;
           &lt;faultstring&gt;Oops!&lt;/faultstring&gt;
       &lt;/SOAP-ENV:Fault&gt;
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
            </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1577" href="#d5e1577"></a>5.7&nbsp;Server-side testing</h2></div></div></div>
        
        <p>
            When it comes to testing your Web service endpoints, there are two possible approaches:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    Write <span class="emphasis"><em>Unit Tests</em></span>, where you provide (mock) arguments for your endpoint to
                    consume.
                </p>
                <p>
                    The advantage of this approach is that it's quite easy to accomplish (especially for classes
                    annotated with <code class="interfacename">@Endpoint</code>); the disadvantage is that
                    you are not really testing the exact content of the XML messages that are sent over the wire.
                </p>
            </li><li class="listitem">
                <p>
                    Write <span class="emphasis"><em>Integrations Tests</em></span>, which do test the contents of the message.
                </p>
            </li></ul></div>
        <p>
            The first approach can easily be accomplished with mocking frameworks such as EasyMock, JMock, etc.
            The next section will focus on writing integration tests, using the test features introduced in Spring
            Web Services 2.0.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1590" href="#d5e1590"></a>5.7.1&nbsp;Writing server-side integration tests</h3></div></div></div>
            
            <p>
                Spring Web Services 2.0 introduced support for creating endpoint integration tests.
                In this context, an endpoint is class handles (SOAP) messages (see <a class="xref" href="#server-endpoints" title="5.4&nbsp;Endpoints">Section&nbsp;5.4, &#8220;Endpoints&#8221;</a>).
            </p>
            <p>
                The integration test support lives in the <span class="package">org.springframework.ws.test.server</span> package.
                The core class in that package is the <code class="classname">MockWebServiceClient</code>.
                The underlying idea is that this client creates a request message, and then sends it over to the
                endpoint(s) that are configured in a standard <code class="classname">MessageDispatcherServlet</code>
                application context (see <a class="xref" href="#message-dispatcher-servlet" title="5.3.1&nbsp;MessageDispatcherServlet">Section&nbsp;5.3.1, &#8220;<code class="classname">MessageDispatcherServlet</code>&#8221;</a>).
                These endpoints will handle the message, and create a response.
                The client then receives this response, and verifies it against registered expectations.
            </p>
            <p>
                The typical usage of the <code class="classname">MockWebServiceClient</code> is:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                        <p>
                            Create a <code class="classname">MockWebServiceClient</code> instance by calling
                            <code class="methodname">MockWebServiceClient.createClient(ApplicationContext)</code> or
                            <code class="methodname">MockWebServiceClient.createClient(WebServiceMessageReceiver, WebServiceMessageFactory)</code>.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Send request messages by calling <code class="methodname">sendRequest(RequestCreator)</code>,
                            possibly by using the default <code class="interfacename">RequestCreator</code> implementations
                            provided in <code class="classname">RequestCreators</code> (which can be statically imported).
                        </p>
                    </li><li class="listitem">
                        <p>
                            Set up response expectations by calling <code class="methodname">andExpect(ResponseMatcher)</code>,
                            possibly by using the default <code class="interfacename">ResponseMatcher</code> implementations
                            provided in <code class="classname">ResponseMatchers</code> (which can be statically imported).
                            Multiple expectations can be set up by chaining
                            <code class="methodname">andExpect(ResponseMatcher)</code> calls.
                        </p>
                    </li></ol></div><p>
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                <p>
                    Note that the <code class="classname">MockWebServiceClient</code> (and related classes) offers a
                    'fluent' API, so you can typically use the Code Completion features (i.e. ctrl-space) in your IDE
                    to guide you through the process of setting up the mock server.
                </p>
            </td></tr></table></div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                <p>
                    Also note that you rely on the standard logging features available in Spring Web Services in your
                    unit tests.
                    Sometimes it might be useful to inspect the request or response message to find out why a
                    particular tests failed.
                    See <a class="xref" href="#logging" title="4.4&nbsp;Message Logging and Tracing">Section&nbsp;4.4, &#8220;Message Logging and Tracing&#8221;</a> for more information.
                </p>
            </td></tr></table></div>
            <p>
                Consider, for example, this simple Web service endpoint class:
            </p>
            <div class="programlistingco"><pre class="programlisting">import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;
import org.springframework.ws.server.endpoint.annotation.ResponsePayload;

@Endpoint                                                                                                              <span class="co" id="server.test.endpoint.annotation"><img src="images/callouts/1.png" alt="(1)"></span>
public class CustomerEndpoint {

  @ResponsePayload                                                                                                     <span class="co" id="server.test.endpoint.method.responsePayload"><img src="images/callouts/2.png" alt="(2)"></span>
  public CustomerCountResponse getCustomerCount(                                                                       <span class="co" id="server.test.endpoint.method.method"><img src="images/callouts/2.png" alt="(2)"></span>
      @RequestPayload CustomerCountRequest request) {                                                                  <span class="co" id="server.test.endpoint.method.requestPayload"><img src="images/callouts/2.png" alt="(2)"></span>
    CustomerCountResponse response = new CustomerCountResponse();
    response.setCustomerCount(10);
    return response;
  }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">CustomerEndpoint</code> in annotated with
                            <code class="interfacename">@Endpoint</code>.
                            See <a class="xref" href="#server-endpoints" title="5.4&nbsp;Endpoints">Section&nbsp;5.4, &#8220;Endpoints&#8221;</a>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="methodname">getCustomerCount()</code> method takes a
                            <code class="classname">CustomerCountRequest</code> as argument, and returns a
                            <code class="classname">CustomerCountResponse</code>.
                            Both of these classes are objects supported by a marshaller.
                            For instance, they can have a <code class="interfacename">@XmlRootElement</code> annotation
                            to be supported by JAXB2.
                        </p>
                    </td></tr></table></div></div>
            <p>
                A typical test for <code class="classname">CustomerEndpoint</code> would look like this:
            </p>
            <div class="programlistingco"><pre class="programlisting">import javax.xml.transform.Source;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.xml.transform.StringSource;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.ws.test.server.MockWebServiceClient;                                                        <span class="co" id="server.test.test.imports.client"><img src="images/callouts/1.png" alt="(1)"></span>
import static org.springframework.ws.test.server.RequestCreators.*;                                                    <span class="co" id="server.test.test.imports.requestCreators"><img src="images/callouts/1.png" alt="(1)"></span>
import static org.springframework.ws.test.server.ResponseMatchers.*;                                                   <span class="co" id="client.test.test.imports.responseMatchers"><img src="images/callouts/1.png" alt="(1)"></span>

@RunWith(SpringJUnit4ClassRunner.class)                                                                                <span class="co" id="server.test.test.spring.runWith"><img src="images/callouts/2.png" alt="(2)"></span>
@ContextConfiguration("spring-ws-servlet.xml")                                                                         <span class="co" id="server.test.test.spring.configuration"><img src="images/callouts/2.png" alt="(2)"></span>
public class CustomerEndpointIntegrationTest {

  @Autowired
  private ApplicationContext applicationContext;                                                                       <span class="co" id="server.test.test.applicationContext"><img src="images/callouts/3.png" alt="(3)"></span>

  private MockWebServiceClient mockClient;

  @Before
  public void createClient() {
    mockClient = MockWebServiceClient.createClient(applicationContext);                                                <span class="co" id="server.test.test.mockClient"><img src="images/callouts/4.png" alt="(4)"></span>
  }

  @Test
  public void customerEndpoint() throws Exception {
    Source requestPayload = new StringSource(
      "&lt;customerCountRequest xmlns='http://springframework.org/spring-ws'&gt;" +
        "&lt;customerName&gt;John Doe&lt;/customerName&gt;" +
      "&lt;/customerCountRequest&gt;");
    Source responsePayload = new StringSource(
      "&lt;customerCountResponse xmlns='http://springframework.org/spring-ws'&gt;" +
        "&lt;customerCount&gt;10&lt;/customerCount&gt;" +
      "&lt;/customerCountResponse&gt;");

    mockClient.sendRequest(withPayload(requestPayload)).                                                               <span class="co" id="server.test.test.send"><img src="images/callouts/5.png" alt="(5)"></span>
      andExpect(payload(responsePayload));                                                                             <span class="co" id="server.test.test.expect"><img src="images/callouts/5.png" alt="(5)"></span>
  }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">CustomerEndpointIntegrationTest</code> imports the
                            <code class="classname">MockWebServiceClient</code>, and statically imports
                            <code class="classname">RequestCreators</code> and <code class="classname">ResponseMatchers</code>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            This test uses the standard testing facilities provided in the Spring Framework.
                            This is not required, but is generally the easiest way to set up the test.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The application context is a standard Spring-WS application context (see
                            <a class="xref" href="#message-dispatcher-servlet" title="5.3.1&nbsp;MessageDispatcherServlet">Section&nbsp;5.3.1, &#8220;<code class="classname">MessageDispatcherServlet</code>&#8221;</a>), read from
                            <code class="filename">spring-ws-servlet.xml</code>.
                            In this case, the application context will contain a bean definition for
                            <code class="classname">CustomerEndpoint</code> (or a perhaps a
                            <code class="literal">&lt;context:component-scan /&gt;</code> is used).
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            In a <code class="interfacename">@Before</code> method, we create a
                            <code class="classname">MockWebServiceClient</code> by using the
                            <code class="methodname">createClient</code> factory method.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            We send a request by calling <code class="methodname">sendRequest()</code> with a
                            <code class="methodname">withPayload()</code> <code class="interfacename">RequestCreator</code>
                            provided by the statically imported <code class="classname">RequestCreators</code> (see <a class="xref" href="#server-test-request-creator" title="5.7.2&nbsp;RequestCreator and RequestCreators">Section&nbsp;5.7.2, &#8220;<code class="interfacename">RequestCreator</code> and <code class="classname">RequestCreators</code>&#8221;</a>).
                        </p>
                        <p>
                            We also set up response expectations by calling <code class="methodname">andExpect()</code> with a
                            <code class="methodname">payload()</code> <code class="interfacename">ResponseMatcher</code> provided
                            by the statically imported <code class="classname">ResponseMatchers</code> (see <a class="xref" href="#server-test-response-matcher" title="5.7.3&nbsp;ResponseMatcher and ResponseMatchers">Section&nbsp;5.7.3, &#8220;<code class="interfacename">ResponseMatcher</code> and <code class="classname">ResponseMatchers</code>&#8221;</a>).
                        </p>
                        <p>
                            This part of the test might look a bit confusing, but the Code Completion features of your
                            IDE are of great help.
                            After typing <code class="methodname">sendRequest(</code>, simply type ctrl-space, and your IDE
                            will provide you with a list of possible request creating strategies, provided you
                            statically imported <code class="classname">RequestCreators</code>.
                            The same applies to <code class="methodname">andExpect(</code>, provided you statically imported
                            <code class="classname">ResponseMatchers</code>.
                        </p>
                    </td></tr></table></div></div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-test-request-creator" href="#server-test-request-creator"></a>5.7.2&nbsp;<code class="interfacename">RequestCreator</code> and <code class="classname">RequestCreators</code></h3></div></div></div>
            
            <p>
                Initially, the <code class="classname">MockWebServiceClient</code> will need to create a request message for the
                endpoint to consume.
                The client uses the <code class="interfacename">RequestCreator</code>
                strategy interface for this purpose:
            </p>
            <pre class="programlisting">public interface RequestCreator {

  WebServiceMessage createRequest(WebServiceMessageFactory messageFactory)
    throws IOException;

}</pre>
            <p>
                You can write your own implementations of this interface, creating a request message
                by using the message factory, but you certainly do not have to.
                The <code class="classname">RequestCreators</code> class provides a way to create a
                <code class="interfacename">RequestCreator</code> based on a given payload in the
                <code class="methodname">withPayload()</code> method.
                You will typically statically import <code class="classname">RequestCreators</code>.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-test-response-matcher" href="#server-test-response-matcher"></a>5.7.3&nbsp;<code class="interfacename">ResponseMatcher</code> and <code class="classname">ResponseMatchers</code></h3></div></div></div>
            
            <p>
                When the request message has been processed by the endpoint, and a response has been received,
                the <code class="classname">MockWebServiceClient</code> can verify whether this response message meets certain
                expectations.
                The client uses the <code class="interfacename">ResponseMatcher</code> strategy interface for this purpose:
            </p>
            <pre class="programlisting">public interface ResponseMatcher {

    void match(WebServiceMessage request,
               WebServiceMessage response)
      throws IOException, AssertionError;

}</pre>
            <p>
                Once again you can write your own implementations of this interface, throwing
                <code class="classname">AssertionError</code>s when the message does not meet your expectations, but you
                certainly do not have to, as the <code class="classname">ResponseMatchers</code> class provides standard
                <code class="interfacename">ResponseMatcher</code> implementations for you to use in your tests.
                You will typically statically import this class.
            </p>
            <p>
                The <code class="classname">ResponseMatchers</code> class provides the following response matchers:
                </p><div class="informaltable">
                    <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">ResponseMatchers</code> method</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">payload()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects a given response payload.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">validPayload()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects the response payload to validate against given XSD schema(s).</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">xpath()</code></td><td style="border-bottom: 0.5pt solid ; ">
                                    Expects a given XPath expression to exist, not exist, or evaluate to a given
                                    value.
                                </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">soapHeader()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects a given SOAP header to exist in the response message.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">noFault()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects that the response message does not contain a SOAP Fault.</td></tr><tr><td style="border-right: 0.5pt solid ; ">
                                    <code class="methodname">mustUnderstandFault()</code>,
                                    <code class="methodname">clientOrSenderFault()</code>,
                                    <code class="methodname">serverOrReceiverFault()</code>, and
                                    <code class="methodname">versionMismatchFault()</code>
                                </td><td style="">Expects the response message to contain a specific SOAP Fault.</td></tr></tbody></table>
                </div><p>
                You can set up multiple response expectations by chaining <code class="methodname">andExpect()</code> calls,
                like so:
                </p><pre class="programlisting">mockClient.sendRequest(...).
 andExpect(payload(expectedResponsePayload)).
 andExpect(validPayload(schemaResource));
</pre><p>
            </p>
            <p>
                For more information on the response matchers provided by <code class="classname">ResponseMatchers</code>,
                refer to the class level Javadoc.
            </p>
        </div>
    </div>
<div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.d5e1417" class="footnote">
                    <p><a href="#d5e1417" class="para"><sup class="para">[2] </sup></a>For more information on WS-Addressing, see <a class="ulink" href="http://en.wikipedia.org/wiki/WS-Addressing" target="_top">http://en.wikipedia.org/wiki/WS-Addressing</a>.</p>
                </div></div></div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="client" href="#client"></a>6.&nbsp;Using Spring Web Services on the Client</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1768" href="#d5e1768"></a>6.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            Spring-WS provides a client-side Web service API that allows for consistent, XML-driven access to
            Web services. It also caters for the use of marshallers and unmarshallers
            so that your service tier code can deal exclusively with Java objects.
        </p>
        <p>
            The <span class="package">org.springframework.ws.client.core</span> package provides the core functionality
            for using the client-side access API. It contains template classes that simplify the use of Web
            services, much like the core Spring <code class="classname">JdbcTemplate</code> does for JDBC. The
            design principle common to Spring template classes is to provide helper methods to perform common
            operations, and for more sophisticated usage, delegate to user implemented callback interfaces.
            The Web service template follows the same design. The classes offer various convenience methods
            for the sending and receiving of XML messages, marshalling objects to XML before sending, and
            allows for multiple transport options.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1774" href="#d5e1774"></a>6.2&nbsp;Using the client-side API</h2></div></div></div>
        
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="client-web-service-template" href="#client-web-service-template"></a>6.2.1&nbsp;<code class="classname">WebServiceTemplate</code></h3></div></div></div>
            
            <p>
                The <code class="classname">WebServiceTemplate</code> is the core class for client-side Web service
                access in Spring-WS. It contains methods for sending <code class="classname">Source</code> objects,
                and receiving response messages as either <code class="classname">Source</code> or
                <code class="classname">Result</code>. Additionally, it can marshal objects to XML before sending
                them across a transport, and unmarshal any response XML into an object again.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="client-transports" href="#client-transports"></a>URIs and Transports</h4></div></div></div>
                
                <p>
                    The <code class="classname">WebServiceTemplate</code> class uses an URI as the message destination.
                    You can either set a <span class="property">defaultUri</span> property on the template itself,
                    or supply an URI explicitly when calling a method on the template. The URI will be
                    resolved into a <code class="interfacename">WebServiceMessageSender</code>, which is
                    responsible for sending the XML message across a transport layer. You can set one or
                    more message senders using the <span class="property">messageSender</span> or
                    <span class="property">messageSenders</span> properties of the
                    <code class="classname">WebServiceTemplate</code> class.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1793" href="#d5e1793"></a>HTTP transports</h5></div></div></div>
                    
                    <p>
                        There are two implementations of the <code class="classname">WebServiceMessageSender</code>
                        interface for sending messages via HTTP. The default implementation is the
                        <code class="classname">HttpUrlConnectionMessageSender</code>, which uses the facilities provided
                        by Java itself. The alternative is the <code class="classname">HttpComponentsMessageSender</code>,
                        which uses the
                        <a class="ulink" href="http://hc.apache.org/httpcomponents-client-ga" target="_top">Apache HttpComponents HttpClient</a>.
                        Use the latter if you need more advanced and easy-to-use functionality (such as authentication,
                        HTTP connection pooling, and so forth).
                    </p>
                    <p>
                        To use the HTTP transport, either set the <span class="property">defaultUri</span> to something like
                        <code class="uri">http://example.com/services</code>, or supply the <em class="parameter"><code>uri</code></em> parameter
                        for one of the methods.
                    </p>
                    <p>
                        The following example shows how the default configuration can be used for HTTP transports:
                        </p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&gt;
        &lt;constructor-arg ref="messageFactory"/&gt;
        &lt;property name="defaultUri" value="http://example.com/WebService"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
                    </p>
                    <p>
                        The following example shows how override the default configuration, and to use Apache HttpClient to
                        authenticate using HTTP authentication:
                        </p><pre class="programlisting">&lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&gt;
    &lt;constructor-arg ref="messageFactory"/&gt;
    &lt;property name="messageSender"&gt;
        &lt;bean class="org.springframework.ws.transport.http.HttpComponentsMessageSender"&gt;
            &lt;property name="credentials"&gt;
                &lt;bean class="org.apache.http.auth.UsernamePasswordCredentials"&gt;
                    &lt;constructor-arg value="john:secret"/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="defaultUri" value="http://example.com/WebService"/&gt;
&lt;/bean&gt;</pre><p>
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1808" href="#d5e1808"></a>JMS transport</h5></div></div></div>
                    
                    <p>
                        For sending messages over JMS, Spring Web Services provides the
                        <code class="classname">JmsMessageSender</code>. This class uses the facilities of the Spring framework
                        to transform the <code class="interfacename">WebServiceMessage</code> into a JMS
                        <code class="interfacename">Message</code>, send it on its way on a
                        <code class="interfacename">Queue</code> or <code class="interfacename">Topic</code>, and receive a
                        response (if any).
                    </p>
                    <p>
                        To use the <code class="classname">JmsMessageSender</code>, you need to set the
                        <span class="property">defaultUri</span> or <em class="parameter"><code>uri</code></em> parameter to a JMS URI, which - at a
                        minimum - consists of the <code class="literal">jms:</code> prefix and a destination name. Some examples of
                        JMS URIs are: <code class="uri">jms:SomeQueue</code>,
                        <code class="uri">jms:SomeTopic?priority=3&amp;deliveryMode=NON_PERSISTENT</code>, and
                        <code class="uri">jms:RequestQueue?replyToName=ResponseName</code>.
                        For more information on this URI syntax, refer to the class level Javadoc of the
                        <code class="classname">JmsMessageSender</code>.
                    </p>
                    <p>
                        By default, the <code class="classname">JmsMessageSender</code> send JMS
                        <code class="interfacename">BytesMessage</code>, but
                        this can be overriden to use <code class="interfacename">TextMessages</code> by using the
                        <code class="literal">messageType</code> parameter on the JMS URI. For example:
                        <code class="uri">jms:Queue?messageType=TEXT_MESSAGE</code>.
                        Note that <code class="interfacename">BytesMessages</code> are the preferred type, because
                        <code class="interfacename">TextMessages</code> do not support attachments and character
                        encodings reliably.
                    </p>
                    <p>
                        The following example shows how to use the JMS transport in combination with an ActiceMQ
                        connection factory:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="vm://localhost?broker.persistent=false"/&gt;
    &lt;/bean&gt;

    &lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&gt;
        &lt;constructor-arg ref="messageFactory"/&gt;
        &lt;property name="messageSender"&gt;
            &lt;bean class="org.springframework.ws.transport.jms.JmsMessageSender"&gt;
                &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="defaultUri" value="jms:RequestQueue?deliveryMode=NON_PERSISTENT"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1835" href="#d5e1835"></a>Email transport</h5></div></div></div>
                    
                    <p>
                        Spring Web Services also provides an email transport, which can be used to send web service
                        messages via SMTP, and retrieve them via either POP3 or IMAP. The client-side email
                        functionality is contained in the <code class="classname">MailMessageSender</code> class.
                        This class creates an email message from the request
                        <code class="interfacename">WebServiceMessage</code>, and sends it via SMTP. It then waits for a
                        response message to arrive in the incoming POP3 or IMAP server.
                    </p>
                    <p>
                        To use the <code class="classname">MailMessageSender</code>, set the <span class="property">defaultUri</span> or
                        <em class="parameter"><code>uri</code></em> parameter to a <code class="literal">mailto</code> URI. Here are some URI
                        examples: <code class="uri">mailto:john@example.com</code>, and
                        <code class="uri">mailto:server@localhost?subject=SOAP%20Test</code>. Make sure that the message sender is
                        properly configured with a <span class="property">transportUri</span>, which indicates the server to use for
                        sending requests (typically a SMTP server), and a <span class="property">storeUri</span>, which indicates
                        the server to poll for responses (typically a POP3 or IMAP server).
                    </p>
                    <p>
                        The following example shows how to use the email transport:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&gt;
        &lt;constructor-arg ref="messageFactory"/&gt;
        &lt;property name="messageSender"&gt;
            &lt;bean class="org.springframework.ws.transport.mail.MailMessageSender"&gt;
                &lt;property name="from" value="Spring-WS SOAP Client &amp;lt;client@example.com&amp;gt;"/&gt;
                &lt;property name="transportUri" value="smtp://client:s04p@smtp.example.com"/&gt;
                &lt;property name="storeUri" value="imap://client:s04p@imap.example.com/INBOX"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="defaultUri" value="mailto:server@example.com?subject=SOAP%20Test"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1851" href="#d5e1851"></a>XMPP transport</h5></div></div></div>
                    
                    <p>
                        Spring Web Services 2.0 introduced an XMPP (Jabber) transport, which can be used to send and
                        receive web service messages via XMPP. The client-side XMPP
                        functionality is contained in the <code class="classname">XmppMessageSender</code> class.
                        This class creates an XMPP message from the request
                        <code class="interfacename">WebServiceMessage</code>, and sends it via XMPP. It then listens for a
                        response message to arrive.
                    </p>
                    <p>
                        To use the <code class="classname">XmppMessageSender</code>, set the <span class="property">defaultUri</span> or
                        <em class="parameter"><code>uri</code></em> parameter to a <code class="literal">xmpp</code> URI, for example
                        <code class="uri">xmpp:johndoe@jabber.org</code>. The sender also requires an
                        <code class="classname">XMPPConnection</code> to work, which can be conveniently created using the
                        <code class="classname">org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean</code>.
                    </p>
                    <p>
                        The following example shows how to use the xmpp transport:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/&gt;

    &lt;bean id="connection" class="org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean"&gt;
        &lt;property name="host" value="jabber.org"/&gt;
        &lt;property name="username" value="username"/&gt;
        &lt;property name="password" value="password"/&gt;
    &lt;/bean&gt;

    &lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&gt;
        &lt;constructor-arg ref="messageFactory"/&gt;
        &lt;property name="messageSender"&gt;
            &lt;bean class="org.springframework.ws.transport.xmpp.XmppMessageSender"&gt;
                &lt;property name="connection" ref="connection"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="defaultUri" value="xmpp:user@jabber.org"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
                    </p>
                </div>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1866" href="#d5e1866"></a>Message factories</h4></div></div></div>
                
                <p>
                    In addition to a message sender, the <code class="classname">WebServiceTemplate</code> requires a Web
                    service message factory. There are two message factories for SOAP:
                    <code class="classname">SaajSoapMessageFactory</code> and <code class="classname">AxiomSoapMessageFactory</code>.
                    If no message factory is specified (via the <span class="property">messageFactory</span> property),
                    Spring-WS will use the <code class="classname">SaajSoapMessageFactory</code> by default.
                </p>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1874" href="#d5e1874"></a>6.2.2&nbsp;Sending and receiving a <code class="interfacename">WebServiceMessage</code>
            </h3></div></div></div>
            
            <p>
                The <code class="classname">WebServiceTemplate</code> contains many convenience methods to send and receive
                web service messages. There are methods that accept and return a <code class="interfacename">Source</code>
                and those that return a <code class="interfacename">Result</code>. Additionally, there are methods which
                marshal and unmarshal objects to XML. Here is an example that sends a simple XML message to a Web
                service.
            </p>

            <pre class="programlisting">
import java.io.StringReader;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.springframework.ws.WebServiceMessageFactory;
import org.springframework.ws.client.core.WebServiceTemplate;
import org.springframework.ws.transport.WebServiceMessageSender;

public class WebServiceClient {

    private static final String MESSAGE =
        "&lt;message xmlns=\"http://tempuri.org\"&gt;Hello Web Service World&lt;/message&gt;";

    private final WebServiceTemplate webServiceTemplate = new WebServiceTemplate();

    public void setDefaultUri(String defaultUri) {
        webServiceTemplate.setDefaultUri(defaultUri);
    }

    <em class="lineannotation"><span class="lineannotation">// send to the configured default URI</span></em>
    public void simpleSendAndReceive() {
        StreamSource source = new StreamSource(new StringReader(MESSAGE));
        StreamResult result = new StreamResult(System.out);
        webServiceTemplate.sendSourceAndReceiveToResult(source, result);
    }

    <em class="lineannotation"><span class="lineannotation">// send to an explicit URI</span></em>
    public void customSendAndReceive() {
        StreamSource source = new StreamSource(new StringReader(MESSAGE));
        StreamResult result = new StreamResult(System.out);
        webServiceTemplate.sendSourceAndReceiveToResult("http://localhost:8080/AnotherWebService",
            source, result);
    }

}</pre>
            <pre class="programlisting">
&lt;beans xmlns="http://www.springframework.org/schema/beans"&gt;

    &lt;bean id="webServiceClient" class="WebServiceClient"&gt;
        &lt;property name="defaultUri" value="http://localhost:8080/WebService"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
            <p>
                The above example uses the <code class="classname">WebServiceTemplate</code> to send a hello
                world message to the web service located at <code class="uri">http://localhost:8080/WebService</code>
                (in the case of the <code class="methodname">simpleSendAndReceive()</code> method),
                and writes the result to the console. The <code class="classname">WebServiceTemplate</code> is
                injected with the default URI, which is used because no URI was supplied explicitly
                in the Java code.
            </p>
            <p>
                Please note that the <code class="classname">WebServiceTemplate</code> class is thread-safe once
                configured (assuming that all of it's dependencies are thread-safe too, which is the case for
                all of the dependencies that ship with Spring-WS), and so multiple objects can use the same
                shared <code class="classname">WebServiceTemplate</code> instance if so desired.
                The <code class="classname">WebServiceTemplate</code> exposes a zero argument constructor and
                <span class="property">messageFactory</span>/<span class="property">messageSender</span> bean properties which
                can be used for constructing the instance (using a Spring container or plain Java code).
                Alternatively, consider deriving from Spring-WS's <code class="classname">WebServiceGatewaySupport</code>
                convenience base class, which exposes convenient bean properties to enable easy configuration.
                (You do <span class="emphasis"><em>not</em></span> have to extend this base class... it is provided as a convenience
                class only.)
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1898" href="#d5e1898"></a>6.2.3&nbsp;Sending and receiving POJOs - marshalling and unmarshalling</h3></div></div></div>
            
            <p>
                In order to facilitate the sending of plain Java objects, the
                <code class="classname">WebServiceTemplate</code> has a number of <code class="literal">send(..)</code> methods
                that take an <code class="classname">Object</code> as an argument for a message's data content.
                The method <code class="methodname">marshalSendAndReceive(..)</code> in the
                <code class="classname">WebServiceTemplate</code> class delegates the conversion of the request object
                to XML to a <code class="interfacename">Marshaller</code>, and the conversion of the response
                XML to an object to an <code class="interfacename">Unmarshaller</code>. (For more information
                about marshalling and unmarshaller, refer to
                <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/oxm.html" target="_top">the Spring documentation</a>.)
                By using the
                marshallers, your application code can focus on the business object that is being sent or
                received and not be concerned with the details of how it is represented as XML. In order to
                use the marshalling functionality, you have to set a marshaller and unmarshaller with the
                <span class="property">marshaller</span>/<span class="property">unmarshaller</span> properties of the
                <code class="classname">WebServiceTemplate</code> class.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1912" href="#d5e1912"></a>6.2.4&nbsp;
                <code class="interfacename">WebServiceMessageCallback</code>
            </h3></div></div></div>
            
            <p>
                To accommodate the setting of SOAP headers and other settings on the message, the
                <code class="interfacename">WebServiceMessageCallback</code> interface gives you access to the
                message <span class="emphasis"><em>after</em></span> it has been created, but <span class="emphasis"><em>before</em></span> it
                is sent. The example below demonstrates how to set the SOAP Action header on a message
                that is created by marshalling an object.
            </p>
            <pre class="programlisting">
public void marshalWithSoapActionHeader(MyObject o) {

    webServiceTemplate.marshalSendAndReceive(o, new WebServiceMessageCallback() {

        public void doWithMessage(WebServiceMessage message) {
            ((SoapMessage)message).setSoapAction("http://tempuri.org/Action");
        }
    });
}</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                <p>
                    Note that you can also use the
                    <code class="classname">org.springframework.ws.soap.client.core.SoapActionCallback</code> to set the SOAP
                    Action header.
                </p>
            </td></tr></table></div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1923" href="#d5e1923"></a>WS-Addressing</h4></div></div></div>
                
                <p>
                    In addition to the <a class="link" href="#server-ws-addressing" title="5.5.1&nbsp;WS-Addressing">server-side WS-Addressing</a> support,
                    Spring Web Services also has support for this specification on the client-side.
                </p>
                <p>
                    For setting WS-Addressing headers on the client, you can use the
                    <code class="classname">org.springframework.ws.soap.addressing.client.ActionCallback</code>. This callback
                    takes the desired Action header as a parameter. It also has constructors for specifying the
                    WS-Addressing version, and a <code class="literal">To</code> header. If not specified, the
                    <code class="literal">To</code> header will default to the URL of the connection being made.
                </p>
                <p>
                    Here is an example of setting the <code class="literal">Action</code> header to
                    <code class="uri">http://samples/RequestOrder</code>:</p><pre class="programlisting">
webServiceTemplate.marshalSendAndReceive(o, new ActionCallback("http://samples/RequestOrder"));
</pre><p>

                </p>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1935" href="#d5e1935"></a>6.2.5&nbsp;
                <code class="interfacename">WebServiceMessageExtractor</code>
            </h3></div></div></div>
            
            <p>
                The <code class="interfacename">WebServiceMessageExtractor</code> interface is a low-level
                callback interface that allows you to have full control over the process to extract an
                <code class="classname">Object</code> from a received <code class="interfacename">WebServiceMessage</code>.
                The <code class="classname">WebServiceTemplate</code> will invoke the <code class="methodname">extractData(..)</code>
                method on a supplied <code class="interfacename">WebServiceMessageExtractor</code>
                <span class="emphasis"><em>while the underlying connection to the serving resource is still open</em></span>.
                The following example illustrates the <code class="interfacename">WebServiceMessageExtractor</code>
                in action:
            </p>
            <pre class="programlisting">
public void marshalWithSoapActionHeader(final Source s) {
    final Transformer transformer = transformerFactory.newTransformer();
    webServiceTemplate.sendAndReceive(new WebServiceMessageCallback() {
        public void doWithMessage(WebServiceMessage message) {
            transformer.transform(s, message.getPayloadResult());
        },
        new WebServiceMessageExtractor() {
            public Object extractData(WebServiceMessage message) throws IOException
                <em class="lineannotation"><span class="lineannotation">// do your own transforms with message.getPayloadResult()</span></em>
                <em class="lineannotation"><span class="lineannotation">//     or message.getPayloadSource()</span></em>
            }
        });
}</pre>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1950" href="#d5e1950"></a>6.3&nbsp;Client-side testing</h2></div></div></div>
        
        <p>
            When it comes to testing your Web service clients (i.e. classes that uses the
            <code class="classname">WebServiceTemplate</code> to access a Web service), there are two possible
            approaches:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                <p>
                    Write <span class="emphasis"><em>Unit Tests</em></span>, which simply mock away the
                    <code class="classname">WebServiceTemplate</code> class,
                    <code class="interfacename">WebServiceOperations</code> interface, or the complete client class.
                </p>
                <p>
                    The advantage of this approach is that it's quite easy to accomplish; the disadvantage is that
                    you are not really testing the exact content of the XML messages that are sent over the wire,
                    especially when mocking out the entire client class.
                </p>
            </li><li class="listitem">
                <p>
                    Write <span class="emphasis"><em>Integrations Tests</em></span>, which do test the contents of the message.
                </p>
            </li></ul></div>
        <p>
            The first approach can easily be accomplished with mocking frameworks such as EasyMock, JMock, etc.
            The next section will focus on writing integration tests, using the test features introduced in Spring
            Web Services 2.0.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1965" href="#d5e1965"></a>6.3.1&nbsp;Writing client-side integration tests</h3></div></div></div>
            
            <p>
                Spring Web Services 2.0 introduced support for creating Web service client integration tests.
                In this context, a client is a class that uses the <code class="classname">WebServiceTemplate</code>
                to access a Web service.
            </p>
            <p>
                The integration test support lives in the <span class="package">org.springframework.ws.test.client</span> package.
                The core class in that package is the <code class="classname">MockWebServiceServer</code>.
                The underlying idea is that the web service template connects to this mock server, sends it request
                message, which the mock server then verifies against the registered expectations.
                If the expectations are met, the mock server then prepares a response message, which is send back to the
                template.
            </p>
            <p>
                The typical usage of the <code class="classname">MockWebServiceServer</code> is:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                        <p>
                            Create a <code class="classname">MockWebServiceServer</code> instance by calling
                            <code class="methodname">MockWebServiceServer.createServer(WebServiceTemplate)</code>,
                            <code class="methodname">MockWebServiceServer.createServer(WebServiceGatewaySupport)</code>, or
                            <code class="methodname">MockWebServiceServer.createServer(ApplicationContext)</code>.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Set up request expectations by calling <code class="methodname">expect(RequestMatcher)</code>,
                            possibly by using the default <code class="interfacename">RequestMatcher</code> implementations
                            provided in <code class="classname">RequestMatchers</code> (which can be statically imported).
                            Multiple expectations can be set up by chaining
                            <code class="methodname">andExpect(RequestMatcher)</code> calls.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Create an appropriate response message by calling
                            <code class="methodname">andRespond(ResponseCreator)</code>, possibly by using the default
                            <code class="interfacename">ResponseCreator</code> implementations provided in
                            <code class="classname">ResponseCreators</code> (which can be statically imported).
                        </p>
                    </li><li class="listitem">
                        <p>
                            Use the <code class="classname">WebServiceTemplate</code> as normal, either directly of through
                            client code.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Call <code class="methodname">MockWebServiceServer.verify()</code> to make sure that all
                            expectations have been met.
                        </p>
                    </li></ol></div><p>
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                <p>
                    Note that the <code class="classname">MockWebServiceServer</code> (and related classes) offers a
                    'fluent' API, so you can typically use the Code Completion features (i.e. ctrl-space) in your IDE
                    to guide you through the process of setting up the mock server.
                </p>
            </td></tr></table></div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                <p>
                    Also note that you rely on the standard logging features available in Spring Web Services in your
                    unit tests.
                    Sometimes it might be useful to inspect the request or response message to find out why a
                    particular tests failed.
                    See <a class="xref" href="#logging" title="4.4&nbsp;Message Logging and Tracing">Section&nbsp;4.4, &#8220;Message Logging and Tracing&#8221;</a> for more information.
                </p>
            </td></tr></table></div>
            <p>
                Consider, for example, this Web service client class:
            </p>
            <div class="programlistingco"><pre class="programlisting">import org.springframework.ws.client.core.support.WebServiceGatewaySupport;

public class CustomerClient extends WebServiceGatewaySupport {                                                         <span class="co" id="client.test.client.gateway"><img src="images/callouts/1.png" alt="(1)"></span>

  public int getCustomerCount() {
    CustomerCountRequest request = new CustomerCountRequest();                                                         <span class="co" id="client.test.client.request"><img src="images/callouts/2.png" alt="(2)"></span>
    request.setCustomerName("John Doe");

    CustomerCountResponse response =
      (CustomerCountResponse) getWebServiceTemplate().marshalSendAndReceive(request);                                  <span class="co" id="client.test.client.response"><img src="images/callouts/3.png" alt="(3)"></span>
      
    return response.getCustomerCount();
  }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">CustomerClient</code> extends
                            <code class="classname">WebServiceGatewaySupport</code>, which provides it with a
                            <span class="property">webServiceTemplate</span> property.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            <code class="classname">CustomerCountRequest</code> is an object supported by a marshaller.
                            For instance, it can have a <code class="interfacename">@XmlRootElement</code> annotation
                            to be supported by JAXB2.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">CustomerClient</code> uses the <code class="classname">WebServiceTemplate</code>
                            offered by <code class="classname">WebServiceGatewaySupport</code> to marshal the request object
                            into a SOAP message, and sends that to the web service.
                            The response object is unmarshalled into a <code class="classname">CustomerCountResponse</code>.
                        </p>
                    </td></tr></table></div></div>
            <p>
                A typical test for <code class="classname">CustomerClient</code> would look like this:
            </p>
            <div class="programlistingco"><pre class="programlisting">import javax.xml.transform.Source;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.xml.transform.StringSource;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.assertEquals;

import org.springframework.ws.test.client.MockWebServiceServer;                                                        <span class="co" id="client.test.test.imports.server"><img src="images/callouts/1.png" alt="(1)"></span>
import static org.springframework.ws.test.client.RequestMatchers.*;                                                    <span class="co" id="client.test.test.imports.requestMatchers"><img src="images/callouts/1.png" alt="(1)"></span>
import static org.springframework.ws.test.client.ResponseCreators.*;                                                   <span class="co" id="client.test.test.imports.responseCreators"><img src="images/callouts/1.png" alt="(1)"></span>

@RunWith(SpringJUnit4ClassRunner.class)                                                                                <span class="co" id="client.test.test.spring.runwith"><img src="images/callouts/2.png" alt="(2)"></span>
@ContextConfiguration("integration-test.xml")                                                                          <span class="co" id="client.test.test.spring.configuration"><img src="images/callouts/2.png" alt="(2)"></span>
public class CustomerClientIntegrationTest {

  @Autowired
  private CustomerClient client;                                                                                       <span class="co" id="client.test.test.client"><img src="images/callouts/3.png" alt="(3)"></span>

  private MockWebServiceServer mockServer;                                                                             <span class="co" id="client.test.test.mockserver"><img src="images/callouts/4.png" alt="(4)"></span>

  @Before
  public void createServer() throws Exception {
    mockServer = MockWebServiceServer.createServer(client);
  }

  @Test
  public void customerClient() throws Exception {
    Source requestPayload = new StringSource(
      "&lt;customerCountRequest xmlns='http://springframework.org/spring-ws'&gt;" +
        "&lt;customerName&gt;John Doe&lt;/customerName&gt;" +
      "&lt;/customerCountRequest&gt;");
    Source responsePayload = new StringSource(
      "&lt;customerCountResponse xmlns='http://springframework.org/spring-ws'&gt;" +
        "&lt;customerCount&gt;10&lt;/customerCount&gt;" +
      "&lt;/customerCountResponse&gt;");

    mockServer.expect(payload(requestPayload)).andRespond(withPayload(responsePayload));                               <span class="co" id="client.test.test.expectAndRespond"><img src="images/callouts/5.png" alt="(5)"></span>

    int result = client.getCustomerCount();                                                                            <span class="co" id="client.test.test.client.invoke.actual"><img src="images/callouts/6.png" alt="(6)"></span>
    assertEquals(10, result);                                                                                          <span class="co" id="client.test.test.client.invoke.assert"><img src="images/callouts/6.png" alt="(6)"></span>

    mockServer.verify();                                                                                               <span class="co" id="client.test.test.client.verify"><img src="images/callouts/7.png" alt="(7)"></span>
  }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">CustomerClientIntegrationTest</code> imports the
                            <code class="classname">MockWebServiceServer</code>, and statically imports
                            <code class="classname">RequestMatchers</code> and <code class="classname">ResponseCreators</code>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            This test uses the standard testing facilities provided in the Spring Framework.
                            This is not required, but is generally the easiest way to set up the test.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">CustomerClient</code> is configured in
                            <code class="filename">integration-test.xml</code>, and wired into this test using
                            <code class="interfacename">@Autowired</code>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            In a <code class="interfacename">@Before</code> method, we create a
                            <code class="classname">MockWebServiceServer</code> by using the
                            <code class="methodname">createServer</code> factory method.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            We define expectations by calling <code class="methodname">expect()</code> with a
                            <code class="methodname">payload()</code> <code class="interfacename">RequestMatcher</code> provided
                            by the statically imported <code class="classname">RequestMatchers</code> (see <a class="xref" href="#client-test-request-matcher" title="6.3.2&nbsp;RequestMatcher and RequestMatchers">Section&nbsp;6.3.2, &#8220;<code class="interfacename">RequestMatcher</code> and <code class="classname">RequestMatchers</code>&#8221;</a>).
                        </p>
                        <p>
                            We also set up a response by calling <code class="methodname">andRespond()</code> with a
                            <code class="methodname">withPayload()</code> <code class="interfacename">ResponseCreator</code>
                            provided by the statically imported <code class="classname">ResponseCreators</code> (see
                            <a class="xref" href="#client-test-response-creator" title="6.3.3&nbsp;ResponseCreator and ResponseCreators">Section&nbsp;6.3.3, &#8220;<code class="interfacename">ResponseCreator</code> and <code class="classname">ResponseCreators</code>&#8221;</a>).
                        </p>
                        <p>
                            This part of the test might look a bit confusing, but the Code Completion features of your
                            IDE are of great help.
                            After typing <code class="methodname">expect(</code>, simply type ctrl-space, and your IDE will
                            provide you with a list of possible request matching strategies, provided you
                            statically imported <code class="classname">RequestMatchers</code>.
                            The same applies to <code class="methodname">andRespond(</code>, provided you statically imported
                            <code class="classname">ResponseCreators</code>.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/6.png" alt="6" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            We call <code class="methodname">getCustomerCount()</code> on the
                            <code class="classname">CustomerClient</code>, thus using the
                            <code class="classname">WebServiceTemplate</code>.
                            The template has been set up for 'testing mode' by now, so no real
                            (HTTP) connection is made by this method call.
                            We also make some JUnit assertions based on the result of the method call.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/7.png" alt="7" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            We call <code class="methodname">verify()</code> on the
                            <code class="classname">MockWebServiceServer</code>, thus verifying that the expected
                            message was actually received.
                        </p>
                    </td></tr></table></div></div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="client-test-request-matcher" href="#client-test-request-matcher"></a>6.3.2&nbsp;<code class="interfacename">RequestMatcher</code> and <code class="classname">RequestMatchers</code></h3></div></div></div>
            
            <p>
                To verify whether the request message meets certain expectations, the
                <code class="classname">MockWebServiceServer</code> uses the <code class="interfacename">RequestMatcher</code>
                strategy interface.
                The contract defined by this interface is quite simple:
            </p>
            <pre class="programlisting">public interface RequestMatcher {

  void match(URI uri,
             WebServiceMessage request)
    throws IOException,
           AssertionError;

}</pre>
            <p>
                You can write your own implementations of this interface, throwing
                <code class="classname">AssertionError</code>s when the message does not meet your expectations, but you
                certainly do not have to.
                The <code class="classname">RequestMatchers</code> class provides standard
                <code class="interfacename">RequestMatcher</code> implementations for you to use in your tests.
                You will typically statically import this class.
            </p>
            <p>
                The <code class="classname">RequestMatchers</code> class provides the following request matchers:
                </p><div class="informaltable">
                    <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">RequestMatchers</code> method</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">anything()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects any sort of request.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">payload()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects a given request payload.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">validPayload()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects the request payload to validate against given XSD schema(s).</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">xpath()</code></td><td style="border-bottom: 0.5pt solid ; ">
                                    Expects a given XPath expression to exist, not exist, or evaluate to a given
                                    value.
                                </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">soapHeader()</code></td><td style="border-bottom: 0.5pt solid ; ">Expects a given SOAP header to exist in the request message.</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="methodname">connectionTo()</code></td><td style="">Expects a connection to the given URL.</td></tr></tbody></table>
                </div><p>
                You can set up multiple request expectations by chaining <code class="methodname">andExpect()</code> calls,
                like so:
                </p><pre class="programlisting">mockServer.expect(connectionTo("http://example.com")).
 andExpect(payload(expectedRequestPayload)).
 andExpect(validPayload(schemaResource)).
 andRespond(...);
</pre><p>
            </p>
            <p>
                For more information on the request matchers provided by <code class="classname">RequestMatchers</code>,
                refer to the class level Javadoc.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="client-test-response-creator" href="#client-test-response-creator"></a>6.3.3&nbsp;<code class="interfacename">ResponseCreator</code> and <code class="classname">ResponseCreators</code></h3></div></div></div>
            
            <p>
                When the request message has been verified and meets the defined expectations, the
                <code class="classname">MockWebServiceServer</code> will create a response message for the
                <code class="classname">WebServiceTemplate</code> to consume.
                The server uses the <code class="interfacename">ResponseCreator</code>
                strategy interface for this purpose:
            </p>
            <pre class="programlisting">public interface ResponseCreator {

  WebServiceMessage createResponse(URI uri,
                                   WebServiceMessage request,
                                   WebServiceMessageFactory messageFactory)
    throws IOException;

}</pre>
            <p>
                Once again you can write your own implementations of this interface, creating a response message
                by using the message factory, but you certainly do not have to, as the
                <code class="classname">ResponseCreators</code> class provides standard
                <code class="interfacename">ResponseCreator</code> implementations for you to use in your tests.
                You will typically statically import this class.
            </p>
            <p>
                The <code class="classname">ResponseCreators</code> class provides the following responses:
                </p><div class="informaltable">
                    <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">ResponseCreators</code> method</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">withPayload()</code></td><td style="border-bottom: 0.5pt solid ; ">Creates a response message with a given payload.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">withError()</code></td><td style="border-bottom: 0.5pt solid ; ">
                                    Creates an error in the response connection.
                                    This method gives you the opportunity to test your error handling.
                                </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">withException()</code></td><td style="border-bottom: 0.5pt solid ; ">
                                    Throws an exception when reading from the response connection.
                                    This method gives you the opportunity to test your exception handling.
                                </td></tr><tr><td style="border-right: 0.5pt solid ; ">
                                    <code class="methodname">withMustUnderstandFault()</code>,
                                    <code class="methodname">withClientOrSenderFault()</code>,
                                    <code class="methodname">withServerOrReceiverFault()</code>, and
                                    <code class="methodname">withVersionMismatchFault()</code>
                                </td><td style="">
                                    Creates a response message with a given SOAP fault.
                                    This method gives you the opportunity to test your Fault handling.
                                </td></tr></tbody></table>
                </div><p>
            </p>
            <p>
                For more information on the request matchers provided by <code class="classname">RequestMatchers</code>,
                refer to the class level Javadoc.
            </p>
        </div>
    </div>
</div>
        <div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="security" href="#security"></a>7.&nbsp;Securing your Web services with Spring-WS</h2></div></div></div>
    

    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-introduction" href="#security-introduction"></a>7.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            This chapter explains how to add WS-Security aspects to your Web services. We will focus on the
            three different areas of WS-Security, namely:
        </p>
        <p>
            <b>Authentication.&nbsp;</b>
            
                This is the process of determining whether a <span class="emphasis"><em>principal</em></span> is who they claim to be.
                In this context, a "principal" generally means a user, device or some other system which can perform
                an action in your application.
            
        </p>
        <p>
            <b>Digital signatures.&nbsp;</b>
            
                The digital signature of a message is a piece of information based on both the document and the signer's
                private key. It is created through the use of a hash function and a private signing function (encrypting
                with the signer's private key).
            
        </p>
        <p>
            <b>Encryption and Decryption.&nbsp;</b>
            
                <span class="emphasis"><em>Encryption</em></span> is the process of transforming data into a form that is impossible to
                read without the appropriate key. It is mainly used to keep information hidden from anyone for whom it
                is not intended.
                <span class="emphasis"><em>Decryption</em></span> is the reverse of encryption; it is the process of transforming of
                encrypted data back into an readable form.
            
        </p>
        <p>
            All of these three areas are implemented using the <code class="classname">XwsSecurityInterceptor</code> or
            <code class="classname">Wss4jSecurityInterceptor</code>, which we
            will describe in <a class="xref" href="#security-xws-security-interceptor" title="7.2&nbsp; XwsSecurityInterceptor">Section&nbsp;7.2, &#8220;
            <code class="classname">XwsSecurityInterceptor</code>
        &#8221;</a> and
            <a class="xref" href="#security-wss4j-security-interceptor" title="7.3&nbsp; Wss4jSecurityInterceptor">Section&nbsp;7.3, &#8220;
            <code class="classname">Wss4jSecurityInterceptor</code>
        &#8221;</a>, respectively
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
            <p>
                Note that WS-Security (especially encryption and signing) requires substantial amounts of memory, and
                will also decrease performance. If performance is important to you, you might want to consider not using
                WS-Security, or simply use HTTP-based security.
            </p>
        </td></tr></table></div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-xws-security-interceptor" href="#security-xws-security-interceptor"></a>7.2&nbsp;
            <code class="classname">XwsSecurityInterceptor</code>
        </h2></div></div></div>
        
        <p>
            The <code class="classname">XwsSecurityInterceptor</code> is an <code class="classname">EndpointInterceptor</code>
            (see <a class="xref" href="#server-endpoint-interceptor" title="5.5.2&nbsp;Intercepting requests - the EndpointInterceptor interface">Section&nbsp;5.5.2, &#8220;Intercepting requests - the <code class="interfacename">EndpointInterceptor</code> interface&#8221;</a>) that is based on SUN's XML and Web Services Security
            package (XWSS). This WS-Security implementation is part of the Java Web Services Developer Pack
            (<a class="ulink" href="http://java.sun.com/webservices/" target="_top"><em class="citetitle">Java WSDP</em></a>).
        </p>
        <p>
            Like any other endpoint interceptor, it is defined in the endpoint mapping (see
            <a class="xref" href="#server-endpoint-mapping" title="5.5&nbsp;Endpoint mappings">Section&nbsp;5.5, &#8220;Endpoint mappings&#8221;</a>). This means that you can be selective about adding WS-Security
            support: some endpoint mappings require it, while others do not.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
            <p>
                Note that XWSS requires both a SUN 1.5 JDK and the SUN SAAJ reference implementation.
                The WSS4J interceptor does not have these requirements (see
                <a class="xref" href="#security-wss4j-security-interceptor" title="7.3&nbsp; Wss4jSecurityInterceptor">Section&nbsp;7.3, &#8220;
            <code class="classname">Wss4jSecurityInterceptor</code>
        &#8221;</a>).
            </p>
        </td></tr></table></div>
        <p>
            The <code class="classname">XwsSecurityInterceptor</code> requires a <span class="emphasis"><em>security policy file</em></span>
            to operate. This XML file tells the interceptor what security aspects to require from incoming SOAP
            messages, and what aspects to add to outgoing messages. The basic format of the policy file will be
            explained in the following sections, but you can find a more in-depth tutorial
            <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp564887" target="_top">
                <em class="citetitle">here</em>
            </a>.
            You can set the policy with the <span class="property">policyConfiguration</span> property, which
            requires a Spring resource. The policy file can contain multiple elements, e.g. require a
            username token on incoming messages, and sign all outgoing messages. It contains a
            <code class="literal">SecurityConfiguration</code> element as root (not a <code class="literal">JAXRPCSecurity</code> element).
        </p>
        <p>
            Additionally, the security interceptor requires one or more<code class="classname">CallbackHandler</code>s to
            operate. These handlers are used to retrieve certificates, private keys, validate user credentials,
            etc. Spring-WS offers handlers for most common security concerns, e.g. authenticating against a Spring
            Security authentication manager, signing outgoing messages based on a X509 certificate. The following
            sections will indicate what callback handler to use for which security concern. You can set the callback
            handlers using the <span class="property">callbackHandler</span> or <span class="property">callbackHandlers</span>
            property.
        </p>
        <p>
            Here is an example that shows how to wire the <code class="classname">XwsSecurityInterceptor</code> up:
            </p><pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="wsSecurityInterceptor"
        class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor"&gt;
        &lt;property name="policyConfiguration" value="classpath:securityPolicy.xml"/&gt;
        &lt;property name="callbackHandlers"&gt;
            &lt;list&gt;
                &lt;ref bean="certificateHandler"/&gt;
                &lt;ref bean="authenticationHandler"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;
</pre><p>
            This interceptor is configured using the
            <code class="filename">securityPolicy.xml</code>
            file on the classpath. It
            uses two callback handlers which are defined further on in the file.
        </p>

        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="keystore" href="#keystore"></a>7.2.1&nbsp;Keystores</h3></div></div></div>
            
            <p>
                For most cryptographic operations, you will use the standard
                <code class="classname">java.security.KeyStore</code> objects.
                These operations include certificate verification, message signing, signature verification, and encryption, but
                excludes username and time-stamp verification. This section aims to give you some background knowledge on
                keystores, and the Java tools that you can use to store keys and certificates in a keystore file. This
                information is mostly not related to Spring-WS, but to the general cryptographic features of Java.
            </p>
            <p>
                The <code class="classname">java.security.KeyStore</code>
                class represents a storage facility for cryptographic keys
                and certificates. It can contain three different sort of elements:
            </p>
            <p>
                <b>Private Keys.&nbsp;</b>
                
                    These keys are used for self-authentication. The private key is accompanied by certificate chain for
                    the corresponding public key. Within the field of WS-Security, this accounts to message signing and
                    message decryption.
                
            </p>
            <p>
                <b>Symmetric Keys.&nbsp;</b>
                
                    Symmetric (or secret) keys are used for message encryption and decryption as well. The difference
                    being that both sides (sender and recipient) share the same, secret key.
                
            </p>
            <p>
                <b>Trusted certificates.&nbsp;</b>
                
                    These X509 certificates are called a
                    <span class="emphasis"><em>trusted certificate</em></span>
                    because the keystore owner
                    trusts that the public key in the certificates indeed belong to the owner of the certificate. Within
                    WS-Security, these certificates are used for certificate validation, signature verification, and
                    encryption.
                
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2255" href="#d5e2255"></a>KeyTool</h4></div></div></div>
                
                <p>
                    Supplied with your Java Virtual Machine is the
                    <span class="command"><strong>keytool</strong></span>
                    program, a key and certificate
                    management utility. You can use this tool to create new keystores, add new private keys and
                    certificates to them, etc. It is beyond the scope of this document to provide a full reference of
                    the
                    <span class="command"><strong>keytool</strong></span>
                    command, but you can find a reference
                    <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    ,
                    or by giving the command
                    <code class="prompt">keytool -help</code>
                    on the command line.
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2263" href="#d5e2263"></a>KeyStoreFactoryBean</h4></div></div></div>
                
                <p>
                    To easily load a keystore using Spring configuration, you can use the
                    <code class="classname">KeyStoreFactoryBean</code>. It has a resource location property, which you can set to
                    point to the path of the keystore to load. A password may be given to check the integrity of the
                    keystore data. If a password is not given, integrity checking is not performed.
                </p>
                <pre class="programlisting">
&lt;bean id="keyStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
    &lt;property name="password" value="password"/&gt;
    &lt;property name="location" value="classpath:org/springframework/ws/soap/security/xwss/test-keystore.jks"/&gt;
&lt;/bean&gt;</pre>
                <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td><th align="left">Caution</th></tr><tr><td align="left" valign="top">
                    <p>
                        If you don't specify the location property, a new, empty keystore will be created, which is most
                        likely not what you want.
                    </p>
                </td></tr></table></div>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="security-key-store-callback-handler" href="#security-key-store-callback-handler"></a>KeyStoreCallbackHandler</h4></div></div></div>
                
                <p>
                    To use the keystores within a
                    <code class="classname">XwsSecurityInterceptor</code>, you will need to define a
                    <code class="classname">KeyStoreCallbackHandler</code>. This callback has three properties with type keystore:
                    (<code class="methodname">keyStore</code>,<code class="methodname">trustStore</code>, and
                    <code class="methodname">symmetricStore</code>). The exact stores used by the handler depend on the
                    cryptographic operations that are to be performed by this handler. For private key operation, the
                    <code class="methodname">keyStore</code>
                    is used, for symmetric key operations the
                    <code class="methodname">symmetricStore</code>, and for determining trust relationships, the
                    <code class="methodname">trustStore</code>. The following table indicates this:
                    </p><div class="informaltable">
                        <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Cryptographic operation</th><th style="border-bottom: 0.5pt solid ; ">Keystore used</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Certificate validation</td><td style="border-bottom: 0.5pt solid ; ">
                                        first the<code class="methodname">keyStore</code>, then the
                                        <code class="methodname">trustStore</code>
                                    </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Decryption based on private key</td><td style="border-bottom: 0.5pt solid ; ">
                                        <code class="methodname">keyStore</code>
                                    </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Decryption based on symmetric key</td><td style="border-bottom: 0.5pt solid ; ">
                                        <code class="methodname">symmetricStore</code>
                                    </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Encryption based on public key certificate</td><td style="border-bottom: 0.5pt solid ; ">
                                        <code class="methodname">trustStore</code>
                                    </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Encryption based on symmetric key</td><td style="border-bottom: 0.5pt solid ; ">
                                        <code class="methodname">symmetricStore</code>
                                    </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Signing</td><td style="border-bottom: 0.5pt solid ; ">
                                        <code class="methodname">keyStore</code>
                                    </td></tr><tr><td style="border-right: 0.5pt solid ; ">Signature verification</td><td style="">
                                        <code class="methodname">trustStore</code>
                                    </td></tr></tbody></table>
                    </div><p>
                    Additionally, the
                    <code class="classname">KeyStoreCallbackHandler</code>
                    has a
                    <code class="methodname">privateKeyPassword</code>
                    property, which should be set to unlock the private key(s)
                    contained in the<code class="methodname">keyStore</code>.
                </p>
                <p>
                    If the
                    <code class="methodname">symmetricStore</code>
                    is not set, it will default to the
                    <code class="methodname">keyStore</code>. If the key or trust store is not set, the callback handler will use
                    the standard Java mechanism to load or create it. Refer to the JavaDoc of the
                    <code class="classname">KeyStoreCallbackHandler</code>
                    to know how this mechanism works.
                </p>
                <p>
                    For instance, if you want to use the
                    <code class="classname">KeyStoreCallbackHandler</code>
                    to validate incoming
                    certificates or signatures, you would use a trust store, like so:
                    </p><pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="trustStore" ref="trustStore"/&gt;
    &lt;/bean&gt;

    &lt;bean id="trustStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:truststore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
                    If you want to use it to decrypt incoming certificates or sign outgoing messages, you would use a key
                    store, like so:
                    </p><pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="keyStore" ref="keyStore"/&gt;
        &lt;property name="privateKeyPassword" value="changeit"/&gt;
    &lt;/bean&gt;

    &lt;bean id="keyStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:keystore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
                </p>
                <p>
                    The following sections will indicate where the
                    <code class="classname">KeyStoreCallbackHandler</code>
                    can be
                    used, and which properties to set for particular cryptographic operations.
                </p>
            </div>
        </div>

        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2330" href="#d5e2330"></a>7.2.2&nbsp;Authentication</h3></div></div></div>
            
            <p>
                As stated in the introduction,
                <span class="emphasis"><em>authentication</em></span>
                is the task of determining whether a
                principal is who they claim to be. Within WS-Security, authentication can take two forms: using a username
                and password token (using either a plain text password or a password digest), or using a X509 certificate.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2334" href="#d5e2334"></a>Plain Text Username Authentication</h4></div></div></div>
                
                <p>
                    The simplest form of username authentication uses<span class="emphasis"><em>plain text passwords</em></span>. In this
                    scenario, the SOAP message will contain a
                    <code class="literal">UsernameToken</code>
                    element, which itself
                    contains a
                    <code class="literal">Username</code>
                    element and a
                    <code class="literal">Password</code>
                    element which contains
                    the plain text password. Plain text authentication can be compared to the Basic Authentication provided
                    by HTTP servers.
                </p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
                    <p>
                        Note that plain text passwords are not very secure. Therefore, you should always add additional
                        security measures to your transport layer if you are using them (using HTTPS instead of plain HTTP,
                        for instance).
                    </p>
                </td></tr></table></div>
                <p>
                    To require that every incoming message contains a
                    <code class="literal">UsernameToken</code>
                    with a plain
                    text password, the security policy file should contain a
                    <code class="literal">RequireUsernameToken</code>
                    element, with the
                    <code class="literal">passwordDigestRequired</code>
                    attribute set to<code class="literal">false</code>.
                    You can find a reference of possible child elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp567459" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
    ...
    &lt;xwss:RequireUsernameToken passwordDigestRequired="false" nonceRequired="false"/&gt;
    ...
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    If the username token is not present, the
                    <code class="classname">XwsSecurityInterceptor</code>
                    will return a
                    SOAP Fault to the sender. If it is present, it will fire a
                    <code class="classname">PasswordValidationCallback</code>
                    with a
                    <code class="classname">PlainTextPasswordRequest</code>
                    to the registered handlers. Within Spring-WS, there are three classes which handle this particular
                    callback.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="security-simple-password-validation-callback-handler" href="#security-simple-password-validation-callback-handler"></a>SimplePasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The simplest password validation handler is the
                        <code class="classname">SimplePasswordValidationCallbackHandler</code>. This handler validates passwords
                        against an in-memory
                        <code class="classname">Properties</code>
                        object, which you can specify using the
                        <code class="methodname">users</code>
                        property, like so:
                    </p>
                    <pre class="programlisting">
&lt;bean id="passwordValidationHandler"
    class="org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandler"&gt;
    &lt;property name="users"&gt;
        &lt;props&gt;
            &lt;prop key="Bert"&gt;Ernie&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                    <p>
                        In this case, we are only allowing the user "Bert" to log in using the password "Ernie".
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2363" href="#d5e2363"></a>SpringPlainTextPasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The <code class="classname">SpringPlainTextPasswordValidationCallbackHandler</code> uses
                        <a class="ulink" href="http://www.springframework.org/security" target="_top"><em class="citetitle">Spring Security</em></a>
                        to authenticate users. It is beyond the scope of this document to describe Spring Security,
                        but suffice it to say that it is a full-fledged security framework.
                        You can read more about it in the <a class="ulink" href="http://www.springframework.org/security" target="_top">
                            <em class="citetitle">Spring Security reference documentation</em>
                        </a>.
                    </p>
                    <p>
                        The <code class="classname">SpringPlainTextPasswordValidationCallbackHandler</code> requires
                        an <code class="classname">AuthenticationManager</code> to operate. It uses this manager to
                        authenticate against a <code class="classname">UsernamePasswordAuthenticationToken</code>
                        that it creates. If authentication is successful, the token is stored in the
                        <code class="classname">SecurityContextHolder</code>. You can set the authentication manager using the
                        <code class="methodname">authenticationManager</code>property:
                    </p>
                    <pre class="programlisting">
&lt;beans&gt;
  &lt;bean id="springSecurityHandler"
      class="org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler"&gt;
    &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
  &lt;/bean&gt;

  &lt;bean id="authenticationManager" class="org.springframework.security.providers.ProviderManager"&gt;
      &lt;property name="providers"&gt;
          &lt;bean class="org.springframework.security.providers.dao.DaoAuthenticationProvider"&gt;
              &lt;property name="userDetailsService" ref="userDetailsService"/&gt;
          &lt;/bean&gt;
      &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" /&gt;
  ...
&lt;/beans&gt;</pre>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2378" href="#d5e2378"></a>JaasPlainTextPasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The
                        <code class="classname">JaasPlainTextPasswordValidationCallbackHandler</code>
                        is based on the standard
                        <a class="ulink" href="http://java.sun.com/products/jaas/" target="_top">
                            <em class="citetitle">Java Authentication and Authorization
                                Service
                            </em>
                        </a>
                        . It is beyond the scope of this document to provide a full
                        introduction into JAAS, but there is a
                        <a class="ulink" href="http://www.javaworld.com/javaworld/jw-09-2002/jw-0913-jaas.html" target="_top">
                            <em class="citetitle">good tutorial</em>
                        </a>
                        available.
                    </p>
                    <p>
                        The
                        <code class="classname">JaasPlainTextPasswordValidationCallbackHandler</code>
                        requires only a
                        <code class="methodname">loginContextName</code>
                        to operate. It creates a new JAAS
                        <code class="classname">LoginContext</code>
                        using this name, and handles the standard JAAS
                        <code class="classname">NameCallback</code>
                        and
                        <code class="classname">PasswordCallback</code>
                        using the username
                        and password provided in the SOAP message. This means that this callback handler
                        integrates with any JAAS
                        <code class="classname">LoginModule</code>
                        that fires these callbacks during the
                        <code class="methodname">login()</code>
                        phase, which is standard behavior.
                    </p>
                    <p>
                        You can wire up a
                        <code class="classname">JaasPlainTextPasswordValidationCallbackHandler</code>
                        as follows:
                    </p>
                    <pre class="programlisting">
&lt;bean id="jaasValidationHandler"
    class="org.springframework.ws.soap.security.xwss.callback.jaas.JaasPlainTextPasswordValidationCallbackHandler"&gt;
    &lt;property name="loginContextName" value="MyLoginModule" /&gt;
&lt;/bean&gt;</pre>
                    <p>
                        In this case, the callback handler uses the
                        <code class="classname">LoginContext</code>
                        named
                        "MyLoginModule". This module should be defined in your
                        <code class="filename">jaas.config</code>
                        file, as
                        explained in the abovementioned tutorial.
                    </p>
                </div>
            </div>

            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2400" href="#d5e2400"></a>Digest Username Authentication</h4></div></div></div>
                
                <p>
                    When using password digests, the SOAP message also contains a
                    <code class="literal">UsernameToken</code>
                    element,
                    which itself contains a
                    <code class="literal">Username</code>
                    element and a
                    <code class="literal">Password</code>
                    element.
                    The difference is that the password is not sent as plain text, but as a
                    <span class="emphasis"><em>digest</em></span>. The
                    recipient compares this digest to the digest he calculated from the known password of the user, and if
                    they are the same, the user is authenticated. It can be compared to the Digest Authentication provided
                    by HTTP servers.
                </p>
                <p>
                    To require that every incoming message contains a
                    <code class="literal">UsernameToken</code>
                    element with a
                    password digest, the security policy file should contain a
                    <code class="literal">RequireUsernameToken</code>
                    element, with the
                    <code class="literal">passwordDigestRequired</code>
                    attribute set to<code class="literal">true</code>.
                    Additionally, the
                    <code class="literal">nonceRequired</code>
                    should be set to<code class="literal">true</code>:
                    You can find a reference of possible child elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp567459" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
    ...
    &lt;xwss:RequireUsernameToken passwordDigestRequired="true" nonceRequired="true"/&gt;
    ...
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    If the username token is not present, the
                    <code class="classname">XwsSecurityInterceptor</code>
                    will return a
                    SOAP Fault to the sender. If it is present, it will fire a
                    <code class="classname">PasswordValidationCallback</code>
                    with a
                    <code class="classname">DigestPasswordRequest</code>
                    to the registered handlers. Within Spring-WS, there are two classes which handle this particular
                    callback.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2421" href="#d5e2421"></a>SimplePasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The
                        <code class="classname">SimplePasswordValidationCallbackHandler</code>
                        can handle both plain text
                        passwords as well as password digests. It is described in<a class="xref" href="#security-simple-password-validation-callback-handler" title="SimplePasswordValidationCallbackHandler">the section called &#8220;SimplePasswordValidationCallbackHandler&#8221;</a>.
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2426" href="#d5e2426"></a>SpringDigestPasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The <code class="classname">SpringDigestPasswordValidationCallbackHandler</code>
                        requires an Spring Security <code class="classname">UserDetailService</code>
                        to operate. It uses this service to retrieve the password
                        of the user specified in the token. The digest of the password contained in this details object
                        is then compared with the digest in the message. If they are equal, the user has successfully
                        authenticated, and a <code class="classname">UsernamePasswordAuthenticationToken</code>
                        is stored in the <code class="classname">SecurityContextHolder</code>. You can set the service using the
                        <code class="methodname">userDetailsService</code>. Additionally, you can set a
                        <code class="methodname">userCache</code> property, to cache loaded user details.
                    </p>
                    <pre class="programlisting">
&lt;beans&gt;
    &lt;bean class="org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler"&gt;
        &lt;property name="userDetailsService" ref="userDetailsService"/&gt;
    &lt;/bean&gt;

    &lt;bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" /&gt;
    ...
&lt;/beans&gt;</pre>
                </div>
            </div>

            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="security-certificate-authentication" href="#security-certificate-authentication"></a>Certificate Authentication</h4></div></div></div>
                
                <p>
                    A more secure way of authentication uses X509 certificates. In this scenerario, the SOAP message
                    contains a<code class="literal">BinarySecurityToken</code>, which contains a Base 64-encoded version of a X509
                    certificate. The certificate is used by the recipient to authenticate. The certificate stored in the
                    message is also used to sign the message (see<a class="xref" href="#security-verifying-signatures" title="Verifying Signatures">the section called &#8220;Verifying Signatures&#8221;</a>).
                </p>
                <p>
                    To make sure that all incoming SOAP messages carry a<code class="literal">BinarySecurityToken</code>, the
                    security policy file should contain a
                    <code class="literal">RequireSignature</code>
                    element. This element can
                    further carry other elements, which will be covered in<a class="xref" href="#security-verifying-signatures" title="Verifying Signatures">the section called &#8220;Verifying Signatures&#8221;</a>.
                    You can find a reference of possible child elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565769" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
    ...
    &lt;xwss:RequireSignature requireTimestamp="false"&gt;
    ...
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    When a message arrives that carries no certificate, the
                    <code class="classname">XwsSecurityInterceptor</code>
                    will return a SOAP Fault to the sender. If it is present, it will fire a
                    <code class="classname">CertificateValidationCallback</code>. There are three handlers within Spring-WS
                    which handle this callback for authentication purposes.
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                    <p>
                        In most cases, certificate
                        <span class="emphasis"><em>authentication</em></span>
                        should be preceded by certificate
                        <span class="emphasis"><em>validation</em></span>, since you only want to authenticate against valid certificates.
                        Invalid certificates such as certificates for which the expiration date has passed, or which are not
                        in your store of trusted certificates, should be ignored.
                    </p>
                    <p>
                        In Spring-WS terms, this means that the
                        <code class="classname">SpringCertificateValidationCallbackHandler</code>
                        or
                        <code class="classname">JaasCertificateValidationCallbackHandler</code>
                        should be preceded by
                        <code class="classname">KeyStoreCallbackHandler</code>. This can be accomplished by setting the order of the
                        <code class="methodname">callbackHandlers</code>
                        property in the configuration of the
                        <code class="classname">XwsSecurityInterceptor</code>:
                        </p><pre class="programlisting">
&lt;bean id="wsSecurityInterceptor"
    class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor"&gt;
    &lt;property name="policyConfiguration" value="classpath:securityPolicy.xml"/&gt;
    &lt;property name="callbackHandlers"&gt;
        &lt;list&gt;
            &lt;ref bean="keyStoreHandler"/&gt;
            &lt;ref bean="springSecurityHandler"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</pre><p>
                        Using this setup, the interceptor will first determine if the certificate in the message is valid
                        using the keystore, and then authenticate against it.
                    </p>
                </td></tr></table></div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2462" href="#d5e2462"></a>KeyStoreCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The
                        <code class="classname">KeyStoreCallbackHandler</code>
                        uses a standard Java keystore to validate
                        certificates. This certificate validation process consists of the following steps:
                        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                                <p>
                                    First, the handler will check whether the certificate is in the private
                                    <code class="methodname">keyStore</code>. If it is, it is valid.
                                </p>
                            </li><li class="listitem">
                                <p>
                                    If the certificate is not in the private keystore, the handler will check whether
                                    the current date and time are within the validity period given in the certificate.
                                    If they are not, the certificate is invalid; if it is, it will continue with the final
                                    step.
                                </p>
                            </li><li class="listitem">
                                <p>
                                    Finally, a
                                    <span class="emphasis"><em>certification path</em></span>
                                    for the certificate is created. This
                                    basically means that the handler will determine whether the certificate has been issued
                                    by any of the certificate authorities in the<code class="methodname">trustStore</code>. If
                                    a certification path can be built successfully, the certificate is valid. Otherwise,
                                    the certificate is not.
                                </p>
                            </li></ol></div><p>
                    </p>
                    <p>
                        To use the
                        <code class="classname">KeyStoreCallbackHandler</code>
                        for certificate validation purposes, you
                        will most likely set only the
                        <code class="methodname">trustStore</code>
                        property:
                        </p><pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="trustStore" ref="trustStore"/&gt;
    &lt;/bean&gt;

    &lt;bean id="trustStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:truststore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
                        Using this setup, the certificate that is to be validated must either be in the trust store itself,
                        or the trust store must contain a certificate authority that issued the certificate.
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2480" href="#d5e2480"></a>SpringCertificateValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The <code class="classname">SpringCertificateValidationCallbackHandler</code>
                        requires an Spring Security <code class="classname">AuthenticationManager</code> to operate. It uses
                        this manager to authenticate against a <code class="classname">X509AuthenticationToken</code>
                        that it creates. The configured authentication manager is expected to supply a provider which
                        can handle this token (usually an instance of
                        <code class="classname">X509AuthenticationProvider</code>). If authentication is succesful, the token is
                        stored in the <code class="classname">SecurityContextHolder</code>. You can set the authentication
                        manager using the <span class="property">authenticationManager</span>
                        property:
                    </p>
                    <pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="springSecurityCertificateHandler"
        class="org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler"&gt;
        &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
    &lt;/bean&gt;

    &lt;bean id="authenticationManager"
        class="org.springframework.security.providers.ProviderManager"&gt;
        &lt;property name="providers"&gt;
            &lt;bean class="org.springframework.ws.soap.security.x509.X509AuthenticationProvider"&gt;
                &lt;property name="x509AuthoritiesPopulator"&gt;
                    &lt;bean class="org.springframework.ws.soap.security.x509.populator.DaoX509AuthoritiesPopulator"&gt;
                        &lt;property name="userDetailsService" ref="userDetailsService"/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

  &lt;bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" /&gt;
  ...
&lt;/beans&gt;</pre>
                    <p>
                        In this case, we are using a custom user details service to obtain authentication details based on
                        the certificate. Refer to the
                        <a class="ulink" href="http://www.springframework.org/security" target="_top">
                            <em class="citetitle">Spring Security reference documentation</em>
                        </a>
                        for more information about authentication against X509 certificates.
                    </p>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2493" href="#d5e2493"></a>JaasCertificateValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The
                        <code class="classname">JaasCertificateValidationCallbackHandler</code>
                        requires a
                        <code class="methodname">loginContextName</code>
                        to operate. It creates a new JAAS
                        <code class="classname">LoginContext</code>
                        using this name and with the
                        <code class="classname">X500Principal</code>
                        of the certificate. This means that this callback handler
                        integrates with any JAAS
                        <code class="classname">LoginModule</code>
                        that handles X500 principals.
                    </p>
                    <p>
                        You can wire up a
                        <code class="classname">JaasCertificateValidationCallbackHandler</code>
                        as follows:
                    </p>
                    <pre class="programlisting">
&lt;bean id="jaasValidationHandler"
    class="org.springframework.ws.soap.security.xwss.callback.jaas.JaasCertificateValidationCallbackHandler"&gt;
    &lt;property name="loginContextName"&gt;MyLoginModule&lt;/property&gt;
&lt;/bean&gt;</pre>
                    <p>
                        In this case, the callback handler uses the
                        <code class="classname">LoginContext</code>
                        named
                        "MyLoginModule". This module should be defined in your
                        <code class="filename">jaas.config</code>
                        file, and
                        should be able to authenticate against X500 principals.
                    </p>
                </div>
            </div>

        </div>

        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2507" href="#d5e2507"></a>7.2.3&nbsp;Digital Signatures</h3></div></div></div>
            
            <p>
                The
                <span class="emphasis"><em>digital signature</em></span>
                of a message is a piece of information based on both the document
                and the signer's private key. There are two main tasks related to signatures in WS-Security: verifying
                signatures and signing messages.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="security-verifying-signatures" href="#security-verifying-signatures"></a>Verifying Signatures</h4></div></div></div>
                
                <p>
                    Just like<a class="link" href="#security-certificate-authentication" title="Certificate Authentication">certificate-based authentication</a>,
                    a signed message contains a
                    <code class="literal">BinarySecurityToken</code>, which contains the certificate used
                    to sign the message. Additionally, it contains a
                    <code class="literal">SignedInfo</code>
                    block, which indicates
                    what part of the message was signed.
                </p>
                <p>
                    To make sure that all incoming SOAP messages carry a<code class="literal">BinarySecurityToken</code>, the
                    security policy file should contain a
                    <code class="literal">RequireSignature</code>
                    element.
                    It can also contain a
                    <code class="literal">SignatureTarget</code>
                    element, which specifies the target message
                    part which was expected to be signed, and various other subelements. You can also define the private key
                    alias to use, whether to use a symmetric instead of a private key, and many other properties. You can
                    find a reference of possible child elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565769" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
    &lt;xwss:RequireSignature requireTimestamp="false"/&gt;
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    If the signature is not present, the
                    <code class="classname">XwsSecurityInterceptor</code>
                    will return a
                    SOAP Fault to the sender. If it is present, it will fire a
                    <code class="classname">SignatureVerificationKeyCallback</code>
                    to the registered handlers. Within Spring-WS,
                    there are is one class which handles this particular callback: the
                    <code class="classname">KeyStoreCallbackHandler</code>.
                </p>

                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2528" href="#d5e2528"></a>KeyStoreCallbackHandler</h5></div></div></div>
                    
                    <p>
                        As described in<a class="xref" href="#security-key-store-callback-handler" title="KeyStoreCallbackHandler">the section called &#8220;KeyStoreCallbackHandler&#8221;</a>, the
                        <code class="classname">KeyStoreCallbackHandler</code>
                        uses a
                        <code class="classname">java.security.KeyStore</code>
                        for handling various cryptographic callbacks, including signature verification. For signature
                        verification, the handler uses the
                        <code class="methodname">trustStore</code>
                        property:
                    </p>
                    <pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="trustStore" ref="trustStore"/&gt;
    &lt;/bean&gt;

    &lt;bean id="trustStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:org/springframework/ws/soap/security/xwss/test-truststore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre>
                </div>
            </div>

            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2536" href="#d5e2536"></a>Signing Messages</h4></div></div></div>
                
                <p>
                    When signing a message, the
                    <code class="classname">XwsSecurityInterceptor</code>
                    adds the
                    <code class="literal">BinarySecurityToken</code>
                    to the message, and a
                    <code class="literal">SignedInfo</code>
                    block, which
                    indicates what part of the message was signed.
                </p>
                <p>
                    To sign all outgoing SOAP messages, the
                    security policy file should contain a
                    <code class="literal">Sign</code>
                    element.
                    It can also contain a
                    <code class="literal">SignatureTarget</code>
                    element, which specifies the target message
                    part which was expected to be signed, and various other subelements. You can also define the private key
                    alias to use, whether to use a symmetric instead of a private key, and many other properties. You can
                    find a reference of possible child elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565497" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
	&lt;xwss:Sign includeTimestamp="false" /&gt;
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    The
                    <code class="classname">XwsSecurityInterceptor</code>
                    will fire a
                    <code class="classname">SignatureKeyCallback</code>
                    to the registered handlers. Within Spring-WS,
                    there are is one class which handles this particular callback: the
                    <code class="classname">KeyStoreCallbackHandler</code>.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2552" href="#d5e2552"></a>KeyStoreCallbackHandler</h5></div></div></div>
                    
                    <p>
                        As described in<a class="xref" href="#security-key-store-callback-handler" title="KeyStoreCallbackHandler">the section called &#8220;KeyStoreCallbackHandler&#8221;</a>, the
                        <code class="classname">KeyStoreCallbackHandler</code>
                        uses a
                        <code class="classname">java.security.KeyStore</code>
                        for handling various cryptographic callbacks, including signing messages. For adding signatures,
                        the handler uses the
                        <code class="methodname">keyStore</code>
                        property. Additionally, you must set
                        the
                        <code class="methodname">privateKeyPassword</code>
                        property to unlock the private key used for signing.
                    </p>
                    <pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="keyStore" ref="keyStore"/&gt;
        &lt;property name="privateKeyPassword" value="changeit"/&gt;
    &lt;/bean&gt;

    &lt;bean id="keyStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:keystore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre>
                </div>
            </div>
        </div>

        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2561" href="#d5e2561"></a>7.2.4&nbsp;Encryption and Decryption</h3></div></div></div>
            
            <p>
                When
                <span class="emphasis"><em>encrypting</em></span>, the message is transformed into a form that can only be read with the
                appropriate key. The message can be
                <span class="emphasis"><em>decrypted</em></span>
                to reveal the original, readable message.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2566" href="#d5e2566"></a>Decryption</h4></div></div></div>
                
                <p>
                    To decrypt incoming SOAP messages, the security policy file should contain a
                    <code class="literal">RequireEncryption</code>
                    element. This element can further carry a
                    <code class="literal">EncryptionTarget</code>
                    element which indicates which part of the message should be
                    encrypted, and a
                    <code class="literal">SymmetricKey</code>
                    to indicate that a shared secret instead of the regular
                    private key should be used to decrypt the message. You can read a description of the other elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565951" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
    &lt;xwss:RequireEncryption /&gt;
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    If an incoming message is not encrypted, the
                    <code class="classname">XwsSecurityInterceptor</code>
                    will return a
                    SOAP Fault to the sender. If it is present, it will fire a
                    <code class="classname">DecryptionKeyCallback</code>
                    to the registered handlers. Within Spring-WS, there is one class which handled this particular callback:
                    the<code class="classname">KeyStoreCallbackHandler</code>.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2579" href="#d5e2579"></a>KeyStoreCallbackHandler</h5></div></div></div>
                    
                    <p>
                        As described in<a class="xref" href="#security-key-store-callback-handler" title="KeyStoreCallbackHandler">the section called &#8220;KeyStoreCallbackHandler&#8221;</a>, the
                        <code class="classname">KeyStoreCallbackHandler</code>
                        uses a
                        <code class="classname">java.security.KeyStore</code>
                        for handling various cryptographic callbacks, including decryption. For decryption,
                        the handler uses the
                        <code class="methodname">keyStore</code>
                        property. Additionally, you must set
                        the
                        <code class="methodname">privateKeyPassword</code>
                        property to unlock the private key used for
                        decryption. For decryption based on symmetric keys, it will use the
                        <code class="methodname">symmetricStore</code>.
                    </p>
                    <pre class="programlisting">
&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="keyStore" ref="keyStore"/&gt;
        &lt;property name="privateKeyPassword" value="changeit"/&gt;
    &lt;/bean&gt;

    &lt;bean id="keyStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:keystore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre>
                </div>
            </div>

            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2589" href="#d5e2589"></a>Encryption</h4></div></div></div>
                
                <p>
                    To encrypt outgoing SOAP messages, the security policy file should contain a
                    <code class="literal">Encrypt</code>
                    element. This element can further carry a
                    <code class="literal">EncryptionTarget</code>
                    element which indicates
                    which part of the message should be encrypted, and a
                    <code class="literal">SymmetricKey</code>
                    to indicate that a
                    shared secret instead of the regular public key should be used to encrypt the message. You can read a
                    description of the other elements
                    <a class="ulink" href="http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565951" target="_top">
                        <em class="citetitle">here</em>
                    </a>
                    .
                </p>
                <pre class="programlisting">
&lt;xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&gt;
    &lt;xwss:Encrypt /&gt;
&lt;/xwss:SecurityConfiguration&gt;</pre>
                <p>
                    The
                    <code class="classname">XwsSecurityInterceptor</code>
                    will fire a
                    <code class="classname">EncryptionKeyCallback</code>
                    to the registered handlers in order to retrieve the
                    encryption information. Within Spring-WS, there is one class which handled this particular callback: the
                    <code class="classname">KeyStoreCallbackHandler</code>.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2602" href="#d5e2602"></a>KeyStoreCallbackHandler</h5></div></div></div>
                    
                    <p>
                        As described in<a class="xref" href="#security-key-store-callback-handler" title="KeyStoreCallbackHandler">the section called &#8220;KeyStoreCallbackHandler&#8221;</a>, the
                        <code class="classname">KeyStoreCallbackHandler</code>
                        uses a
                        <code class="classname">java.security.KeyStore</code>
                        for handling various cryptographic callbacks, including encryption. For encryption based on public
                        keys, the handler uses the
                        <code class="methodname">trustStore</code>
                        property. For encryption based on
                        symmetric keys, it will use the<code class="methodname">symmetricStore</code>.
                    </p>
                    <pre class="programlisting">&lt;beans&gt;
    &lt;bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler"&gt;
        &lt;property name="trustStore" ref="trustStore"/&gt;
    &lt;/bean&gt;

    &lt;bean id="trustStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
        &lt;property name="location" value="classpath:truststore.jks"/&gt;
        &lt;property name="password" value="changeit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre>
                </div>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="security-xws-exception-handling" href="#security-xws-exception-handling"></a>7.2.5&nbsp;Security Exception Handling</h3></div></div></div>
            
            <p>
                When an securement or validation action fails, the <code class="classname">XwsSecurityInterceptor</code>
                will throw a <code class="exceptionname">WsSecuritySecurementException</code> or
                <code class="exceptionname">WsSecurityValidationException</code> respectively.
                These exceptions bypass the <a class="link" href="#server-endpoint-exception-resolver" title="5.6&nbsp;Handling Exceptions">standard
                exception handling mechanism</a>, but are handled in the interceptor itself.
            </p>
            <p>
                <code class="exceptionname">WsSecuritySecurementException</code> exceptions are handled in the
                <code class="methodname">handleSecurementException</code> method of the
                <code class="classname">XwsSecurityInterceptor</code>.
                By default, this method will simply log an error, and stop further processing of the message.
            </p>
            <p>
                Similarly, <code class="exceptionname">WsSecurityValidationException</code> exceptions are handled in the
                <code class="methodname">handleValidationException</code> method of the
                <code class="classname">XwsSecurityInterceptor</code>.
                By default, this method will create a SOAP 1.1 Client or SOAP 1.2 Sender Fault, and send that back as
                a response.
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
                <p>
                    Both <code class="methodname">handleSecurementException</code> and
                    <code class="methodname">handleValidationException</code> are protected methods, which you can override
                    to change their default behavior.
                </p>
            </td></tr></table></div>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-wss4j-security-interceptor" href="#security-wss4j-security-interceptor"></a>7.3&nbsp;
            <code class="classname">Wss4jSecurityInterceptor</code>
        </h2></div></div></div>
        
        <p>
            The <code class="classname">Wss4jSecurityInterceptor</code> is an <code class="classname">EndpointInterceptor</code>
            (see <a class="xref" href="#server-endpoint-interceptor" title="5.5.2&nbsp;Intercepting requests - the EndpointInterceptor interface">Section&nbsp;5.5.2, &#8220;Intercepting requests - the <code class="interfacename">EndpointInterceptor</code> interface&#8221;</a>) that is based on
            <a class="ulink" href="http://ws.apache.org/wss4j/" target="_top">Apache's WSS4J</a>.
        </p>
        <p>
            WSS4J implements the following standards:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                    <p>OASIS Web Serives Security: SOAP Message Security 1.0 Standard 200401, March 2004</p>
                </li><li class="listitem">
                    <p>Username Token profile V1.0</p>
                </li><li class="listitem">
                    <p>X.509 Token Profile V1.0</p>
                </li></ul></div><p>
        </p>
        <p>
            This interceptor supports messages created by the
            <code class="classname">AxiomSoapMessageFactory</code>
            and the
            <code class="classname">SaajSoapMessageFactory</code>.
        </p>

        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2649" href="#d5e2649"></a>7.3.1&nbsp;Configuring
                <code class="classname">Wss4jSecurityInterceptor</code>
            </h3></div></div></div>
            
            <p>
                WSS4J uses no external configuration file; the interceptor is entirely configured by properties.
                The validation and securement actions executed by this interceptor are specified via
                <span class="property">validationActions</span>
                and
                <span class="property">securementActions</span>
                properties, respectively.
                Actions are passed as a space-separated strings. Here is an example configuration:
            </p>
            <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="UsernameToken Encrypt"/&gt;
    ...
    &lt;property name="securementActions" value="Encrypt"/&gt;
    ...
&lt;/bean&gt;</pre>
            <p>Validation actions are:</p>
            <div class="informaltable">
                <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Validation action</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">UsernameToken</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Validates username token</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">Timestamp</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Validates the timestamp</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">Encrypt</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Decrypts the message</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">Signature</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Validates the signature</td></tr><tr><td style="border-right: 0.5pt solid ; ">
                                <code class="methodname">NoSecurity</code>
                            </td><td style="">No action performed</td></tr></tbody></table>
            </div>
            <p>Securement actions are:</p>
            <div class="informaltable">
                <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Securement action</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">UsernameToken</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Adds a username token</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">UsernameTokenSignature</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Adds a username token and a signature username token secret key</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">Timestamp</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Adds a timestamp</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">Encrypt</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Encrypts the response</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <code class="methodname">Signature</code>
                            </td><td style="border-bottom: 0.5pt solid ; ">Signs the response</td></tr><tr><td style="border-right: 0.5pt solid ; ">
                                <code class="methodname">NoSecurity</code>
                            </td><td style="">No action performed</td></tr></tbody></table>
            </div>
            <p>
                The order of the actions is significant and is enforced by the interceptor. The interceptor
                will reject an incoming SOAP message if its security actions were performed in a different order than
                the one specified by<code class="methodname">validationActions</code>.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2718" href="#d5e2718"></a>7.3.2&nbsp;Handling Digital Certificates</h3></div></div></div>
            
            <p>
                For cryptographic operations requiring interaction with a keystore or certificate handling
                (signature, encryption and decryption operations), WSS4J
                requires an instance of<code class="interfacename">org.apache.ws.security.components.crypto.Crypto</code>.
            </p>
            <p>
                <code class="interfacename">Crypto</code>
                instances can be obtained from WSS4J's
                <code class="classname">CryptoFactory</code>
                or more conveniently
                with the Spring-WS<code class="classname">CryptoFactoryBean</code>.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2726" href="#d5e2726"></a>CryptoFactoryBean</h4></div></div></div>
                
                <p>
                    Spring-WS provides a convenient factory bean,
                    <code class="classname">CryptoFactoryBean</code>
                    that constructs and configures
                    <code class="classname">Crypto</code>
                    instances via strong-typed properties
                    (prefered) or through a
                    <code class="classname">Properties</code>
                    object.
                </p>
                <p>
                    By default,
                    <code class="classname">CryptoFactoryBean</code>
                    returns instances of
                    <code class="classname">org.apache.ws.security.components.crypto.Merlin</code>.
                    This can be changed by setting the
                    <span class="property">cryptoProvider</span>
                    property
                    (or its equivalent
                    <code class="literal">org.apache.ws.security.crypto.provider</code>
                    string property).
                </p>
                <p>
                    Here is a simple example configuration:
                </p>
                <pre class="programlisting">
&lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
    &lt;property name="keyStorePassword" value="mypassword"/&gt;
    &lt;property name="keyStoreLocation" value="file:/path_to_keystore/keystore.jks"/&gt;
&lt;/bean&gt;
				</pre>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2739" href="#d5e2739"></a>7.3.3&nbsp;Authentication</h3></div></div></div>
            
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2741" href="#d5e2741"></a>Validating Username Token</h4></div></div></div>
                
                <p>
                    Spring-WS provides a set of callback handlers to integrate with Spring Security.
                    Additionally, a simple callback handler
                    <code class="classname">SimplePasswordValidationCallbackHandler</code>
                    is provided to configure users and passwords with an in-memory
                    <code class="classname">Properties</code>
                    object.
                </p>
                <p>
                    Callback handlers are configured via <code class="classname">Wss4jSecurityInterceptor</code>'s
                    <span class="property">validationCallbackHandler</span>
                    property.
                </p>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2749" href="#d5e2749"></a>SimplePasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        <code class="classname">SimplePasswordValidationCallbackHandler</code>
                        validates plain text and digest
                        username tokens against an in-memory
                        <code class="classname">Properties</code>
                        object. It is configured
                        as follows:
                    </p>
                    <pre class="programlisting">&lt;bean id="callbackHandler"
    class="org.springframework.ws.soap.security.wss4j.callback.SimplePasswordValidationCallbackHandler"&gt;
    &lt;property name="users"&gt;
        &lt;props&gt;
            &lt;prop key="Bert"&gt;Ernie&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                </div>
                <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d5e2755" href="#d5e2755"></a>SpringSecurityPasswordValidationCallbackHandler</h5></div></div></div>
                    
                    <p>
                        The <code class="classname">SpringSecurityPasswordValidationCallbackHandler</code> validates plain text
                        and digest passwords using a Spring Security
                        <code class="classname">UserDetailService</code>
                        to operate. It uses this service to retrieve the
                        (digest of ) the password of the user specified in the token. The (digest of) the password contained in this
                        details object is then compared with the digest in the message. If they are equal, the user has
                        successfully authenticated, and a
                        <code class="classname">UsernamePasswordAuthenticationToken</code>
                        is stored in the<code class="classname">SecurityContextHolder</code>. You can set the service using the
                        <span class="property">userDetailsService</span>. Additionally, you can set a
                        <span class="property">userCache</span>
                        property, to cache loaded user details.
                    </p>
                    <pre class="programlisting">&lt;beans&gt;
    &lt;bean class="org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler"&gt;
        &lt;property name="userDetailsService" ref="userDetailsService"/&gt;
    &lt;/bean&gt;

    &lt;bean id="userDetailsService" class="com.mycompany.app.dao.UserDetailService" /&gt;
    ...
&lt;/beans&gt;
					</pre>
                </div>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2765" href="#d5e2765"></a>Adding Username Token</h4></div></div></div>
                
                <p>
                    Adding a username token to an outgoing message is as simple as adding
                    <code class="literal">UsernameToken</code>
                    to the
                    <span class="property">securementActions</span>
                    property of the
                    <code class="classname">Wss4jSecurityInterceptor</code>
                    and specifying
                    <span class="property">securementUsername</span>
                    and<span class="property">securementPassword</span>.
                </p>
                <p>
                    The password type can be set via the
                    <span class="property">securementPasswordType</span>
                    property. Possible
                    values are
                    <code class="literal">PasswordText</code>
                    for plain text passwords or
                    <code class="literal">PasswordDigest</code>
                    for digest passwords, which is the default.
                </p>
                <p>
                    The following example generates a username token with a digest password:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="UsernameToken"/&gt;
    &lt;property name="securementUsername" value="Ernie"/&gt;
    &lt;property name="securementPassword" value="Bert"/&gt;
&lt;/bean&gt;</pre>
                <p>
                    If plain text password type is chosen, it is possible to instruct the interceptor to add
                    <code class="literal">Nonce</code>
                    and/or
                    <code class="literal">Created</code>
                    elements using the
                    <span class="property">securementUsernameTokenElements</span>
                    property. The value must be a list containing
                    the desired elements' names separated by spaces (case sensitive).
                </p>
                <p>
                    The next example generates a username token with a plain text password,
                    a
                    <code class="literal">Nonce</code>
                    and a
                    <code class="literal">Created</code>
                    element:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="UsernameToken"/&gt;
    &lt;property name="securementUsername" value="Ernie"/&gt;
    &lt;property name="securementPassword" value="Bert"/&gt;
    &lt;property name="securementPasswordType" value="PasswordText"/&gt;
    &lt;property name="securementUsernameTokenElements" value="Nonce Created"/&gt;
&lt;/bean&gt;</pre>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2787" href="#d5e2787"></a>Certificate Authentication</h4></div></div></div>
                
                <p>
                    As certificate authentication is akin to digital signatures, WSS4J handles it as part of the signature
                    validation and securement.
                    Specifically, the
                    <span class="property">securementSignatureKeyIdentifier</span>
                    property must be set to
                    <code class="literal">DirectReference</code>
                    in order to instruct WSS4J to
                    generate a
                    <code class="literal">BinarySecurityToken</code>
                    element containing the X509 certificate and to
                    include it in the outgoing message. The certificate's name and password are passed through the
                    <span class="property">securementUsername</span>
                    and
                    <span class="property">securementPassword</span>
                    properties respectively.
                    See the next example:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="Signature"/&gt;
    &lt;property name="securementSignatureKeyIdentifier" value="DirectReference"/&gt;
    &lt;property name="securementUsername" value="mycert"/&gt;
    &lt;property name="securementPassword" value="certpass"/&gt;
    &lt;property name="securementSignatureCrypto"&gt;
      &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
        &lt;property name="keyStorePassword" value="123456"/&gt;
        &lt;property name="keyStoreLocation" value="classpath:/keystore.jks"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                <p>
                    For the certificate validation, regular signature validation applies:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="Signature"/&gt;
    &lt;property name="validationSignatureCrypto"&gt;
      &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
        &lt;property name="keyStorePassword" value="123456"/&gt;
        &lt;property name="keyStoreLocation" value="classpath:/keystore.jks"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                <p>
                    At the end of the validation, the interceptor will automatically verify the validity of the certificate
                    by delegating to the default WSS4J implementation.
                    If needed, this behavior can be changed by redefining the
                    <code class="methodname">verifyCertificateTrust</code>
                    method.
                </p>
                <p>
                    For more details, please refer to<a class="xref" href="#security-wss4j-digital-signatures" title="7.3.5&nbsp;Digital Signatures">Section&nbsp;7.3.5, &#8220;Digital Signatures&#8221;</a>.
                </p>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2802" href="#d5e2802"></a>7.3.4&nbsp;Security Timestamps</h3></div></div></div>
            
            <p>
                This section describes the various timestamp options available in the
                <code class="classname">Wss4jSecurityInterceptor</code>.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2806" href="#d5e2806"></a>Validating Timestamps</h4></div></div></div>
                
                <p>
                    To validate timestamps add
                    <code class="literal">Timestamp</code>
                    to the
                    <span class="property">validationActions</span>
                    property.
                    It is possible to override timestamp semantics specified by the initiator of the SOAP message
                    by setting
                    <span class="property">timestampStrict</span>
                    to
                    <code class="literal">true</code>
                    and
                    specifying a server-side time to live in seconds (defaults to 300) via the
                    <span class="property">timeToLive</span>
                    property
                    <a href="#ftn.d5e2814" class="footnote" name="d5e2814"><sup class="footnote">[3]</sup></a>
                    .
                </p>
                <p>
                    In the following example, the interceptor will limit the timestamp validity window to 10
                    seconds, rejecting any valid timestamp token outside that window:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="Timestamp"/&gt;
    &lt;property name="timestampStrict" value="true"/&gt;
    &lt;property name="timeToLive" value="10"/&gt;
&lt;/bean&gt;
					 </pre>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2819" href="#d5e2819"></a>Adding Timestamps</h4></div></div></div>
                
                <p>
                    Adding
                    <code class="literal">Timestamp</code>
                    to the
                    <span class="property">securementActions</span>
                    property
                    generates a timestamp header in outgoing messages. The
                    <span class="property">timestampPrecisionInMilliseconds</span>
                    property specifies whether the precision
                    of the generated timestamp is in milliseconds. The default value is<code class="literal">true</code>.
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="Timestamp"/&gt;
    &lt;property name="timestampPrecisionInMilliseconds" value="true"/&gt;
&lt;/bean&gt;
					</pre>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="security-wss4j-digital-signatures" href="#security-wss4j-digital-signatures"></a>7.3.5&nbsp;Digital Signatures</h3></div></div></div>
            
            <p>
                This section describes the various signature options available in the
                <code class="classname">Wss4jSecurityInterceptor</code>.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2831" href="#d5e2831"></a>Verifying Signatures</h4></div></div></div>
                
                <p>
                    To instruct the<code class="classname">Wss4jSecurityInterceptor</code>,
                    <span class="property">validationActions</span>
                    must contain the
                    <code class="literal">Signature</code>
                    action.
                    Additionally, the
                    <span class="property">validationSignatureCrypto</span>
                    property
                    must point to the keystore containing the public certificates of the initiator:
                </p>
                <pre class="programlisting">&lt;bean id="wsSecurityInterceptor" class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="Signature"/&gt;
    &lt;property name="validationSignatureCrypto"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
            &lt;property name="keyStorePassword" value="123456"/&gt;
            &lt;property name="keyStoreLocation" value="classpath:/keystore.jks"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2839" href="#d5e2839"></a>Signing Messages</h4></div></div></div>
                
                <p>
                    Signing outgoing messages is enabled by adding
                    <code class="literal">Signature</code>
                    action
                    to the<span class="property">securementActions</span>. The alias and the password of the private key to use
                    are specified by the
                    <span class="property">securementUsername</span>
                    and
                    <span class="property">securementPassword</span>
                    properties respectively.
                    <span class="property">securementSignatureCrypto</span>
                    must point to the keystore containing the private key:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="Signature"/&gt;
    &lt;property name="securementUsername" value="mykey"/&gt;
    &lt;property name="securementPassword" value="123456"/&gt;
    &lt;property name="securementSignatureCrypto"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
            &lt;property name="keyStorePassword" value="123456"/&gt;
            &lt;property name="keyStoreLocation" value="classpath:/keystore.jks"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
				</pre>
                <p>
                    Furthermore, the signature algorithm can be defined
                    via the
                    <span class="property">securementSignatureAlgorithm</span>.
                </p>
                <p>
                    The key identifier type to use can be customized via the
                    <span class="property">securementSignatureKeyIdentifier</span>
                    property.
                    Only
                    <code class="literal">IssuerSerial</code>
                    and
                    <code class="literal">DirectReference</code>
                    are valid for signature.
                </p>
                <p>
                    <span class="property">securementSignatureParts</span>
                    property controls which part of the message shall be
                    signed.
                    The value of this property is a list of semi-colon separated element names that identify the
                    elements to sign.
                    The general form of a signature part is
                    <code class="literal">{}{namespace}Element</code>
                    <a href="#ftn.d5e2857" class="footnote" name="d5e2857"><sup class="footnote">[4]</sup></a>
                    .
                    The default behavior is to sign the SOAP body.
                </p>
                <p>
                    As an example, here is how to sign the
                    <code class="literal">echoResponse</code>
                    element
                    in the Spring Web Services echo sample:
                </p>
                <pre class="programlisting">&lt;property name="securementSignatureParts"
    value="{}{http://www.springframework.org/spring-ws/samples/echo}echoResponse"/&gt;
    			</pre>
                <p>
                    To specify an element without a namespace use the string
                    <code class="literal">Null</code>
                    as the namespace name (case sensitive).
                </p>
                <p>
                    If there is no other element in the request with a local name of
                    <code class="methodname">Body</code>
                    then
                    the SOAP namespace identifier can be empty (<code class="methodname">{}</code>).
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2867" href="#d5e2867"></a>Signature Confirmation</h4></div></div></div>
                
                <p>
                    Signature confirmation is enabled by setting
                    <span class="property">enableSignatureConfirmation</span>
                    to
                    <code class="literal">true</code>.
                    Note that signature confirmation action spans over the request and the response.
                    This implies that
                    <code class="methodname">secureResponse</code>
                    and
                    <code class="methodname">validateRequest</code>
                    must be set to true (which is the default value) even if there are no corresponding security actions.
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="Signature"/&gt;
    &lt;property name="enableSignatureConfirmation" value="true"/&gt;
    &lt;property name="validationSignatureCrypto"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
            &lt;property name="keyStorePassword" value="123456"/&gt;
            &lt;property name="keyStoreLocation" value="file:/keystore.jks"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2875" href="#d5e2875"></a>7.3.6&nbsp;Encryption and Decryption</h3></div></div></div>
            
            <p>
                This section describes the various encryption and descryption options available in the
                <code class="classname">Wss4jSecurityInterceptor</code>.
            </p>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2879" href="#d5e2879"></a>Decryption</h4></div></div></div>
                
                <p>
                    Decryption of incoming SOAP messages requires
                    <code class="literal">Encrypt</code>
                    action be added
                    to the
                    <span class="property">validationActions</span>
                    property. The rest of the configuration
                    depends on the key information that appears in the message
                    <a href="#ftn.d5e2884" class="footnote" name="d5e2884"><sup class="footnote">[5]</sup></a>
                    .
                </p>
                <p>
                    To decrypt messages with an embedded encypted symmetric key
                    (
                    <code class="literal">xenc:EncryptedKey</code>
                    element),
                    <span class="property">validationDecryptionCrypto</span>
                    needs to point to a keystore containing the
                    decryption private key. Additionally,
                    <span class="property">validationCallbackHandler</span>
                    has to be injected
                    with a
                    <code class="classname">org.springframework.ws.soap.security.wss4j.callback.KeyStoreCallbackHandler</code>
                    specifying the key's password:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="Encrypt"/&gt;
    &lt;property name="validationDecryptionCrypto"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
            &lt;property name="keyStorePassword" value="123456"/&gt;
            &lt;property name="keyStoreLocation" value="classpath:/keystore.jks"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="validationCallbackHandler"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.callback.KeyStoreCallbackHandler"&gt;
            &lt;property name="privateKeyPassword" value="mykeypass"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                <p>
                    To support decryption of messages with an embedded
                    <span class="emphasis"><em>key name</em></span>
                    (
                    <code class="literal">ds:KeyName</code>
                    element),
                    configure a
                    <code class="classname">KeyStoreCallbackHandler</code>
                    that
                    points to the keystore with the symmetric secret key. The property
                    <span class="property">symmetricKeyPassword</span>
                    indicates the key's password, the key name being the
                    one specified by
                    <code class="literal">ds:KeyName</code>
                    element:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="validationActions" value="Encrypt"/&gt;
    &lt;property name="validationCallbackHandler"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.callback.KeyStoreCallbackHandler"&gt;
            &lt;property name="keyStore"&gt;
                &lt;bean class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
                    &lt;property name="location" value="classpath:keystore.jks"/&gt;
                    &lt;property name="type" value="JCEKS"/&gt;
                    &lt;property name="password" value="123456"/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name="symmetricKeyPassword" value="mykeypass"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
            </div>
            <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e2899" href="#d5e2899"></a>Encryption</h4></div></div></div>
                
                <p>
                    Adding
                    <code class="literal">Encrypt</code>
                    to the
                    <span class="property">securementActions</span>
                    enables encryption
                    of outgoing messages.
                    The certifacte's alias to use for the encryption is set via the
                    <span class="property">securementEncryptionUser</span>
                    property.
                    The keystore where the certificate reside is accessed using the
                    <span class="property">securementEncryptionCrypto</span>
                    property.
                    As encryption relies on public certificates, no password needs to be passed.
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="Encrypt"/&gt;
    &lt;property name="securementEncryptionUser" value="mycert"/&gt;
    &lt;property name="securementEncryptionCrypto"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean"&gt;
            &lt;property name="keyStorePassword" value="123456"/&gt;
            &lt;property name="keyStoreLocation" value="file:/keystore.jks"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                <p>
                    Encryption can be customized in several ways:
                    The key identifier type to use is defined by<span class="property">securementEncryptionKeyIdentifier</span>.
                    Possible values are<code class="literal">IssuerSerial</code>,<code class="literal">X509KeyIdentifier</code>,
                    <code class="literal">DirectReference</code>,<code class="literal">Thumbprint</code>,
                    <code class="literal">SKIKeyIdentifier</code>
                    or<code class="literal">EmbeddedKeyName</code>.
                </p>
                <p>
                    If the
                    <code class="literal">EmbeddedKeyName</code>
                    type is chosen, you need to specify the
                    <span class="emphasis"><em>secret key</em></span>
                    to use for the encryption. The alias of the key is set via the
                    <span class="property">securementEncryptionUser</span>
                    property just as for the other key identifier types.
                    However, WSS4J requires a callback handler to fetch the secret key.
                    Thus,
                    <span class="property">securementCallbackHandler</span>
                    must be provided with a
                    <code class="classname">KeyStoreCallbackHandler</code>
                    pointing to the appropriate keystore.
                    By default, the
                    <code class="literal">ds:KeyName</code>
                    element in the resulting WS-Security header takes the
                    value of the
                    <span class="property">securementEncryptionUser</span>
                    property. To indicate a different name,
                    set the
                    <span class="property">securementEncryptionEmbeddedKeyName</span>
                    with the desired value.
                    In the next example, the outgoing message will be encrypted with a key aliased
                    <code class="literal">secretKey</code>
                    whereas
                    <code class="literal">myKey</code>
                    will appear in
                    <code class="literal">ds:KeyName</code>
                    element:
                </p>
                <pre class="programlisting">&lt;bean class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&gt;
    &lt;property name="securementActions" value="Encrypt"/&gt;
    &lt;property name="securementEncryptionKeyIdentifier" value="EmbeddedKeyName"/&gt; 
    &lt;property name="securementEncryptionUser" value="secretKey"/&gt;
    &lt;property name="securementEncryptionEmbeddedKeyName" value="myKey"/&gt;
    &lt;property name="securementCallbackHandler"&gt;
        &lt;bean class="org.springframework.ws.soap.security.wss4j.callback.KeyStoreCallbackHandler"&gt;
            &lt;property name="symmetricKeyPassword" value="keypass"/&gt;
            &lt;property name="keyStore"&gt;
                &lt;bean class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean"&gt;
                    &lt;property name="location" value="file:/keystore.jks"/&gt;
                    &lt;property name="type" value="jceks"/&gt;
                    &lt;property name="password" value="123456"/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
                <p>
                    The
                    <span class="property">securementEncryptionKeyTransportAlgorithm</span>
                    property
                    defines which algorithm to use to encrypt the generated symmetric key. Supported values are
                    <code class="literal">http://www.w3.org/2001/04/xmlenc#rsa-1_5</code>, which is the default, and
                    <code class="literal">http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p</code>.
                </p>
                <p>
                    The symmetric encryption algorithm to use can be set via the
                    <span class="property">securementEncryptionSymAlgorithm</span>
                    property.
                    Supported values are
                    <code class="literal">http://www.w3.org/2001/04/xmlenc#aes128-cbc</code>
                    (default value),
                    <code class="literal">http://www.w3.org/2001/04/xmlenc#tripledes-cbc</code>,
                    <code class="literal">http://www.w3.org/2001/04/xmlenc#aes256-cbc</code>,
                    <code class="literal">http://www.w3.org/2001/04/xmlenc#aes192-cbc</code>.
                </p>
                <p>
                    Finally, the
                    <span class="property">securementEncryptionParts</span>
                    property defines which parts of the
                    message will be encrypted. The value of this property is a list of semi-colon separated element
                    names that identify the elements to encrypt. An encryption mode specifier and a namespace
                    identification, each inside a pair of curly brackets, may precede each element name.
                    The encryption mode specifier is either
                    <code class="literal">{Content}</code>
                    or
                    <code class="literal">{Element}</code>
                    <a href="#ftn.d5e2942" class="footnote" name="d5e2942"><sup class="footnote">[6]</sup></a>
                    .
                    The following example identifies the
                    <code class="literal">echoResponse</code>
                    from the echo sample:
                </p>
                <pre class="programlisting">&lt;property name="securementEncryptionParts"
    value="{Content}{http://www.springframework.org/spring-ws/samples/echo}echoResponse"/&gt;</pre>
                <p>
                    Be aware that the element name, the namespace identifier, and the encryption modifier are case
                    sensitive.
                    The encryption modifier and the namespace identifier can be omitted. In this case the encryption
                    mode defaults to
                    <code class="literal">Content</code>
                    and the namespace is set to the SOAP namespace.
                </p>
                <p>
                    To specify an element without a namespace use the value
                    <code class="literal">Null</code>
                    as the namespace
                    name (case sensitive).
                    If no list is specified, the handler encrypts the SOAP Body in
                    <code class="literal">Content</code>
                    mode by
                    default.
                </p>
            </div>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2951" href="#d5e2951"></a>7.3.7&nbsp;Security Exception Handling</h3></div></div></div>
            
            <p>
                The exception handling of the <code class="classname">Wss4jSecurityInterceptor</code> is identical to that of
                the <code class="classname">XwsSecurityInterceptor</code>. See <a class="xref" href="#security-xws-exception-handling" title="7.2.5&nbsp;Security Exception Handling">Section&nbsp;7.2.5, &#8220;Security Exception Handling&#8221;</a>
                for more information.
            </p>
        </div>
    </div>
<div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.d5e2814" class="footnote">
                        <p><a href="#d5e2814" class="para"><sup class="para">[3] </sup></a>
                            The interceptor will always reject already expired timestamps whatever the value of
                            <span class="property">timeToLive</span>
                            is.
                        </p>
                    </div><div id="ftn.d5e2857" class="footnote">
                        <p><a href="#d5e2857" class="para"><sup class="para">[4] </sup></a>
                            The first empty brackets are used for encryption parts only.
                        </p>
                    </div><div id="ftn.d5e2884" class="footnote">
                        <p><a href="#d5e2884" class="para"><sup class="para">[5] </sup></a>
                            This is because WSS4J needs only a Crypto for encypted keys, whereas embedded key name
                            validation is delegated to a callback handler.
                        </p>
                    </div><div id="ftn.d5e2942" class="footnote">
                        <p><a href="#d5e2942" class="para"><sup class="para">[6] </sup></a>
                            Please refer to the W3C XML Encryption specification about the differences between
                            Element and Content encryption.
                        </p>
                    </div></div></div>
    </div>
    <div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="resources" href="#resources"></a>Part&nbsp;III.&nbsp;Other Resources</h1></div></div></div>
        
        <div class="partintro"><div></div>
            <p>
                In addition to this reference documentation, there exist a number of
                other resources that may help you learn how to use Spring Web Services.
                These additional, third-party resources are enumerated in this section.
            </p>
        </div>
        <div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="d5e2961" href="#d5e2961"></a>Bibliography</h2></div></div></div>
    
    <div class="biblioentry"><a name="waldo-94" href="#waldo-94"></a><p>[waldo-94] 
        <span class="authorgroup"><span class="firstname">Jim</span> <span class="surname">Waldo</span>, <span class="firstname">Ann</span> <span class="surname">Wollrath</span>, and <span class="firstname">Sam</span> <span class="surname">Kendall</span>. </span>
        <span class="title"><i>A Note on Distributed Computing</i>. </span>
        <span class="publisher">
            <span class="publishername">Springer Verlag. </span>
        </span>
        <span class="date">1994. </span>
    </p></div>
    <div class="biblioentry"><a name="alpine" href="#alpine"></a><p>[alpine] 
        <span class="authorgroup"><span class="firstname">Steve</span> <span class="surname">Loughran</span> and <span class="firstname">Edmund</span> <span class="surname">Smith</span>. </span>
        <span class="title"><i>Rethinking the Java SOAP Stack</i>. </span>
        <span class="date">May 17, 2005. </span>
        <span class="copyright">Copyright &copy; 2005 IEEE Telephone Laboratories, Inc.. </span>
    </p></div>
    <div class="biblioentry"><a name="effective-enterprise-java" href="#effective-enterprise-java"></a><p>[effective-enterprise-java] 
        <span class="authorgroup"><span class="firstname">Ted</span> <span class="surname">Neward</span>. </span>
        <span class="editor"><span class="firstname">Scott</span> <span class="surname">Meyers</span>. </span>
        <span class="title"><i>Effective Enterprise Java</i>. </span>
        <span class="publisher">
            <span class="publishername">Addison-Wesley. </span>
        </span>
        <span class="date">2004. </span>
    </p></div>
    <div class="biblioentry"><a name="effective-xml" href="#effective-xml"></a><p>[effective-xml] 
        <span class="authorgroup"><span class="firstname">Elliotte Rusty</span> <span class="surname">Harold</span>. </span>
        <span class="editor"><span class="firstname">Scott</span> <span class="surname">Meyers</span>. </span>
        <span class="title"><i>Effective XML</i>. </span>
        <span class="publisher">
            <span class="publishername">Addison-Wesley. </span>
        </span>
        <span class="date">2004. </span>
    </p></div>
</div>
    </div>
</div></body></html>