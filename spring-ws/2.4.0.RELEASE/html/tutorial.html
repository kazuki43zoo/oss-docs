<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Writing Contract-First Web Services</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Web Services Reference Documentation"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;Introduction"><link rel="prev" href="why-contract-first.html" title="2.&nbsp;Why Contract First?"><link rel="next" href="pt02.html" title="Part&nbsp;II.&nbsp;Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Writing Contract-First Web Services</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="why-contract-first.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;Introduction</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="pt02.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial" href="#tutorial"></a>3.&nbsp;Writing Contract-First Web Services</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e193" href="#d5e193"></a>3.1&nbsp;Introduction</h2></div></div></div>
        
        <p>
            This tutorial shows you how to write
            <a class="link" href="why-contract-first.html" title="2.&nbsp;Why Contract First?">contract-first Web services</a>, that is,
            developing web services that start with the XML Schema/WSDL contract first
            followed by the Java code second. Spring-WS focuses on this development style,
            and this tutorial will help you get started. Note that the first part of this
            tutorial contains almost no Spring-WS specific information: it is mostly about
            XML, XSD, and WSDL. The <a class="link" href="tutorial.html#tutorial-creating-project" title="3.5&nbsp;Creating the project">second part</a>
            focuses on implementing this contract using Spring-WS .
        </p>
        <p>
            The most important thing when doing contract-first Web service development is
            to try and think in terms of XML. This means that Java-language concepts are
            of lesser importance. It is the XML that is sent across the wire, and you
            should focus on that. The fact that Java is used to implement the Web service
            is an implementation detail. An important detail, but a detail nonetheless.
        </p>
        <p>
            In this tutorial, we will define a Web service that is created by a Human Resources
            department. Clients can send holiday request forms to this service to book a holiday.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e200" href="#d5e200"></a>3.2&nbsp;Messages</h2></div></div></div>
        
        <p>
            In this section, we will focus on the actual XML messages that are sent to
            and from the Web service. We will start out by determining what these messages
            look like.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e203" href="#d5e203"></a>3.2.1&nbsp;Holiday</h3></div></div></div>
            
            <p>
                In the scenario, we have to deal with holiday requests, so it makes sense
                to determine what a holiday looks like in XML:
            </p>
            <pre class="programlisting">
&lt;Holiday xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;StartDate&gt;2006-07-03&lt;/StartDate&gt;
    &lt;EndDate&gt;2006-07-07&lt;/EndDate&gt;
&lt;/Holiday&gt;</pre>
            <p>
                A holiday consists of a start date and an end date. We have also decided to
                use the standard
                <a class="ulink" href="http://www.cl.cam.ac.uk/~mgk25/iso-time.html" target="_top">ISO 8601</a>
                date format for the dates, because that will save a lot of parsing hassle.
                We have also added a namespace to the element, to make sure our elements
                can used within other XML documents.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e209" href="#d5e209"></a>3.2.2&nbsp;Employee</h3></div></div></div>
            
            <p>
                There is also the notion of an employee in the scenario. Here is what it
                looks like in XML:
            </p>
            <pre class="programlisting">
&lt;Employee xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;Number&gt;42&lt;/Number&gt;
    &lt;FirstName&gt;Arjen&lt;/FirstName&gt;
    &lt;LastName&gt;Poutsma&lt;/LastName&gt;
&lt;/Employee&gt;</pre>
            <p>
                We have used the same namespace as before. If this
                <code class="literal">&lt;Employee/&gt;</code> element could be used in other
                scenarios, it might make sense to use a different namespace, such as
                <code class="literal">http://mycompany.com/employees/schemas</code>.
            </p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e216" href="#d5e216"></a>3.2.3&nbsp;HolidayRequest</h3></div></div></div>
            
            <p>
                Both the holiday and employee element can be put in a
                <code class="literal">&lt;HolidayRequest/&gt;</code>:
            </p>
            <pre class="programlisting">
&lt;HolidayRequest xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;Holiday&gt;
        &lt;StartDate&gt;2006-07-03&lt;/StartDate&gt;
        &lt;EndDate&gt;2006-07-07&lt;/EndDate&gt;
    &lt;/Holiday&gt;
    &lt;Employee&gt;
        &lt;Number&gt;42&lt;/Number&gt;
        &lt;FirstName&gt;Arjen&lt;/FirstName&gt;
        &lt;LastName&gt;Poutsma&lt;/LastName&gt;
    &lt;/Employee&gt;
&lt;/HolidayRequest&gt;</pre>
            <p>
                The order of the two elements does not matter: <code class="literal">&lt;Employee/&gt;</code>
                could have been the first element just as well. What is important is
                that all of the data is there. In fact, the data is the only thing
                that is important: we are taking a <span class="emphasis"><em>data-driven</em></span>
                approach.
            </p>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial.xsd" href="#tutorial.xsd"></a>3.3&nbsp;Data Contract</h2></div></div></div>
        
        <p>
            Now that we have seen some examples of the XML data that we will use,
            it makes sense to formalize this into a schema. This data contract
            defines the message format we accept. There are four different ways
            of defining such a contract for XML:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>DTDs</p></li><li class="listitem"><p><a class="ulink" href="http://www.w3.org/XML/Schema" target="_top">XML Schema (XSD)</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.relaxng.org/" target="_top">RELAX NG</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.schematron.com/" target="_top">Schematron</a></p></li></ul></div>
        <p>
            DTDs have limited namespace support, so they are not suitable for Web
            services. Relax NG and Schematron certainly are easier than XML Schema.
            Unfortunately, they are not so widely supported across platforms. We
            will use XML Schema.
        </p>
        <p>
            By far the easiest way to create an XSD is to infer it from sample
            documents. Any good XML editor or Java IDE offers this functionality.
            Basically, these tools use some sample XML documents, and generate a
            schema from it that validates them all. The end result certainly needs
            to be polished up, but it's a great starting point.
        </p>
        <p>
            Using the sample described above, we end up with the following
            generated schema:
        </p>
        <pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"
        xmlns:hr="http://mycompany.com/hr/schemas"&gt;
    &lt;xs:element name="HolidayRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="hr:Holiday"/&gt;
                &lt;xs:element ref="hr:Employee"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="Holiday"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="hr:StartDate"/&gt;
                &lt;xs:element ref="hr:EndDate"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="StartDate" type="xs:NMTOKEN"/&gt;
    &lt;xs:element name="EndDate" type="xs:NMTOKEN"/&gt;
    &lt;xs:element name="Employee"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element ref="hr:Number"/&gt;
                &lt;xs:element ref="hr:FirstName"/&gt;
                &lt;xs:element ref="hr:LastName"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name="Number" type="xs:integer"/&gt;
    &lt;xs:element name="FirstName" type="xs:NCName"/&gt;
    &lt;xs:element name="LastName" type="xs:NCName"/&gt;
&lt;/xs:schema&gt;</pre>
        <p>
            This generated schema obviously can be improved. The first thing
            to notice is that every type has a root-level element declaration.
            This means that the Web service should be able to accept all of
            these elements as data. This is not desirable: we only want to
            accept a <code class="literal">&lt;HolidayRequest/&gt;</code>. By removing
            the wrapping element tags (thus keeping the types), and inlining
            the results, we can accomplish this.
        </p>
        <pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:hr="http://mycompany.com/hr/schemas"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"&gt;
    &lt;xs:element name="HolidayRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="Holiday" type="hr:HolidayType"/&gt;
                &lt;xs:element name="Employee" type="hr:EmployeeType"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:complexType name="HolidayType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="StartDate" type="xs:NMTOKEN"/&gt;
            &lt;xs:element name="EndDate" type="xs:NMTOKEN"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="EmployeeType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Number" type="xs:integer"/&gt;
            &lt;xs:element name="FirstName" type="xs:NCName"/&gt;
            &lt;xs:element name="LastName" type="xs:NCName"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre>
        <p>
            The schema still has one problem: with a schema like this, you
            can expect the following messages to validate:
        </p>
        <pre class="programlisting">
&lt;HolidayRequest xmlns="http://mycompany.com/hr/schemas"&gt;
    &lt;Holiday&gt;
        &lt;StartDate&gt;this is not a date&lt;/StartDate&gt;
        &lt;EndDate&gt;neither is this&lt;/EndDate&gt;
    &lt;/Holiday&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- ... --&gt;</span></em>
&lt;/HolidayRequest&gt;</pre>
        <p>
            Clearly, we must make sure that the start and end date are really dates.
            XML Schema has an excellent built-in <code class="literal">date</code> type which
            we can use. We also change the <code class="literal">NCName</code>s to
            <code class="literal">string</code>s. Finally, we change the <code class="literal">sequence</code> in
            <code class="literal">&lt;HolidayRequest/&gt;</code> to <code class="literal">all</code>.
            This tells the XML parser that the order of
            <code class="literal">&lt;Holiday/&gt;</code> and
            <code class="literal">&lt;Employee/&gt;</code> is not significant. Our final
            XSD now looks like this:
        </p>
        <div class="programlistingco"><pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:hr="http://mycompany.com/hr/schemas"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"&gt;
    &lt;xs:element name="HolidayRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:all&gt;
                &lt;xs:element name="Holiday" type="hr:HolidayType"/&gt;                                                     <span class="co" id="tutorial.xsd.all"><img src="images/callouts/1.png" alt="(1)"></span>
                &lt;xs:element name="Employee" type="hr:EmployeeType"/&gt;
            &lt;/xs:all&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:complexType name="HolidayType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="StartDate" type="xs:date"/&gt;
            &lt;xs:element name="EndDate" type="xs:date"/&gt;                                                                <span class="co" id="tutorial.xsd.dates.1"><img src="images/callouts/2.png" alt="(2)"></span>
        &lt;/xs:sequence&gt;                                                                                                 <span class="co" id="tutorial.xsd.dates.2"><img src="images/callouts/2.png" alt="(2)"></span>
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="EmployeeType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="Number" type="xs:integer"/&gt;
            &lt;xs:element name="FirstName" type="xs:string"/&gt;
            &lt;xs:element name="LastName" type="xs:string"/&gt;                                                             <span class="co" id="tutorial.xsd.strings.1"><img src="images/callouts/3.png" alt="(3)"></span>
        &lt;/xs:sequence&gt;                                                                                                 <span class="co" id="tutorial.xsd.strings.2"><img src="images/callouts/3.png" alt="(3)"></span>
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        <code class="literal">all</code> tells the XML parser that the order of
                        <code class="literal">&lt;Holiday/&gt;</code> and
                        <code class="literal">&lt;Employee/&gt;</code> is not significant.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We use the <code class="literal">xsd:date</code> data type, which consist of a year, month, and day, for
                        <code class="literal">&lt;StartDate/&gt;</code> and <code class="literal">&lt;EndDate/&gt;</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        <code class="literal">xsd:string</code> is used for the first and last name.
                    </p>
                </td></tr></table></div></div>
        <p>
            We store this file as <code class="filename">hr.xsd</code>.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-service-contract" href="#tutorial-service-contract"></a>3.4&nbsp;Service contract</h2></div></div></div>
        
        <p>
            A service contract is generally expressed as a <a class="ulink" href="http://www.w3.org/TR/wsdl" target="_top">WSDL</a> file.
            Note that in Spring-WS, <span class="emphasis"><em>writing the WSDL by hand is not required</em></span>. Based on the XSD and
            some conventions, Spring-WS can create the WSDL for you, as explained in the section entitled
            <a class="xref" href="tutorial.html#tutorial.implementing.endpoint" title="3.6&nbsp;Implementing the Endpoint">Section&nbsp;3.6, &#8220;Implementing the Endpoint&#8221;</a>.
            You can skip to <a class="link" href="tutorial.html#tutorial-creating-project" title="3.5&nbsp;Creating the project">the next section</a> if you want to; the
            remainder of this section will show you how to write your own WSDL by hand.
         </p>
         <p>
            We start our WSDL with the standard preamble, and by importing our existing XSD. To
            separate the schema from the definition, we will use a separate namespace for the WSDL definitions:
            <code class="uri">http://mycompany.com/hr/definitions</code>.
        </p>
        <pre class="programlisting">&lt;wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  xmlns:schema="http://mycompany.com/hr/schemas"
                  xmlns:tns="http://mycompany.com/hr/definitions"
                  targetNamespace="http://mycompany.com/hr/definitions"&gt;
    &lt;wsdl:types&gt;
        &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
            &lt;xsd:import namespace="http://mycompany.com/hr/schemas" schemaLocation="hr.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;</pre>
        <p>
            Next, we add our messages based on the written schema types. We only have one message: one with the
            <code class="literal">&lt;HolidayRequest/&gt;</code> we put in the schema:
        </p>
        <pre class="programlisting">
    &lt;wsdl:message name="HolidayRequest"&gt;
        &lt;wsdl:part element="schema:HolidayRequest" name="HolidayRequest"/&gt;
    &lt;/wsdl:message&gt;</pre>
        <p>
            We add the message to a port type as an operation:
        </p>
        <pre class="programlisting">
    &lt;wsdl:portType name="HumanResource"&gt;
        &lt;wsdl:operation name="Holiday"&gt;
            &lt;wsdl:input message="tns:HolidayRequest" name="HolidayRequest"/&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;</pre>
        <p>
            That finished the abstract part of the WSDL (the interface, as it were), and leaves the concrete part.
            The concrete part consists of a <code class="literal">binding</code>, which tells the client <span class="emphasis"><em>how</em></span>
            to invoke the operations you've just defined; and a <code class="literal">service</code>, which tells it
            <span class="emphasis"><em>where</em></span> to invoke it.
        </p>
        <p>
            Adding a concrete part is pretty standard: just refer to the abstract part you defined previously, make sure
            you use <span class="emphasis"><em>document/literal</em></span> for the <code class="literal">soap:binding</code> elements
            (<code class="literal">rpc/encoded</code> is deprecated), pick a <code class="literal">soapAction</code> for the operation
            (in this case <code class="uri">http://mycompany.com/RequestHoliday</code>, but any URI will do), and determine the
            <code class="literal">location</code> URL where you want request to come in (in this case
            <code class="uri">http://mycompany.com/humanresources</code>):
        </p>
        <div class="programlistingco"><pre class="programlisting">
&lt;wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  xmlns:schema="http://mycompany.com/hr/schemas"
                  xmlns:tns="http://mycompany.com/hr/definitions"
                  targetNamespace="http://mycompany.com/hr/definitions"&gt;
    &lt;wsdl:types&gt;
        &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
            &lt;xsd:import namespace="http://mycompany.com/hr/schemas"                                                    <span class="co" id="tutorial.wsdl.import"><img src="images/callouts/1.png" alt="(1)"></span>
                schemaLocation="hr.xsd"/&gt;
        &lt;/xsd:schema&gt;
    &lt;/wsdl:types&gt;
    &lt;wsdl:message name="HolidayRequest"&gt;                                                                               <span class="co" id="tutorial.wsdl.message.def"><img src="images/callouts/2.png" alt="(2)"></span>
        &lt;wsdl:part element="schema:HolidayRequest" name="HolidayRequest"/&gt;                                             <span class="co" id="tutorial.wsdl.message.part"><img src="images/callouts/3.png" alt="(3)"></span>
    &lt;/wsdl:message&gt;
    &lt;wsdl:portType name="HumanResource"&gt;                                                                               <span class="co" id="tutorial.wsdl.portType.def"><img src="images/callouts/4.png" alt="(4)"></span>
        &lt;wsdl:operation name="Holiday"&gt;
            &lt;wsdl:input message="tns:HolidayRequest" name="HolidayRequest"/&gt;                                           <span class="co" id="tutorial.wsdl.message.ref"><img src="images/callouts/2.png" alt="(2)"></span>
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;
    &lt;wsdl:binding name="HumanResourceBinding" type="tns:HumanResource"&gt;                                                <span class="co" id="tutorial.wsdl.portType.ref"><img src="images/callouts/4.png" alt="(4)"></span><span class="co" id="tutorial.wsdl.binding.def"><img src="images/callouts/5.png" alt="(5)"></span>
        &lt;soap:binding style="document"                                                                                 <span class="co" id="tutorial.wsdl.doclit.doc"><img src="images/callouts/6.png" alt="(6)"></span>
            transport="http://schemas.xmlsoap.org/soap/http"/&gt;                                                         <span class="co" id="tutorial.wsdl.transport"><img src="images/callouts/7.png" alt="(7)"></span>
        &lt;wsdl:operation name="Holiday"&gt;
            &lt;soap:operation soapAction="http://mycompany.com/RequestHoliday"/&gt;                                         <span class="co" id="tutorial.wsdl.soapAction"><img src="images/callouts/8.png" alt="(8)"></span>
            &lt;wsdl:input name="HolidayRequest"&gt;
                &lt;soap:body use="literal"/&gt;                                                                             <span class="co" id="tutorial.wsdl.doclit.lit"><img src="images/callouts/6.png" alt="(6)"></span>
            &lt;/wsdl:input&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:binding&gt;
    &lt;wsdl:service name="HumanResourceService"&gt;
        &lt;wsdl:port binding="tns:HumanResourceBinding" name="HumanResourcePort"&gt;                                        <span class="co" id="tutorial.wsdl.binding.ref"><img src="images/callouts/5.png" alt="(5)"></span>
            &lt;soap:address location="http://localhost:8080/holidayService/"/&gt;                                           <span class="co" id="tutorial.wsdl.address"><img src="images/callouts/9.png" alt="(9)"></span>
        &lt;/wsdl:port&gt;
    &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We import the schema defined in <a class="xref" href="tutorial.html#tutorial.xsd" title="3.3&nbsp;Data Contract">Section&nbsp;3.3, &#8220;Data Contract&#8221;</a>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the <code class="literal">HolidayRequest</code> message, which gets used in the
                        <code class="literal">portType</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="literal">HolidayRequest</code> type is defined in the schema.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the <code class="literal">HumanResource</code> port type, which gets used in the
                        <code class="literal">binding</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the <code class="literal">HumanResourceBinding</code> binding, which gets used in the
                        <code class="literal">port</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/6.png" alt="6" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We use a document/literal style.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/7.png" alt="7" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The literal <code class="uri">http://schemas.xmlsoap.org/soap/http</code> signifies a
                        HTTP transport.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/8.png" alt="8" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="literal">soapAction</code> attribute signifies the <code class="literal">SOAPAction</code> HTTP
                        header that will be sent with every request.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/9.png" alt="9" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="uri">http://localhost:8080/holidayService/</code> address is the URL where the Web
                        service can be invoked.
                    </p>
                </td></tr></table></div></div>
        <p>
            This is the final WSDL. We will describe how to implement the resulting schema and WSDL in the next section.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-creating-project" href="#tutorial-creating-project"></a>3.5&nbsp;Creating the project</h2></div></div></div>
        
        <p>
            In this section, we will be using <a class="ulink" href="http://maven.apache.org/" target="_top">Maven3</a> to create the
            initial project structure for us. Doing so is not required, but greatly reduces the amount of code we
            have to write to setup our HolidayService.
        </p>
        <p>
            The following command creates a Maven3 web application project for us, using the Spring-WS archetype
            (that is, project template)
        </p>
<pre class="screen">mvn archetype:create -DarchetypeGroupId=org.springframework.ws \
  -DarchetypeArtifactId=spring-ws-archetype \
  -DarchetypeVersion= \
  -DgroupId=com.mycompany.hr \
  -DartifactId=holidayService
</pre>
        <p>
            This command will create a new directory called <code class="filename">holidayService</code>. In this directory,
            there is a <code class="filename">'src/main/webapp'</code> directory, which will contain the root of the WAR file.
            You will find the standard web application deployment descriptor <code class="filename">'WEB-INF/web.xml'</code>
            here, which defines a Spring-WS <code class="classname">MessageDispatcherServlet</code> and maps all incoming
            requests to this servlet.
        </p>
        <pre class="programlisting">
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
             http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         version="2.4"&gt;

    &lt;display-name&gt;MyCompany HR Holiday Service&lt;/display-name&gt;

    <em class="lineannotation"><span class="lineannotation">&lt;!-- take especial notice of the name of this servlet --&gt;</span></em>
    &lt;servlet&gt;
        &lt;servlet-name&gt;<em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>spring-ws</strong></span></span></em>&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.ws.transport.http.MessageDispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre>
        <p>
            In addition to the above <code class="filename">'WEB-INF/web.xml'</code> file, you will also need another,
            Spring-WS-specific configuration file, named <code class="filename">'WEB-INF/spring-ws-servlet.xml'</code>.
            This file contains all of the Spring-WS-specific beans such as <code class="literal">EndPoints</code>,
            <code class="literal">WebServiceMessageReceivers</code>, and suchlike, and is used to create a new Spring container.
            The name of this file is derived from the name of the attendant servlet (in this case
            <code class="literal">'spring-ws'</code>) with <code class="literal">'-servlet.xml'</code> appended to it.
            So if you defined a <code class="classname">MessageDispatcherServlet</code> with the name
            <code class="literal">'dynamite'</code>, the name of the Spring-WS-specific configuration file would be
            <code class="filename">'WEB-INF/dynamite-servlet.xml'</code>.
        </p>
        <p>
            (You can see the contents of the <code class="filename">'WEB-INF/spring-ws-servlet.xml'</code> file for this
            example in <a class="xref" href="tutorial.html#tutorial.example.sws-conf-file">???</a>.)
        </p>
        <p>
            Once you had the project structure created, you can put the schema and wsdl from previous section into
            <code class="filename">'WEB-INF/'</code> folder.
        </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial.implementing.endpoint" href="#tutorial.implementing.endpoint"></a>3.6&nbsp;Implementing the Endpoint</h2></div></div></div>
        
        <p>
           In Spring-WS, you will implement <span class="emphasis"><em>Endpoints</em></span> to handle incoming XML messages.
           An endpoint is typically created by annotating a class with the <code class="interfacename">@Endpoint</code>
           annotation.
           In this endpoint class, you will create one or more methods that handle incoming request.
           The method signatures can be quite flexible: you can include just about any sort of parameter type related
           to the incoming XML message, as will be explained later.
        </p>
        <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e399" href="#d5e399"></a>3.6.1&nbsp;Handling the XML Message</h3></div></div></div>
            
            <p>
                In this sample application, we are going to use <a class="ulink" href="http://www.jdom.org" target="_top">JDom 2</a> to handle
                the XML message.
                We are also using <a class="ulink" href="https://www.w3.org/TR/xpath20/" target="_top">XPath</a>, because it allows us to
                select particular parts of the XML JDOM tree, without requiring strict schema conformance.
            </p>
            <div class="programlistingco"><pre class="programlisting">package com.mycompany.hr.ws;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;

import com.mycompany.hr.service.HumanResourceService;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.filter.Filters;
import org.jdom2.xpath.XPathExpression;
import org.jdom2.xpath.XPathFactory;

@Endpoint                                                                                                              <span class="co" id="tutorial.endpoint.atEndpoint"><img src="images/callouts/1.png" alt="(1)"></span>
public class HolidayEndpoint {

    private static final String NAMESPACE_URI = "http://mycompany.com/hr/schemas";

    private XPathExpression&lt;Element&gt; startDateExpression;

    private XPathExpression&lt;Element&gt; endDateExpression;

    private XPathExpression&lt;Element&gt; firstNameExpression;

    private XPathExpression&lt;Element&gt; lastNameExpression;

    private HumanResourceService humanResourceService;
                                                                                                                       <span class="co" id="tutorial.endpoint.constr"><img src="images/callouts/2.png" alt="(2)"></span>
    @Autowired
    public HolidayEndpoint(HumanResourceService humanResourceService) throws JDOMException {
        this.humanResourceService = humanResourceService;

        Namespace namespace = Namespace.getNamespace("hr", NAMESPACE_URI);
        XPathFactory xPathFactory = XPathFactory.instance();
        startDateExpression = xPathFactory.compile("//hr:StartDate", Filters.element(), null, namespace);
        endDateExpression = xPathFactory.compile("//hr:EndDate", Filters.element(), null, namespace);
        firstNameExpression = xPathFactory.compile("//hr:FirstName", Filters.element(), null, namespace);
        lastNameExpression = xPathFactory.compile("//hr:LastName", Filters.element(), null, namespace);
    }

    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "HolidayRequest")                                              <span class="co" id="tutorial.endpoint.payloadRoot"><img src="images/callouts/3.png" alt="(3)"></span>
    public void handleHolidayRequest(@RequestPayload Element holidayRequest) throws Exception {                        <span class="co" id="tutorial.endpoint.method"><img src="images/callouts/4.png" alt="(4)"></span>
        Date startDate = parseDate(startDateExpression, holidayRequest);
        Date endDate = parseDate(endDateExpression, holidayRequest);
        String name = firstNameExpression.evaluateFirst(holidayRequest).getText() + " " + lastNameExpression.evaluateFirst(holidayRequest).getText();

        humanResourceService.bookHoliday(startDate, endDate, name);
    }

    private Date parseDate(XPathExpression&lt;Element&gt; expression, Element element) throws ParseException {
        Element result = expression.evaluateFirst(element);
        if (result != null) {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
            return dateFormat.parse(result.getText());
        } else {
            throw new IllegalArgumentException("Could not evaluate [" + expression + "] on [" + element + "]");
        }
    }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">HolidayEndpoint</code> is annotated with
                            <code class="interfacename">@Endpoint</code>.
                            This marks the class as a special sort of <code class="interfacename">@Component</code>,
                            suitable for handling XML messages in Spring-WS, and also making it eligible for suitable
                            for component scanning.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">HolidayEndpoint</code> requires the
                            <code class="interfacename">HumanResourceService</code> business service to operate, so we
                            inject the dependency via the constructor and annotate it with
                            <code class="interfacename">@Autowired</code>.
                        </p>
                        <p>
                            Next, we set up XPath expressions using the JDOM2 API.
                            There are four expressions: <code class="literal">//hr:StartDate</code> for
                            extracting the <code class="literal">&lt;StartDate&gt;</code> text value,
                            <code class="literal">//hr:EndDate</code> for
                            extracting the end date and two for extracting the names of
                            the employee.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="interfacename">@PayloadRoot</code> annotation tells Spring-WS that the
                            <code class="methodname">handleHolidayRequest</code> method is suitable for handling XML messages.
                            The sort of message that this method can handle is indicated by the annotation values,
                            in this case, it can handle XML elements that have the <code class="literal">HolidayRequest</code>
                            local part and the <code class="literal">http://mycompany.com/hr/schemas</code> namespace.
                        </p>
                        <p>
                            More information about mapping messages to endpoints is provided in the next section.
                        </p>
                    </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="methodname">handleHolidayRequest(..)</code> method is the main handling method
                            method, which gets passed with the <code class="literal">&lt;HolidayRequest/&gt;</code> element from
                            the incoming XML message.
                            The <code class="interfacename">@RequestPayload</code> annotation indicates that the
                            <em class="parameter"><code>holidayRequest</code></em> parameter should be mapped to the payload of the
                            request message.
                        </p>
                        <p>
                            We use the XPath expressions to extract the string values from the XML messages,
                            and convert these values to <code class="classname">Date</code> objects using a
                            <code class="classname">SimpleDateFormat</code> (the <code class="methodname">parseData</code> method).
                        </p>
                        <p>
                            With these values, we invoke a method on the business service.
                            Typically, this will result in a database transaction being started, and some records being
                            altered in the database.
                        </p>
                        <p>
                            Finally, we define a <code class="literal">void</code> return type, which indicates to Spring-WS
                            that we do not want to send a response message.
                            If we wanted a response message, we could have returned a JDOM Element
                            that represents the payload of the response message.
                        </p>
                    </td></tr></table></div></div>
            <p>
                 Using JDOM is just one of the options to handle the XML: other options include DOM, dom4j, XOM,
                 SAX, and StAX, but also marshalling techniques like JAXB, Castor, XMLBeans,
                 JiBX, and XStream, as is explained in the next chapter.
                 We chose JDOM because it gives us access to the raw XML, and because it
                 is based on classes (not interfaces and factory methods as with W3C DOM and dom4j), which makes the
                 code less verbose. We use XPath because it is less fragile than marshalling technologies: we don't
                 care for strict schema conformance, as long as we can find the dates and the name.
             </p>
             <p>
                 Because we use JDOM, we must add some dependencies to the Maven <code class="filename">pom.xml</code>, which is in the
                 root of our project directory. Here is the relevant section of the POM:
             </p>
             <pre class="programlisting">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.ws&lt;/groupId&gt;
        &lt;artifactId&gt;spring-ws-core&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jdom&lt;/groupId&gt;
        &lt;artifactId&gt;jdom&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jaxen&lt;/groupId&gt;
        &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>
             <p>
                Here is how we would configure these classes in our <code class="filename">spring-ws-servlet.xml</code>
                Spring XML configuration file, by using component scanning.
                We also instruct Spring-WS to use annotation-driven endpoints, with the
                <code class="literal">&lt;sws:annotation-driven&gt;</code> element.
            </p>
            <a name="tutorial.example.sws-conf-file" href="#tutorial.example.sws-conf-file"></a><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:sws="http://www.springframework.org/schema/web-services"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/web-services http://www.springframework.org/schema/web-services/web-services-2.0.xsd
  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

  &lt;context:component-scan base-package="com.mycompany.hr"/&gt;

  &lt;sws:annotation-driven/&gt;

&lt;/beans&gt;</pre>
            </div>
            <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e454" href="#d5e454"></a>3.6.2&nbsp;Routing the Message to the Endpoint</h3></div></div></div>
                
                <p>
                    As part of writing the endpoint, we also used the <code class="interfacename">@PayloadRoot</code>
                    annotation to indicate which sort of messages can be handled by the
                    <code class="methodname">handleHolidayRequest</code> method.
                    In Spring-WS, this process is the responsibility of an
                    <code class="interfacename">EndpointMapping</code>.
                    Here we route messages based on
                    their content, by using a <code class="classname">PayloadRootAnnotationMethodEndpointMapping</code>.
                    The annotation used above:</p><pre class="programlisting">
@PayloadRoot(namespace = "http://mycompany.com/hr/schemas", localPart = "HolidayRequest")</pre><p>
                    basically means that whenever an XML message is received with the namespace
                    <code class="literal">http://mycompany.com/hr/schemas</code> and the
                    <code class="literal">HolidayRequest</code> local name, it will be routed to the
                    <code class="methodname">handleHolidayRequest</code> method.
                    By using the <code class="literal">&lt;sws:annotation-driven&gt;</code> element in our configuration, we
                    enable the detection of the <code class="interfacename">@PayloadRoot</code> annotations.
                    It is possible (and quite common) to have multiple, related handling methods in an endpoint, each
                    of them handling different XML messages.
                </p>
                <p>
                    There are also other ways to map endpoints to XML messages, which will be described in the next
                    chapter.
                </p>
            </div>
            <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e468" href="#d5e468"></a>3.6.3&nbsp;Providing the Service and Stub implementation</h3></div></div></div>
                
                <p>
                    Now that we have the <span class="emphasis"><em>Endpoint</em></span>, we need 
                    <code class="interfacename">HumanResourceService</code> and its implementation for use by 
                    <code class="classname">HolidayEndpoint</code>.
                </p>
                <pre class="programlisting">package com.mycompany.hr.service;

import java.util.Date;

public interface HumanResourceService {
    void bookHoliday(Date startDate, Date endDate, String name);
}</pre>
                <p>
                    For tutorial purposes, we will use a simple stub implementation of the 
                    <code class="interfacename">HumanResourceService</code>.
                </p>
                <div class="programlistingco"><pre class="programlisting">package com.mycompany.hr.service;

import java.util.Date;

import org.springframework.stereotype.Service;

@Service                                                                                                               <span class="co" id="tutorial.stubimpl.atService"><img src="images/callouts/1.png" alt="(1)"></span>
public class StubHumanResourceService implements HumanResourceService {
    public void bookHoliday(Date startDate, Date endDate, String name) {
        System.out.println("Booking holiday for [" + startDate + "-" + endDate + "] for [" + name + "] ");
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                        <p>
                            The <code class="classname">StubHumanResourceService</code> is annotated with
                            <code class="interfacename">@Service</code>.
                            This marks the class as a business facade, which makes this a candidate for injection 
                            by <code class="interfacename">@Autowired</code> in <code class="classname">HolidayEndpoint</code>.
                        </p>
                    </td></tr></table></div></div>
        </div>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-publishing-wsdl" href="#tutorial-publishing-wsdl"></a>3.7&nbsp;Publishing the WSDL</h2></div></div></div>
        
        <p>
            Finally, we need to publish the WSDL. As stated in <a class="xref" href="tutorial.html#tutorial-service-contract" title="3.4&nbsp;Service contract">Section&nbsp;3.4, &#8220;Service contract&#8221;</a>, we don't
            need to write a WSDL ourselves; Spring-WS can generate one for us based on some conventions.
            Here is how we define the generation:
        </p>
        <div class="programlistingco"><pre class="programlisting">&lt;sws:dynamic-wsdl id="holiday"                                                                                         <span class="co" id="tutorial.wsdl.gen.bean"><img src="images/callouts/1.png" alt="(1)"></span>
    portTypeName="HumanResource"                                                                                       <span class="co" id="tutorial.wsdl.gen.portType"><img src="images/callouts/3.png" alt="(3)"></span>
    locationUri="/holidayService/"                                                                                     <span class="co" id="tutorial.wsdl.gen.locationUri"><img src="images/callouts/4.png" alt="(4)"></span>
    targetNamespace="http://mycompany.com/hr/definitions"&gt;                                                             <span class="co" id="tutorial.wsdl.gen.tns"><img src="images/callouts/5.png" alt="(5)"></span>
  &lt;sws:xsd location="/WEB-INF/hr.xsd"/&gt;                                                                                <span class="co" id="tutorial.wsdl.gen.schema"><img src="images/callouts/2.png" alt="(2)"></span>
&lt;/sws:dynamic-wsdl&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/1.png" alt="1" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The id determines the URL where the WSDL can be retrieved.
                        In this case, the id is <code class="varname">holiday</code>, which means that the WSDL can be retrieved
                        as <code class="filename">holiday.wsdl</code> in the servlet context.
                        The full URL will typically be <code class="uri">http://localhost:8080/holidayService/holiday.wsdl</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/3.png" alt="3" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        Next, we set the WSDL port type to be <code class="literal">HumanResource</code>.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/4.png" alt="4" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We set the location where the service can be reached:
                        <code class="uri">/holidayService/</code>.
                        We use a relative URI and we instruct the framework to transform it
                        dynamically to an absolute URI.
                        Hence, if the service is deployed to different contexts we don't have
                        to change the URI manually.
                        For more information, please refer to <a class="xref" href="server.html#server-automatic-wsdl-exposure" title="Automatic WSDL exposure">the section called &#8220;Automatic WSDL exposure&#8221;</a>
                    </p>
                    <p>
                        For the location transformation to work, we need to add an init parameter to <code class="classname">spring-ws</code>
                        servlet in <code class="filename">web.xml</code>:</p><pre class="programlisting">&lt;init-param&gt;
  &lt;param-name&gt;transformWsdlLocations&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/init-param&gt;</pre><p>
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/5.png" alt="5" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        We define the target namespace for the WSDL definition itself.
                        Setting this attribute is not required.
                        If not set, the WSDL will have the same namespace as the XSD schema.
                    </p>
                </td></tr><tr><td width="5%" valign="top" align="left"><p><span><img src="images/callouts/2.png" alt="2" border="0"></span></p></td><td valign="top" align="left">
                    <p>
                        The <code class="varname">xsd</code> element refers to the human resource schema we defined in
                        <a class="xref" href="tutorial.html#tutorial.xsd" title="3.3&nbsp;Data Contract">Section&nbsp;3.3, &#8220;Data Contract&#8221;</a>.
                        We simply placed the schema in the <code class="filename">WEB-INF</code> directory of the application.
                    </p>
                </td></tr></table></div></div>
        <p>
            You can create a WAR file using <span class="command"><strong>mvn install</strong></span>.
            If you deploy the application (to Tomcat, Jetty, etc.), and point your browser at
            <a class="ulink" href="http://localhost:8080/holidayService/holiday.wsdl" target="_top">this location</a>, you will
            see the generated WSDL. This WSDL is ready to be used by clients, such as
            <a class="ulink" href="http://www.soapui.org/" target="_top">soapUI</a>, or other SOAP frameworks.
        </p>
    </div>
    <p>
        That concludes this tutorial. The tutorial code can be found in the full distribution of Spring-WS.
        The next step would be to look at the echo sample application that is part
        of the distribution. After that, look at the airline sample, which is a bit more complicated, because it
        uses JAXB, WS-Security, Hibernate, and a transactional service layer.
        Finally, you can read the rest of the reference documentation.
    </p>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="why-contract-first.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="pt02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;Why Contract First?&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;II.&nbsp;Reference</td></tr></table></div></body></html>