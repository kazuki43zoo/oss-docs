
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Usage Guide Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ReleaseNotes.html" />
    
    
    <link rel="prev" href="Downloads.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="GettingStarted.html">
            
                <a href="GettingStarted.html">
            
                    
                    Getting Started
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="Downloads.html">
            
                <a href="Downloads.html">
            
                    
                    Downloads
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="Usage.html">
            
                <a href="Usage.html">
            
                    
                    Usage Guide
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ReleaseNotes.html">
            
                <a href="ReleaseNotes.html">
            
                    
                    Release Notes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="snapshot.html">
            
                <a href="snapshot.html">
            
                    
                    Snapshot dependencies
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="FAQ.html">
            
                <a href="FAQ.html">
            
                    
                    FAQ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <a target="_blank" href="http://groups.google.com/group/rest-assured">
            
                    
                    Support
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Usage Guide</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>Note that if you&apos;re using version 1.9.0 or earlier please refer to the <a href="Usage_Legacy">legacy</a> documentation.</p>
<p>REST Assured is a Java DSL for simplifying testing of REST based services built on top of HTTP Builder. It supports POST, GET, PUT, DELETE, OPTIONS, PATCH and HEAD requests and can be used to validate and verify the response of these requests.</p>
<h1 id="contents">Contents</h1>
<ol>
<li><a href="#static-imports">Static imports</a></li>
<li><a href="#examples">Examples</a><ol>
<li><a href="#example-1---json">JSON Example</a></li>
<li><a href="#json-schema-validation">JSON Schema Validation</a></li>
<li><a href="#example-2---xml">XML Example</a></li>
<li><a href="#example-3---complex-parsing-and-validation">Advanced</a><ol>
<li><a href="#xml-example">XML</a></li>
<li><a href="#json-example">JSON</a></li>
</ol>
</li>
<li><a href="#additional-examples">Additional Examples</a></li>
</ol>
</li>
<li><a href="#note-on-floats-and-doubles">Note on floats and doubles</a></li>
<li><a href="#note-on-syntax">Note on syntax</a> (<a href="#syntactic-sugar">syntactic sugar</a>)</li>
<li><a href="#getting-response-data">Getting Response Data</a><ol>
<li><a href="#extracting-values-from-the-response-after-validation">Extracting values from the Response after validation</a></li>
<li><a href="#json-using-jsonpath">JSON (using JsonPath)</a></li>
<li><a href="#xml-using-xmlpath">XML (using XmlPath)</a></li>
<li><a href="#single-path">Single Path</a></li>
<li><a href="#headers-cookies-status-etc">Headers, cookies, status etc</a><ol>
<li><a href="#multi-value-headers">Multi-value headers</a></li>
<li><a href="#multi-value-cookies">Multi-value cookies</a></li>
<li><a href="#detailed-cookies">Detailed Cookies</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#specifying-request-data">Specifying Request Data</a><ol>
<li><a href="#invoking-http-resources">Invoking HTTP resources</a></li>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#multi-value-parameter">Multi-value Parameter</a></li>
<li><a href="#no-value-parameter">No-value Parameter</a></li>
<li><a href="#path-parameters">Path Parameters</a></li>
<li><a href="#cookies">Cookies</a></li>
<li><a href="#headers">Headers</a></li>
<li><a href="#content-type">Content-Type</a></li>
<li><a href="#request-body">Request Body</a></li>
</ol>
</li>
<li><a href="#verifying-response-data">Verifying Response Data</a><ol>
<li><a href="#response-body">Response Body</a></li>
<li><a href="#cookies-1">Cookies</a></li>
<li><a href="#status">Status</a></li>
<li><a href="#headers-1">Headers</a></li>
<li><a href="#content-type-1">Content-Type</a></li>
<li><a href="#full-bodycontent-matching">Full body/content matching</a></li>
<li><a href="#use-the-response-to-verify-other-parts-of-the-response">Use the response to verify other parts of the response</a></li>
<li><a href="#measuring-response-time">Measuring response time</a></li>
</ol>
</li>
<li><a href="#authentication">Authentication</a><ol>
<li><a href="#basic-authentication">Basic</a><ol>
<li><a href="#preemptive-basic-authentication">Preemptive</a></li>
<li><a href="#challenged-basic-authentication">Challenged</a></li>
</ol>
</li>
<li><a href="#digest-authentication">Digest</a></li>
<li><a href="#form-authentication">Form</a><ol>
<li><a href="#csrf">CSRF</a></li>
<li><a href="#include-additional-fields-in-form-authentication">Include additional fields in Form Authentication</a></li>
</ol>
</li>
<li><a href="#oauth">OAuth</a><ol>
<li><a href="#oauth-1">OAuth1</a></li>
<li><a href="#oauth-2">OAuth2</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#multi-part-form-data">Multi-part form data</a></li>
<li><a href="#object-mapping">Object Mapping</a><ol>
<li><a href="#serialization">Serialization</a><ol>
<li><a href="#content-type-based-serialization">Content-Type based Serialization</a></li>
<li><a href="#create-json-from-a-hashmap">Create JSON from a HashMap</a></li>
<li><a href="#using-an-explicit-serializer">Using an Explicit Serializer</a></li>
</ol>
</li>
<li><a href="#deserialization">Deserialization</a><ol>
<li><a href="#content-type-based-deserialization">Content-Type based Deserialization</a></li>
<li><a href="#custom-content-type-deserialization">Custom Content-Type Deserialization</a></li>
<li><a href="#using-an-explicit-deserializer">Using an Explicit Deserializer</a></li>
</ol>
</li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#custom">Custom</a></li>
</ol>
</li>
<li>Parsers<ol>
<li><a href="#custom-parsers">Custom</a></li>
<li><a href="#default-parser">Default</a></li>
</ol>
</li>
<li><a href="#default-values">Default Values</a></li>
<li><a href="#specification-re-use">Specification Re-use</a><ol>
<li><a href="#querying-requestspecification">Querying RequestSpecification</a></li>
</ol>
</li>
<li><a href="#filters">Filters</a><ol>
<li><a href="#ordered-filters">Ordered Filters</a></li>
<li><a href="#response-builder">Response Builder</a></li>
</ol>
</li>
<li><a href="#logging">Logging</a><ol>
<li><a href="#request-logging">Request Logging</a></li>
<li><a href="#response-logging">Response Logging</a></li>
<li><a href="#log-if-validation-fails">Log if validation fails</a></li>
</ol>
</li>
<li><a href="#root-path">Root Path</a><ol>
<li><a href="#path-arguments">Path Arguments</a></li>
</ol>
</li>
<li><a href="#session-support">Session Support</a><ol>
<li><a href="#session-filter">Session Filter</a></li>
</ol>
</li>
<li><a href="#ssl">SSL</a><ol>
<li><a href="#ssl-invalid-hostname">SSL invalid hostname</a></li>
</ol>
</li>
<li><a href="#url-encoding">URL Encoding</a></li>
<li><a href="#proxy-configuration">Proxy Configuration</a><ol>
<li><a href="#static-proxy-configuration">Static Proxy Configuration</a></li>
<li><a href="#request-specification-proxy-configuration">Request Specification Proxy Configuration</a></li>
</ol>
</li>
<li><a href="#detailed-configuration">Detailed configuration</a><ol>
<li><a href="#encoder-config">Encoder Config</a></li>
<li><a href="#decoder-config">Decoder Config</a></li>
<li><a href="#session-config">Session Config</a></li>
<li><a href="#redirect-dsl">Redirect DSL</a></li>
<li><a href="#connection-config">Connection Config</a></li>
<li><a href="#json-config">JSON Config</a></li>
<li><a href="#http-client-config">HTTP Client Config</a></li>
<li><a href="#ssl-config">SSL Config</a></li>
<li><a href="#param-config">Param Config</a></li>
</ol>
</li>
<li><a href="#spring-mock-mvc-module">Spring Mock Mvc Module</a><ol>
<li><a href="#bootstrapping-restassuredmockmvc">Bootstrapping RestAssuredMockMvc</a></li>
<li><a href="#asynchronous-requests">Asynchronous Requests</a></li>
<li><a href="#adding-request-post-processors">Adding Request Post Processors</a></li>
<li><a href="#adding-result-handlers">Adding Result Handlers</a></li>
<li><a href="#using-result-matchers">Using Result Matchers</a></li>
<li><a href="#interceptors">Interceptors</a></li>
<li><a href="#specifications">Specifications</a></li>
<li><a href="#resetting-restassuredmockmvc">Resetting RestAssuredMockMvc</a></li>
<li><a href="#spring-mvc-authentication">Spring MVC Authentication</a><ol>
<li><a href="#using-spring-security-test">Using Spring Security Test</a></li>
<li><a href="#injecting-a-user">Injecting a User</a></li>
</ol>
</li>
<li><a href="#note-on-parameters">Note on parameters</a></li>
</ol>
</li>
<li><a href="#scala-support-module">Scala Support Module</a></li>
<li><a href="#kotlin">Kotlin</a></li>
<li><a href="#more-info">More Info</a></li>
</ol>
<h2 id="static-imports">Static imports</h2>
<p>In order to use REST assured effectively it&apos;s recommended to statically import methods from the following classes:</p>
<pre><code class="lang-java">io.restassured.RestAssured.*
io.restassured.matcher.RestAssuredMatchers.*
org.hamcrest.Matchers.*
</code></pre>
<p>If you want to use <a href="http://json-schema.org/" target="_blank">Json Schema</a> validation you should also statically import these methods:</p>
<pre><code class="lang-java">io.restassured.module.jsv.JsonSchemaValidator.*
</code></pre>
<p>Refer to <a href="#json-schema-validation">Json Schema Validation</a> section for more info.</p>
<p>If you&apos;re using Spring MVC you can use the <a href="#spring-mock-mvc-module">spring-mock-mvc</a> module to unit test your Spring Controllers using the Rest Assured DSL. To do this statically import the methods from <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/RestAssuredMockMvc.html" target="_blank">RestAssuredMockMvc</a> <em>instead</em> of importing the methods from <code>io.restassured.RestAssured</code>:</p>
<pre><code class="lang-java">io.restassured.module.mockmvc.RestAssuredMockMvc.*
</code></pre>
<h1 id="examples">Examples</h1>
<h2 id="example-1---json">Example 1 - JSON</h2>
<p>Assume that the GET request (to <a href="http://localhost:8080/lotto" target="_blank">http://localhost:8080/lotto</a>) returns JSON as:</p>
<pre><code class="lang-javascript">{
<span class="hljs-string">&quot;lotto&quot;</span>:{
 <span class="hljs-string">&quot;lottoId&quot;</span>:<span class="hljs-number">5</span>,
 <span class="hljs-string">&quot;winning-numbers&quot;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">34</span>,<span class="hljs-number">23</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>],
 <span class="hljs-string">&quot;winners&quot;</span>:[{
   <span class="hljs-string">&quot;winnerId&quot;</span>:<span class="hljs-number">23</span>,
   <span class="hljs-string">&quot;numbers&quot;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">34</span>,<span class="hljs-number">23</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]
 },{
   <span class="hljs-string">&quot;winnerId&quot;</span>:<span class="hljs-number">54</span>,
   <span class="hljs-string">&quot;numbers&quot;</span>:[<span class="hljs-number">52</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">18</span>,<span class="hljs-number">22</span>]
 }]
}
}
</code></pre>
<p>REST assured can then help you to easily make the GET request and verify the response. E.g. if you want to verify that lottoId is equal to 5 you can do like this:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/lotto&quot;</span>).then().body(<span class="hljs-string">&quot;lotto.lottoId&quot;</span>, equalTo(<span class="hljs-number">5</span>));
</code></pre>
<p>or perhaps you want to check that the winnerId&apos;s are 23 and 54:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/lotto&quot;</span>).then().body(<span class="hljs-string">&quot;lotto.winners.winnerId&quot;</span>, hasItems(<span class="hljs-number">23</span>, <span class="hljs-number">54</span>));
</code></pre>
<p>Note: <code>equalTo</code> and <code>hasItems</code> are Hamcrest matchers which you should statically import from <code>org.hamcrest.Matchers</code>.</p>
<p>Note that the &quot;json path&quot; syntax uses <a href="http://groovy-lang.org/processing-xml.html#_gpath" target="_blank">Groovy&apos;s GPath</a> notation and is not to be confused with Jayway&apos;s <a href="https://github.com/jayway/JsonPath" target="_blank">JsonPath</a> syntax.</p>
<h3 id="returning-floats-and-doubles-as-bigdecimal">Returning floats and doubles as BigDecimal</h3>
<p>You can configure Rest Assured and JsonPath to return BigDecimal&apos;s instead of float and double for Json Numbers. For example consider the following JSON document:</p>
<pre><code class="lang-javascript">{

    <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">12.12</span> 

}
</code></pre>
<p>By default  you validate that price is equal to 12.12 as a float like this:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/price&quot;</span>).then().body(<span class="hljs-string">&quot;price&quot;</span>, is(<span class="hljs-number">12.12f</span>));
</code></pre>
<p>but if you like you can configure REST Assured to use a JsonConfig that returns all Json numbers as BigDecimal:</p>
<pre><code class="lang-java">given().
        config(RestAssured.config().jsonConfig(jsonConfig().numberReturnType(BIG_DECIMAL))).
when().
        get(<span class="hljs-string">&quot;/price&quot;</span>).
then().
        body(<span class="hljs-string">&quot;price&quot;</span>, is(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">12.12</span>));
</code></pre>
<h3 id="json-schema-validation">JSON Schema validation</h3>
<p>From version <code>2.1.0</code> REST Assured has support for <a href="http://json-schema.org/" target="_blank">Json Schema</a> validation. For example given the following schema located in the classpath as <code>products-schema.json</code>:</p>
<pre><code class="lang-javascript">{
    <span class="hljs-string">&quot;$schema&quot;</span>: <span class="hljs-string">&quot;http://json-schema.org/draft-04/schema#&quot;</span>,
    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Product set&quot;</span>,
    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;array&quot;</span>,
    <span class="hljs-string">&quot;items&quot;</span>: {
        <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Product&quot;</span>,
        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,
        <span class="hljs-string">&quot;properties&quot;</span>: {
            <span class="hljs-string">&quot;id&quot;</span>: {
                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The unique identifier for a product&quot;</span>,
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>
            },
            <span class="hljs-string">&quot;name&quot;</span>: {
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>
            },
            <span class="hljs-string">&quot;price&quot;</span>: {
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>,
                <span class="hljs-string">&quot;minimum&quot;</span>: <span class="hljs-number">0</span>,
                <span class="hljs-string">&quot;exclusiveMinimum&quot;</span>: <span class="hljs-literal">true</span>
            },
            <span class="hljs-string">&quot;tags&quot;</span>: {
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;array&quot;</span>,
                <span class="hljs-string">&quot;items&quot;</span>: {
                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>
                },
                <span class="hljs-string">&quot;minItems&quot;</span>: <span class="hljs-number">1</span>,
                <span class="hljs-string">&quot;uniqueItems&quot;</span>: <span class="hljs-literal">true</span>
            },
            <span class="hljs-string">&quot;dimensions&quot;</span>: {
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,
                <span class="hljs-string">&quot;properties&quot;</span>: {
                    <span class="hljs-string">&quot;length&quot;</span>: {<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>},
                    <span class="hljs-string">&quot;width&quot;</span>: {<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>},
                    <span class="hljs-string">&quot;height&quot;</span>: {<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>}
                },
                <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;width&quot;</span>, <span class="hljs-string">&quot;height&quot;</span>]
            },
            <span class="hljs-string">&quot;warehouseLocation&quot;</span>: {
                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Coordinates of the warehouse with the product&quot;</span>,
                <span class="hljs-string">&quot;$ref&quot;</span>: <span class="hljs-string">&quot;http://json-schema.org/geo&quot;</span>
            }
        },
        <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>]
    }
}
</code></pre>
<p>you can validate that a resource (<code>/products</code>) conforms with the schema:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/products&quot;</span>).then().assertThat().body(matchesJsonSchemaInClasspath(<span class="hljs-string">&quot;products-schema.json&quot;</span>));
</code></pre>
<p><code>matchesJsonSchemaInClasspath</code> is statically imported from <code>io.restassured.module.jsv.JsonSchemaValidator</code> and it&apos;s recommended to statically import all methods from this class. However in order to use it you need to depend on the <code>json-schema-validator</code> module by either <a href="http://dl.bintray.com/johanhaleby/generic/json-schema-validator-3.1.0-dist.zip" target="_blank">downloading</a> it from the download page or add the following dependency from Maven:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.rest-assured<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-schema-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 id="json-schema-validation-settings">JSON Schema Validation Settings</h3>
<p>REST Assured&apos;s <code>json-schema-validator</code> module uses Francis Galiegue&apos;s <a href="https://github.com/fge/json-schema-validator" target="_blank">json-schema-validator</a> (<code>fge</code>) library to perform validation. If you need to configure the underlying <code>fge</code> library you can for example do like this:</p>
<pre><code class="lang-java"><span class="hljs-comment">// Given</span>
JsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.newBuilder().setValidationConfiguration(ValidationConfiguration.newBuilder().setDefaultVersion(DRAFTV4).freeze()).freeze();

<span class="hljs-comment">// When</span>
get(<span class="hljs-string">&quot;/products&quot;</span>).then().assertThat().body(matchesJsonSchemaInClasspath(<span class="hljs-string">&quot;products-schema.json&quot;</span>).using(jsonSchemaFactory));
</code></pre>
<p>The <code>using</code> method allows you to pass in a <code>jsonSchemaFactory</code> instance that REST Assured will use during validation. This allows fine-grained configuration for the validation.</p>
<p>The <code>fge</code> library also allows the validation to be <code>checked</code> or <code>unchecked</code>. By default REST Assured uses <code>checked</code> validation but if you want to change this you can supply an instance of <a href="http://static.javadoc.io/io.restassured/json-schema-validator/3.1.0/io/restassured/module/jsv/JsonSchemaValidatorSettings.html" target="_blank">JsonSchemaValidatorSettings</a> to the matcher. For example:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/products&quot;</span>).then().assertThat().body(matchesJsonSchemaInClasspath(<span class="hljs-string">&quot;products-schema.json&quot;</span>).using(settings().with().checkedValidation(<span class="hljs-keyword">false</span>)));
</code></pre>
<p>Where the <code>settings</code> method is statically imported from the <a href="http://static.javadoc.io/io.restassured/json-schema-validator/3.1.0/io/restassured/module/jsv/JsonSchemaValidatorSettings.html" target="_blank">JsonSchemaValidatorSettings</a> class.</p>
<h3 id="json-schema-validation-with-static-configuration">Json Schema Validation with static configuration</h3>
<p>Now imagine that you always want to use <code>unchecked</code> validation as well as setting the default json schema version to version 3. Instead of supplying this to all matchers throughout your code you can define it statically. For example:</p>
<pre><code class="lang-java">JsonSchemaValidator.settings = settings().with().jsonSchemaFactory(
        JsonSchemaFactory.newBuilder().setValidationConfiguration(ValidationConfiguration.newBuilder().setDefaultVersion(DRAFTV3).freeze()).freeze()).
        and().with().checkedValidation(<span class="hljs-keyword">false</span>);

get(<span class="hljs-string">&quot;/products&quot;</span>).then().assertThat().body(matchesJsonSchemaInClasspath(<span class="hljs-string">&quot;products-schema.json&quot;</span>));
</code></pre>
<p>Now any <code>matcher</code> method imported from <a href="http://static.javadoc.io/io.restassured/json-schema-validator/3.1.0/io/restassured/module/jsv/JsonSchemaValidatorSettings.html" target="_blank">JsonSchemaValidator</a> will use <code>DRAFTV3</code> as default version and unchecked validation.</p>
<p>To reset the <code>JsonSchemaValidator</code> to its default settings simply call the <code>reset</code> method:</p>
<pre><code class="lang-java">JsonSchemaValidator.reset();
</code></pre>
<h3 id="json-schema-validation-without-rest-assured">Json Schema Validation without REST Assured</h3>
<p>You can also use the <code>json-schema-validator</code> module without depending on REST Assured. As long as you have a JSON document represented as a <code>String</code> you can do like this:</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.restassured.module.jsv.JsonSchemaValidator.matchesJsonSchemaInClasspath;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.hamcrest.MatcherAssert.assertThat;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonSchemaValidatorWithoutRestAssuredTest</span> </span>{


    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
    <span class="hljs-title">validates_schema_in_classpath</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Given</span>
        String json = ... <span class="hljs-comment">// Greeting response</span>

        <span class="hljs-comment">// Then</span>
        assertThat(json, matchesJsonSchemaInClasspath(<span class="hljs-string">&quot;greeting-schema.json&quot;</span>));
    }
}
</code></pre>
<p>Refer to the <a href="GattingStarted">getting started</a> page for more info on this.</p>
<h3 id="anonymous-json-root-validation">Anonymous JSON root validation</h3>
<p>A JSON document doesn&apos;t necessarily need a named root attribute. This is for example valid JSON:</p>
<pre><code class="lang-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</code></pre>
<p>An anonymous JSON root can be verified by using <code>$</code> or an empty string as path. For example let&apos;s say that this JSON document is exposed from <code>http://localhost:8080/json</code> then we can validate it like this with REST Assured:</p>
<pre><code class="lang-java">when().
     get(<span class="hljs-string">&quot;/json&quot;</span>).
then().
     body(<span class="hljs-string">&quot;$&quot;</span>, hasItems(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// An empty string &quot;&quot; would work as well</span>
</code></pre>
<h2 id="example-2---xml">Example 2 - XML</h2>
<p>XML can be verified in a similar way. Imagine that a POST request to <code>http://localhost:8080/greetXML</code> returns:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">greeting</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">firstName</span>&gt;</span>{params(&quot;firstName&quot;)}<span class="hljs-tag">&lt;/<span class="hljs-name">firstName</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">lastName</span>&gt;</span>{params(&quot;lastName&quot;)}<span class="hljs-tag">&lt;/<span class="hljs-name">lastName</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">greeting</span>&gt;</span>
</code></pre>
<p>i.e. it sends back a greeting based on the firstName and lastName parameter sent in the request. You can easily perform and verify e.g. the firstName with REST assured:</p>
<pre><code class="lang-java">given().
         parameters(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).
when().
         post(<span class="hljs-string">&quot;/greetXML&quot;</span>).
then().
         body(<span class="hljs-string">&quot;greeting.firstName&quot;</span>, equalTo(<span class="hljs-string">&quot;John&quot;</span>)).
</code></pre>
<p>If you want to verify both firstName and lastName you may do like this:</p>
<pre><code class="lang-java">given().
         parameters(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).
when().
         post(<span class="hljs-string">&quot;/greetXML&quot;</span>).
then().
         body(<span class="hljs-string">&quot;greeting.firstName&quot;</span>, equalTo(<span class="hljs-string">&quot;John&quot;</span>)).
         body(<span class="hljs-string">&quot;greeting.lastName&quot;</span>, equalTo(<span class="hljs-string">&quot;Doe&quot;</span>));
</code></pre>
<p>or a little shorter:</p>
<pre><code class="lang-java">with().parameters(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).when().post(<span class="hljs-string">&quot;/greetXML&quot;</span>).then().body(<span class="hljs-string">&quot;greeting.firstName&quot;</span>, equalTo(<span class="hljs-string">&quot;John&quot;</span>), <span class="hljs-string">&quot;greeting.lastName&quot;</span>, equalTo(<span class="hljs-string">&quot;Doe&quot;</span>));
</code></pre>
<p>See <a href="http://groovy-lang.org/processing-xml.html#_gpath" target="_blank">this</a> link for more info about the syntax (it follows Groovy&apos;s <a href="http://groovy-lang.org/processing-xml.html#_gpath" target="_blank">GPath</a> syntax).</p>
<h3 id="xml-namespaces">XML namespaces</h3>
<p>To make body expectations take namespaces into account you need to declare the namespaces using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/XmlConfig.html" target="_blank">io.restassured.config.XmlConfig</a>. For example let&apos;s say that a resource called <code>namespace-example</code> located at <code>http://localhost:8080</code> returns the following XML:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">foo</span> <span class="hljs-attr">xmlns:ns</span>=<span class="hljs-string">&quot;http://localhost/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">bar</span>&gt;</span>sudo <span class="hljs-tag">&lt;/<span class="hljs-name">bar</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ns:bar</span>&gt;</span>make me a sandwich!<span class="hljs-tag">&lt;/<span class="hljs-name">ns:bar</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span>
</code></pre>
<p>You can then declare the <code>http://localhost/</code> uri and validate the response:</p>
<pre><code class="lang-java">given().
        config(RestAssured.config().xmlConfig(xmlConfig().declareNamespace(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;http://localhost/&quot;</span>))).
when().
         get(<span class="hljs-string">&quot;/namespace-example&quot;</span>).
then().
         body(<span class="hljs-string">&quot;foo.bar.text()&quot;</span>, equalTo(<span class="hljs-string">&quot;sudo make me a sandwich!&quot;</span>)).
         body(<span class="hljs-string">&quot;:foo.:bar.text()&quot;</span>, equalTo(<span class="hljs-string">&quot;sudo &quot;</span>)).
         body(<span class="hljs-string">&quot;foo.test:bar.text()&quot;</span>, equalTo(<span class="hljs-string">&quot;make me a sandwich!&quot;</span>));
</code></pre>
<p>The path syntax follows Groovy&apos;s XmlSlurper syntax. Note that in versions prior to 2.6.0 the path syntax was <em>not</em> following Groovy&apos;s XmlSlurper syntax. Please see <a href="https://github.com/rest-assured/rest-assured/wiki/ReleaseNotes26#non-backward-compatible-changes" target="_blank">release notes</a> for versin 2.6.0 to see how the previous syntax looked like.</p>
<h3 id="xpath">XPath</h3>
<p>You can also verify XML responses using x-path. For example:</p>
<pre><code class="lang-java">given().parameters(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).when().post(<span class="hljs-string">&quot;/greetXML&quot;</span>).then().body(hasXPath(<span class="hljs-string">&quot;/greeting/firstName&quot;</span>, containsString(<span class="hljs-string">&quot;Jo&quot;</span>)));
</code></pre>
<p>or</p>
<pre><code class="lang-java">given().parameters(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).post(<span class="hljs-string">&quot;/greetXML&quot;</span>).then().body(hasXPath(<span class="hljs-string">&quot;/greeting/firstName[text()=&apos;John&apos;]&quot;</span>));
</code></pre>
<p>To use namespaces in the XPath expression you need to enable them in the configuration, for example:</p>
<pre><code class="lang-java">given().
        config(RestAssured.config().xmlConfig(xmlConfig().with().namespaceAware(<span class="hljs-keyword">true</span>))).
when().
         get(<span class="hljs-string">&quot;/package-db-xml&quot;</span>).
then().
         body(hasXPath(<span class="hljs-string">&quot;/db:package-database&quot;</span>, namespaceContext));
</code></pre>
<p>Where <code>namespaceContext</code> is an instance of <a href="http://docs.oracle.com/javase/7/docs/api/javax/xml/namespace/NamespaceContext.html" target="_blank">javax.xml.namespace.NamespaceContext</a>.</p>
<h3 id="schema-and-dtd-validation">Schema and DTD validation</h3>
<p>XML response bodies can also be verified against an XML Schema (XSD) or DTD.</p>
<h4 id="xsd-example">XSD example</h4>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/carRecords&quot;</span>).then().assertThat().body(matchesXsd(xsd));
</code></pre>
<h4 id="dtd-example">DTD example</h4>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/videos&quot;</span>).then().assertThat().body(matchesDtd(dtd));
</code></pre>
<p>The <code>matchesXsd</code> and <code>matchesDtd</code> methods are Hamcrest matchers which you can import from <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/matcher/RestAssuredMatchers.html" target="_blank">io.restassured.matcher.RestAssuredMatchers</a>.<br>
&lt;/p&gt;</p>
<h2 id="example-3---complex-parsing-and-validation">Example 3 - Complex parsing and validation</h2>
<p>This is where REST Assured really starts to shine! Since REST Assured is implemented in Groovy it can be really beneficial to take advantage of Groovy&#x2019;s collection API. Let&#x2019;s begin by looking at an example in Groovy:</p>
<pre><code class="lang-groovy"><span class="hljs-keyword">def</span> words = [<span class="hljs-string">&apos;ant&apos;</span>, <span class="hljs-string">&apos;buffalo&apos;</span>, <span class="hljs-string">&apos;cat&apos;</span>, <span class="hljs-string">&apos;dinosaur&apos;</span>]
<span class="hljs-keyword">def</span> wordsWithSizeGreaterThanFour = words.findAll { it.length() &gt; <span class="hljs-number">4</span> }
</code></pre>
<p>At the first line we simply define a list with some words but the second line is more interesting. 
Here we search the words list for all words that are longer than 4 characters by calling the findAll with a Groovy closure. 
The closure has an implicit variable called <code>it</code> which represents the current item in the list. 
The result is a new list, <code>wordsWithSizeGreaterThanFour</code>, containing <code>buffalo</code> and <code>dinosaur</code>. </p>
<p>There are other interesting methods that we can use on collections in Groovy as well, for example:</p>
<ul>
<li><code>find</code> &#x2013; finds the first item matching a closure predicate</li>
<li><code>collect</code> &#x2013; collect the return value of calling a closure on each item in a collection</li>
<li><code>sum</code> &#x2013; Sum all the items in the collection</li>
<li><code>max</code>/<code>min</code> &#x2013; returns the max/min values of the collection</li>
</ul>
<p>So how do we take advantage of this when validating our XML or JSON responses with REST Assured?</p>
<h3 id="xml-example">XML Example</h3>
<p>Let&#x2019;s say we have a resource at <code>http://localhost:8080/shopping</code> that returns the following XML:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">shopping</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;groceries&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>Chocolate<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;supplies&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>Paper<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">quantity</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>Pens<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;present&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">when</span>=<span class="hljs-string">&quot;Aug 10&quot;</span>&gt;</span>Kathryn&apos;s Birthday<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">category</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">shopping</span>&gt;</span>
</code></pre>
<p>Let&#x2019;s also say we want to write a test that verifies that the category of type groceries has items Chocolate and Coffee. In REST Assured it can look like this:</p>
<pre><code class="lang-java">when().
       get(<span class="hljs-string">&quot;/shopping&quot;</span>).
then().
       body(<span class="hljs-string">&quot;shopping.category.find { it.@type == &apos;groceries&apos; }.item&quot;</span>, hasItems(<span class="hljs-string">&quot;Chocolate&quot;</span>, <span class="hljs-string">&quot;Coffee&quot;</span>));
</code></pre>
<p>What&apos;s going on here? First of all the XML path <code>shopping.category</code> returns a list of all categories. 
On this list we invoke a function, <code>find</code>, to return the single category that has the XML attribute, <code>type</code>, equal to <code>groceries</code>. 
On this category we then continue by getting all the items associated with this category. 
Since there are more than one item associated with the groceries category a list will be returned and we verify this list against the <code>hasItems</code> Hamcrest matcher.</p>
<p>But what if you want to get the items and not validate them against a Hamcrest matcher? For this purpose you can use <a href="http://static.javadoc.io/io.restassured/xml-path/3.1.0/io/restassured/path/xml/XmlPath.html" target="_blank">XmlPath</a>:</p>
<pre><code class="lang-java"><span class="hljs-comment">// Get the response body as a String</span>
String response = get(<span class="hljs-string">&quot;/shopping&quot;</span>).asString();
<span class="hljs-comment">// And get the groceries from the response. &quot;from&quot; is statically imported from the XmlPath class</span>
List&lt;String&gt; groceries = from(response).getList(<span class="hljs-string">&quot;shopping.category.find { it.@type == &apos;groceries&apos; }.item&quot;</span>);
</code></pre>
<p>If the list of groceries is the only thing you care about in the response body you can also use a <a href="#single-path">shortcut</a>:</p>
<pre><code class="lang-java"><span class="hljs-comment">// Get the response body as a String</span>
List&lt;String&gt; groceries = get(<span class="hljs-string">&quot;/shopping&quot;</span>).path(<span class="hljs-string">&quot;shopping.category.find { it.@type == &apos;groceries&apos; }.item&quot;</span>);
</code></pre>
<h4 id="depth-first-search">Depth-first search</h4>
<p>It&apos;s actually possible to simplify the previous example even further:</p>
<pre><code class="lang-java">when().
       get(<span class="hljs-string">&quot;/shopping&quot;</span>).
then().
       body(<span class="hljs-string">&quot;**.find { it.@type == &apos;groceries&apos; }&quot;</span>, hasItems(<span class="hljs-string">&quot;Chocolate&quot;</span>, <span class="hljs-string">&quot;Coffee&quot;</span>));
</code></pre>
<p><code>**</code> is a shortcut for doing depth first searching in the XML document. 
We search for the first node that has an attribute named <code>type</code> equal to &quot;groceries&quot;. Notice also that we don&apos;t end the XML path with &quot;item&quot;. 
The reason is that <code>toString()</code> is called automatically on the category node which returns a list of the item values.</p>
<h3 id="json-example">JSON Example</h3>
<p>Let&apos;s say we have a resource at <code>http://localhost:8080/store</code> that returns the following JSON document:</p>
<pre><code class="lang-javascript">{  
   <span class="hljs-string">&quot;store&quot;</span>:{  
      <span class="hljs-string">&quot;book&quot;</span>:[  
         {  
            <span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;Nigel Rees&quot;</span>,
            <span class="hljs-string">&quot;category&quot;</span>:<span class="hljs-string">&quot;reference&quot;</span>,
            <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">8.95</span>,
            <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Sayings of the Century&quot;</span>
         },
         {  
            <span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;Evelyn Waugh&quot;</span>,
            <span class="hljs-string">&quot;category&quot;</span>:<span class="hljs-string">&quot;fiction&quot;</span>,
            <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">12.99</span>,
            <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Sword of Honour&quot;</span>
         },
         {  
            <span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;Herman Melville&quot;</span>,
            <span class="hljs-string">&quot;category&quot;</span>:<span class="hljs-string">&quot;fiction&quot;</span>,
            <span class="hljs-string">&quot;isbn&quot;</span>:<span class="hljs-string">&quot;0-553-21311-3&quot;</span>,
            <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">8.99</span>,
            <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Moby Dick&quot;</span>
         },
         {  
            <span class="hljs-string">&quot;author&quot;</span>:<span class="hljs-string">&quot;J. R. R. Tolkien&quot;</span>,
            <span class="hljs-string">&quot;category&quot;</span>:<span class="hljs-string">&quot;fiction&quot;</span>,
            <span class="hljs-string">&quot;isbn&quot;</span>:<span class="hljs-string">&quot;0-395-19395-8&quot;</span>,
            <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">22.99</span>,
            <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;The Lord of the Rings&quot;</span>
         }
      ]
   }
}
</code></pre>
<h4 id="example-1">Example 1</h4>
<p>As a first example let&apos;s say we want to make the request to &quot;/store&quot; and assert that the titles of the books with a price less than 10 are &quot;Sayings of the Century&quot; and &quot;Moby Dick&quot;:</p>
<pre><code class="lang-java">when().
       get(<span class="hljs-string">&quot;/store&quot;</span>).
then().
       body(<span class="hljs-string">&quot;store.book.findAll { it.price &lt; 10 }.title&quot;</span>, hasItems(<span class="hljs-string">&quot;Sayings of the Century&quot;</span>, <span class="hljs-string">&quot;Moby Dick&quot;</span>));
</code></pre>
<p>Just as in the XML examples above we use a closure to find all books with a price less than 10 and then return the titles of all the books. 
We then use the <code>hasItems</code> matcher to assert that the titles are the ones we expect. Using <a href="http://static.javadoc.io/io.restassured/json-path/3.1.0/io/restassured/path/json/JsonPath.html" target="_blank">JsonPath</a> we can return the titles instead:</p>
<pre><code class="lang-java"><span class="hljs-comment">// Get the response body as a String</span>
String response = get(<span class="hljs-string">&quot;/store&quot;</span>).asString();
<span class="hljs-comment">// And get all books with price &lt; 10 from the response. &quot;from&quot; is statically imported from the JsonPath class</span>
List&lt;String&gt; bookTitles = from(response).getList(<span class="hljs-string">&quot;store.book.findAll { it.price &lt; 10 }.title&quot;</span>);
</code></pre>
<h4 id="example-2">Example 2</h4>
<p> Let&apos;s consider instead that we want to assert that the sum of the length of all author names are greater than 50. 
 This is a rather complex question to answer and it really shows the strength of closures and Groovy collections. 
 In REST Assured it looks like this:</p>
<pre><code class="lang-java"> when().
        get(<span class="hljs-string">&quot;/store&quot;</span>);
 then().
        body(<span class="hljs-string">&quot;store.book.author.collect { it.length() }.sum()&quot;</span>, greaterThan(<span class="hljs-number">50</span>));
</code></pre>
<p>First we get all the authors (<code>store.book.author</code>) and invoke the collect method on the resulting list with the closure <code>{ it.length() }</code>. 
What it does is to call the <code>length()</code> method on each author in the list and returns the result to a new list. 
On this list we simply call the <code>sum()</code> method to sum all the length&apos;s. 
The end result is <code>53</code> and we assert that it&apos;s greater than 50 by using the <code>greaterThan</code> matcher. 
But it&apos;s actually possible to simplify this even further. Consider the &quot;<a href="#example-3---complex-parsing-and-validation">words</a>&quot; example again:</p>
<pre><code class="lang-groovy"><span class="hljs-keyword">def</span> words = [<span class="hljs-string">&apos;ant&apos;</span>, <span class="hljs-string">&apos;buffalo&apos;</span>, <span class="hljs-string">&apos;cat&apos;</span>, <span class="hljs-string">&apos;dinosaur&apos;</span>]
</code></pre>
<p>Groovy has a very handy way of calling a function for each element in the list by using the spread operator, <code>*</code>. For example:</p>
<pre><code class="lang-groovy"><span class="hljs-keyword">def</span> words = [<span class="hljs-string">&apos;ant&apos;</span>, <span class="hljs-string">&apos;buffalo&apos;</span>, <span class="hljs-string">&apos;cat&apos;</span>, <span class="hljs-string">&apos;dinosaur&apos;</span>]
<span class="hljs-keyword">assert</span> [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>] == words*.length()
</code></pre>
<p>I.e. Groovy returns a new list with the lengths of the items in the words list. We can utilize this for the author list in REST Assured as well:</p>
<pre><code class="lang-java">when().
       get(<span class="hljs-string">&quot;/store&quot;</span>);
then().
       body(<span class="hljs-string">&quot;store.book.author*.length().sum()&quot;</span>, greaterThan(<span class="hljs-number">50</span>)).
</code></pre>
<p>And of course we can use <a href="http://static.javadoc.io/io.restassured/json-path/3.1.0/io/restassured/path/json/JsonPath.html" target="_blank">JsonPath</a> to actually return the result:</p>
<pre><code class="lang-java"><span class="hljs-comment">// Get the response body as a string</span>
String response = get(<span class="hljs-string">&quot;/store&quot;</span>).asString();
<span class="hljs-comment">// Get the sum of all author length&apos;s as an int. &quot;from&quot; is again statically imported from the JsonPath class</span>
<span class="hljs-keyword">int</span> sumOfAllAuthorLengths = from(response).getInt(<span class="hljs-string">&quot;store.book.author*.length().sum()&quot;</span>);
<span class="hljs-comment">// We can also assert that the sum is equal to 53 as expected.</span>
assertThat(sumOfAllAuthorLengths, is(<span class="hljs-number">53</span>));
</code></pre>
<h2 id="additional-examples">Additional Examples</h2>
<p>Micha Kops has written a really good blog with several examples (including code examples that you can checkout). You can read it <a href="http://www.hascode.com/2011/10/testing-restful-web-services-made-easy-using-the-rest-assured-framework/" target="_blank">here</a>.</p>
<p>Also <a href="https://www.linkedin.com/in/basdijkstra" target="_blank">Bas Dijkstra</a> has been generous enough to open source his REST Assured workshop. You can read more about this <a href="http://www.ontestautomation.com/open-sourcing-my-workshop-an-experiment/" target="_blank">here</a> and you can try out, and contribute to, the exercises available in <a href="https://github.com/basdijkstra/workshops/" target="_blank">his</a> github repository. </p>
<h2 id="note-on-floats-and-doubles">Note on floats and doubles</h2>
<p>Floating point numbers must be compared with a Java &quot;float&quot; primitive. For example, if we consider the following JSON object:</p>
<pre><code class="lang-javascript">{

    <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">12.12</span> 

}
</code></pre>
<p>the following test will fail, because we compare with a &quot;double&quot; instead of a &quot;float&quot;:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/price&quot;</span>).then().assertThat().body(<span class="hljs-string">&quot;price&quot;</span>, equalTo(<span class="hljs-number">12.12</span>));
</code></pre>
<p>Instead, compare with a float with:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/price&quot;</span>).then().assertThat().body(<span class="hljs-string">&quot;price&quot;</span>, equalTo(<span class="hljs-number">12.12f</span>));
</code></pre>
<h2 id="note-on-syntax">Note on syntax</h2>
<p>When reading blogs about REST Assured you may see a lot of examples using the &quot;given / expect / when&quot; syntax, for example:</p>
<pre><code class="lang-java">given().
        param(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>).
expect().
        body(<span class="hljs-string">&quot;lotto.lottoId&quot;</span>, equalTo(<span class="hljs-number">5</span>)).
when().
        get(<span class="hljs-string">&quot;/lotto&quot;</span>);
</code></pre>
<p>This is the so called &quot;legacy syntax&quot; which was the de facto way of writing tests in REST Assured 1.x. While this works fine it turned out to be quite confusing and annoying for many users. The reason for not using &quot;given / when / then&quot; in the first place was mainly technical. So prior to REST Assured 2.0 there was no support &quot;given / when / then&quot; which is more or less the standard approach when you&apos;re doing some kind of BDD-like testing. The &quot;given / expect / when&quot; approach still works fine in 2.0 but &quot;given / when / then&quot; reads better and is easier to understand for most people and is thus recommended in most cases. There&apos;s however one benefit of using the &quot;given / expect / when&quot; approach and that is that ALL expectation errors can be displayed at the same time which is not possible with the new syntax (since the expectations are defined last). This means that if you would have had multiple expectations in the previous example such as</p>
<pre><code class="lang-java">given().
        param(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>).
expect().
        statusCode(<span class="hljs-number">400</span>).
        body(<span class="hljs-string">&quot;lotto.lottoId&quot;</span>, equalTo(<span class="hljs-number">6</span>)).
when().
        get(<span class="hljs-string">&quot;/lotto&quot;</span>);
</code></pre>
<p>REST Assured will report that both the status code expectation and the body expectation are wrong. Rewriting this with the new syntax</p>
<pre><code class="lang-java">given().
        param(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/lotto&quot;</span>).
then().
        statusCode(<span class="hljs-number">400</span>).
        body(<span class="hljs-string">&quot;lotto.lottoId&quot;</span>, equalTo(<span class="hljs-number">6</span>));
</code></pre>
<p>will only report an error at the first failed expectation / assertion (that status code was expected to be 400 but it was actually 200). You would have to re-run the test in order to catch the second error.</p>
<h3 id="syntactic-sugar">Syntactic Sugar</h3>
<p>Another thing worth mentioning is that REST Assured contains some methods that are only there for syntactic sugar. For example the &quot;and&quot; method which can add readability if you&apos;re writing everything in a one-liner, for example:</p>
<pre><code class="lang-java">given().param(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>).and().header(<span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>).when().get(<span class="hljs-string">&quot;/something&quot;</span>).then().assertThat().statusCode(<span class="hljs-number">200</span>).and().body(<span class="hljs-string">&quot;x.y&quot;</span>, equalTo(<span class="hljs-string">&quot;z&quot;</span>));
</code></pre>
<p>This is the same thing as:</p>
<pre><code class="lang-java">given().
        param(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>).
        header(<span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/something&quot;</span>).
then().
        statusCode(<span class="hljs-number">200</span>).
        body(<span class="hljs-string">&quot;x.y&quot;</span>, equalTo(<span class="hljs-string">&quot;z&quot;</span>));
</code></pre>
<h1 id="getting-response-data">Getting Response Data</h1>
<p>You can also get the content of a response. E.g. let&apos;s say you want to return the body of a get request to &quot;/lotto&quot;. You can get it a variety of different ways:</p>
<pre><code class="lang-java">InputStream stream = get(<span class="hljs-string">&quot;/lotto&quot;</span>).asInputStream(); <span class="hljs-comment">// Don&apos;t forget to close this one when you&apos;re done</span>
<span class="hljs-keyword">byte</span>[] byteArray = get(<span class="hljs-string">&quot;/lotto&quot;</span>).asByteArray();
String json = get(<span class="hljs-string">&quot;/lotto&quot;</span>).asString();
</code></pre>
<h2 id="extracting-values-from-the-response-after-validation">Extracting values from the Response after validation</h2>
<p>You can extract values from the response or return the response instance itself after you&apos;ve done validating the response by using the <code>extract</code> method. This is useful for example if you want to use values from the response in sequent requests. For example given that a resource called <code>title</code> returns the following JSON</p>
<pre><code class="lang-javascript"> {
     <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;My Title&quot;</span>,
      <span class="hljs-string">&quot;_links&quot;</span>: {
              <span class="hljs-string">&quot;self&quot;</span>: { <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;/title&quot;</span> },
              <span class="hljs-string">&quot;next&quot;</span>: { <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;/title?page=2&quot;</span> }
           }
 }
</code></pre>
<p>and you want to validate that content type is equal to <code>JSON</code> and the title is equal to <code>My Title</code>
but you also want to extract the link to the <code>next</code> title to use that in a subsequent request. This is how:</p>
<pre><code class="lang-java">String nextTitleLink =
given().
        param(<span class="hljs-string">&quot;param_name&quot;</span>, <span class="hljs-string">&quot;param_value&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/title&quot;</span>).
then().
        contentType(JSON).
        body(<span class="hljs-string">&quot;title&quot;</span>, equalTo(<span class="hljs-string">&quot;My Title&quot;</span>)).
extract().
        path(<span class="hljs-string">&quot;_links.next.href&quot;</span>);

get(nextTitleLink). ..
</code></pre>
<p>You could also decide to instead return the entire response if you need to extract multiple values from the response:</p>
<pre><code class="lang-java">Response response = 
given().
        param(<span class="hljs-string">&quot;param_name&quot;</span>, <span class="hljs-string">&quot;param_value&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/title&quot;</span>).
then().
        contentType(JSON).
        body(<span class="hljs-string">&quot;title&quot;</span>, equalTo(<span class="hljs-string">&quot;My Title&quot;</span>)).
extract().
        response(); 

String nextTitleLink = response.path(<span class="hljs-string">&quot;_links.next.href&quot;</span>);
String headerValue = response.header(<span class="hljs-string">&quot;headerName&quot;</span>);
</code></pre>
<h2 id="json-using-jsonpath">JSON (using JsonPath)</h2>
<p>Once we have the response body we can then use the <a href="http://static.javadoc.io/io.restassured/json-path/3.1.0/io/restassured/path/json/JsonPath.html" target="_blank">JsonPath</a> to get data from the response body:</p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> lottoId = from(json).getInt(<span class="hljs-string">&quot;lotto.lottoId&quot;</span>);
List&lt;Integer&gt; winnerIds = from(json).get(<span class="hljs-string">&quot;lotto.winners.winnerId&quot;</span>);
</code></pre>
<p>Or a bit more efficiently:</p>
<pre><code class="lang-java">JsonPath jsonPath = <span class="hljs-keyword">new</span> JsonPath(json).setRoot(<span class="hljs-string">&quot;lotto&quot;</span>);
<span class="hljs-keyword">int</span> lottoId = jsonPath.getInt(<span class="hljs-string">&quot;lottoId&quot;</span>);
List&lt;Integer&gt; winnerIds = jsonPath.get(<span class="hljs-string">&quot;winners.winnderId&quot;</span>);
</code></pre>
<p>Note that you can use <code>JsonPath</code> standalone without depending on REST Assured, see <a href="GettingStarted">getting started guide</a> for more info on this.</p>
<h3 id="jsonpath-configuration">JsonPath Configuration</h3>
<p>You can configure object de-serializers etc for JsonPath by configuring it, for example:</p>
<pre><code class="lang-java">JsonPath jsonPath = <span class="hljs-keyword">new</span> JsonPath(SOME_JSON).using(<span class="hljs-keyword">new</span> JsonPathConfig(<span class="hljs-string">&quot;UTF-8&quot;</span>));
</code></pre>
<p>It&apos;s also possible to configure JsonPath statically so that all instances of JsonPath will shared the same configuration:</p>
<pre><code class="lang-java">JsonPath.config = <span class="hljs-keyword">new</span> JsonPathConfig(<span class="hljs-string">&quot;UTF-8&quot;</span>);
</code></pre>
<p>You can read more about JsonPath at <a href="http://www.jayway.com/2013/04/12/whats-new-in-rest-assured-1-8/" target="_blank">this blog</a>.</p>
<p>Note that the JsonPath implementation uses <a href="http://groovy-lang.org/processing-xml.html#_gpath" target="_blank">Groovy&apos;s GPath</a> syntax and is not to be confused with Jayway&apos;s <a href="https://github.com/jayway/JsonPath" target="_blank">JsonPath</a> implementation.</p>
<h2 id="xml-using-xmlpath">XML (using XmlPath)</h2>
<p>You also have the corresponding functionality for XML using  <a href="http://static.javadoc.io/io.restassured/xml-path/3.1.0/io/restassured/path/xml/XmlPath.html" target="_blank">XmlPath</a>:</p>
<pre><code class="lang-java">String xml = post(<span class="hljs-string">&quot;/greetXML?firstName=John&amp;lastName=Doe&quot;</span>).andReturn().asString();
<span class="hljs-comment">// Now use XmlPath to get the first and last name</span>
String firstName = from(xml).get(<span class="hljs-string">&quot;greeting.firstName&quot;</span>);
String lastName = from(xml).get(<span class="hljs-string">&quot;greeting.firstName&quot;</span>);

<span class="hljs-comment">// or a bit more efficiently:</span>
XmlPath xmlPath = <span class="hljs-keyword">new</span> XmlPath(xml).setRoot(<span class="hljs-string">&quot;greeting&quot;</span>);
String firstName = xmlPath.get(<span class="hljs-string">&quot;firstName&quot;</span>);
String lastName = xmlPath.get(<span class="hljs-string">&quot;lastName&quot;</span>);
</code></pre>
<p>Note that you can use <code>XmlPath</code> standalone without depending on REST Assured, see <a href="GettingStarted">getting started guide</a> for more info on this.</p>
<h3 id="xmlpath-configuration">XmlPath Configuration</h3>
<p>You can configure object de-serializers and charset for XmlPath by configuring it, for example:</p>
<pre><code class="lang-java">XmlPath xmlPath = <span class="hljs-keyword">new</span> XmlPath(SOME_XML).using(<span class="hljs-keyword">new</span> XmlPathConfig(<span class="hljs-string">&quot;UTF-8&quot;</span>));
</code></pre>
<p>It&apos;s also possible to configure XmlPath statically so that all instances of XmlPath will shared the same configuration:</p>
<pre><code class="lang-java">XmlPath.config = <span class="hljs-keyword">new</span> XmlPathConfig(<span class="hljs-string">&quot;UTF-8&quot;</span>);
</code></pre>
<p>You can read more about XmlPath at <a href="http://www.jayway.com/2013/04/12/whats-new-in-rest-assured-1-8/" target="_blank">this blog</a>.</p>
<h3 id="parsing-html-with-xmlpath">Parsing HTML with XmlPath</h3>
<p>By configuring XmlPath with <a href="http://static.javadoc.io/io.rest-assured/xml-path/3.1.0/io/restassured/path/xml/XmlPath.CompatibilityMode.html" target="_blank">compatibility mode</a> <code>HTML</code> you can also use the XmlPath syntax (Gpath) to parse HTML pages. For example if you want to extract the title of this HTML document:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>my title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>you can configure XmlPath like this:</p>
<pre><code class="lang-java">String html = ...
XmlPath xmlPath = <span class="hljs-keyword">new</span> XmlPath(CompatibilityMode.HTML, html);
</code></pre>
<p>and then extract the title like this:</p>
<pre><code class="lang-java">xmlPath.getString(<span class="hljs-string">&quot;html.head.title&quot;</span>); <span class="hljs-comment">// will return &quot;mytitle&quot;</span>
</code></pre>
<p>In this example we&apos;ve statically imported: <code>io.restassured.path.xml.XmlPath.CompatibilityMode.HTML</code>;</p>
<h2 id="single-path">Single path</h2>
<p>If you only want to make a request and return a single path you can use a shortcut:</p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> lottoId = get(<span class="hljs-string">&quot;/lotto&quot;</span>).path(<span class="hljs-string">&quot;lotto.lottoid&quot;</span>);
</code></pre>
<p>REST Assured will automatically determine whether to use JsonPath or XmlPath based on the content-type of the response. If no content-type is defined then REST Assured will try to look at the <a href="#default-parser">default parser</a> if defined. You can also manually decide which path instance to use, e.g.</p>
<pre><code class="lang-java">String firstName = post(<span class="hljs-string">&quot;/greetXML?firstName=John&amp;lastName=Doe&quot;</span>).andReturn().xmlPath().getString(<span class="hljs-string">&quot;firstName&quot;</span>);
</code></pre>
<p>Options are <code>xmlPath</code>, <code>jsonPath</code> and <code>htmlPath</code>.</p>
<h2 id="headers-cookies-status-etc">Headers, cookies, status etc</h2>
<p>You can also get headers, cookies, status line and status code:</p>
<pre><code class="lang-java">Response response = get(<span class="hljs-string">&quot;/lotto&quot;</span>);

<span class="hljs-comment">// Get all headers</span>
Headers allHeaders = response.getHeaders();
<span class="hljs-comment">// Get a single header value:</span>
String headerName = response.getHeader(<span class="hljs-string">&quot;headerName&quot;</span>);

<span class="hljs-comment">// Get all cookies as simple name-value pairs</span>
Map&lt;String, String&gt; allCookies = response.getCookies();
<span class="hljs-comment">// Get a single cookie value:</span>
String cookieValue = response.getCookie(<span class="hljs-string">&quot;cookieName&quot;</span>);

<span class="hljs-comment">// Get status line</span>
String statusLine = response.getStatusLine();
<span class="hljs-comment">// Get status code</span>
<span class="hljs-keyword">int</span> statusCode = response.getStatusCode();
</code></pre>
<h2 id="multi-value-headers-and-cookies">Multi-value headers and cookies</h2>
<p>A header and a cookie can contain several values for the same name.</p>
<h3 id="multi-value-headers">Multi-value headers</h3>
<p>To get all values for a header you need to first get the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/http/Headers.html" target="_blank">Headers</a> object from the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/response/Response.html" target="_blank">Response</a> object. From the <code>Headers</code> instance you can get all values using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/http/Headers.html#getValues(java.lang.String" target="_blank">Headers.getValues(<header name="">)</header></a>) method which returns a <code>List</code> with all header values.</p>
<h3 id="multi-value-cookies">Multi-value cookies</h3>
<p>To get all values for a cookie you need to first get the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/http/Cookies.html" target="_blank">Cookies</a> object from the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/response/Response.html" target="_blank">Response</a> object. From the <code>Cookies</code> instance you can get all values using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/http/Cookies.html#getValues(java.lang.String" target="_blank">Cookies.getValues(<cookie name="">)</cookie></a>) method which returns a <code>List</code> with all cookie values.</p>
<h2 id="detailed-cookies">Detailed Cookies</h2>
<p>If you need to get e.g. the comment, path or expiry date etc from a cookie you need get a <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/http/Cookie.html" target="_blank">detailed cookie</a> from REST Assured. To do this you can use the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/response/ResponseOptions.html#getDetailedCookie-java.lang.String-" target="_blank">Response.getDetailedCookie(java.lang.String)</a> method. The detailed cookie then contains all attributes from the cookie.</p>
<p>You can also get all detailed response <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/http/Cookies.html" target="_blank">cookies</a> using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/response/ResponseOptions.html#getDetailedCookies--" target="_blank">Response.getDetailedCookies()</a> method.</p>
<h1 id="specifying-request-data">Specifying Request Data</h1>
<p>Besides specifying request parameters you can also specify headers, cookies, body and content type.</p>
<h2 id="invoking-http-resources">Invoking HTTP resources</h2>
<p>You typically perform a request by calling any of the &quot;HTTP methods&quot; in the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/specification/RequestSpecification.html" target="_blank">request specification</a>. For example:</p>
<pre><code class="lang-java">when().get(<span class="hljs-string">&quot;/x&quot;</span>). ..;
</code></pre>
<p>Where <code>get</code> is the HTTP request method.</p>
<p>As of REST Assured 3.0.0 you can use any HTTP verb with your request by making use of the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/specification/RequestSpecification.html#request-java.lang.String-java.lang.String-" target="_blank"></a> method.</p>
<pre><code class="lang-java">when().
       request(<span class="hljs-string">&quot;CONNECT&quot;</span>, <span class="hljs-string">&quot;/somewhere&quot;</span>).
then().
       statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>This will send a &quot;connect&quot; request to the server.</p>
<h2 id="parameters">Parameters</h2>
<p>Normally you specify parameters like this:</p>
<pre><code class="lang-java">given().
       param(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>).
       param(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>).
when().
       get(<span class="hljs-string">&quot;/something&quot;</span>);
</code></pre>
<p>REST Assured will automatically try to determine which parameter type (i.e. query or form parameter) based on the HTTP method. In case of GET query parameters will automatically be used and in case of POST form parameters will be used. In some cases it&apos;s however important to separate between form and query parameters in a PUT or POST. You can then do like this:</p>
<pre><code class="lang-java">given().
       formParam(<span class="hljs-string">&quot;formParamName&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>).
       queryParam(<span class="hljs-string">&quot;queryParamName&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>).
when().
       post(<span class="hljs-string">&quot;/something&quot;</span>);
</code></pre>
<p>Parameters can also be set directly on the url:</p>
<pre><code class="lang-java">..when().get(<span class="hljs-string">&quot;/name?firstName=John&amp;lastName=Doe&quot;</span>);
</code></pre>
<p>For multi-part parameters please refer to the <a href="#multi-part-form-data">Multi-part form data</a> section.</p>
<h3 id="multi-value-parameter">Multi-value parameter</h3>
<p>Multi-value parameters are parameters with more then one value per parameter name (i.e. a list of values per name). You can specify these either by using var-args:</p>
<pre><code class="lang-java">given().param(<span class="hljs-string">&quot;myList&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>). ..
</code></pre>
<p>or using a list:</p>
<pre><code class="lang-java">List&lt;String&gt; values = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
values.add(<span class="hljs-string">&quot;value1&quot;</span>);
values.add(<span class="hljs-string">&quot;value2&quot;</span>);

given().param(<span class="hljs-string">&quot;myList&quot;</span>, values). ..
</code></pre>
<h3 id="no-value-parameter">No-value parameter</h3>
<p>You can also specify a query, request or form parameter without a value at all:</p>
<pre><code class="lang-java">given().param(<span class="hljs-string">&quot;paramName&quot;</span>). ..
</code></pre>
<h3 id="path-parameters">Path parameters</h3>
<p>You can also specify so called path parameters in your request, e.g.</p>
<pre><code class="lang-java">post(<span class="hljs-string">&quot;/reserve/{hotelId}/{roomNumber}&quot;</span>, <span class="hljs-string">&quot;My Hotel&quot;</span>, <span class="hljs-number">23</span>);
</code></pre>
<p>These kinds of path parameters are referred to &quot;unnamed path parameters&quot; in REST Assured since they are index based (<code>hotelId</code> will be equal to &quot;My Hotel&quot; since it&apos;s the first placeholder).</p>
<p>You can also use named path parameters:</p>
<pre><code class="lang-java">given().
        pathParam(<span class="hljs-string">&quot;hotelId&quot;</span>, <span class="hljs-string">&quot;My Hotel&quot;</span>).
        pathParam(<span class="hljs-string">&quot;roomNumber&quot;</span>, <span class="hljs-number">23</span>).
when(). 
        post(<span class="hljs-string">&quot;/reserve/{hotelId}/{roomNumber}&quot;</span>).
then().
         ..
</code></pre>
<p>Path parameters makes it easier to read the request path as well as enabling the request path to easily be re-usable in many tests with different parameter values.</p>
<p>As of version 2.8.0 you can mix unnamed and named path parameters:</p>
<pre><code class="lang-java">given().
        pathParam(<span class="hljs-string">&quot;hotelId&quot;</span>, <span class="hljs-string">&quot;My Hotel&quot;</span>).        
when(). 
        post(<span class="hljs-string">&quot;/reserve/{hotelId}/{roomNumber}&quot;</span>, <span class="hljs-number">23</span>).
then().
         ..
</code></pre>
<p>Here <code>roomNumber</code> will be replaced with <code>23</code>.</p>
<p>Note that specifying too few or too many parameters will result in an error message. For advanced use cases you can add, change, remove (even redundant path parameters) from a <a href="#filters">filter</a>.</p>
<h2 id="cookies">Cookies</h2>
<p>In its simplest form you specify cookies like this:</p>
<pre><code class="lang-java">given().cookie(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>).when().get(<span class="hljs-string">&quot;/cookie&quot;</span>).then().body(equalTo(<span class="hljs-string">&quot;username&quot;</span>));
</code></pre>
<p>You can also specify a multi-value cookie like this:</p>
<pre><code class="lang-java">given().cookie(<span class="hljs-string">&quot;cookieName&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>). ..
</code></pre>
<p>This will create <em>two</em> cookies, <code>cookieName=value1</code> and <code>cookieName=value2</code>.</p>
<p>You can also specify a detailed cookie using:</p>
<pre><code class="lang-java">Cookie someCookie = <span class="hljs-keyword">new</span> Cookie.Builder(<span class="hljs-string">&quot;some_cookie&quot;</span>, <span class="hljs-string">&quot;some_value&quot;</span>).setSecured(<span class="hljs-keyword">true</span>).setComment(<span class="hljs-string">&quot;some comment&quot;</span>).build();
given().cookie(someCookie).when().get(<span class="hljs-string">&quot;/cookie&quot;</span>).then().assertThat().body(equalTo(<span class="hljs-string">&quot;x&quot;</span>));
</code></pre>
<p>or several detailed cookies at the same time:</p>
<pre><code class="lang-java">Cookie cookie1 = Cookie.Builder(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>).setComment(<span class="hljs-string">&quot;comment 1&quot;</span>).build();
Cookie cookie2 = Cookie.Builder(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-number">1234</span>).setComment(<span class="hljs-string">&quot;comment 2&quot;</span>).build();
Cookies cookies = <span class="hljs-keyword">new</span> Cookies(cookie1, cookie2);
given().cookies(cookies).when().get(<span class="hljs-string">&quot;/cookie&quot;</span>).then().body(equalTo(<span class="hljs-string">&quot;username, token&quot;</span>));
</code></pre>
<h2 id="headers">Headers</h2>
<pre><code class="lang-java">given().header(<span class="hljs-string">&quot;MyHeader&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>).and(). ..
given().headers(<span class="hljs-string">&quot;MyHeader&quot;</span>, <span class="hljs-string">&quot;Something&quot;</span>, <span class="hljs-string">&quot;MyOtherHeader&quot;</span>, <span class="hljs-string">&quot;SomethingElse&quot;</span>).and(). ..
</code></pre>
<p>You can also specify a multi-value headers like this:</p>
<pre><code class="lang-java">given().header(<span class="hljs-string">&quot;headerName&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>). ..
</code></pre>
<p>This will create <em>two</em> headers, <code>headerName: value1</code> and <code>headerName: value2</code>.</p>
<h4 id="header-mergingoverwriting">Header Merging/Overwriting</h4>
<p>By default headers are merged. So for example if you do like this:</p>
<pre><code class="lang-java">given().header(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>).header(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>). ..
</code></pre>
<p>The request will contain two headers, &quot;x: 1&quot; and &quot;x: 2&quot;. You can change in this on a per header basis in the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/HeaderConfig.html" target="_blank">HeaderConfig</a>. For example:</p>
<pre><code class="lang-java">given().
        config(RestAssuredConfig.config().headerConfig(headerConfig().overwriteHeadersWithName(<span class="hljs-string">&quot;x&quot;</span>))).
        header(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>).
        header(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/something&quot;</span>).
...
</code></pre>
<p>This means that only one header, &quot;x: 2&quot;, is sent to server.</p>
<h2 id="content-type">Content Type</h2>
<pre><code class="lang-java">given().contentType(ContentType.TEXT). ..
given().contentType(<span class="hljs-string">&quot;application/json&quot;</span>). ..
</code></pre>
<h2 id="request-body">Request Body</h2>
<pre><code class="lang-java">given().body(<span class="hljs-string">&quot;some body&quot;</span>). .. <span class="hljs-comment">// Works for POST, PUT and DELETE requests</span>
given().request().body(<span class="hljs-string">&quot;some body&quot;</span>). .. <span class="hljs-comment">// More explicit (optional)</span>
</code></pre>
<pre><code class="lang-java">given().body(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]{<span class="hljs-number">42</span>}). .. <span class="hljs-comment">// Works for POST, PUT and DELETE</span>
given().request().body(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]{<span class="hljs-number">42</span>}). .. <span class="hljs-comment">// More explicit (optional)</span>
</code></pre>
<p>You can also serialize a Java object to JSON or XML. Click <a href="#serialization">here</a> for details.</p>
<h1 id="verifying-response-data">Verifying Response Data</h1>
<p>You can also verify status code, status line, cookies, headers, content type and body.</p>
<h2 id="response-body">Response Body</h2>
<p>See Usage examples, e.g. <a href="#example-1---json">JSON</a> or <a href="#example-2---xml">XML</a>.</p>
<p>You can also map a response body to a Java Object, click <a href="#deserialization">here</a> for details.</p>
<h2 id="cookies">Cookies</h2>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().cookie(<span class="hljs-string">&quot;cookieName&quot;</span>, <span class="hljs-string">&quot;cookieValue&quot;</span>). ..
get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().cookies(<span class="hljs-string">&quot;cookieName1&quot;</span>, <span class="hljs-string">&quot;cookieValue1&quot;</span>, <span class="hljs-string">&quot;cookieName2&quot;</span>, <span class="hljs-string">&quot;cookieValue2&quot;</span>). ..
get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().cookies(<span class="hljs-string">&quot;cookieName1&quot;</span>, <span class="hljs-string">&quot;cookieValue1&quot;</span>, <span class="hljs-string">&quot;cookieName2&quot;</span>, containsString(<span class="hljs-string">&quot;Value2&quot;</span>)). ..
</code></pre>
<h2 id="status">Status</h2>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().statusCode(<span class="hljs-number">200</span>). ..
get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().statusLine(<span class="hljs-string">&quot;something&quot;</span>). ..
get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().statusLine(containsString(<span class="hljs-string">&quot;some&quot;</span>)). ..
</code></pre>
<h2 id="headers">Headers</h2>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().header(<span class="hljs-string">&quot;headerName&quot;</span>, <span class="hljs-string">&quot;headerValue&quot;</span>). ..
get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().headers(<span class="hljs-string">&quot;headerName1&quot;</span>, <span class="hljs-string">&quot;headerValue1&quot;</span>, <span class="hljs-string">&quot;headerName2&quot;</span>, <span class="hljs-string">&quot;headerValue2&quot;</span>). ..
get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().headers(<span class="hljs-string">&quot;headerName1&quot;</span>, <span class="hljs-string">&quot;headerValue1&quot;</span>, <span class="hljs-string">&quot;headerName2&quot;</span>, containsString(<span class="hljs-string">&quot;Value2&quot;</span>)). ..
</code></pre>
<p>It&apos;s also possible to use a mapping function when validating headers. For example let&apos;s say you want to validate that the <code>Content-Length</code> header is less than 1000. You can then use a mapping function to first convert the header value to an int and then use an <code>Integer</code> before validating it with a Hamcrest matcher:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/something&quot;</span>).then().assertThat().header(<span class="hljs-string">&quot;Content-Length&quot;</span>, Integer::parseInt, lessThan(<span class="hljs-number">1000</span>));
</code></pre>
<h2 id="content-type">Content-Type</h2>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().contentType(ContentType.JSON). ..
</code></pre>
<h2 id="full-bodycontent-matching">Full body/content matching</h2>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().assertThat().body(equalTo(<span class="hljs-string">&quot;something&quot;</span>)). ..
</code></pre>
<h2 id="use-the-response-to-verify-other-parts-of-the-response">Use the response to verify other parts of the response</h2>
<p>You can use data from the response to verify another part of the response. For example consider the following JSON document returned from service x:</p>
<pre><code class="lang-javascript">{ <span class="hljs-string">&quot;userId&quot;</span> : <span class="hljs-string">&quot;some-id&quot;</span>, <span class="hljs-string">&quot;href&quot;</span> : <span class="hljs-string">&quot;http://localhost:8080/some-id&quot;</span> }
</code></pre>
<p>You may notice that the &quot;href&quot; attribute ends with the value of the &quot;userId&quot; attribute. If we want to verify this we can implement a <code>io.restassured.matcher.ResponseAwareMatcher</code> and use it like this:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().body(<span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-keyword">new</span> ResponseAwareMatcher&lt;Response&gt;() {
                                  <span class="hljs-keyword">public</span> Matcher&lt;?&gt; matcher(Response response) {
                                          <span class="hljs-keyword">return</span> equalTo(<span class="hljs-string">&quot;http://localhost:8080/&quot;</span> + response.path(<span class="hljs-string">&quot;userId&quot;</span>));
                                  }
                       });
</code></pre>
<p>If you&apos;re using Java 8 you can use a lambda expression instead:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().body(<span class="hljs-string">&quot;href&quot;</span>, response -&gt; equalTo(<span class="hljs-string">&quot;http://localhost:8080/&quot;</span> + response.path(<span class="hljs-string">&quot;userId&quot;</span>));
</code></pre>
<p>There are some predefined matchers that you can use defined in the <code>io.restassured.matcher.RestAssuredMatchers</code> (or <code>io.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers</code> if using the spring-mock-mvc module). For example:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().body(<span class="hljs-string">&quot;href&quot;</span>, endsWithPath(<span class="hljs-string">&quot;userId&quot;</span>));
</code></pre>
<p><code>ResponseAwareMatchers</code> can also be composed, either with another <code>ResponseAwareMatcher</code> or with a Hamcrest Matcher. For example:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().body(<span class="hljs-string">&quot;href&quot;</span>, and(startsWith(<span class="hljs-string">&quot;http:/localhost:8080/&quot;</span>), endsWithPath(<span class="hljs-string">&quot;userId&quot;</span>)));
</code></pre>
<p>The <code>and</code> method is statically imported from <code>io.restassured.matcher.ResponseAwareMatcherComposer</code>.</p>
<h2 id="measuring-response-time">Measuring Response Time</h2>
<p>As of version 2.8.0 REST Assured has support measuring response time. For example:</p>
<pre><code class="lang-java"><span class="hljs-keyword">long</span> timeInMs = get(<span class="hljs-string">&quot;/lotto&quot;</span>).time()
</code></pre>
<p>or using a specific time unit:</p>
<pre><code class="lang-java"><span class="hljs-keyword">long</span> timeInSeconds = get(<span class="hljs-string">&quot;/lotto&quot;</span>).timeIn(SECONDS);
</code></pre>
<p>where <code>SECONDS</code> is just a standard <code>TimeUnit</code>. You can also validate it using the validation DSL:</p>
<pre><code class="lang-java">when().
      get(<span class="hljs-string">&quot;/lotto&quot;</span>).
then().
      time(lessThan(<span class="hljs-number">2000L</span>)); <span class="hljs-comment">// Milliseconds</span>
</code></pre>
<p>or</p>
<pre><code class="lang-java">when().
      get(<span class="hljs-string">&quot;/lotto&quot;</span>).
then().
      time(lessThan(<span class="hljs-number">2L</span>), SECONDS);
</code></pre>
<p>Please note that response time measurement should be performed when the JVM is hot! (i.e. running a response time measurement when only running a single test will yield erroneous results). Also note that you can only vaguely regard these measurments to correlate with the server request processing time (since the response time will include the HTTP round trip and REST Assured processing time among other things).</p>
<h1 id="authentication">Authentication</h1>
<p>REST assured also supports several authentication schemes, for example OAuth, digest, certificate, form and preemptive basic authentication. You can either set authentication for each request:</p>
<pre><code class="lang-java">given().auth().basic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>). ..
</code></pre>
<p>but you can also define authentication for all requests:</p>
<pre><code class="lang-java">RestAssured.authentication = basic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);
</code></pre>
<p>or you can use a <a href="#specification-re-use">specification</a>.</p>
<h2 id="basic-authentication">Basic Authentication</h2>
<p>There are two types of basic authentication, preemptive and &quot;challenged basic authentication&quot;.</p>
<h3 id="preemptive-basic-authentication">Preemptive Basic Authentication</h3>
<p>This will send the basic authentication credential even before the server gives an unauthorized response in certain situations, thus reducing the overhead of making an additional connection. This is typically what you want to use in most situations unless you&apos;re testing the servers ability to challenge. Example:</p>
<pre><code class="lang-java">given().auth().preemptive().basic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>).when().get(<span class="hljs-string">&quot;/secured/hello&quot;</span>).then().statusCode(<span class="hljs-number">200</span>);
</code></pre>
<h3 id="challenged-basic-authentication">Challenged Basic Authentication</h3>
<p>When using &quot;challenged basic authentication&quot; REST Assured will not supply the credentials unless the server has explicitly asked for it. This means that REST Assured will make an additional request to the server in order to be challenged and then follow up with the same request once more but this time setting the basic credentials in the header.</p>
<pre><code class="lang-java">given().auth().basic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>).when().get(<span class="hljs-string">&quot;/secured/hello&quot;</span>).then().statusCode(<span class="hljs-number">200</span>);
</code></pre>
<h2 id="digest-authentication">Digest Authentication</h2>
<p>Currently only &quot;challenged digest authentication&quot; is supported. Example:</p>
<pre><code class="lang-java">given().auth().digest(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>).when().get(<span class="hljs-string">&quot;/secured&quot;</span>). ..
</code></pre>
<h2 id="form-authentication">Form Authentication</h2>
<p><a href="https://en.wikipedia.org/wiki/Form-based_authentication" target="_blank">Form authentication</a> is very popular on the internet. It&apos;s typically associated with a user filling out his credentials (username and password) on a webpage and then pressing a login button of some sort. A very simple HTML page that provide the basis for form authentication may look like this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;j_spring_security_check&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>User:&amp;nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&apos;text&apos;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&apos;j_username&apos;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&apos;password&apos;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&apos;j_password&apos;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&apos;2&apos;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>I.e. the server expects the user to fill-out the &quot;j_username&quot; and &quot;j_password&quot; input fields and then press &quot;submit&quot; to login. With REST Assured you can test a service protected by form authentication like this:</p>
<pre><code class="lang-java">given().
        auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/formAuth&quot;</span>);
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>While this may work it&apos;s not optimal. What happens when form authentication is used like this in REST Assured an additional request have to made to the server in order to retrieve the webpage with the login details. REST Assured will then try to parse this page and look for two input fields (with username and password) as well as the form action URI. This may work or fail depending on the complexity of the webpage. A better option is to supply the these details when setting up the form authentication. In this case one could do:</p>
<pre><code class="lang-java">given().
        auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, <span class="hljs-keyword">new</span> FormAuthConfig(<span class="hljs-string">&quot;/j_spring_security_check&quot;</span>, <span class="hljs-string">&quot;j_username&quot;</span>, <span class="hljs-string">&quot;j_password&quot;</span>)).
when().
        get(<span class="hljs-string">&quot;/formAuth&quot;</span>);
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>This way REST Assured doesn&apos;t need to make an additional request and parse the webpage. There&apos;s also a predefined FormAuthConfig called <code>springSecurity</code> that you can use if you&apos;re using the default Spring Security properties:</p>
<pre><code class="lang-java">given().
        auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, FormAuthConfig.springSecurity()).
when().
        get(<span class="hljs-string">&quot;/formAuth&quot;</span>);
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<h3 id="csrf">CSRF</h3>
<p>Today it&apos;s common for the server to supply a <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank">CSRF</a> token with the response in order to avoid these kinds of attacks. REST Assured has support for automatically parsing and supplying the CSRF token to the server. In order for this to work REST Assured <em>must</em> make an additional request and parse (parts) of the website.</p>
<p>You can enable CSRF support by doing the following:</p>
<pre><code class="lang-java">given().
        auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, formAuthConfig().withAutoDetectionOfCsrf()).
when().
        get(<span class="hljs-string">&quot;/formAuth&quot;</span>);
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>Now REST Assured will automatically try to detect if the webpage contains a CSRF token. In order to assist REST Assured and make the parsing more robust it&apos;s possible to supply the CSRF field name (here we imagine that we&apos;re using Spring Security default values and thus can make use of the predefined <code>springSecurity</code> FormAuthConfig):</p>
<pre><code class="lang-java">given().
        auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, springSecurity().withCsrfFieldName(<span class="hljs-string">&quot;_csrf&quot;</span>)).
when().
        get(<span class="hljs-string">&quot;/formAuth&quot;</span>);
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>We&apos;ve now told REST Assured to search for the CSRF field name called &quot;_csrf&quot; (which is it both faster and less prone to error).</p>
<p>By default the CSRF value is sent as a form parameter with the request but you can configure to send it as a header instead if that&apos;s required:</p>
<pre><code class="lang-java">given().
        auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, springSecurity().withCsrfFieldName(<span class="hljs-string">&quot;_csrf&quot;</span>).sendCsrfTokenAsHeader()).
when().
        get(<span class="hljs-string">&quot;/formAuth&quot;</span>);
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<h3 id="include-additional-fields-in-form-authentication">Include additional fields in Form Authentication</h3>
<p>Since version 3.1.0 REST Assured can include additional input fields when using form authentication. Just use the <code>FormAuthConfig</code> and specify the additional values to include. For example if you have an html page that looks like this:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>User:&amp;nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;j_username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;j_password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstInputField&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span>/&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;secondInputField&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value2&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>and you&apos;d like to include the value of form parameters <code>firstInputField</code> and <code>secondInputField</code> you can do like this:</p>
<pre><code class="lang-java">given().auth().form(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, formAuthConfig().withAdditionalFields(<span class="hljs-string">&quot;firstInputField&quot;</span>, <span class="hljs-string">&quot;secondInputField&quot;</span>). ..
</code></pre>
<p>REST Assured will automatically parse the HTML page, find the values for the additional fields and include them as form parameters in the login request.</p>
<h2 id="oauth">OAuth</h2>
<p>In order to use OAuth 1 and OAuth 2 (for query parameter signing) you need to add <a href="https://github.com/fernandezpablo85/scribe-java" target="_blank">Scribe</a> to your classpath (if you&apos;re using version 2.1.0 or older of REST Assured then please refer to the <a href="Usage_Legacy#OAuth">legacy</a> documentation). In Maven you can simply add the following dependency:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.scribejava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>scribejava-apis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>If you&apos;re not using Maven <a href="https://github.com/fernandezpablo85/scribe-java/releases" target="_blank">download</a> a Scribe release manually and put it in your classpath.</p>
<h3 id="oauth-1">OAuth 1</h3>
<p>OAuth 1 requires <a href="#oauth">Scribe</a> in the classpath. To use auth 1 authentication you can do:</p>
<pre><code class="lang-java">given().auth().oauth(..). ..
</code></pre>
<h3 id="oauth-2">OAuth 2</h3>
<p>Since version <code>2.5.0</code> you can use OAuth 2 authentication without depending on <a href="#oauth">Scribe</a>:</p>
<pre><code class="lang-java">given().auth().oauth2(accessToken). ..
</code></pre>
<p>This will put the OAuth2 <code>accessToken</code> in a header. To be more explicit you can also do:</p>
<pre><code class="lang-java">given().auth().preemptive().oauth2(accessToken). ..
</code></pre>
<p>There reason why <code>given().auth().oauth2(..)</code> still exists is for backward compatibility (they do the same thing). If you need to provide the OAuth2 token in a query parameter you currently need <a href="#oauth">Scribe</a> in the classpath. Then you can do like this:</p>
<pre><code class="lang-java">given().auth().oauth2(accessToken, OAuthSignature.QUERY_STRING). ..
</code></pre>
<h2 id="custom-authentication">Custom Authentication</h2>
<p>Rest Assured allows you to create custom authentication providers. You do this by implementing the <code>io.restassured.spi.AuthFilter</code> interface (preferably) and apply it as a <a href="#filters">filter</a>. For example let&apos;s say that your security consists of adding together two headers together in a new header called &quot;AUTH&quot; (this is of course not secure). Then you can do that like this (Java 8 syntax):</p>
<pre><code class="lang-java">given().
        filter((requestSpec, responseSpec, ctx) -&gt; {
            String header1 = requestSpec.getHeaders().getValue(<span class="hljs-string">&quot;header1&quot;</span>);
            String header2 = requestSpec.getHeaders().getValue(<span class="hljs-string">&quot;header2&quot;</span>);
            requestSpec.header(<span class="hljs-string">&quot;AUTH&quot;</span>, header1 + header2);
            <span class="hljs-keyword">return</span> ctx.next(requestSpec, responseSpec);
        }).
when().
        get(<span class="hljs-string">&quot;/customAuth&quot;</span>).
then().
  statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>The reason why you want to use a <code>AuthFilter</code> and not <code>Filter</code> is that <code>AuthFilters</code> are automatically removed when doing <code>given().auth().none(). ..</code>.</p>
<h1 id="multi-part-form-data">Multi-part form data</h1>
<p>When sending larger amount of data to the server it&apos;s common to use the multipart form data technique. Rest Assured provide methods called <code>multiPart</code> that allows you to specify a file, byte-array, input stream or text to upload. In its simplest form you can upload a file like this:</p>
<pre><code class="lang-java">given().
        multiPart(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/path/to/file&quot;</span>)).
when().
        post(<span class="hljs-string">&quot;/upload&quot;</span>);
</code></pre>
<p>It will assume a control name called &quot;file&quot;. In HTML the control name is the attribute name of the input tag. To clarify let&apos;s look at the following HTML form:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadForm&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;40&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Upload!&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>The control name in this case is the name of the input tag with name &quot;file&quot;. If you have a different control name then you need to specify it:</p>
<pre><code class="lang-java">given().
        multiPart(<span class="hljs-string">&quot;controlName&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/path/to/file&quot;</span>)).
when().
        post(<span class="hljs-string">&quot;/upload&quot;</span>);
</code></pre>
<p>It&apos;s also possible to supply multiple &quot;multi-parts&quot; entities in the same request:</p>
<pre><code class="lang-java"><span class="hljs-keyword">byte</span>[] someData = ..
given().
        multiPart(<span class="hljs-string">&quot;controlName1&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/path/to/file&quot;</span>)).
        multiPart(<span class="hljs-string">&quot;controlName2&quot;</span>, <span class="hljs-string">&quot;my_file_name.txt&quot;</span>, someData).
        multiPart(<span class="hljs-string">&quot;controlName3&quot;</span>, someJavaObject, <span class="hljs-string">&quot;application/json&quot;</span>).
when().
        post(<span class="hljs-string">&quot;/upload&quot;</span>);
</code></pre>
<p>For more advanced use cases you can make use of the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/builder/MultiPartSpecBuilder.html" target="_blank">MultiPartSpecBuilder</a>. For example:</p>
<pre><code class="lang-java">Greeting greeting = <span class="hljs-keyword">new</span> Greeting();
greeting.setFirstName(<span class="hljs-string">&quot;John&quot;</span>);
greeting.setLastName(<span class="hljs-string">&quot;Doe&quot;</span>);

given().
        multiPart(<span class="hljs-keyword">new</span> MultiPartSpecBuilder(greeting, ObjectMapperType.JACKSON_2)
                .fileName(<span class="hljs-string">&quot;greeting.json&quot;</span>)
                .controlName(<span class="hljs-string">&quot;text&quot;</span>)
                .mimeType(<span class="hljs-string">&quot;application/vnd.custom+json&quot;</span>).build()).
when().
        post(<span class="hljs-string">&quot;/multipart/json&quot;</span>).
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>You can specify, among other things, the default <code>control name</code> and filename using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/MultiPartConfig.html" target="_blank">MultiPartConfig</a>. For example:</p>
<pre><code class="lang-java">given().config(config().multiPartConfig(multiPartConfig().defaultControlName(<span class="hljs-string">&quot;something-else&quot;</span>))). ..
</code></pre>
<p>This will configure the default control name to be &quot;something-else&quot; instead of &quot;file&quot;.</p>
<p>For additional info refer to <a href="http://blog.jayway.com/2011/09/15/multipart-form-data-file-uploading-made-simple-with-rest-assured/" target="_blank">this</a> blog post.</p>
<h1 id="object-mapping">Object Mapping</h1>
<p>REST Assured supports mapping Java objects to and from JSON and XML. For JSON you need to have either Jackson or Gson in the classpath and for XML you need JAXB.</p>
<h2 id="serialization">Serialization</h2>
<p>Let&apos;s say we have the following Java object:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>{
    <span class="hljs-keyword">private</span> String message;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> message;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessage</span><span class="hljs-params">(String message)</span> </span>{
        <span class="hljs-keyword">this</span>.message = message;
    }
}
</code></pre>
<p>and you want to serialize this object to JSON and send it with the request. There are several ways to do this, e.g:</p>
<h3 id="content-type-based-serialization">Content-Type based Serialization</h3>
<pre><code class="lang-java">Message message = <span class="hljs-keyword">new</span> Message();
message.setMessage(<span class="hljs-string">&quot;My messagee&quot;</span>);
given().
       contentType(<span class="hljs-string">&quot;application/json&quot;</span>).
       body(message).
when().
      post(<span class="hljs-string">&quot;/message&quot;</span>);
</code></pre>
<p>In this example REST Assured will serialize the object to JSON since the request content-type is set to &quot;application/json&quot;. It will first try to use Jackson if found in classpath and if not Gson will be used. If you change the content-type to &quot;application/xml&quot; REST Assured will serialize to XML using JAXB. If no content-type is defined REST Assured will try to serialize in the following order:</p>
<ol>
<li>JSON using Jackson 2 (Faster Jackson (databind))</li>
<li>JSON using Jackson (databind)</li>
<li>JSON using Gson</li>
<li>XML using JAXB</li>
</ol>
<p>REST Assured also respects the charset of the content-type. E.g.</p>
<pre><code class="lang-java">Message message = <span class="hljs-keyword">new</span> Message();
message.setMessage(<span class="hljs-string">&quot;My messagee&quot;</span>);
given().
       contentType(<span class="hljs-string">&quot;application/json; charset=UTF-16&quot;</span>).
       body(message).
when().
      post(<span class="hljs-string">&quot;/message&quot;</span>);
</code></pre>
<p>You can also serialize the <code>Message</code> instance as a form parameter:</p>
<pre><code class="lang-java">Message message = <span class="hljs-keyword">new</span> Message();
message.setMessage(<span class="hljs-string">&quot;My messagee&quot;</span>);
given().
       contentType(<span class="hljs-string">&quot;application/json; charset=UTF-16&quot;</span>).
       formParam(<span class="hljs-string">&quot;param1&quot;</span>, message).
when().
      post(<span class="hljs-string">&quot;/message&quot;</span>);
</code></pre>
<p>The message object will be serialized to JSON using Jackson (databind) (if present) or Gson (if present) with UTF-16 encoding.</p>
<h3 id="create-json-from-a-hashmap">Create JSON from a HashMap</h3>
<p>You can also create a JSON document by supplying a Map to REST Assured.</p>
<pre><code class="lang-java">Map&lt;String, Object&gt;  jsonAsMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
jsonAsMap.put(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);
jsonAsMap.put(<span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>);

given().
        contentType(JSON).
        body(jsonAsMap).
when().
        post(<span class="hljs-string">&quot;/somewhere&quot;</span>).
then().
        statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>This will provide a JSON payload as:</p>
<pre><code class="lang-javascript">{ <span class="hljs-string">&quot;firstName&quot;</span> : <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;lastName&quot;</span> : <span class="hljs-string">&quot;Doe&quot;</span> }
</code></pre>
<h3 id="using-an-explicit-serializer">Using an Explicit Serializer</h3>
<p>If you have multiple object mappers in the classpath at the same time or don&apos;t care about setting the content-type you can specify a serializer explicity. E.g.</p>
<pre><code class="lang-java">Message message = <span class="hljs-keyword">new</span> Message();
message.setMessage(<span class="hljs-string">&quot;My messagee&quot;</span>);
given().
       body(message, ObjectMapperType.JAXB).
when().
      post(<span class="hljs-string">&quot;/message&quot;</span>);
</code></pre>
<p>In this example the Message object will be serialized to XML using JAXB.</p>
<h2 id="deserialization">Deserialization</h2>
<p>Again let&apos;s say we have the following Java object:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>{
    <span class="hljs-keyword">private</span> String message;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> message;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessage</span><span class="hljs-params">(String message)</span> </span>{
        <span class="hljs-keyword">this</span>.message = message;
    }
}
</code></pre>
<p>and we want the response body to be deserialized into a Message object.</p>
<h3 id="content-type-based-deserialization">Content-Type based Deserialization</h3>
<p>Let&apos;s assume then that the server returns a JSON body like this:</p>
<pre><code class="lang-javascript">{<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;My message&quot;</span>}
</code></pre>
<p>To deserialize this to a Message object we simply to like this:</p>
<pre><code class="lang-java">Message message = get(<span class="hljs-string">&quot;/message&quot;</span>).as(Message.class);
</code></pre>
<p>For this to work the response content-type must be &quot;application/json&quot; (or something that contains &quot;json&quot;). If the server instead returned</p>
<pre><code class="lang-xml"><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> standalone=<span class="hljs-string">&quot;yes&quot;</span><span class="hljs-meta">?&gt;</span></span>
<span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>My message<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
</code></pre>
<p>and a content-type of &quot;application/xml&quot; you wouldn&apos;t have to change the code at all:</p>
<pre><code class="lang-java">Message message = get(<span class="hljs-string">&quot;/message&quot;</span>).as(Message.class);
</code></pre>
<h4 id="custom-content-type-deserialization">Custom Content-Type Deserialization</h4>
<p>If the server returns a custom content-type, let&apos;s say &quot;application/something&quot;, and you still want to use the object mapping in REST Assured there are a couple of different ways to go about. You can either use the <a href="http://code.google.com/p/rest-assured/wiki/Usage#Using_an_Explicit_Deserializer" target="_blank">explicit</a> approach or register a parser for the custom content-type:</p>
<pre><code class="lang-java">Message message = expect().parser(<span class="hljs-string">&quot;application/something&quot;</span>, Parser.XML).when().get(<span class="hljs-string">&quot;/message&quot;</span>).as(Message.class);
</code></pre>
<p>or</p>
<pre><code class="lang-java">Message message = expect().defaultParser(Parser.XML).when().get(<span class="hljs-string">&quot;/message&quot;</span>).as(Message.class);
</code></pre>
<p>You can also register a default or custom parser <a href="#default-values">statically</a> or using <a href="#specification-re-use">specifications</a>.</p>
<h3 id="using-an-explicit-deserializer">Using an Explicit Deserializer</h3>
<p>If you have multiple object mappers in the classpath at the same time  or don&apos;t care about the response content-type you can specify a deserializer explicitly. E.g.</p>
<pre><code class="lang-java">Message message = get(<span class="hljs-string">&quot;/message&quot;</span>).as(Message.class, ObjectMapperType.GSON);
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>You can configure the pre-defined object mappers by using a <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/ObjectMapperConfig.html" target="_blank">ObjectMapperConfig</a> and pass it to <a href="#detailed-configuration">detailed configuration</a>. For example to change GSON to use lower case with underscores as field naming policy you can do like this:</p>
<pre><code class="lang-java">RestAssured.config = RestAssuredConfig.config().objectMapperConfig(objectMapperConfig().gsonObjectMapperFactory(
                <span class="hljs-keyword">new</span> GsonObjectMapperFactory() {
                    <span class="hljs-function"><span class="hljs-keyword">public</span> Gson <span class="hljs-title">create</span><span class="hljs-params">(Class cls, String charset)</span> </span>{
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GsonBuilder().setFieldNamingPolicy(LOWER_CASE_WITH_UNDERSCORES).create();
                    }
                }
        ));
</code></pre>
<p>There are pre-defined object mapper factories for GSON, JAXB, Jackson and Faster Jackson.</p>
<h2 id="custom">Custom</h2>
<p>By default REST Assured will scan the classpath to find various object mappers. If you want to integrate an object mapper that is not supported by default or if you&apos;ve rolled your own you can implement the
<a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/mapper/ObjectMapper.html" target="_blank">io.restassured.mapper.ObjectMapper</a> interface. You tell REST Assured to use your object mapper either by passing it as a second parameter to the body:</p>
<pre><code class="lang-java">given().body(myJavaObject, myObjectMapper).when().post(<span class="hljs-string">&quot;..&quot;</span>)
</code></pre>
<p>or you can define it statically once and for all:</p>
<pre><code class="lang-java">RestAssured.config = RestAssuredConfig.config().objectMapperConfig(<span class="hljs-keyword">new</span> ObjectMapperConfig(myObjectMapper));
</code></pre>
<p>For an example see <a href="https://github.com/rest-assured/rest-assured/blob/master/examples/rest-assured-itest-java/src/test/java/io/restassured/itest/java/CustomObjectMappingITest.java" target="_blank">here</a>.</p>
<h1 id="custom-parsers">Custom parsers</h1>
<p>REST Assured providers predefined parsers for e.g. HTML, XML and JSON. But you can parse other kinds of content by registering a predefined parser for unsupported content-types by using:</p>
<pre><code class="lang-java">RestAssured.registerParser(&lt;content-type&gt;, &lt;parser&gt;);
</code></pre>
<p>E.g. to register that mime-type &apos;application/vnd.uoml+xml&apos; should be parsed using the XML parser do:</p>
<pre><code class="lang-java">RestAssured.registerParser(<span class="hljs-string">&quot;application/vnd.uoml+xml&quot;</span>, Parser.XML);
</code></pre>
<p>You can also unregister a parser using:</p>
<pre><code class="lang-java">RestAssured.unregisterParser(<span class="hljs-string">&quot;application/vnd.uoml+xml&quot;</span>);
</code></pre>
<p>Parsers can also be specified per &quot;request&quot;:</p>
<pre><code class="lang-java">get(..).then().using().parser(<span class="hljs-string">&quot;application/vnd.uoml+xml&quot;</span>, Parser.XML). ..;
</code></pre>
<p>and using a <a href="sSpecification-re-use">response specification</a>.</p>
<h1 id="default-parser">Default parser</h1>
<p>Sometimes it&apos;s useful to specify a default parser, e.g. if the response doesn&apos;t contain a content-type at all:</p>
<pre><code class="lang-java">RestAssured.defaultParser = Parser.JSON;
</code></pre>
<p>You can also specify a default parser for a single request:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().using().defaultParser(Parser.JSON). ..
</code></pre>
<p>or using a <a href="#specification-re-use">response specification</a>.</p>
<h1 id="default-values">Default values</h1>
<p>By default REST assured assumes host localhost and port 8080 when doing a request. If you want a different port you can do:</p>
<pre><code class="lang-java">given().port(<span class="hljs-number">80</span>). ..
</code></pre>
<p>or simply:</p>
<pre><code class="lang-java">..when().get(<span class="hljs-string">&quot;http://myhost.org:80/doSomething&quot;</span>);
</code></pre>
<p>You can also change the default base URI, base path, port and authentication scheme for all subsequent requests:</p>
<pre><code class="lang-java">RestAssured.baseURI = <span class="hljs-string">&quot;http://myhost.org&quot;</span>;
RestAssured.port = <span class="hljs-number">80</span>;
RestAssured.basePath = <span class="hljs-string">&quot;/resource&quot;</span>;
RestAssured.authentication = basic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);
RestAssured.rootPath = <span class="hljs-string">&quot;x.y.z&quot;</span>;
</code></pre>
<p>This means that a request like e.g. <code>get(&quot;/hello&quot;)</code> goes to: <a href="http://myhost.org:80/resource/hello" target="_blank">http://myhost.org:80/resource/hello</a> with basic authentication credentials &quot;username&quot; and &quot;password&quot;. See <a href="http://code.google.com/p/rest-assured/wiki/Usage#Root_path" target="_blank">rootPath</a> for more info about setting the root paths. Other default values you can specify are:</p>
<pre><code class="lang-java">RestAssured.filters(..); <span class="hljs-comment">// List of default filters</span>
RestAssured.requestSpecification = .. <span class="hljs-comment">// Default request specification</span>
RestAssured.responseSpecification = .. <span class="hljs-comment">// Default response specification</span>
RestAssured.urlEncodingEnabled = .. <span class="hljs-comment">// Specify if Rest Assured should URL encoding the parameters</span>
RestAssured.defaultParser = .. <span class="hljs-comment">// Specify a default parser for response bodies if no registered parser can handle data of the response content-type</span>
RestAssured.registerParser(..) <span class="hljs-comment">// Specify a parser for the given content-type</span>
RestAssured.unregisterParser(..) <span class="hljs-comment">// Unregister a parser for the given content-type</span>
</code></pre>
<p>You can reset to the standard baseURI (localhost), basePath (empty), standard port (8080), standard root path (&quot;&quot;), default authentication scheme (none) and url encoding enabled (true) using:</p>
<pre><code class="lang-java">RestAssured.reset();
</code></pre>
<h1 id="specification-re-use">Specification Re-use</h1>
<p>Instead of having to duplicate response expectations and/or request parameters for different tests you can re-use an entire specification. To do this you define a specification using either the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/builder/RequestSpecBuilder.html" target="_blank">RequestSpecBuilder</a> or <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/builder/ResponseSpecBuilder.html" target="_blank">ResponseSpecBuilder</a>.</p>
<p>E.g. let&apos;s say you want to make sure that the expected status code is 200 and that the size of the JSON array &quot;x.y&quot; has size 2 in several tests you can define a ResponseSpecBuilder like this:</p>
<pre><code class="lang-java">ResponseSpecBuilder builder = <span class="hljs-keyword">new</span> ResponseSpecBuilder();
builder.expectStatusCode(<span class="hljs-number">200</span>);
builder.expectBody(<span class="hljs-string">&quot;x.y.size()&quot;</span>, is(<span class="hljs-number">2</span>));
ResponseSpecification responseSpec = builder.build();

<span class="hljs-comment">// Now you can re-use the &quot;responseSpec&quot; in many different tests:</span>
when().
       get(<span class="hljs-string">&quot;/something&quot;</span>).
then().
       spec(responseSpec).
       body(<span class="hljs-string">&quot;x.y.z&quot;</span>, equalTo(<span class="hljs-string">&quot;something&quot;</span>));
</code></pre>
<p>In this example the data defined in &quot;responseSpec&quot; is merged with the additional body expectation and all expectations must be fulfilled in order for the test to pass.</p>
<p>You can do the same thing if you need to re-use request data in different tests. E.g.</p>
<pre><code class="lang-java">RequestSpecBuilder builder = <span class="hljs-keyword">new</span> RequestSpecBuilder();
builder.addParam(<span class="hljs-string">&quot;parameter1&quot;</span>, <span class="hljs-string">&quot;parameterValue&quot;</span>);
builder.addHeader(<span class="hljs-string">&quot;header1&quot;</span>, <span class="hljs-string">&quot;headerValue&quot;</span>);
RequestSpecification requestSpec = builder.build();

given().
        spec(requestSpec).
        param(<span class="hljs-string">&quot;parameter2&quot;</span>, <span class="hljs-string">&quot;paramValue&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/something&quot;</span>).
then().
        body(<span class="hljs-string">&quot;x.y.z&quot;</span>, equalTo(<span class="hljs-string">&quot;something&quot;</span>));
</code></pre>
<p>Here the request&apos;s data is merged with the data in the &quot;requestSpec&quot; so the request will contain two parameters (&quot;parameter1&quot; and &quot;parameter2&quot;) and one header (&quot;header1&quot;).</p>
<h2 id="querying-requestspecification">Querying RequestSpecification</h2>
<p>Sometimes it&apos;s useful to be able to query/extract values form a RequestSpecification. For this reason you can use the <code>io.restassured.specification.SpecificationQuerier</code>. For example:</p>
<pre><code class="lang-java">RequestSpecification spec = ...
QueryableRequestSpecification queryable = SpecificationQuerier.query(spec);
String headerValue = queryable.getHeaders().getValue(<span class="hljs-string">&quot;header&quot;</span>);
String param = queryable.getFormParams().get(<span class="hljs-string">&quot;someparam&quot;</span>);
</code></pre>
<h1 id="filters">Filters</h1>
<p>A filter allows you to inspect and alter a request before it&apos;s actually committed and also inspect and <a href="#response-builder">alter</a> the response before it&apos;s returned to the expectations. You can regard it as an &quot;around advice&quot; in AOP terms. Filters can be used to implement custom authentication schemes, session management, logging etc. To create a filter you need to implement the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/filter/Filter.html" target="_blank">io.restassured.filter.Filter</a> interface. To use a filter you can do:</p>
<pre><code class="lang-java">given().filter(<span class="hljs-keyword">new</span> MyFilter()). ..
</code></pre>
<p>There are a couple of filters provided by REST Assured that are ready to use:</p>
<ol>
<li><code>io.restassured.filter.log.RequestLoggingFilter</code>: A filter that&apos;ll print the request specification details.</li>
<li><code>io.restassured.filter.log.ResponseLoggingFilter</code>: A filter that&apos;ll print the response details if the response matches a given status code.</li>
<li><code>io.restassured.filter.log.ErrorLoggingFilter</code>: A filter that&apos;ll print the response body if an error occurred (status code is between 400 and 500).</li>
</ol>
<h3 id="ordered-filters">Ordered Filters</h3>
<p>As of REST Assured 3.0.2 you can implement the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/filter/OrderedFilter.html" target="_blank">io.restassured.filter.OrderedFilter</a> interface if you need to control the filter ordering. Here you implement the <code>getOrder</code> method to return an integer representing the precedence of the filter. A lower value gives higher precedence. The highest precedence you can define is <code>Integer.MIN_VALUE</code> and the lowest precedence is <code>Integer.MAX_VALUE</code>. Filters not implementing <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/filter/OrderedFilter.html" target="_blank">io.restassured.filter.OrderedFilter</a> will have a default precedence of <code>1000</code>. Click <a href="https://github.com/rest-assured/rest-assured/blob/master/examples/rest-assured-itest-java/src/test/java/io/restassured/itest/java/OrderedFilterITest.java" target="_blank">here</a> for some examples.</p>
<h3 id="response-builder">Response Builder</h3>
<p>If you need to change the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/response/Response.html" target="_blank">Response</a> from a filter you can use the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/builder/ResponseBuilder.html" target="_blank">ResponseBuilder</a> to create a new Response based on the original response. For example if you want to change the body of the original response to something else you can do:</p>
<pre><code class="lang-java">Response newResponse = <span class="hljs-keyword">new</span> ResponseBuilder().clone(originalResponse).setBody(<span class="hljs-string">&quot;Something&quot;</span>).build();
</code></pre>
<h1 id="logging">Logging</h1>
<p>In many cases it can be useful to print the response and/or request details in order to help you create the correct expectations and send the correct requests. To do help you do this you can use one of the predefined <a href="#filters">filters</a> supplied with REST Assured or you can use one of the shortcuts.</p>
<h2 id="request-logging">Request Logging</h2>
<p>Since version 1.5 REST Assured supports logging the <em><a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/specification/RequestSpecification.html" target="_blank">request specification</a></em> before it&apos;s sent to the server using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/filter/log/RequestLoggingFilter.html" target="_blank">RequestLoggingFilter</a>. Note that the HTTP Builder and HTTP Client may add additional headers then what&apos;s printed in the log. The filter will <em>only</em> log details specified in the request specification. I.e. you can NOT regard the details logged by the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/filter/log/RequestLoggingFilter.html" target="_blank">RequestLoggingFilter</a> to be what&apos;s actually sent to the server. Also subsequent filters may alter the request <em>after</em> the logging has taken place. If you need to log what&apos;s <em>actually</em> sent on the wire refer to the <a href="http://hc.apache.org/httpcomponents-client-ga/logging.html" target="_blank">HTTP Client logging docs</a> or use an external tool such <a href="http://www.wireshark.org/" target="_blank">Wireshark</a>. Examples:</p>
<pre><code class="lang-java">given().log().all(). .. <span class="hljs-comment">// Log all request specification details including parameters, headers and body</span>
given().log().params(). .. <span class="hljs-comment">// Log only the parameters of the request</span>
given().log().body(). .. <span class="hljs-comment">// Log only the request body</span>
given().log().headers(). .. <span class="hljs-comment">// Log only the request headers</span>
given().log().cookies(). .. <span class="hljs-comment">// Log only the request cookies</span>
given().log().method(). .. <span class="hljs-comment">// Log only the request method</span>
given().log().path(). .. <span class="hljs-comment">// Log only the request path</span>
</code></pre>
<h2 id="response-logging">Response Logging</h2>
<p>If you want to print the response body regardless of the status code you can do:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().body() ..
</code></pre>
<p>This will print the response body regardless if an error occurred. If you&apos;re only interested in printing the response body if an error occur then you can use:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().ifError(). ..
</code></pre>
<p>You can also log all details in the response including status line, headers and cookies:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().all(). ..
</code></pre>
<p>as well as only status line, headers or cookies:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().statusLine(). .. <span class="hljs-comment">// Only log the status line</span>
get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().headers(). .. <span class="hljs-comment">// Only log the response headers</span>
get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().cookies(). .. <span class="hljs-comment">// Only log the response cookies</span>
</code></pre>
<p>You can also configure to log the response only if the status code matches some value:</p>
<pre><code class="lang-java">get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().ifStatusCodeIsEqualTo(<span class="hljs-number">302</span>). .. <span class="hljs-comment">// Only log if the status code is equal to 302</span>
get(<span class="hljs-string">&quot;/x&quot;</span>).then().log().ifStatusCodeMatches(matcher). .. <span class="hljs-comment">// Only log if the status code matches the supplied Hamcrest matcher</span>
</code></pre>
<h2 id="log-if-validation-fails">Log if validation fails</h2>
<p>Since REST Assured 2.3.1 you can log the request or response only if the validation fails. To log the request do:</p>
<pre><code class="lang-java">given().log().ifValidationFails(). ..
</code></pre>
<p>To log the response do:</p>
<pre><code class="lang-java">.. .then().log().ifValidationFails(). ..
</code></pre>
<p>It&apos;s also possible to enable this for both the request and the response at the same time using the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/LogConfig.html" target="_blank">LogConfig</a>:</p>
<pre><code class="lang-java">given().config(RestAssured.config().logConfig(logConfig().enableLoggingOfRequestAndResponseIfValidationFails(HEADERS))). ..
</code></pre>
<p>This will log only the headers if validation fails.</p>
<p>There&apos;s also a shortcut for enabling logging of the request and response for all requests if validation fails:</p>
<pre><code class="lang-java">RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
</code></pre>
<h1 id="root-path">Root path</h1>
<p>To avoid duplicated paths in body expectations you can specify a root path. E.g. instead of writing:</p>
<pre><code class="lang-java">when().
         get(<span class="hljs-string">&quot;/something&quot;</span>).
then().
         body(<span class="hljs-string">&quot;x.y.firstName&quot;</span>, is(..)).
         body(<span class="hljs-string">&quot;x.y.lastName&quot;</span>, is(..)).
         body(<span class="hljs-string">&quot;x.y.age&quot;</span>, is(..)).
         body(<span class="hljs-string">&quot;x.y.gender&quot;</span>, is(..));
</code></pre>
<p>you can use a root path and do:</p>
<pre><code class="lang-java">when().
        get(<span class="hljs-string">&quot;/something&quot;</span>).
then().
         root(<span class="hljs-string">&quot;x.y&quot;</span>). <span class="hljs-comment">// You can also use the &quot;root&quot; method</span>
         body(<span class="hljs-string">&quot;firstName&quot;</span>, is(..)).
         body(<span class="hljs-string">&quot;lastName&quot;</span>, is(..)).
         body(<span class="hljs-string">&quot;age&quot;</span>, is(..)).
         body(<span class="hljs-string">&quot;gender&quot;</span>, is(..));
</code></pre>
<p>You can also set a default root path using:</p>
<pre><code class="lang-java">RestAssured.rootPath = <span class="hljs-string">&quot;x.y&quot;</span>;
</code></pre>
<p>In more advanced use cases it may also be useful to append additional root arguments to existing root arguments. To do this you can use the <code>appendRoot</code> method, for example:</p>
<pre><code class="lang-java">when().
         get(<span class="hljs-string">&quot;/jsonStore&quot;</span>).
then().
         root(<span class="hljs-string">&quot;store.%s&quot;</span>, withArgs(<span class="hljs-string">&quot;book&quot;</span>)).
         body(<span class="hljs-string">&quot;category.size()&quot;</span>, equalTo(<span class="hljs-number">4</span>)).
         appendRoot(<span class="hljs-string">&quot;%s.%s&quot;</span>, withArgs(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;size()&quot;</span>)).
         body(withNoArgs(), equalTo(<span class="hljs-number">4</span>));
</code></pre>
<p>It&apos;s also possible to detach a root. For example:</p>
<pre><code class="lang-java">when().
         get(<span class="hljs-string">&quot;/jsonStore&quot;</span>).
then().
         root(<span class="hljs-string">&quot;store.category&quot;</span>).
         body(<span class="hljs-string">&quot;size()&quot;</span>, equalTo(<span class="hljs-number">4</span>)).
         detachRoot(<span class="hljs-string">&quot;category&quot;</span>).
         body(<span class="hljs-string">&quot;size()&quot;</span>, equalTo(<span class="hljs-number">1</span>));
</code></pre>
<h1 id="path-arguments">Path arguments</h1>
<p>Path arguments are useful in situations where you have e.g. pre-defined variables that constitutes the path. For example</p>
<pre><code class="lang-java">String someSubPath = <span class="hljs-string">&quot;else&quot;</span>;
<span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;
get(<span class="hljs-string">&quot;/x&quot;</span>).then().body(<span class="hljs-string">&quot;something.%s[%d]&quot;</span>, withArgs(someSubPath, index), equalTo(<span class="hljs-string">&quot;some value&quot;</span>)). ..
</code></pre>
<p>will expect that the body path &quot;<code>something.else[0]</code>&quot; is equal to &quot;some value&quot;.</p>
<p>Another usage is if you have complex <a href="http://code.google.com/p/rest-assured/wiki/Usage#Root_path" target="_blank">root paths</a> and don&apos;t wish to duplicate the path for small variations:</p>
<pre><code class="lang-java">when().
       get(<span class="hljs-string">&quot;/x&quot;</span>).
then().
       root(<span class="hljs-string">&quot;filters.filterConfig[%d].filterConfigGroups.find { it.name == &apos;GroupName&apos; }.includes&quot;</span>).
       body(withArgs(<span class="hljs-number">0</span>), hasItem(<span class="hljs-string">&quot;first&quot;</span>)).
       body(withArgs(<span class="hljs-number">1</span>), hasItem(<span class="hljs-string">&quot;second&quot;</span>)).
       ..
</code></pre>
<p>The path arguments follows the standard <a href="http://download.oracle.com/javase/1,5.0/docs/api/java/util/Formatter.html#syntax" target="_blank">formatting syntax</a> of Java.</p>
<p>Note that the <code>withArgs</code> method can be statically imported from the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/RestAssured.html" target="_blank">io.restassured.RestAssured</a> class.</p>
<p>Sometimes it&apos;s also useful to validate a body without any additional arguments when all arguments have already been specified in the root path. This is where <code>withNoArgs</code> come into play. For example:</p>
<pre><code class="lang-java">when().
         get(<span class="hljs-string">&quot;/jsonStore&quot;</span>).
then().
         root(<span class="hljs-string">&quot;store.%s&quot;</span>, withArgs(<span class="hljs-string">&quot;book&quot;</span>)).
         body(<span class="hljs-string">&quot;category.size()&quot;</span>, equalTo(<span class="hljs-number">4</span>)).
         appendRoot(<span class="hljs-string">&quot;%s.%s&quot;</span>, withArgs(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;size()&quot;</span>)).
         body(withNoArgs(), equalTo(<span class="hljs-number">4</span>));
</code></pre>
<h1 id="session-support">Session support</h1>
<p>REST Assured provides a simplified way for managing sessions. You can define a session id value in the DSL:</p>
<pre><code class="lang-java">given().sessionId(<span class="hljs-string">&quot;1234&quot;</span>). ..
</code></pre>
<p>This is actually just a short-cut for:</p>
<pre><code class="lang-java">given().cookie(<span class="hljs-string">&quot;JSESSIONID&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>). ..
</code></pre>
<p>You can also specify a default <code>sessionId</code> that&apos;ll be supplied with all subsequent requests:</p>
<pre><code class="lang-java">RestAssured.sessionId = <span class="hljs-string">&quot;1234&quot;</span>;
</code></pre>
<p>By default the session id name is <code>JSESSIONID</code> but you can change it using the <a href="#session-config">SessionConfig</a>:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().sessionConfig(<span class="hljs-keyword">new</span> SessionConfig().sessionIdName(<span class="hljs-string">&quot;phpsessionid&quot;</span>));
</code></pre>
<p>You can also specify a sessionId using the <code>RequestSpecBuilder</code> and reuse it in many tests:</p>
<pre><code class="lang-java">RequestSpecBuilder spec = <span class="hljs-keyword">new</span> RequestSpecBuilder().setSessionId(<span class="hljs-string">&quot;value1&quot;</span>).build();

<span class="hljs-comment">// Make the first request with session id equal to value1</span>
given().spec(spec). .. 
<span class="hljs-comment">// Make the second request with session id equal to value1</span>
given().spec(spec). ..
</code></pre>
<p>It&apos;s also possible to get the session id from the response object:</p>
<pre><code class="lang-java">String sessionId = get(<span class="hljs-string">&quot;/something&quot;</span>).sessionId();
</code></pre>
<h2 id="session-filter">Session Filter</h2>
<p>As of version 2.0.0 you can use a <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/filter/session/SessionFilter.html" target="_blank">session filter</a> to automatically capture and apply the session, for example:</p>
<pre><code class="lang-java">SessionFilter sessionFilter = <span class="hljs-keyword">new</span> SessionFilter();

given().
          auth().form(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>).
          filter(sessionFilter).
when().
          get(<span class="hljs-string">&quot;/formAuth&quot;</span>).
then().
          statusCode(<span class="hljs-number">200</span>);


given().
          filter(sessionFilter). <span class="hljs-comment">// Reuse the same session filter instance to automatically apply the session id from the previous response</span>
when().
          get(<span class="hljs-string">&quot;/x&quot;</span>).
then().
          statusCode(<span class="hljs-number">200</span>);
</code></pre>
<p>To get session id caught by the <code>SessionFilter</code> you can do like this:</p>
<pre><code class="lang-java">String sessionId = sessionFilter.getSessionId();
</code></pre>
<h1 id="ssl">SSL</h1>
<p>In most situations SSL should just work out of the box thanks to the excellent work of HTTP Builder and HTTP Client. There are however some cases where you&apos;ll run into trouble. You may for example run into a SSLPeerUnverifiedException if the server is using an invalid certificate. The easiest way to workaround this is to use &quot;relaxed HTTPs validation&quot;. For example:</p>
<pre><code class="lang-java">given().relaxedHTTPSValidation().when().get(<span class="hljs-string">&quot;https://some_server.com&quot;</span>). ..
</code></pre>
<p>You can also define this statically for all requests:</p>
<pre><code class="lang-java">RestAssured.useRelaxedHTTPSValidation();
</code></pre>
<p>or in a <a href="#specification-re-use">request specification</a>.</p>
<p>This will assume an SSLContext protocol of  <code>SSL</code>. To change to another protocol use an overloaded versionen of  <code>relaxedHTTPSValidation</code>. For example:</p>
<pre><code class="lang-java">given().relaxedHTTPSValidation(<span class="hljs-string">&quot;TLS&quot;</span>).when().get(<span class="hljs-string">&quot;https://some_server.com&quot;</span>). ..
</code></pre>
<p>You can also be more fine-grained and create Java keystore file and use it with REST Assured. It&apos;s not too difficult, first follow the guide <a href="https://github.com/jgritman/httpbuilder/wiki/SSL" target="_blank">here</a> and then use the keystore in Rest Assured like this:</p>
<pre><code class="lang-java">given().keystore(<span class="hljs-string">&quot;/pathToJksInClassPath&quot;</span>, &lt;password&gt;). ..
</code></pre>
<p>or you can specify it for every request:</p>
<pre><code class="lang-java">RestAssured.keystore(<span class="hljs-string">&quot;/pathToJksInClassPath&quot;</span>, &lt;password&gt;);
</code></pre>
<p>You can also define a keystore in a re-usable <a href="http://code.google.com/p/rest-assured/wiki/Usage#Specification_Re-use" target="_blank">specification</a>.</p>
<p>If you already loaded a keystore with a password you can use it as a truststore:</p>
<pre><code class="lang-java">RestAssured.trustStore(keystore);
</code></pre>
<p>You can find a working example <a href="https://github.com/rest-assured/rest-assured/blob/master/examples/rest-assured-itest-java/src/test/java/io/restassured/itest/java/SSLTest.java" target="_blank">here</a>.</p>
<p>For more advanced SSL Configuration refer to the <a href="#ssl-config">SSL Configuration</a> section.</p>
<h2 id="ssl-invalid-hostname">SSL invalid hostname</h2>
<p>If the certificate is specifying an invalid hostname you don&apos;t need to create and import a keystore. As of version <code>2.2.0</code> you can do:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().sslConfig(sslConfig().allowAllHostnames());
</code></pre>
<p>to allow all hostnames for all requests or:</p>
<pre><code class="lang-java">given().config(RestAssured.config().sslConfig(sslConfig().allowAllHostnames()). .. ;
</code></pre>
<p>for a single request.</p>
<p>Note that if you use &quot;relaxed HTTPs validation&quot; then <code>allowAllHostnames</code> is activated by default.</p>
<h1 id="url-encoding">URL Encoding</h1>
<p>Usually you don&apos;t have to think about URL encoding since Rest Assured provides this automatically out of the box. In some cases though it may be useful to turn URL Encoding off. One reason may be that you already the have some parameters encoded before you supply them to Rest Assured. To prevent double URL encoding you need to tell Rest Assured to disable it&apos;s URL encoding. E.g.</p>
<pre><code class="lang-java">String response = given().urlEncodingEnabled(<span class="hljs-keyword">false</span>).get(<span class="hljs-string">&quot;https://jira.atlassian.com:443/rest/api/2.0.alpha1/search?jql=project%20=%20BAM%20AND%20issuetype%20=%20Bug&quot;</span>).asString();
..
</code></pre>
<p>or</p>
<pre><code class="lang-java">RestAssured.baseURI = <span class="hljs-string">&quot;https://jira.atlassian.com&quot;</span>;
RestAssured.port = <span class="hljs-number">443</span>;
RestAssured.urlEncodingEnabled = <span class="hljs-keyword">false</span>;
<span class="hljs-keyword">final</span> String query = <span class="hljs-string">&quot;project%20=%20BAM%20AND%20issuetype%20=%20Bug&quot;</span>;
String response = get(<span class="hljs-string">&quot;/rest/api/2.0.alpha1/search?jql={q}&quot;</span>, query);
..
</code></pre>
<h1 id="proxy-configuration">Proxy Configuration</h1>
<p>Starting from version 2.3.2 REST Assured has better support for proxies. For example if you have a proxy at localhost port 8888 you can do:</p>
<pre><code class="lang-java">given().proxy(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>). ..
</code></pre>
<p>Actually you don&apos;t even have to specify the hostname if the server is running on your local environment:</p>
<pre><code class="lang-java">given().proxy(<span class="hljs-number">8888</span>). .. <span class="hljs-comment">// Will assume localhost</span>
</code></pre>
<p>To use HTTPS you need to supply a third parameter (scheme) or use the <code>io.restassured.specification.ProxySpecification</code>. For example:</p>
<pre><code class="lang-java">given().proxy(host(<span class="hljs-string">&quot;localhost&quot;</span>).withScheme(<span class="hljs-string">&quot;https&quot;</span>)). ..
</code></pre>
<p>where <code>host</code> is statically imported from <code>io.restassured.specification.ProxySpecification</code>.</p>
<p>Starting from version 2.7.0 you can also specify preemptive basic authentication for proxies. For example:</p>
<pre><code>given().proxy(auth(&quot;username&quot;, &quot;password&quot;)).when() ..
</code></pre><p>where <code>auth</code> is statically imported from <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/specification/ProxySpecification.html" target="_blank">io.restassured.specification.ProxySpecification</a>. You can of course also combine authentication with a different host:</p>
<pre><code class="lang-java">given().proxy(host(<span class="hljs-string">&quot;http://myhost.org&quot;</span>).withAuth(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)). ..
</code></pre>
<h2 id="static-proxy-configuration">Static Proxy Configuration</h2>
<p>It&apos;s also possible to configure a proxy statically for all requests, for example:</p>
<pre><code class="lang-java">RestAssured.proxy(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);
</code></pre>
<p>or:</p>
<pre><code class="lang-java">RestAssured.proxy = host(<span class="hljs-string">&quot;localhost&quot;</span>).withPort(<span class="hljs-number">8888</span>);
</code></pre>
<h2 id="request-specification-proxy-configuration">Request Specification Proxy Configuration</h2>
<p>You can also create a request specification and specify the proxy there:</p>
<pre><code class="lang-java">RequestSpecification specification = <span class="hljs-keyword">new</span> RequestSpecBuilder().setProxy(<span class="hljs-string">&quot;localhost&quot;</span>).build();
given().spec(specification). ..
</code></pre>
<h1 id="detailed-configuration">Detailed configuration</h1>
<p>Detailed configuration is provided by the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/RestAssuredConfig.html" target="_blank">RestAssuredConfig</a> instance with which you can configure the parameters of <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/HttpClientConfig.html" target="_blank">HTTP Client</a> as well as <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/RedirectConfig.html" target="_blank">Redirect</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/LogConfig.html" target="_blank">Log</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/EncoderConfig.html" target="_blank">Encoder</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/DecoderConfig.html" target="_blank">Decoder</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/SessionConfig.html" target="_blank">Session</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/ObjectMapperConfig.html" target="_blank">ObjectMapper</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/ConnectionConfig.html" target="_blank">Connection</a>, <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/SSLConfig.html" target="_blank">SSL</a> and <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/ParamConfig.html" target="_blank">ParamConfig</a> settings. Examples:</p>
<p>For a specific request:</p>
<pre><code class="lang-java">given().config(RestAssured.config().redirect(redirectConfig().followRedirects(<span class="hljs-keyword">false</span>))). ..
</code></pre>
<p>or using a RequestSpecBuilder:</p>
<pre><code class="lang-java">RequestSpecification spec = <span class="hljs-keyword">new</span> RequestSpecBuilder().setConfig(RestAssured.config().redirect(redirectConfig().followRedirects(<span class="hljs-keyword">false</span>))).build();
</code></pre>
<p>or for all requests:</p>
<pre><code class="lang-java">RestAssured.config = config().redirect(redirectConfig().followRedirects(<span class="hljs-keyword">true</span>).and().maxRedirects(<span class="hljs-number">0</span>));
</code></pre>
<p><code>config()</code> and <code>newConfig()</code> can be statically imported from <code>io.restassured.config.RestAssuredConfig</code>.</p>
<h2 id="encoder-config">Encoder Config</h2>
<p>With the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/EncoderConfig.html" target="_blank">EncoderConfig</a> you can specify the default content encoding charset (if it&apos;s not specified in the content-type header) and query parameter charset for all requests. If no content charset is specified then ISO-8859-1 is used and if no query parameter charset is specified then UTF-8 is used. Usage example:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().encoderConfig(encoderConfig().defaultContentCharset(<span class="hljs-string">&quot;US-ASCII&quot;</span>));
</code></pre>
<p>You can also specify which encoder charset to use for a specific content-type if no charset is defined explicitly for this content-type by using the <code>defaultCharsetForContentType</code> method in the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/EncoderConfig.html" target="_blank">EncoderConfig</a>. For example:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config(config().encoderConfig(encoderConfig().defaultCharsetForContentType(<span class="hljs-string">&quot;UTF-16&quot;</span>, <span class="hljs-string">&quot;application/xml&quot;</span>)));
</code></pre>
<p>This will assume UTF-16 encoding for &quot;application/xml&quot; content-types that does explicitly specify a charset. By default &quot;application/json&quot; is specified to use &quot;UTF-8&quot; as default content-type as this is specified by <a href="https://www.ietf.org/rfc/rfc4627.txt" target="_blank">RFC4627</a>.</p>
<h3 id="avoid-adding-the-charset-to-content-type-header-automatically">Avoid adding the charset to content-type header automatically</h3>
<p>By default REST Assured adds the charset header automatically. To disable this completely you can configure the <code>EncoderConfig</code> like this:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config(config().encoderConfig(encoderConfig().appendDefaultContentCharsetToContentTypeIfUndefined(<span class="hljs-keyword">false</span>));
</code></pre>
<h2 id="decoder-config">Decoder Config</h2>
<p>With the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/DecoderConfig.html" target="_blank">DecoderConfig</a> you can set the default response content decoding charset for all responses. This is useful if you expect a different content charset than ISO-8859-1 (which is the default charset) and the response doesn&apos;t define the charset in the content-type header. Usage example:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().decoderConfig(decoderConfig().defaultContentCharset(<span class="hljs-string">&quot;UTF-8&quot;</span>));
</code></pre>
<p>You can also use the <code>DecoderConfig</code> to specify which content decoders to apply. When you do this the <code>Accept-Encoding</code> header will be added automatically to the request and the response body will be decoded automatically. By default GZIP and DEFLATE decoders are enabled. To for example to remove GZIP decoding but retain DEFLATE decoding you can do the following:</p>
<pre><code class="lang-java">given().config(RestAssured.config().decoderConfig(decoderConfig().contentDecoders(DEFLATE))). ..
</code></pre>
<p>You can also specify which decoder charset to use for a specific content-type if no charset is defined explicitly for this content-type by using the &quot;defaultCharsetForContentType&quot; method in the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/DecoderConfig.html" target="_blank">DecoderConfig</a>. For example:</p>
<pre><code class="lang-java">RestAssured.config = config(config().decoderConfig(decoderConfig().defaultCharsetForContentType(<span class="hljs-string">&quot;UTF-16&quot;</span>, <span class="hljs-string">&quot;application/xml&quot;</span>)));
</code></pre>
<p>This will assume UTF-16 encoding for &quot;application/xml&quot; content-types that does explicitly specify a charset. By default &quot;application/json&quot; is using &quot;UTF-8&quot; as default charset as this is specified by <a href="https://www.ietf.org/rfc/rfc4627.txt" target="_blank">RFC4627</a>.</p>
<h2 id="session-config">Session Config</h2>
<p>With the session config you can configure the default session id name that&apos;s used by REST Assured. The default session id name is <code>JSESSIONID</code> and you only need to change it if the name in your application is different and you want to make use of REST Assured&apos;s <a href="#Session_support">session support</a>. Usage:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().sessionConfig(<span class="hljs-keyword">new</span> SessionConfig().sessionIdName(<span class="hljs-string">&quot;phpsessionid&quot;</span>));
</code></pre>
<h2 id="redirect-dsl">Redirect DSL</h2>
<p>Redirect configuration can also be specified using the DSL. E.g.</p>
<pre><code class="lang-java">given().redirects().max(<span class="hljs-number">12</span>).and().redirects().follow(<span class="hljs-keyword">true</span>).when(). ..
</code></pre>
<h2 id="connection-config">Connection Config</h2>
<p>Lets you configure connection settings for REST Assured. For example if you want to force-close the Apache HTTP Client connection after each response. You may want to do this if you make a lot of fast consecutive requests with small amount of data in the response. However if you&apos;re downloading (especially large amounts of) chunked data you must not close connections after each response. By default connections are <em>not</em> closed after each response.</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().connectionConfig(connectionConfig().closeIdleConnectionsAfterEachResponse());
</code></pre>
<h2 id="json-config">Json Config</h2>
<p><a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/path/json/config/JsonPathConfig.html" target="_blank">JsonPathConfig</a> allows you to configure the Json settings either when used by REST Assured or by <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/path/json/JsonPath.html" target="_blank">JsonPath</a>. It let&apos;s you configure how JSON numbers should be treated.</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().jsonConfig(jsonConfig().numberReturnType(NumberReturnType.BIG_DECIMAL))
</code></pre>
<h2 id="http-client-config">HTTP Client Config</h2>
<p>Let&apos;s you configure properties for the HTTP Client instance that REST Assured will be using when executing requests. By default REST Assured creates a new instance of http client for each &quot;given&quot; statement. To configure reuse do the following:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().httpClient(httpClientConfig().reuseHttpClientInstance());
</code></pre>
<p>You can also supply a custom HTTP Client instance by using the <code>httpClientFactory</code> method, for example:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().httpClient(httpClientConfig().httpClientFactory(
         <span class="hljs-keyword">new</span> HttpClientConfig.HttpClientFactory() {

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> HttpClient <span class="hljs-title">createHttpClient</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemDefaultHttpClient();
            }
        }));
</code></pre>
<p><strong>Note that currently you need to supply an instance of <code>AbstractHttpClient</code>.</strong></p>
<p>It&apos;s also possible to configure default parameters etc.</p>
<h2 id="ssl-config">SSL Config</h2>
<p>The <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/SSLConfig.html" target="_blank">SSLConfig</a> allows you to specify more advanced SSL configuration such as truststore, keystore type and host name verifier. For example:</p>
<pre><code class="lang-java">RestAssured.config = RestAssured.config().sslConfig(sslConfig().with().keystoreType(&lt;type&gt;).and().strictHostnames());
</code></pre>
<h2 id="param-config">Param Config</h2>
<p><a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/config/ParamConfig.html" target="_blank">ParamConfig</a> allows you to configure how different parameter types should be updated on &quot;collision&quot;. By default all parameters are merged so if you do:</p>
<pre><code class="lang-java">given().queryParam(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>).queryParam(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>).when().get(<span class="hljs-string">&quot;/x&quot;</span>). ...
</code></pre>
<p>REST Assured will send a query string of <code>param1=value1&amp;param1=value2</code>. This is not always what you want though so you can configure REST Assured to <em>replace</em> values instead:</p>
<pre><code class="lang-java">given().
        config(config().paramConfig(paramConfig().queryParamsUpdateStrategy(REPLACE))).
        queryParam(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>).
        queryParam(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/x&quot;</span>). ..
</code></pre>
<p>REST Assured will now replace <code>param1</code> with <code>value2</code> (since it&apos;s written last) instead of merging them together. You can also configure the update strategy for each type of for all parameter types instead of doing it per individual basis:</p>
<pre><code class="lang-java">given().config(config().paramConfig(paramConfig().replaceAllParameters())). ..
</code></pre>
<p>This is also supported in the <a href="#spring-mock-mvc-module">Spring Mock Mvc Module</a> (but the config there is called <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/config/MockMvcParamConfig.html" target="_blank">MockMvcParamConfig</a>.</p>
<h1 id="spring-mock-mvc-module">Spring Mock Mvc Module</h1>
<p>REST Assured 2.2.0 introduced support for <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html" target="_blank">Spring Mock Mvc</a> using the <code>spring-mock-mvc</code> module. This means that you can unit test Spring Mvc Controllers. For example given the following Spring controller:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingController</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String template = <span class="hljs-string">&quot;Hello, %s!&quot;</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong counter = <span class="hljs-keyword">new</span> AtomicLong();

    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">&quot;/greeting&quot;</span>, method = GET)
    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-function">Greeting <span class="hljs-title">greeting</span><span class="hljs-params">(
            @RequestParam(value=<span class="hljs-string">&quot;name&quot;</span>, required=<span class="hljs-keyword">false</span>, defaultValue=<span class="hljs-string">&quot;World&quot;</span>)</span> String name) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, name));
    }
}
</code></pre>
<p>you can test it using <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/RestAssuredMockMvc.html" target="_blank">RestAssuredMockMvc</a> like this:</p>
<pre><code class="lang-java">given().
        standaloneSetup(<span class="hljs-keyword">new</span> GreetingController()).
        param(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Johan&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/greeting&quot;</span>).
then().
        statusCode(<span class="hljs-number">200</span>).
        body(<span class="hljs-string">&quot;id&quot;</span>, equalTo(<span class="hljs-number">1</span>)).
        body(<span class="hljs-string">&quot;content&quot;</span>, equalTo(<span class="hljs-string">&quot;Hello, Johan!&quot;</span>));
</code></pre>
<p>i.e. it&apos;s very similar to the standard REST Assured syntax. This makes it really fast to run your tests and it&apos;s also easier to bootstrap the environment and use mocks (if needed) than standard REST Assured. Most things that you&apos;re used to in standard REST Assured works with RestAssured Mock Mvc as well. For example (certain) configuration, static specifications, logging etc etc. To use it you need to depend on the Spring Mock Mvc module:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.rest-assured<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-mock-mvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>Or <a href="http://dl.bintray.com/johanhaleby/generic/spring-mock-mvc-3.1.0-dist.zip" target="_blank">download</a> it from the download page if you&apos;re not using Maven.</p>
<h2 id="bootstrapping-restassuredmockmvc">Bootstrapping RestAssuredMockMvc</h2>
<p>First of all you should statically import methods in:</p>
<pre><code class="lang-java">io.restassured.module.mockmvc.RestAssuredMockMvc.*
io.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers.*
</code></pre>
<p>instead of those defined in</p>
<pre><code class="lang-java">io.restassured.RestAssured.*
io.restassured.matcher.RestAssuredMatchers.*
</code></pre>
<p>Refer to <a href="#static-imports">static import</a> section of the documentation for additional static imports.</p>
<p>In order to start a test using RestAssuredMockMvc you need to initialize it with a either a set of Controllers, a MockMvc instance or a WebApplicationContext from Spring. You can do this for a single request as seen in the previous example:</p>
<pre><code class="lang-java">given().standaloneSetup(<span class="hljs-keyword">new</span> GreetingController()). ..
</code></pre>
<p>or you can do it statically:</p>
<pre><code class="lang-java">RestAssuredMockMvc.standaloneSetup(<span class="hljs-keyword">new</span> GreetingController());
</code></pre>
<p>If defined statically you don&apos;t have to specify any Controllers (or MockMvc or WebApplicationContext instance) in the DSL. This means that the previous example can be written as:</p>
<pre><code class="lang-java">given().
        param(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Johan&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/greeting&quot;</span>).
then().
        statusCode(<span class="hljs-number">200</span>).
        body(<span class="hljs-string">&quot;id&quot;</span>, equalTo(<span class="hljs-number">1</span>)).
        body(<span class="hljs-string">&quot;content&quot;</span>, equalTo(<span class="hljs-string">&quot;Hello, Johan!&quot;</span>));
</code></pre>
<h2 id="asynchronous-requests">Asynchronous Requests</h2>
<p>As of version <code>2.5.0</code> RestAssuredMockMvc has support for asynchronous requests. For example let&apos;s say you have the following controller:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostAsyncController</span> </span>{

    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">&quot;/stringBody&quot;</span>, method = POST)
    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function">Callable&lt;String&gt; <span class="hljs-title">stringBody</span><span class="hljs-params">(<span class="hljs-keyword">final</span> @RequestBody String body)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Callable&lt;String&gt;() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
                <span class="hljs-keyword">return</span> body;
            }
        };
    }
}
</code></pre>
<p>You can test this like so:</p>
<pre><code class="lang-java">given().
        body(<span class="hljs-string">&quot;a string&quot;</span>).
when().
        async().post(<span class="hljs-string">&quot;/stringBody&quot;</span>).
then().
        body(equalTo(<span class="hljs-string">&quot;a string&quot;</span>));
</code></pre>
<p>This will use the default timeout of 1 second. You can change the timeout by using the DSL:</p>
<pre><code class="lang-java">given().
        body(<span class="hljs-string">&quot;a string&quot;</span>).
when().
        async().with().timeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS).post(<span class="hljs-string">&quot;/stringBody&quot;</span>).
then().
        body(equalTo(<span class="hljs-string">&quot;a string&quot;</span>));
</code></pre>
<p>It&apos;s also possible to configure a default timeout by using the <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/2.4.1/io/restassured/module/mockmvc/config/AsyncConfig.html" target="_blank">AsyncConfig</a>, for example:</p>
<pre><code class="lang-java">given().
        config(config().asyncConfig(withTimeout(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS))).
        body(<span class="hljs-string">&quot;a string&quot;</span>).
when().
        async().post(<span class="hljs-string">&quot;/stringBody&quot;</span>).
then().
        body(equalTo(<span class="hljs-string">&quot;a string&quot;</span>));
</code></pre>
<p><code>withTimeout</code> is statically imported from <code>io.restassured.module.mockmvc.config.AsyncConfig</code> and is just a shortcut for creating an <code>AsyncConfig</code> with a given timeout. Apply the config globally to apply to all requests:</p>
<pre><code class="lang-java">RestAssuredMockMvc.config = RestAssuredMockMvc.config().asyncConfig(withTimeout(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS));

<span class="hljs-comment">// Request 1</span>
given().
        body(<span class="hljs-string">&quot;a string&quot;</span>).
when().
        async().post(<span class="hljs-string">&quot;/stringBody&quot;</span>).
then().
        body(equalTo(<span class="hljs-string">&quot;a string&quot;</span>));

<span class="hljs-comment">// Request 2</span>
given().
        body(<span class="hljs-string">&quot;another string&quot;</span>).
when().
        async().post(<span class="hljs-string">&quot;/stringBody&quot;</span>).
then().
        body(equalTo(<span class="hljs-string">&quot;a string&quot;</span>));
</code></pre>
<p>Both request 1 and 2 will now use the default timeout of 100 milliseconds.</p>
<h2 id="adding-request-post-processors">Adding Request Post Processors</h2>
<p>Spring MockMvc has support for <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/request/RequestPostProcessor.html" target="_blank">Request Post Processors</a> and you can use these in RestAssuredMockMvc as well. For example:</p>
<pre><code class="lang-java">given().postProcessors(myPostProcessor1, myPostProcessor2). ..
</code></pre>
<p>Note that it&apos;s recommended the add <code>RequestPostProcessors</code> from <code>org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors</code> (i.e. authentication <code>RequestPostProcessors</code>) to <code>auth</code> instead for better readability (result will be the same):</p>
<pre><code class="lang-java">given().auth().with(httpBasic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)). ..
</code></pre>
<p>where httpBasic is statically imported from <a href="http://docs.spring.io/autorepo/docs/spring-security/current/apidocs/org/springframework/security/test/web/servlet/request/SecurityMockMvcRequestPostProcessors.html" target="_blank">SecurityMockMvcRequestPostProcessor</a>.</p>
<h2 id="adding-result-handlers">Adding Result Handlers</h2>
<p>Spring MockMvc has support for <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/ResultHandler.html" target="_blank">Result Handlers</a> and you can use these in RestAssuredMockMvc as well. For example let&apos;s say you want to use the native MockMvc logging:</p>
<pre><code class="lang-java">.. .then().apply(print()). ..
</code></pre>
<p>where <code>print</code> is statically imported from <code>org.springframework.test.web.servlet.result.MockMvcResultHandlers</code>. Note that if you&apos;re using REST Assured 2.6.0 or older you used the <code>resultHandlers</code> method:</p>
<pre><code class="lang-java">given().resultHandlers(print()). ..
</code></pre>
<p>but this was deprected in REST Assured 2.8.0.</p>
<h2 id="using-result-matchers">Using Result Matchers</h2>
<p>Spring MockMvc provides a bunch of <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/ResultMatcher.html" target="_blank">Result Matchers</a> that you may find useful. RestAssuredMockMvc has support for these as well if needed. For example let&apos;s say that for some reason you want to verify that the status code is equal to 200 using a ResultMatcher:</p>
<pre><code class="lang-java">given().
        param(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Johan&quot;</span>).
when().
        get(<span class="hljs-string">&quot;/greeting&quot;</span>).
then().
        assertThat(status().isOk()).
        body(<span class="hljs-string">&quot;id&quot;</span>, equalTo(<span class="hljs-number">1</span>)).
        body(<span class="hljs-string">&quot;content&quot;</span>, equalTo(<span class="hljs-string">&quot;Hello, Johan!&quot;</span>));
</code></pre>
<p>where <code>status</code> is statically imported from <code>org.springframework.test.web.servlet.result.MockMvcResultMatchers</code>. Note that you can also use the <code>expect</code> method which is the same as <code>assertThat</code> but more close to the syntax of native MockMvc.</p>
<h2 id="interceptors">Interceptors</h2>
<p>For more advanced use cases you can also get ahold of and modify the <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockHttpServletRequestBuilder.html" target="_blank">MockHttpServletRequestBuilder</a> before the request is performed. To do this define a <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/intercept/MockHttpServletRequestBuilderInterceptor.html" target="_blank">MockHttpServletRequestBuilderInterceptor</a> and use it with RestAssuredMockMvc:</p>
<pre><code class="lang-java">given().interceptor(myInterceptor). ..
</code></pre>
<h2 id="specifications">Specifications</h2>
<p>Just as with standard Rest Assured you can use <a href="#specification_re-use">specifications</a> to allow for better re-use. Note that the request specification builder for RestAssuredMockMvc is called <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.html" target="_blank">MockMvcRequestSpecBuilder</a>. The same <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/builder/ResponseSpecBuilder.html" target="_blank">ResponseSpecBuilder</a> can be used in RestAssuredMockMvc as well though. Specifications can be defined statically as well just as with standard Rest Assured. For example:</p>
<pre><code class="lang-java">RestAssuredMockMvc.requestSpecification = <span class="hljs-keyword">new</span> MockMvcRequestSpecBuilder().addQueryParam(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Johan&quot;</span>).build();
RestAssuredMockMvc.responseSpecification = <span class="hljs-keyword">new</span> ResponseSpecBuilder().expectStatusCode(<span class="hljs-number">200</span>).expectBody(<span class="hljs-string">&quot;content&quot;</span>, equalTo(<span class="hljs-string">&quot;Hello, Johan!&quot;</span>)).build();

given().
        standaloneSetup(<span class="hljs-keyword">new</span> GreetingController()).
when().
        get(<span class="hljs-string">&quot;/greeting&quot;</span>).
then().
        body(<span class="hljs-string">&quot;id&quot;</span>, equalTo(<span class="hljs-number">1</span>));
</code></pre>
<h2 id="resetting-restassuredmockmvc">Resetting RestAssuredMockMvc</h2>
<p>If you&apos;ve used any static configuration you can easily reset RestAssuredMockMvc to its default state by callin the <code>RestAssuredMockMvc.reset()</code> method.</p>
<h2 id="spring-mvc-authentication">Spring MVC Authentication</h2>
<p>Version <code>2.3.0</code> of <code>spring-mock-mvc</code> supports authentication. For example:</p>
<pre><code class="lang-java">given().auth().principal(..). ..
</code></pre>
<p>Some authentication methods require Spring Security to be on the classpath (optional). It&apos;s also possible to define authentication statically:</p>
<pre><code class="lang-java">RestAssuredMockMvc.authentication = principal(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);
</code></pre>
<p>where the <code>principal</code> method is statically imported from <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/RestAssuredMockMvc.html" target="_blank">RestAssuredMockMvc</a>. It&apos;s also possible to define an authentication scheme in a request builder:</p>
<pre><code class="lang-java">MockMvcRequestSpecification spec = <span class="hljs-keyword">new</span> MockMvcRequestSpecBuilder.setAuth(principal(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)).build();
</code></pre>
<h3 id="using-spring-security-test">Using Spring Security Test</h3>
<p>Since version <code>2.5.0</code> there&apos;s also better support for Spring Security. If you have <code>spring-security-test</code> in classpath you can do for example:</p>
<pre><code class="lang-java">given().auth().with(httpBasic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)). ..
</code></pre>
<p>where <code>httpBasic</code> is statically imported from <a href="http://docs.spring.io/autorepo/docs/spring-security/current/apidocs/org/springframework/security/test/web/servlet/request/SecurityMockMvcRequestPostProcessors.html" target="_blank">SecurityMockMvcRequestPostProcessor</a>. This will apply basic authentication to the request. For this to work you need apply the <a href="http://docs.spring.io/autorepo/docs/spring-security/current/apidocs/org/springframework/security/test/web/servlet/setup/SecurityMockMvcConfigurers.html" target="_blank">SecurityMockMvcConfigurer</a> to the MockMvc instance. You can either do this manually:</p>
<pre><code class="lang-java">MockMvc mvc = MockMvcBuilders.webAppContextSetup(context).apply(SecurityMockMvcConfigurers.springSecurity()).build();
</code></pre>
<p>or RESTAssuredMockMvc will automatically try to apply the <code>springSecurity</code> configurer automatically if you initalize it with an instance of <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/setup/AbstractMockMvcBuilder.html" target="_blank">AbstractMockMvcBuilder</a>, for example when configuring a &quot;web app context&quot;:</p>
<pre><code class="lang-java">given().webAppContextSetup(context).auth().with(httpBasic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)). ..
</code></pre>
<p>Here&apos;s a full example:</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> io.restassured.module.mockmvc.RestAssuredMockMvc;
<span class="hljs-keyword">import</span> org.junit.After;
<span class="hljs-keyword">import</span> org.junit.Before;
<span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> org.junit.runner.RunWith;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;
<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
<span class="hljs-keyword">import</span> org.springframework.test.context.web.WebAppConfiguration;
<span class="hljs-keyword">import</span> org.springframework.web.context.WebApplicationContext;

<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.restassured.module.mockmvc.RestAssuredMockMvc.given;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.httpBasic;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.authenticated;

<span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner.class)
<span class="hljs-meta">@ContextConfiguration</span>(classes = MyConfiguration.class)
<span class="hljs-meta">@WebAppConfiguration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicAuthExample</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> WebApplicationContext context;

    <span class="hljs-meta">@Before</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
    <span class="hljs-title">rest_assured_is_initialized_with_the_web_application_context_before_each_test</span><span class="hljs-params">()</span> </span>{
        RestAssuredMockMvc.webAppContextSetup(context);
    }

    <span class="hljs-meta">@After</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
    <span class="hljs-title">rest_assured_is_reset_after_each_test</span><span class="hljs-params">()</span> </span>{
        RestAssuredMockMvc.reset();
    }

    <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
    <span class="hljs-title">basic_auth_example</span><span class="hljs-params">()</span> </span>{
        given().
                auth().with(httpBasic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)).
        when().
                get(<span class="hljs-string">&quot;/secured/x&quot;</span>).
        then().
                statusCode(<span class="hljs-number">200</span>).
                expect(authenticated().withUsername(<span class="hljs-string">&quot;username&quot;</span>));
    }
}
</code></pre>
<p>You can also define authentication for all request, for example:</p>
<pre><code class="lang-java">RestAssuredMockMvc.authentication = with(httpBasic(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>));
</code></pre>
<p>where <code>with</code> is statically imported from <code>io.restassured.module.mockmvc.RestAssuredMockMvc</code>. It&apos;s also possible to use a <a href="#specifications">request specification</a>.</p>
<h3 id="injecting-a-user">Injecting a User</h3>
<p>It&apos;s also possible use to of Spring Security test annotations such as <a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#test-method-withmockuser" target="_blank">@WithMockUser</a> and <a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#test-method-withuserdetails" target="_blank">@WithUserDetails</a>. For example let&apos;s say you want to test this controller:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAwareController</span> </span>{

    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">&quot;/user-aware&quot;</span>, method = GET)
    <span class="hljs-keyword">public</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function">String <span class="hljs-title">userAware</span><span class="hljs-params">(@AuthenticationPrincipal User user)</span> </span>{
        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span> || !user.getUsername().equals(<span class="hljs-string">&quot;authorized_user&quot;</span>)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Not authorized&quot;</span>);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success&quot;</span>);
    }
}
</code></pre>
<p>As you can see the <code>userAware</code> method takes a <a href="http://docs.spring.io/autorepo/docs/spring-security/current/apidocs/org/springframework/security/core/userdetails/User.html" target="_blank">User</a> as argument and we let Spring Security inject it by using the <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/bind/annotation/AuthenticationPrincipal.html" target="_blank">@AuthenticationPrincipal</a> annotation. To generate a test user we could do like this:</p>
<pre><code class="lang-java"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">&quot;authorized_user&quot;</span>)
<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">spring_security_mock_annotations_example</span><span class="hljs-params">()</span> </span>{
    given().
            webAppContextSetup(context).
     when().
            get(<span class="hljs-string">&quot;/user-aware&quot;</span>).
     then().
            statusCode(<span class="hljs-number">200</span>).
            body(equalTo(<span class="hljs-string">&quot;Success&quot;</span>)).
            expect(authenticated().withUsername(<span class="hljs-string">&quot;authorized_user&quot;</span>));
}
</code></pre>
<p>Note that it&apos;s also possible to not use annotations and instead use a <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/request/RequestPostProcessor.html" target="_blank">RequestPostProcessor</a> such as <a href="http://docs.spring.io/autorepo/docs/spring-security/4.0.0.RELEASE/apidocs/org/springframework/security/test/web/servlet/request/SecurityMockMvcRequestPostProcessors.html#user(java.lang.String" target="_blank">SecurityMockMvcRequestPostProcessors#user(java.lang.String)</a>).</p>
<h2 id="note-on-parameters">Note on parameters</h2>
<p>MockMvc doesn&apos;t differentiate between different kinds of parameters so <code>param</code>, <code>formParam</code> and <code>queryParam</code> currently just delegates to param in MockMvc. <code>formParam</code> adds the <code>application/x-www-form-urlencoded</code> content-type header automatically though just as standard Rest Assured does.</p>
<h1 id="scala-support-module">Scala Support Module</h1>
<p>REST Assured 2.6.0 introduced the <a href="http://dl.bintray.com/johanhaleby/generic/scala-support-3.1.0-dist.zip" target="_blank">scala-support</a> module that adds an alias to the &quot;then&quot; method defined in the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/response/Response.html" target="_blank">Response</a> or <a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/response/MockMvcResponse.html" target="_blank">MockMvcResponse</a> called &quot;Then&quot;. The reason for this is that <code>then</code> might be a reserved keyword in Scala in the future and the compiler issues a warning when using a method with this name. To enable the use of <code>Then</code> simply import the <code>io.restassured.module.scala.RestAssuredSupport.AddThenToResponse</code> class from the <code>scala-support</code> module. For example:</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> io.restassured.RestAssured.when
<span class="hljs-keyword">import</span> io.restassured.module.scala.RestAssuredSupport.AddThenToResponse
<span class="hljs-keyword">import</span> org.hamcrest.Matchers.equalTo
<span class="hljs-keyword">import</span> org.junit.Test

<span class="hljs-meta">@Test</span>
def `trying out rest assured in scala with implicit conversion`() {
  when().
          get(<span class="hljs-string">&quot;/greetJSON&quot;</span>).
  Then().
          statusCode(<span class="hljs-number">200</span>).
          body(<span class="hljs-string">&quot;key&quot;</span>, equalTo(<span class="hljs-string">&quot;value&quot;</span>))
}
</code></pre>
<p>Note that this is also supported for the <a href="#spring-mock-mvc-module">Spring Mock Mvc Module</a>.</p>
<p>To use it do like this:</p>
<h4 id="sbt">SBT:</h4>
<pre><code class="lang-scala">libraryDependencies += <span class="hljs-string">&quot;io.rest-assured&quot;</span> % <span class="hljs-string">&quot;scala-support&quot;</span> % <span class="hljs-string">&quot;3.1.0&quot;</span>
</code></pre>
<h4 id="maven">Maven:</h4>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.rest-assured<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>scala-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h4 id="gradle">Gradle:</h4>
<pre><code class="lang-xml">testCompile &apos;io.rest-assured:scala-support:3.1.0&apos;
</code></pre>
<h3 id="no-build-manager">No build manager:</h3>
<p>Download the <a href="http://dl.bintray.com/johanhaleby/generic/scala-support-3.1.0-dist.zip" target="_blank">distribution file</a> manually.</p>
<h1 id="kotlin">Kotlin</h1>
<p>Kotlin is a language developed by <a href="https://www.jetbrains.com/" target="_blank">JetBrains</a> and it integrates very well with Java and REST Assured. When using it with REST Assured there&apos;s one thing that can be a bit annoying. That is you have to escape <code>when</code> since it&apos;s a reserved keyword in Kotlin. For example:</p>
<pre><code class="lang-kotlin">Test <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">kotlin_rest_assured_example</span><span class="hljs-params">()</span> {</span>
    given().
            param(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;Johan&quot;</span>).
            param(<span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Haleby&quot;</span>).
    `<span class="hljs-keyword">when</span>`().
            <span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;/greeting&quot;</span>).
    then().
            statusCode(<span class="hljs-number">200</span>).
            body(<span class="hljs-string">&quot;greeting.firstName&quot;</span>, equalTo(<span class="hljs-string">&quot;Johan&quot;</span>)).
            body(<span class="hljs-string">&quot;greeting.lastName&quot;</span>, equalTo(<span class="hljs-string">&quot;Haleby&quot;</span>))
}
</code></pre>
<p>To get around this, create an <a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank">extension function</a> that creates an alias to <code>when</code> called <code>When</code>:</p>
<pre><code class="lang-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> RequestSpecification.<span class="hljs-title">When</span><span class="hljs-params">()</span>: RequestSpecification {</span>
    <span class="hljs-keyword">return</span> this.`<span class="hljs-keyword">when</span>`()
}
</code></pre>
<p>The code can now be written like this:</p>
<pre><code class="lang-kotlin">Test <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">kotlin_rest_assured_example</span><span class="hljs-params">()</span> {</span>
    given().
            param(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;Johan&quot;</span>).
            param(<span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Haleby&quot;</span>).
    When().
            <span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;/greeting&quot;</span>).
    then().
            statusCode(<span class="hljs-number">200</span>).
            body(<span class="hljs-string">&quot;greeting.firstName&quot;</span>, equalTo(<span class="hljs-string">&quot;Johan&quot;</span>)).
            body(<span class="hljs-string">&quot;greeting.lastName&quot;</span>, equalTo(<span class="hljs-string">&quot;Haleby&quot;</span>))
}
</code></pre>
<p>Notice that we don&apos;t need any escaping anymore. For more details refer to <a href="http://code.haleby.se/2015/11/06/rest-assured-with-kotlin/" target="_blank">this</a> blog post.</p>
<h1 id="more-info">More info</h1>
<p>For more information refer to the <a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/index.html" target="_blank">javadoc</a>:</p>
<ul>
<li><a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/RestAssured.html" target="_blank">RestAssured</a></li>
<li><a href="http://static.javadoc.io/io.restassured/spring-mock-mvc/3.1.0/io/restassured/module/mockmvc/RestAssuredMockMvc.html" target="_blank">RestAssuredMockMvc Javadoc</a></li>
<li><a href="http://static.javadoc.io/io.rest-assured/rest-assured/3.1.0/io/restassured/specification/package-summary.html" target="_blank">Specification package</a></li>
</ul>
<p>You can also have a look at some code examples:</p>
<ul>
<li>REST Assured <a href="https://github.com/rest-assured/rest-assured/tree/master/examples/rest-assured-itest-java/src/test/java/io/restassured/itest/java" target="_blank">tests</a></li>
<li><a href="https://github.com/rest-assured/rest-assured/blob/master/json-path/src/test/java/io/restassured/path/json/JsonPathTest.java" target="_blank">JsonPathTest</a></li>
<li><a href="https://github.com/rest-assured/rest-assured/blob/master/xml-path/src/test/java/io/restassured/path/xml/XmlPathTest.java" target="_blank">XmlPathTest</a></li>
</ul>
<p>If you need support then join the <a href="http://groups.google.com/group/rest-assured" target="_blank">mailing list</a>.</p>
<p>For professional support please contact <a href="https://github.com/johanhaleby" target="_blank">johanhaleby</a>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Downloads.html" class="navigation navigation-prev " aria-label="Previous page: Downloads">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ReleaseNotes.html" class="navigation navigation-next " aria-label="Next page: Release Notes">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Usage Guide","level":"1.4","depth":1,"next":{"title":"Release Notes","level":"1.5","depth":1,"path":"ReleaseNotes.md","ref":"ReleaseNotes.md","articles":[]},"previous":{"title":"Downloads","level":"1.3","depth":1,"path":"Downloads.md","ref":"Downloads.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Usage.md","mtime":"2018-07-30T23:15:05.499Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2018-07-30T23:28:50.789Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

